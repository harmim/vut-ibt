// #anon_enum$AVLINK_UNINIT=0$AVLINK_STARTINIT=1$AVLINK_INIT=2
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 760
enum anonymous$3 { AVLINK_UNINIT=0, AVLINK_STARTINIT=1, AVLINK_INIT=2 };

// #anon_enum$AV_CLASS_CATEGORY_NA=0$AV_CLASS_CATEGORY_INPUT=1$AV_CLASS_CATEGORY_OUTPUT=2$AV_CLASS_CATEGORY_MUXER=3$AV_CLASS_CATEGORY_DEMUXER=4$AV_CLASS_CATEGORY_ENCODER=5$AV_CLASS_CATEGORY_DECODER=6$AV_CLASS_CATEGORY_FILTER=7$AV_CLASS_CATEGORY_BITSTREAM_FILTER=8$AV_CLASS_CATEGORY_SWSCALER=9$AV_CLASS_CATEGORY_SWRESAMPLER=10$AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT=40$AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT=41$AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT=42$AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT=43$AV_CLASS_CATEGORY_DEVICE_OUTPUT=44$AV_CLASS_CATEGORY_DEVICE_INPUT=45$AV_CLASS_CATEGORY_NB=46
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 29
enum anonymous$5 { AV_CLASS_CATEGORY_NA=0, AV_CLASS_CATEGORY_INPUT=1, AV_CLASS_CATEGORY_OUTPUT=2, AV_CLASS_CATEGORY_MUXER=3, AV_CLASS_CATEGORY_DEMUXER=4, AV_CLASS_CATEGORY_ENCODER=5, AV_CLASS_CATEGORY_DECODER=6, AV_CLASS_CATEGORY_FILTER=7, AV_CLASS_CATEGORY_BITSTREAM_FILTER=8, AV_CLASS_CATEGORY_SWSCALER=9, AV_CLASS_CATEGORY_SWRESAMPLER=10, AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT=40, AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT=41, AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT=42, AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT=43, AV_CLASS_CATEGORY_DEVICE_OUTPUT=44, AV_CLASS_CATEGORY_DEVICE_INPUT=45, AV_CLASS_CATEGORY_NB=46 };

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous;

// tag-#anon#ST[S64'last_dts'||S64'duration_gcd'||S32'duration_count'||U32'$pad0'||S64'rfps_duration_sum'||*{ARR2{ARR399{F64}$F64$}$ARR399{F64}$F64$$}$ARR2{ARR399{F64}$F64$}$ARR399{F64}$F64$$$'duration_error'||S64'codec_info_duration'||S64'codec_info_duration_fields'||S32'found_decoder'||U32'$pad1'||S64'last_duration'||S64'fps_first_dts'||S32'fps_first_dts_idx'||U32'$pad2'||S64'fps_last_dts'||S32'fps_last_dts_idx'||U32'$pad3'|]
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 972
struct anonymous$4;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$6;

// tag-#anon#UN[S64'i64'||F64'dbl'||*{cS8}$cS8$'str'||SYM#tag-AVRational#'q'|]
// file /usr/include/x86_64-linux-gnu/libavutil/opt.h line 274
union anonymous$2;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$1;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$0;

// tag-AVAudioServiceType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 692
enum AVAudioServiceType { AV_AUDIO_SERVICE_TYPE_MAIN=0, AV_AUDIO_SERVICE_TYPE_EFFECTS=1, AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED=2, AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED=3, AV_AUDIO_SERVICE_TYPE_DIALOGUE=4, AV_AUDIO_SERVICE_TYPE_COMMENTARY=5, AV_AUDIO_SERVICE_TYPE_EMERGENCY=6, AV_AUDIO_SERVICE_TYPE_VOICE_OVER=7, AV_AUDIO_SERVICE_TYPE_KARAOKE=8, AV_AUDIO_SERVICE_TYPE_NB=9 };

// tag-AVBuffer
// file /usr/include/x86_64-linux-gnu/libavutil/buffer.h line 73
struct AVBuffer;

// tag-AVBufferRef
// file /usr/include/x86_64-linux-gnu/libavutil/buffer.h line 81
struct AVBufferRef;

// tag-AVChapter
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1227
struct AVChapter;

// tag-AVChromaLocation
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 559
enum AVChromaLocation { AVCHROMA_LOC_UNSPECIFIED=0, AVCHROMA_LOC_LEFT=1, AVCHROMA_LOC_CENTER=2, AVCHROMA_LOC_TOPLEFT=3, AVCHROMA_LOC_TOP=4, AVCHROMA_LOC_BOTTOMLEFT=5, AVCHROMA_LOC_BOTTOM=6, AVCHROMA_LOC_NB=7 };

// tag-AVClass
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 67
struct AVClass;

// tag-AVCodec
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1511
struct AVCodec;

// tag-AVCodecContext
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 408
struct AVCodecContext;

// tag-AVCodecDefault
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3465
struct AVCodecDefault;

// tag-AVCodecDescriptor
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 566
struct AVCodecDescriptor;

// tag-AVCodecID
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 102
enum AVCodecID { AV_CODEC_ID_NONE=0, AV_CODEC_ID_MPEG1VIDEO=1, AV_CODEC_ID_MPEG2VIDEO=2, AV_CODEC_ID_MPEG2VIDEO_XVMC=3, AV_CODEC_ID_H261=4, AV_CODEC_ID_H263=5, AV_CODEC_ID_RV10=6, AV_CODEC_ID_RV20=7, AV_CODEC_ID_MJPEG=8, AV_CODEC_ID_MJPEGB=9, AV_CODEC_ID_LJPEG=10, AV_CODEC_ID_SP5X=11, AV_CODEC_ID_JPEGLS=12, AV_CODEC_ID_MPEG4=13, AV_CODEC_ID_RAWVIDEO=14, AV_CODEC_ID_MSMPEG4V1=15, AV_CODEC_ID_MSMPEG4V2=16, AV_CODEC_ID_MSMPEG4V3=17, AV_CODEC_ID_WMV1=18, AV_CODEC_ID_WMV2=19, AV_CODEC_ID_H263P=20, AV_CODEC_ID_H263I=21, AV_CODEC_ID_FLV1=22, AV_CODEC_ID_SVQ1=23, AV_CODEC_ID_SVQ3=24, AV_CODEC_ID_DVVIDEO=25, AV_CODEC_ID_HUFFYUV=26, AV_CODEC_ID_CYUV=27, AV_CODEC_ID_H264=28, AV_CODEC_ID_INDEO3=29, AV_CODEC_ID_VP3=30, AV_CODEC_ID_THEORA=31, AV_CODEC_ID_ASV1=32, AV_CODEC_ID_ASV2=33, AV_CODEC_ID_FFV1=34, AV_CODEC_ID_4XM=35, AV_CODEC_ID_VCR1=36, AV_CODEC_ID_CLJR=37, AV_CODEC_ID_MDEC=38, AV_CODEC_ID_ROQ=39, AV_CODEC_ID_INTERPLAY_VIDEO=40, AV_CODEC_ID_XAN_WC3=41, AV_CODEC_ID_XAN_WC4=42, AV_CODEC_ID_RPZA=43, AV_CODEC_ID_CINEPAK=44, AV_CODEC_ID_WS_VQA=45, AV_CODEC_ID_MSRLE=46, AV_CODEC_ID_MSVIDEO1=47, AV_CODEC_ID_IDCIN=48, AV_CODEC_ID_8BPS=49, AV_CODEC_ID_SMC=50, AV_CODEC_ID_FLIC=51, AV_CODEC_ID_TRUEMOTION1=52, AV_CODEC_ID_VMDVIDEO=53, AV_CODEC_ID_MSZH=54, AV_CODEC_ID_ZLIB=55, AV_CODEC_ID_QTRLE=56, AV_CODEC_ID_TSCC=57, AV_CODEC_ID_ULTI=58, AV_CODEC_ID_QDRAW=59, AV_CODEC_ID_VIXL=60, AV_CODEC_ID_QPEG=61, AV_CODEC_ID_PNG=62, AV_CODEC_ID_PPM=63, AV_CODEC_ID_PBM=64, AV_CODEC_ID_PGM=65, AV_CODEC_ID_PGMYUV=66, AV_CODEC_ID_PAM=67, AV_CODEC_ID_FFVHUFF=68, AV_CODEC_ID_RV30=69, AV_CODEC_ID_RV40=70, AV_CODEC_ID_VC1=71, AV_CODEC_ID_WMV3=72, AV_CODEC_ID_LOCO=73, AV_CODEC_ID_WNV1=74, AV_CODEC_ID_AASC=75, AV_CODEC_ID_INDEO2=76, AV_CODEC_ID_FRAPS=77, AV_CODEC_ID_TRUEMOTION2=78, AV_CODEC_ID_BMP=79, AV_CODEC_ID_CSCD=80, AV_CODEC_ID_MMVIDEO=81, AV_CODEC_ID_ZMBV=82, AV_CODEC_ID_AVS=83, AV_CODEC_ID_SMACKVIDEO=84, AV_CODEC_ID_NUV=85, AV_CODEC_ID_KMVC=86, AV_CODEC_ID_FLASHSV=87, AV_CODEC_ID_CAVS=88, AV_CODEC_ID_JPEG2000=89, AV_CODEC_ID_VMNC=90, AV_CODEC_ID_VP5=91, AV_CODEC_ID_VP6=92, AV_CODEC_ID_VP6F=93, AV_CODEC_ID_TARGA=94, AV_CODEC_ID_DSICINVIDEO=95, AV_CODEC_ID_TIERTEXSEQVIDEO=96, AV_CODEC_ID_TIFF=97, AV_CODEC_ID_GIF=98, AV_CODEC_ID_DXA=99, AV_CODEC_ID_DNXHD=100, AV_CODEC_ID_THP=101, AV_CODEC_ID_SGI=102, AV_CODEC_ID_C93=103, AV_CODEC_ID_BETHSOFTVID=104, AV_CODEC_ID_PTX=105, AV_CODEC_ID_TXD=106, AV_CODEC_ID_VP6A=107, AV_CODEC_ID_AMV=108, AV_CODEC_ID_VB=109, AV_CODEC_ID_PCX=110, AV_CODEC_ID_SUNRAST=111, AV_CODEC_ID_INDEO4=112, AV_CODEC_ID_INDEO5=113, AV_CODEC_ID_MIMIC=114, AV_CODEC_ID_RL2=115, AV_CODEC_ID_ESCAPE124=116, AV_CODEC_ID_DIRAC=117, AV_CODEC_ID_BFI=118, AV_CODEC_ID_CMV=119, AV_CODEC_ID_MOTIONPIXELS=120, AV_CODEC_ID_TGV=121, AV_CODEC_ID_TGQ=122, AV_CODEC_ID_TQI=123, AV_CODEC_ID_AURA=124, AV_CODEC_ID_AURA2=125, AV_CODEC_ID_V210X=126, AV_CODEC_ID_TMV=127, AV_CODEC_ID_V210=128, AV_CODEC_ID_DPX=129, AV_CODEC_ID_MAD=130, AV_CODEC_ID_FRWU=131, AV_CODEC_ID_FLASHSV2=132, AV_CODEC_ID_CDGRAPHICS=133, AV_CODEC_ID_R210=134, AV_CODEC_ID_ANM=135, AV_CODEC_ID_BINKVIDEO=136, AV_CODEC_ID_IFF_ILBM=137, AV_CODEC_ID_IFF_BYTERUN1=138, AV_CODEC_ID_KGV1=139, AV_CODEC_ID_YOP=140, AV_CODEC_ID_VP8=141, AV_CODEC_ID_PICTOR=142, AV_CODEC_ID_ANSI=143, AV_CODEC_ID_A64_MULTI=144, AV_CODEC_ID_A64_MULTI5=145, AV_CODEC_ID_R10K=146, AV_CODEC_ID_MXPEG=147, AV_CODEC_ID_LAGARITH=148, AV_CODEC_ID_PRORES=149, AV_CODEC_ID_JV=150, AV_CODEC_ID_DFA=151, AV_CODEC_ID_WMV3IMAGE=152, AV_CODEC_ID_VC1IMAGE=153, AV_CODEC_ID_UTVIDEO=154, AV_CODEC_ID_BMV_VIDEO=155, AV_CODEC_ID_VBLE=156, AV_CODEC_ID_DXTORY=157, AV_CODEC_ID_V410=158, AV_CODEC_ID_XWD=159, AV_CODEC_ID_CDXL=160, AV_CODEC_ID_XBM=161, AV_CODEC_ID_ZEROCODEC=162, AV_CODEC_ID_MSS1=163, AV_CODEC_ID_MSA1=164, AV_CODEC_ID_TSCC2=165, AV_CODEC_ID_MTS2=166, AV_CODEC_ID_CLLC=167, AV_CODEC_ID_MSS2=168, AV_CODEC_ID_VP9=169, AV_CODEC_ID_AIC=170, AV_CODEC_ID_ESCAPE130_DEPRECATED=171, AV_CODEC_ID_G2M_DEPRECATED=172, AV_CODEC_ID_WEBP_DEPRECATED=173, AV_CODEC_ID_HNM4_VIDEO=174, AV_CODEC_ID_HEVC_DEPRECATED=175, AV_CODEC_ID_FIC=176, AV_CODEC_ID_ALIAS_PIX=177, AV_CODEC_ID_BRENDER_PIX_DEPRECATED=178, AV_CODEC_ID_PAF_VIDEO_DEPRECATED=179, AV_CODEC_ID_EXR_DEPRECATED=180, AV_CODEC_ID_VP7_DEPRECATED=181, AV_CODEC_ID_SANM_DEPRECATED=182, AV_CODEC_ID_SGIRLE_DEPRECATED=183, AV_CODEC_ID_MVC1_DEPRECATED=184, AV_CODEC_ID_MVC2_DEPRECATED=185, AV_CODEC_ID_HQX=186, AV_CODEC_ID_TDSC=187, AV_CODEC_ID_HQ_HQA=188, AV_CODEC_ID_HAP=189, AV_CODEC_ID_DDS=190, AV_CODEC_ID_BRENDER_PIX=1112557912, AV_CODEC_ID_Y41P=1496592720, AV_CODEC_ID_ESCAPE130=1160852272, AV_CODEC_ID_EXR=809850962, AV_CODEC_ID_AVRP=1096176208, AV_CODEC_ID_012V=808530518, AV_CODEC_ID_G2M=4665933, AV_CODEC_ID_AVUI=1096176969, AV_CODEC_ID_AYUV=1096373590, AV_CODEC_ID_TARGA_Y216=1412575542, AV_CODEC_ID_V308=1446195256, AV_CODEC_ID_V408=1446260792, AV_CODEC_ID_YUV4=1498764852, AV_CODEC_ID_SANM=1396788813, AV_CODEC_ID_PAF_VIDEO=1346455126, AV_CODEC_ID_AVRN=1096176238, AV_CODEC_ID_CPIA=1129335105, AV_CODEC_ID_XFACE=1480999235, AV_CODEC_ID_SGIRLE=1397180754, AV_CODEC_ID_MVC1=1297498929, AV_CODEC_ID_MVC2=1297498930, AV_CODEC_ID_SNOW=1397641047, AV_CODEC_ID_WEBP=1464156752, AV_CODEC_ID_SMVJPEG=1397577290, AV_CODEC_ID_HEVC=1211250229, AV_CODEC_ID_VP7=1448097584, AV_CODEC_ID_APNG=1095781959, AV_CODEC_ID_FIRST_AUDIO=65536, AV_CODEC_ID_PCM_S16LE=65536, AV_CODEC_ID_PCM_S16BE=65537, AV_CODEC_ID_PCM_U16LE=65538, AV_CODEC_ID_PCM_U16BE=65539, AV_CODEC_ID_PCM_S8=65540, AV_CODEC_ID_PCM_U8=65541, AV_CODEC_ID_PCM_MULAW=65542, AV_CODEC_ID_PCM_ALAW=65543, AV_CODEC_ID_PCM_S32LE=65544, AV_CODEC_ID_PCM_S32BE=65545, AV_CODEC_ID_PCM_U32LE=65546, AV_CODEC_ID_PCM_U32BE=65547, AV_CODEC_ID_PCM_S24LE=65548, AV_CODEC_ID_PCM_S24BE=65549, AV_CODEC_ID_PCM_U24LE=65550, AV_CODEC_ID_PCM_U24BE=65551, AV_CODEC_ID_PCM_S24DAUD=65552, AV_CODEC_ID_PCM_ZORK=65553, AV_CODEC_ID_PCM_S16LE_PLANAR=65554, AV_CODEC_ID_PCM_DVD=65555, AV_CODEC_ID_PCM_F32BE=65556, AV_CODEC_ID_PCM_F32LE=65557, AV_CODEC_ID_PCM_F64BE=65558, AV_CODEC_ID_PCM_F64LE=65559, AV_CODEC_ID_PCM_BLURAY=65560, AV_CODEC_ID_PCM_LXF=65561, AV_CODEC_ID_S302M=65562, AV_CODEC_ID_PCM_S8_PLANAR=65563, AV_CODEC_ID_PCM_S24LE_PLANAR_DEPRECATED=65564, AV_CODEC_ID_PCM_S32LE_PLANAR_DEPRECATED=65565, AV_CODEC_ID_PCM_S16BE_PLANAR_DEPRECATED=65566, AV_CODEC_ID_PCM_S24LE_PLANAR=407917392, AV_CODEC_ID_PCM_S32LE_PLANAR=542135120, AV_CODEC_ID_PCM_S16BE_PLANAR=1347637264, AV_CODEC_ID_ADPCM_IMA_QT=69632, AV_CODEC_ID_ADPCM_IMA_WAV=69633, AV_CODEC_ID_ADPCM_IMA_DK3=69634, AV_CODEC_ID_ADPCM_IMA_DK4=69635, AV_CODEC_ID_ADPCM_IMA_WS=69636, AV_CODEC_ID_ADPCM_IMA_SMJPEG=69637, AV_CODEC_ID_ADPCM_MS=69638, AV_CODEC_ID_ADPCM_4XM=69639, AV_CODEC_ID_ADPCM_XA=69640, AV_CODEC_ID_ADPCM_ADX=69641, AV_CODEC_ID_ADPCM_EA=69642, AV_CODEC_ID_ADPCM_G726=69643, AV_CODEC_ID_ADPCM_CT=69644, AV_CODEC_ID_ADPCM_SWF=69645, AV_CODEC_ID_ADPCM_YAMAHA=69646, AV_CODEC_ID_ADPCM_SBPRO_4=69647, AV_CODEC_ID_ADPCM_SBPRO_3=69648, AV_CODEC_ID_ADPCM_SBPRO_2=69649, AV_CODEC_ID_ADPCM_THP=69650, AV_CODEC_ID_ADPCM_IMA_AMV=69651, AV_CODEC_ID_ADPCM_EA_R1=69652, AV_CODEC_ID_ADPCM_EA_R3=69653, AV_CODEC_ID_ADPCM_EA_R2=69654, AV_CODEC_ID_ADPCM_IMA_EA_SEAD=69655, AV_CODEC_ID_ADPCM_IMA_EA_EACS=69656, AV_CODEC_ID_ADPCM_EA_XAS=69657, AV_CODEC_ID_ADPCM_EA_MAXIS_XA=69658, AV_CODEC_ID_ADPCM_IMA_ISS=69659, AV_CODEC_ID_ADPCM_G722=69660, AV_CODEC_ID_ADPCM_IMA_APC=69661, AV_CODEC_ID_ADPCM_VIMA_DEPRECATED=69662, AV_CODEC_ID_ADPCM_VIMA=1447644481, AV_CODEC_ID_VIMA=1447644481, AV_CODEC_ID_ADPCM_AFC=1095123744, AV_CODEC_ID_ADPCM_IMA_OKI=1330333984, AV_CODEC_ID_ADPCM_DTK=1146374944, AV_CODEC_ID_ADPCM_IMA_RAD=1380008992, AV_CODEC_ID_ADPCM_G726LE=909260615, AV_CODEC_ID_ADPCM_THP_LE=1414025292, AV_CODEC_ID_AMR_NB=73728, AV_CODEC_ID_AMR_WB=73729, AV_CODEC_ID_RA_144=77824, AV_CODEC_ID_RA_288=77825, AV_CODEC_ID_ROQ_DPCM=81920, AV_CODEC_ID_INTERPLAY_DPCM=81921, AV_CODEC_ID_XAN_DPCM=81922, AV_CODEC_ID_SOL_DPCM=81923, AV_CODEC_ID_MP2=86016, AV_CODEC_ID_MP3=86017, AV_CODEC_ID_AAC=86018, AV_CODEC_ID_AC3=86019, AV_CODEC_ID_DTS=86020, AV_CODEC_ID_VORBIS=86021, AV_CODEC_ID_DVAUDIO=86022, AV_CODEC_ID_WMAV1=86023, AV_CODEC_ID_WMAV2=86024, AV_CODEC_ID_MACE3=86025, AV_CODEC_ID_MACE6=86026, AV_CODEC_ID_VMDAUDIO=86027, AV_CODEC_ID_FLAC=86028, AV_CODEC_ID_MP3ADU=86029, AV_CODEC_ID_MP3ON4=86030, AV_CODEC_ID_SHORTEN=86031, AV_CODEC_ID_ALAC=86032, AV_CODEC_ID_WESTWOOD_SND1=86033, AV_CODEC_ID_GSM=86034, AV_CODEC_ID_QDM2=86035, AV_CODEC_ID_COOK=86036, AV_CODEC_ID_TRUESPEECH=86037, AV_CODEC_ID_TTA=86038, AV_CODEC_ID_SMACKAUDIO=86039, AV_CODEC_ID_QCELP=86040, AV_CODEC_ID_WAVPACK=86041, AV_CODEC_ID_DSICINAUDIO=86042, AV_CODEC_ID_IMC=86043, AV_CODEC_ID_MUSEPACK7=86044, AV_CODEC_ID_MLP=86045, AV_CODEC_ID_GSM_MS=86046, AV_CODEC_ID_ATRAC3=86047, AV_CODEC_ID_VOXWARE=86048, AV_CODEC_ID_APE=86049, AV_CODEC_ID_NELLYMOSER=86050, AV_CODEC_ID_MUSEPACK8=86051, AV_CODEC_ID_SPEEX=86052, AV_CODEC_ID_WMAVOICE=86053, AV_CODEC_ID_WMAPRO=86054, AV_CODEC_ID_WMALOSSLESS=86055, AV_CODEC_ID_ATRAC3P=86056, AV_CODEC_ID_EAC3=86057, AV_CODEC_ID_SIPR=86058, AV_CODEC_ID_MP1=86059, AV_CODEC_ID_TWINVQ=86060, AV_CODEC_ID_TRUEHD=86061, AV_CODEC_ID_MP4ALS=86062, AV_CODEC_ID_ATRAC1=86063, AV_CODEC_ID_BINKAUDIO_RDFT=86064, AV_CODEC_ID_BINKAUDIO_DCT=86065, AV_CODEC_ID_AAC_LATM=86066, AV_CODEC_ID_QDMC=86067, AV_CODEC_ID_CELT=86068, AV_CODEC_ID_G723_1=86069, AV_CODEC_ID_G729=86070, AV_CODEC_ID_8SVX_EXP=86071, AV_CODEC_ID_8SVX_FIB=86072, AV_CODEC_ID_BMV_AUDIO=86073, AV_CODEC_ID_RALF=86074, AV_CODEC_ID_IAC=86075, AV_CODEC_ID_ILBC=86076, AV_CODEC_ID_OPUS_DEPRECATED=86077, AV_CODEC_ID_COMFORT_NOISE=86078, AV_CODEC_ID_TAK_DEPRECATED=86079, AV_CODEC_ID_METASOUND=86080, AV_CODEC_ID_PAF_AUDIO_DEPRECATED=86081, AV_CODEC_ID_ON2AVC=86082, AV_CODEC_ID_DSS_SP=86083, AV_CODEC_ID_FFWAVESYNTH=1179014995, AV_CODEC_ID_SONIC=1397706307, AV_CODEC_ID_SONIC_LS=1397706316, AV_CODEC_ID_PAF_AUDIO=1346455105, AV_CODEC_ID_OPUS=1330664787, AV_CODEC_ID_TAK=1950507339, AV_CODEC_ID_EVRC=1936029283, AV_CODEC_ID_SMV=1936944502, AV_CODEC_ID_DSD_LSBF=1146307660, AV_CODEC_ID_DSD_MSBF=1146307661, AV_CODEC_ID_DSD_LSBF_PLANAR=1146307633, AV_CODEC_ID_DSD_MSBF_PLANAR=1146307640, AV_CODEC_ID_4GV=1932814198, AV_CODEC_ID_FIRST_SUBTITLE=94208, AV_CODEC_ID_DVD_SUBTITLE=94208, AV_CODEC_ID_DVB_SUBTITLE=94209, AV_CODEC_ID_TEXT=94210, AV_CODEC_ID_XSUB=94211, AV_CODEC_ID_SSA=94212, AV_CODEC_ID_MOV_TEXT=94213, AV_CODEC_ID_HDMV_PGS_SUBTITLE=94214, AV_CODEC_ID_DVB_TELETEXT=94215, AV_CODEC_ID_SRT=94216, AV_CODEC_ID_MICRODVD=1833195076, AV_CODEC_ID_EIA_608=1664495672, AV_CODEC_ID_JACOSUB=1246975298, AV_CODEC_ID_SAMI=1396788553, AV_CODEC_ID_REALTEXT=1381259348, AV_CODEC_ID_STL=1399870540, AV_CODEC_ID_SUBVIEWER1=1398953521, AV_CODEC_ID_SUBVIEWER=1400201814, AV_CODEC_ID_SUBRIP=1397909872, AV_CODEC_ID_WEBVTT=1465275476, AV_CODEC_ID_MPL2=1297108018, AV_CODEC_ID_VPLAYER=1448111218, AV_CODEC_ID_PJS=1349012051, AV_CODEC_ID_ASS=1095979808, AV_CODEC_ID_HDMV_TEXT_SUBTITLE=1111774296, AV_CODEC_ID_FIRST_UNKNOWN=98304, AV_CODEC_ID_TTF=98304, AV_CODEC_ID_BINTEXT=1112823892, AV_CODEC_ID_XBIN=1480739150, AV_CODEC_ID_IDF=4801606, AV_CODEC_ID_OTF=5198918, AV_CODEC_ID_SMPTE_KLV=1263294017, AV_CODEC_ID_DVD_NAV=1145979222, AV_CODEC_ID_TIMED_ID3=1414087731, AV_CODEC_ID_BIN_DATA=1145132097, AV_CODEC_ID_PROBE=102400, AV_CODEC_ID_MPEG2TS=131072, AV_CODEC_ID_MPEG4SYSTEMS=131073, AV_CODEC_ID_FFMETADATA=135168, CODEC_ID_NONE=0, CODEC_ID_MPEG1VIDEO=1, CODEC_ID_MPEG2VIDEO=2, CODEC_ID_MPEG2VIDEO_XVMC=3, CODEC_ID_H261=4, CODEC_ID_H263=5, CODEC_ID_RV10=6, CODEC_ID_RV20=7, CODEC_ID_MJPEG=8, CODEC_ID_MJPEGB=9, CODEC_ID_LJPEG=10, CODEC_ID_SP5X=11, CODEC_ID_JPEGLS=12, CODEC_ID_MPEG4=13, CODEC_ID_RAWVIDEO=14, CODEC_ID_MSMPEG4V1=15, CODEC_ID_MSMPEG4V2=16, CODEC_ID_MSMPEG4V3=17, CODEC_ID_WMV1=18, CODEC_ID_WMV2=19, CODEC_ID_H263P=20, CODEC_ID_H263I=21, CODEC_ID_FLV1=22, CODEC_ID_SVQ1=23, CODEC_ID_SVQ3=24, CODEC_ID_DVVIDEO=25, CODEC_ID_HUFFYUV=26, CODEC_ID_CYUV=27, CODEC_ID_H264=28, CODEC_ID_INDEO3=29, CODEC_ID_VP3=30, CODEC_ID_THEORA=31, CODEC_ID_ASV1=32, CODEC_ID_ASV2=33, CODEC_ID_FFV1=34, CODEC_ID_4XM=35, CODEC_ID_VCR1=36, CODEC_ID_CLJR=37, CODEC_ID_MDEC=38, CODEC_ID_ROQ=39, CODEC_ID_INTERPLAY_VIDEO=40, CODEC_ID_XAN_WC3=41, CODEC_ID_XAN_WC4=42, CODEC_ID_RPZA=43, CODEC_ID_CINEPAK=44, CODEC_ID_WS_VQA=45, CODEC_ID_MSRLE=46, CODEC_ID_MSVIDEO1=47, CODEC_ID_IDCIN=48, CODEC_ID_8BPS=49, CODEC_ID_SMC=50, CODEC_ID_FLIC=51, CODEC_ID_TRUEMOTION1=52, CODEC_ID_VMDVIDEO=53, CODEC_ID_MSZH=54, CODEC_ID_ZLIB=55, CODEC_ID_QTRLE=56, CODEC_ID_TSCC=57, CODEC_ID_ULTI=58, CODEC_ID_QDRAW=59, CODEC_ID_VIXL=60, CODEC_ID_QPEG=61, CODEC_ID_PNG=62, CODEC_ID_PPM=63, CODEC_ID_PBM=64, CODEC_ID_PGM=65, CODEC_ID_PGMYUV=66, CODEC_ID_PAM=67, CODEC_ID_FFVHUFF=68, CODEC_ID_RV30=69, CODEC_ID_RV40=70, CODEC_ID_VC1=71, CODEC_ID_WMV3=72, CODEC_ID_LOCO=73, CODEC_ID_WNV1=74, CODEC_ID_AASC=75, CODEC_ID_INDEO2=76, CODEC_ID_FRAPS=77, CODEC_ID_TRUEMOTION2=78, CODEC_ID_BMP=79, CODEC_ID_CSCD=80, CODEC_ID_MMVIDEO=81, CODEC_ID_ZMBV=82, CODEC_ID_AVS=83, CODEC_ID_SMACKVIDEO=84, CODEC_ID_NUV=85, CODEC_ID_KMVC=86, CODEC_ID_FLASHSV=87, CODEC_ID_CAVS=88, CODEC_ID_JPEG2000=89, CODEC_ID_VMNC=90, CODEC_ID_VP5=91, CODEC_ID_VP6=92, CODEC_ID_VP6F=93, CODEC_ID_TARGA=94, CODEC_ID_DSICINVIDEO=95, CODEC_ID_TIERTEXSEQVIDEO=96, CODEC_ID_TIFF=97, CODEC_ID_GIF=98, CODEC_ID_DXA=99, CODEC_ID_DNXHD=100, CODEC_ID_THP=101, CODEC_ID_SGI=102, CODEC_ID_C93=103, CODEC_ID_BETHSOFTVID=104, CODEC_ID_PTX=105, CODEC_ID_TXD=106, CODEC_ID_VP6A=107, CODEC_ID_AMV=108, CODEC_ID_VB=109, CODEC_ID_PCX=110, CODEC_ID_SUNRAST=111, CODEC_ID_INDEO4=112, CODEC_ID_INDEO5=113, CODEC_ID_MIMIC=114, CODEC_ID_RL2=115, CODEC_ID_ESCAPE124=116, CODEC_ID_DIRAC=117, CODEC_ID_BFI=118, CODEC_ID_CMV=119, CODEC_ID_MOTIONPIXELS=120, CODEC_ID_TGV=121, CODEC_ID_TGQ=122, CODEC_ID_TQI=123, CODEC_ID_AURA=124, CODEC_ID_AURA2=125, CODEC_ID_V210X=126, CODEC_ID_TMV=127, CODEC_ID_V210=128, CODEC_ID_DPX=129, CODEC_ID_MAD=130, CODEC_ID_FRWU=131, CODEC_ID_FLASHSV2=132, CODEC_ID_CDGRAPHICS=133, CODEC_ID_R210=134, CODEC_ID_ANM=135, CODEC_ID_BINKVIDEO=136, CODEC_ID_IFF_ILBM=137, CODEC_ID_IFF_BYTERUN1=138, CODEC_ID_KGV1=139, CODEC_ID_YOP=140, CODEC_ID_VP8=141, CODEC_ID_PICTOR=142, CODEC_ID_ANSI=143, CODEC_ID_A64_MULTI=144, CODEC_ID_A64_MULTI5=145, CODEC_ID_R10K=146, CODEC_ID_MXPEG=147, CODEC_ID_LAGARITH=148, CODEC_ID_PRORES=149, CODEC_ID_JV=150, CODEC_ID_DFA=151, CODEC_ID_WMV3IMAGE=152, CODEC_ID_VC1IMAGE=153, CODEC_ID_UTVIDEO=154, CODEC_ID_BMV_VIDEO=155, CODEC_ID_VBLE=156, CODEC_ID_DXTORY=157, CODEC_ID_V410=158, CODEC_ID_XWD=159, CODEC_ID_CDXL=160, CODEC_ID_XBM=161, CODEC_ID_ZEROCODEC=162, CODEC_ID_MSS1=163, CODEC_ID_MSA1=164, CODEC_ID_TSCC2=165, CODEC_ID_MTS2=166, CODEC_ID_CLLC=167, CODEC_ID_Y41P=1496592720, CODEC_ID_ESCAPE130=1160852272, CODEC_ID_EXR=809850962, CODEC_ID_AVRP=1096176208, CODEC_ID_G2M=4665933, CODEC_ID_AVUI=1096176969, CODEC_ID_AYUV=1096373590, CODEC_ID_V308=1446195256, CODEC_ID_V408=1446260792, CODEC_ID_YUV4=1498764852, CODEC_ID_SANM=1396788813, CODEC_ID_PAF_VIDEO=1346455126, CODEC_ID_SNOW=1397641047, CODEC_ID_FIRST_AUDIO=65536, CODEC_ID_PCM_S16LE=65536, CODEC_ID_PCM_S16BE=65537, CODEC_ID_PCM_U16LE=65538, CODEC_ID_PCM_U16BE=65539, CODEC_ID_PCM_S8=65540, CODEC_ID_PCM_U8=65541, CODEC_ID_PCM_MULAW=65542, CODEC_ID_PCM_ALAW=65543, CODEC_ID_PCM_S32LE=65544, CODEC_ID_PCM_S32BE=65545, CODEC_ID_PCM_U32LE=65546, CODEC_ID_PCM_U32BE=65547, CODEC_ID_PCM_S24LE=65548, CODEC_ID_PCM_S24BE=65549, CODEC_ID_PCM_U24LE=65550, CODEC_ID_PCM_U24BE=65551, CODEC_ID_PCM_S24DAUD=65552, CODEC_ID_PCM_ZORK=65553, CODEC_ID_PCM_S16LE_PLANAR=65554, CODEC_ID_PCM_DVD=65555, CODEC_ID_PCM_F32BE=65556, CODEC_ID_PCM_F32LE=65557, CODEC_ID_PCM_F64BE=65558, CODEC_ID_PCM_F64LE=65559, CODEC_ID_PCM_BLURAY=65560, CODEC_ID_PCM_LXF=65561, CODEC_ID_S302M=65562, CODEC_ID_PCM_S8_PLANAR=65563, CODEC_ID_ADPCM_IMA_QT=69632, CODEC_ID_ADPCM_IMA_WAV=69633, CODEC_ID_ADPCM_IMA_DK3=69634, CODEC_ID_ADPCM_IMA_DK4=69635, CODEC_ID_ADPCM_IMA_WS=69636, CODEC_ID_ADPCM_IMA_SMJPEG=69637, CODEC_ID_ADPCM_MS=69638, CODEC_ID_ADPCM_4XM=69639, CODEC_ID_ADPCM_XA=69640, CODEC_ID_ADPCM_ADX=69641, CODEC_ID_ADPCM_EA=69642, CODEC_ID_ADPCM_G726=69643, CODEC_ID_ADPCM_CT=69644, CODEC_ID_ADPCM_SWF=69645, CODEC_ID_ADPCM_YAMAHA=69646, CODEC_ID_ADPCM_SBPRO_4=69647, CODEC_ID_ADPCM_SBPRO_3=69648, CODEC_ID_ADPCM_SBPRO_2=69649, CODEC_ID_ADPCM_THP=69650, CODEC_ID_ADPCM_IMA_AMV=69651, CODEC_ID_ADPCM_EA_R1=69652, CODEC_ID_ADPCM_EA_R3=69653, CODEC_ID_ADPCM_EA_R2=69654, CODEC_ID_ADPCM_IMA_EA_SEAD=69655, CODEC_ID_ADPCM_IMA_EA_EACS=69656, CODEC_ID_ADPCM_EA_XAS=69657, CODEC_ID_ADPCM_EA_MAXIS_XA=69658, CODEC_ID_ADPCM_IMA_ISS=69659, CODEC_ID_ADPCM_G722=69660, CODEC_ID_ADPCM_IMA_APC=69661, CODEC_ID_VIMA=1447644481, CODEC_ID_AMR_NB=73728, CODEC_ID_AMR_WB=73729, CODEC_ID_RA_144=77824, CODEC_ID_RA_288=77825, CODEC_ID_ROQ_DPCM=81920, CODEC_ID_INTERPLAY_DPCM=81921, CODEC_ID_XAN_DPCM=81922, CODEC_ID_SOL_DPCM=81923, CODEC_ID_MP2=86016, CODEC_ID_MP3=86017, CODEC_ID_AAC=86018, CODEC_ID_AC3=86019, CODEC_ID_DTS=86020, CODEC_ID_VORBIS=86021, CODEC_ID_DVAUDIO=86022, CODEC_ID_WMAV1=86023, CODEC_ID_WMAV2=86024, CODEC_ID_MACE3=86025, CODEC_ID_MACE6=86026, CODEC_ID_VMDAUDIO=86027, CODEC_ID_FLAC=86028, CODEC_ID_MP3ADU=86029, CODEC_ID_MP3ON4=86030, CODEC_ID_SHORTEN=86031, CODEC_ID_ALAC=86032, CODEC_ID_WESTWOOD_SND1=86033, CODEC_ID_GSM=86034, CODEC_ID_QDM2=86035, CODEC_ID_COOK=86036, CODEC_ID_TRUESPEECH=86037, CODEC_ID_TTA=86038, CODEC_ID_SMACKAUDIO=86039, CODEC_ID_QCELP=86040, CODEC_ID_WAVPACK=86041, CODEC_ID_DSICINAUDIO=86042, CODEC_ID_IMC=86043, CODEC_ID_MUSEPACK7=86044, CODEC_ID_MLP=86045, CODEC_ID_GSM_MS=86046, CODEC_ID_ATRAC3=86047, CODEC_ID_VOXWARE=86048, CODEC_ID_APE=86049, CODEC_ID_NELLYMOSER=86050, CODEC_ID_MUSEPACK8=86051, CODEC_ID_SPEEX=86052, CODEC_ID_WMAVOICE=86053, CODEC_ID_WMAPRO=86054, CODEC_ID_WMALOSSLESS=86055, CODEC_ID_ATRAC3P=86056, CODEC_ID_EAC3=86057, CODEC_ID_SIPR=86058, CODEC_ID_MP1=86059, CODEC_ID_TWINVQ=86060, CODEC_ID_TRUEHD=86061, CODEC_ID_MP4ALS=86062, CODEC_ID_ATRAC1=86063, CODEC_ID_BINKAUDIO_RDFT=86064, CODEC_ID_BINKAUDIO_DCT=86065, CODEC_ID_AAC_LATM=86066, CODEC_ID_QDMC=86067, CODEC_ID_CELT=86068, CODEC_ID_G723_1=86069, CODEC_ID_G729=86070, CODEC_ID_8SVX_EXP=86071, CODEC_ID_8SVX_FIB=86072, CODEC_ID_BMV_AUDIO=86073, CODEC_ID_RALF=86074, CODEC_ID_IAC=86075, CODEC_ID_ILBC=86076, CODEC_ID_FFWAVESYNTH=1179014995, CODEC_ID_SONIC=1397706307, CODEC_ID_SONIC_LS=1397706316, CODEC_ID_PAF_AUDIO=1346455105, CODEC_ID_OPUS=1330664787, CODEC_ID_FIRST_SUBTITLE=94208, CODEC_ID_DVD_SUBTITLE=94208, CODEC_ID_DVB_SUBTITLE=94209, CODEC_ID_TEXT=94210, CODEC_ID_XSUB=94211, CODEC_ID_SSA=94212, CODEC_ID_MOV_TEXT=94213, CODEC_ID_HDMV_PGS_SUBTITLE=94214, CODEC_ID_DVB_TELETEXT=94215, CODEC_ID_SRT=94216, CODEC_ID_MICRODVD=1833195076, CODEC_ID_EIA_608=1664495672, CODEC_ID_JACOSUB=1246975298, CODEC_ID_SAMI=1396788553, CODEC_ID_REALTEXT=1381259348, CODEC_ID_SUBVIEWER=1400201814, CODEC_ID_FIRST_UNKNOWN=98304, CODEC_ID_TTF=98304, CODEC_ID_BINTEXT=1112823892, CODEC_ID_XBIN=1480739150, CODEC_ID_IDF=4801606, CODEC_ID_OTF=5198918, CODEC_ID_PROBE=102400, CODEC_ID_MPEG2TS=131072, CODEC_ID_MPEG4SYSTEMS=131073, CODEC_ID_FFMETADATA=135168 };

// tag-AVCodecInternal
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1482
struct AVCodecInternal;

// tag-AVCodecParser
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4541
struct AVCodecParser;

// tag-AVCodecParserContext
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4539
struct AVCodecParserContext;

// tag-AVCodecTag
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 443
struct AVCodecTag;

// tag-AVColorPrimaries
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 476
enum AVColorPrimaries { AVCOL_PRI_RESERVED0=0, AVCOL_PRI_BT709=1, AVCOL_PRI_UNSPECIFIED=2, AVCOL_PRI_RESERVED=3, AVCOL_PRI_BT470M=4, AVCOL_PRI_BT470BG=5, AVCOL_PRI_SMPTE170M=6, AVCOL_PRI_SMPTE240M=7, AVCOL_PRI_FILM=8, AVCOL_PRI_BT2020=9, AVCOL_PRI_NB=10 };

// tag-AVColorRange
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 537
enum AVColorRange { AVCOL_RANGE_UNSPECIFIED=0, AVCOL_RANGE_MPEG=1, AVCOL_RANGE_JPEG=2, AVCOL_RANGE_NB=3 };

// tag-AVColorSpace
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 517
enum AVColorSpace { AVCOL_SPC_RGB=0, AVCOL_SPC_BT709=1, AVCOL_SPC_UNSPECIFIED=2, AVCOL_SPC_RESERVED=3, AVCOL_SPC_FCC=4, AVCOL_SPC_BT470BG=5, AVCOL_SPC_SMPTE170M=6, AVCOL_SPC_SMPTE240M=7, AVCOL_SPC_YCOCG=8, AVCOL_SPC_BT2020_NCL=9, AVCOL_SPC_BT2020_CL=10, AVCOL_SPC_NB=11 };

// tag-AVColorTransferCharacteristic
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 494
enum AVColorTransferCharacteristic { AVCOL_TRC_RESERVED0=0, AVCOL_TRC_BT709=1, AVCOL_TRC_UNSPECIFIED=2, AVCOL_TRC_RESERVED=3, AVCOL_TRC_GAMMA22=4, AVCOL_TRC_GAMMA28=5, AVCOL_TRC_SMPTE170M=6, AVCOL_TRC_SMPTE240M=7, AVCOL_TRC_LINEAR=8, AVCOL_TRC_LOG=9, AVCOL_TRC_LOG_SQRT=10, AVCOL_TRC_IEC61966_2_4=11, AVCOL_TRC_BT1361_ECG=12, AVCOL_TRC_IEC61966_2_1=13, AVCOL_TRC_BT2020_10=14, AVCOL_TRC_BT2020_12=15, AVCOL_TRC_NB=16 };

// tag-AVDeviceCapabilitiesQuery
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 316
struct AVDeviceCapabilitiesQuery;

// tag-AVDeviceInfoList
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 315
struct AVDeviceInfoList;

// tag-AVDictionary
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 87
struct AVDictionary;

// tag-AVDictionaryEntry
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 82
struct AVDictionaryEntry;

// tag-AVDiscard
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 680
enum AVDiscard { AVDISCARD_NONE=-16, AVDISCARD_DEFAULT=0, AVDISCARD_NONREF=8, AVDISCARD_BIDIR=16, AVDISCARD_NONINTRA=24, AVDISCARD_NONKEY=32, AVDISCARD_ALL=48 };

// tag-AVDurationEstimationMethod
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1248
enum AVDurationEstimationMethod { AVFMT_DURATION_FROM_PTS=0, AVFMT_DURATION_FROM_STREAM=1, AVFMT_DURATION_FROM_BITRATE=2 };

// tag-AVFieldOrder
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1484
enum AVFieldOrder { AV_FIELD_UNKNOWN=0, AV_FIELD_PROGRESSIVE=1, AV_FIELD_TT=2, AV_FIELD_BB=3, AV_FIELD_TB=4, AV_FIELD_BT=5 };

// tag-AVFilter
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 470
struct AVFilter;

// tag-AVFilterBuffer
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 75
struct AVFilterBuffer;

// tag-AVFilterBufferRef
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 158
struct AVFilterBufferRef;

// tag-AVFilterBufferRefAudioProps
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 125
struct AVFilterBufferRefAudioProps;

// tag-AVFilterBufferRefVideoProps
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 137
struct AVFilterBufferRefVideoProps;

// tag-AVFilterChannelLayouts
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 747
struct AVFilterChannelLayouts;

// tag-AVFilterCommand
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 681
struct AVFilterCommand;

// tag-AVFilterContext
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 64
struct AVFilterContext;

// tag-AVFilterFormats
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 67
struct AVFilterFormats;

// tag-AVFilterGraph
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 656
struct AVFilterGraph;

// tag-AVFilterGraphInternal
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1140
struct AVFilterGraphInternal;

// tag-AVFilterInternal
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 630
struct AVFilterInternal;

// tag-AVFilterLink
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 65
struct AVFilterLink;

// tag-AVFilterPad
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 66
struct AVFilterPad;

// tag-AVFilterPool
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 767
struct AVFilterPool;

// tag-AVFormatContext
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 313
struct AVFormatContext;

// tag-AVFormatInternal
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1254
struct AVFormatInternal;

// tag-AVFrac
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 435
struct AVFrac;

// tag-AVFrame
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 171
struct AVFrame;

// tag-AVFrameSideData
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 134
struct AVFrameSideData;

// tag-AVFrameSideDataType
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 48
enum AVFrameSideDataType { AV_FRAME_DATA_PANSCAN=0, AV_FRAME_DATA_A53_CC=1, AV_FRAME_DATA_STEREO3D=2, AV_FRAME_DATA_MATRIXENCODING=3, AV_FRAME_DATA_DOWNMIX_INFO=4, AV_FRAME_DATA_REPLAYGAIN=5, AV_FRAME_DATA_DISPLAYMATRIX=6, AV_FRAME_DATA_AFD=7, AV_FRAME_DATA_MOTION_VECTORS=8, AV_FRAME_DATA_SKIP_SAMPLES=9, AV_FRAME_DATA_AUDIO_SERVICE_TYPE=10 };

// tag-AVHWAccel
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 2922
struct AVHWAccel;

// tag-AVIOContext
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 111
struct AVIOContext;

// tag-AVIOInterruptCB
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 50
struct AVIOInterruptCB;

// tag-AVIndexEntry
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 775
struct AVIndexEntry;

// tag-AVInputFormat
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 615
struct AVInputFormat;

// tag-AVLockOp
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 5530
enum AVLockOp { AV_LOCK_CREATE=0, AV_LOCK_OBTAIN=1, AV_LOCK_RELEASE=2, AV_LOCK_DESTROY=3 };

// tag-AVMediaType
// file /usr/include/x86_64-linux-gnu/libavutil/avutil.h line 191
enum AVMediaType { AVMEDIA_TYPE_UNKNOWN=-1, AVMEDIA_TYPE_VIDEO=0, AVMEDIA_TYPE_AUDIO=1, AVMEDIA_TYPE_DATA=2, AVMEDIA_TYPE_SUBTITLE=3, AVMEDIA_TYPE_ATTACHMENT=4, AVMEDIA_TYPE_NB=5 };

// tag-AVOption
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 85
struct AVOption;

// tag-AVOptionRange
// file /usr/include/x86_64-linux-gnu/libavutil/opt.h line 316
struct AVOptionRange;

// tag-AVOptionRanges
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 60
struct AVOptionRanges;

// tag-AVOptionType
// file /usr/include/x86_64-linux-gnu/libavutil/opt.h line 221
enum AVOptionType { AV_OPT_TYPE_FLAGS=0, AV_OPT_TYPE_INT=1, AV_OPT_TYPE_INT64=2, AV_OPT_TYPE_DOUBLE=3, AV_OPT_TYPE_FLOAT=4, AV_OPT_TYPE_STRING=5, AV_OPT_TYPE_RATIONAL=6, AV_OPT_TYPE_BINARY=7, AV_OPT_TYPE_DICT=8, AV_OPT_TYPE_CONST=128, AV_OPT_TYPE_IMAGE_SIZE=1397316165, AV_OPT_TYPE_PIXEL_FMT=1346784596, AV_OPT_TYPE_SAMPLE_FMT=1397116244, AV_OPT_TYPE_VIDEO_RATE=1448231252, AV_OPT_TYPE_DURATION=1146442272, AV_OPT_TYPE_COLOR=1129270354, AV_OPT_TYPE_CHANNEL_LAYOUT=1128811585, FF_OPT_TYPE_FLAGS=0, FF_OPT_TYPE_INT=1, FF_OPT_TYPE_INT64=2, FF_OPT_TYPE_DOUBLE=3, FF_OPT_TYPE_FLOAT=4, FF_OPT_TYPE_STRING=5, FF_OPT_TYPE_RATIONAL=6, FF_OPT_TYPE_BINARY=7, FF_OPT_TYPE_CONST=128 };

// tag-AVOutputFormat
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 504
struct AVOutputFormat;

// tag-AVPacket
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1400
struct AVPacket;

// tag-AVPacketList
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1032
struct AVPacketList;

// tag-AVPacketSideData
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1372
struct AVPacketSideData;

// tag-AVPacketSideDataType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1224
enum AVPacketSideDataType { AV_PKT_DATA_PALETTE=0, AV_PKT_DATA_NEW_EXTRADATA=1, AV_PKT_DATA_PARAM_CHANGE=2, AV_PKT_DATA_H263_MB_INFO=3, AV_PKT_DATA_REPLAYGAIN=4, AV_PKT_DATA_DISPLAYMATRIX=5, AV_PKT_DATA_STEREO3D=6, AV_PKT_DATA_AUDIO_SERVICE_TYPE=7, AV_PKT_DATA_QUALITY_STATS=8, AV_PKT_DATA_SKIP_SAMPLES=70, AV_PKT_DATA_JP_DUALMONO=71, AV_PKT_DATA_STRINGS_METADATA=72, AV_PKT_DATA_SUBTITLE_POSITION=73, AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL=74, AV_PKT_DATA_WEBVTT_IDENTIFIER=75, AV_PKT_DATA_WEBVTT_SETTINGS=76, AV_PKT_DATA_METADATA_UPDATE=77 };

// tag-AVPanScan
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 387
struct AVPanScan;

// tag-AVPicture
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3744
struct AVPicture;

// tag-AVPictureStructure
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4532
enum AVPictureStructure { AV_PICTURE_STRUCTURE_UNKNOWN=0, AV_PICTURE_STRUCTURE_TOP_FIELD=1, AV_PICTURE_STRUCTURE_BOTTOM_FIELD=2, AV_PICTURE_STRUCTURE_FRAME=3 };

// tag-AVPictureType
// file /usr/include/x86_64-linux-gnu/libavutil/avutil.h line 264
enum AVPictureType { AV_PICTURE_TYPE_NONE=0, AV_PICTURE_TYPE_I=1, AV_PICTURE_TYPE_P=2, AV_PICTURE_TYPE_B=3, AV_PICTURE_TYPE_S=4, AV_PICTURE_TYPE_SI=5, AV_PICTURE_TYPE_SP=6, AV_PICTURE_TYPE_BI=7 };

// tag-AVPixelFormat
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 61
enum AVPixelFormat { AV_PIX_FMT_NONE=-1, AV_PIX_FMT_YUV420P=0, AV_PIX_FMT_YUYV422=1, AV_PIX_FMT_RGB24=2, AV_PIX_FMT_BGR24=3, AV_PIX_FMT_YUV422P=4, AV_PIX_FMT_YUV444P=5, AV_PIX_FMT_YUV410P=6, AV_PIX_FMT_YUV411P=7, AV_PIX_FMT_GRAY8=8, AV_PIX_FMT_MONOWHITE=9, AV_PIX_FMT_MONOBLACK=10, AV_PIX_FMT_PAL8=11, AV_PIX_FMT_YUVJ420P=12, AV_PIX_FMT_YUVJ422P=13, AV_PIX_FMT_YUVJ444P=14, AV_PIX_FMT_XVMC_MPEG2_MC=15, AV_PIX_FMT_XVMC_MPEG2_IDCT=16, AV_PIX_FMT_UYVY422=17, AV_PIX_FMT_UYYVYY411=18, AV_PIX_FMT_BGR8=19, AV_PIX_FMT_BGR4=20, AV_PIX_FMT_BGR4_BYTE=21, AV_PIX_FMT_RGB8=22, AV_PIX_FMT_RGB4=23, AV_PIX_FMT_RGB4_BYTE=24, AV_PIX_FMT_NV12=25, AV_PIX_FMT_NV21=26, AV_PIX_FMT_ARGB=27, AV_PIX_FMT_RGBA=28, AV_PIX_FMT_ABGR=29, AV_PIX_FMT_BGRA=30, AV_PIX_FMT_GRAY16BE=31, AV_PIX_FMT_GRAY16LE=32, AV_PIX_FMT_YUV440P=33, AV_PIX_FMT_YUVJ440P=34, AV_PIX_FMT_YUVA420P=35, AV_PIX_FMT_VDPAU_H264=36, AV_PIX_FMT_VDPAU_MPEG1=37, AV_PIX_FMT_VDPAU_MPEG2=38, AV_PIX_FMT_VDPAU_WMV3=39, AV_PIX_FMT_VDPAU_VC1=40, AV_PIX_FMT_RGB48BE=41, AV_PIX_FMT_RGB48LE=42, AV_PIX_FMT_RGB565BE=43, AV_PIX_FMT_RGB565LE=44, AV_PIX_FMT_RGB555BE=45, AV_PIX_FMT_RGB555LE=46, AV_PIX_FMT_BGR565BE=47, AV_PIX_FMT_BGR565LE=48, AV_PIX_FMT_BGR555BE=49, AV_PIX_FMT_BGR555LE=50, AV_PIX_FMT_VAAPI_MOCO=51, AV_PIX_FMT_VAAPI_IDCT=52, AV_PIX_FMT_VAAPI_VLD=53, AV_PIX_FMT_VAAPI=53, AV_PIX_FMT_YUV420P16LE=54, AV_PIX_FMT_YUV420P16BE=55, AV_PIX_FMT_YUV422P16LE=56, AV_PIX_FMT_YUV422P16BE=57, AV_PIX_FMT_YUV444P16LE=58, AV_PIX_FMT_YUV444P16BE=59, AV_PIX_FMT_VDPAU_MPEG4=60, AV_PIX_FMT_DXVA2_VLD=61, AV_PIX_FMT_RGB444LE=62, AV_PIX_FMT_RGB444BE=63, AV_PIX_FMT_BGR444LE=64, AV_PIX_FMT_BGR444BE=65, AV_PIX_FMT_YA8=66, AV_PIX_FMT_Y400A=66, AV_PIX_FMT_GRAY8A=66, AV_PIX_FMT_BGR48BE=67, AV_PIX_FMT_BGR48LE=68, AV_PIX_FMT_YUV420P9BE=69, AV_PIX_FMT_YUV420P9LE=70, AV_PIX_FMT_YUV420P10BE=71, AV_PIX_FMT_YUV420P10LE=72, AV_PIX_FMT_YUV422P10BE=73, AV_PIX_FMT_YUV422P10LE=74, AV_PIX_FMT_YUV444P9BE=75, AV_PIX_FMT_YUV444P9LE=76, AV_PIX_FMT_YUV444P10BE=77, AV_PIX_FMT_YUV444P10LE=78, AV_PIX_FMT_YUV422P9BE=79, AV_PIX_FMT_YUV422P9LE=80, AV_PIX_FMT_VDA_VLD=81, AV_PIX_FMT_GBRP=82, AV_PIX_FMT_GBRP9BE=83, AV_PIX_FMT_GBRP9LE=84, AV_PIX_FMT_GBRP10BE=85, AV_PIX_FMT_GBRP10LE=86, AV_PIX_FMT_GBRP16BE=87, AV_PIX_FMT_GBRP16LE=88, AV_PIX_FMT_YUVA422P_LIBAV=89, AV_PIX_FMT_YUVA444P_LIBAV=90, AV_PIX_FMT_YUVA420P9BE=91, AV_PIX_FMT_YUVA420P9LE=92, AV_PIX_FMT_YUVA422P9BE=93, AV_PIX_FMT_YUVA422P9LE=94, AV_PIX_FMT_YUVA444P9BE=95, AV_PIX_FMT_YUVA444P9LE=96, AV_PIX_FMT_YUVA420P10BE=97, AV_PIX_FMT_YUVA420P10LE=98, AV_PIX_FMT_YUVA422P10BE=99, AV_PIX_FMT_YUVA422P10LE=100, AV_PIX_FMT_YUVA444P10BE=101, AV_PIX_FMT_YUVA444P10LE=102, AV_PIX_FMT_YUVA420P16BE=103, AV_PIX_FMT_YUVA420P16LE=104, AV_PIX_FMT_YUVA422P16BE=105, AV_PIX_FMT_YUVA422P16LE=106, AV_PIX_FMT_YUVA444P16BE=107, AV_PIX_FMT_YUVA444P16LE=108, AV_PIX_FMT_VDPAU=109, AV_PIX_FMT_XYZ12LE=110, AV_PIX_FMT_XYZ12BE=111, AV_PIX_FMT_NV16=112, AV_PIX_FMT_NV20LE=113, AV_PIX_FMT_NV20BE=114, AV_PIX_FMT_RGBA64BE_LIBAV=115, AV_PIX_FMT_RGBA64LE_LIBAV=116, AV_PIX_FMT_BGRA64BE_LIBAV=117, AV_PIX_FMT_BGRA64LE_LIBAV=118, AV_PIX_FMT_YVYU422=119, AV_PIX_FMT_VDA=120, AV_PIX_FMT_YA16BE=121, AV_PIX_FMT_YA16LE=122, AV_PIX_FMT_GBRAP_LIBAV=123, AV_PIX_FMT_GBRAP16BE_LIBAV=124, AV_PIX_FMT_GBRAP16LE_LIBAV=125, AV_PIX_FMT_QSV=126, AV_PIX_FMT_MMAL=127, AV_PIX_FMT_D3D11VA_VLD=128, AV_PIX_FMT_RGBA64BE=291, AV_PIX_FMT_RGBA64LE=292, AV_PIX_FMT_BGRA64BE=293, AV_PIX_FMT_BGRA64LE=294, AV_PIX_FMT_0RGB=295, AV_PIX_FMT_RGB0=296, AV_PIX_FMT_0BGR=297, AV_PIX_FMT_BGR0=298, AV_PIX_FMT_YUVA444P=299, AV_PIX_FMT_YUVA422P=300, AV_PIX_FMT_YUV420P12BE=301, AV_PIX_FMT_YUV420P12LE=302, AV_PIX_FMT_YUV420P14BE=303, AV_PIX_FMT_YUV420P14LE=304, AV_PIX_FMT_YUV422P12BE=305, AV_PIX_FMT_YUV422P12LE=306, AV_PIX_FMT_YUV422P14BE=307, AV_PIX_FMT_YUV422P14LE=308, AV_PIX_FMT_YUV444P12BE=309, AV_PIX_FMT_YUV444P12LE=310, AV_PIX_FMT_YUV444P14BE=311, AV_PIX_FMT_YUV444P14LE=312, AV_PIX_FMT_GBRP12BE=313, AV_PIX_FMT_GBRP12LE=314, AV_PIX_FMT_GBRP14BE=315, AV_PIX_FMT_GBRP14LE=316, AV_PIX_FMT_GBRAP=317, AV_PIX_FMT_GBRAP16BE=318, AV_PIX_FMT_GBRAP16LE=319, AV_PIX_FMT_YUVJ411P=320, AV_PIX_FMT_BAYER_BGGR8=321, AV_PIX_FMT_BAYER_RGGB8=322, AV_PIX_FMT_BAYER_GBRG8=323, AV_PIX_FMT_BAYER_GRBG8=324, AV_PIX_FMT_BAYER_BGGR16LE=325, AV_PIX_FMT_BAYER_BGGR16BE=326, AV_PIX_FMT_BAYER_RGGB16LE=327, AV_PIX_FMT_BAYER_RGGB16BE=328, AV_PIX_FMT_BAYER_GBRG16LE=329, AV_PIX_FMT_BAYER_GBRG16BE=330, AV_PIX_FMT_BAYER_GRBG16LE=331, AV_PIX_FMT_BAYER_GRBG16BE=332, AV_PIX_FMT_YUV440P10LE=333, AV_PIX_FMT_YUV440P10BE=334, AV_PIX_FMT_YUV440P12LE=335, AV_PIX_FMT_YUV440P12BE=336, AV_PIX_FMT_AYUV64LE=337, AV_PIX_FMT_AYUV64BE=338, AV_PIX_FMT_VIDEOTOOLBOX=339, AV_PIX_FMT_NB=340, PIX_FMT_NONE=-1, PIX_FMT_YUV420P=0, PIX_FMT_YUYV422=1, PIX_FMT_RGB24=2, PIX_FMT_BGR24=3, PIX_FMT_YUV422P=4, PIX_FMT_YUV444P=5, PIX_FMT_YUV410P=6, PIX_FMT_YUV411P=7, PIX_FMT_GRAY8=8, PIX_FMT_MONOWHITE=9, PIX_FMT_MONOBLACK=10, PIX_FMT_PAL8=11, PIX_FMT_YUVJ420P=12, PIX_FMT_YUVJ422P=13, PIX_FMT_YUVJ444P=14, PIX_FMT_XVMC_MPEG2_MC=15, PIX_FMT_XVMC_MPEG2_IDCT=16, PIX_FMT_UYVY422=17, PIX_FMT_UYYVYY411=18, PIX_FMT_BGR8=19, PIX_FMT_BGR4=20, PIX_FMT_BGR4_BYTE=21, PIX_FMT_RGB8=22, PIX_FMT_RGB4=23, PIX_FMT_RGB4_BYTE=24, PIX_FMT_NV12=25, PIX_FMT_NV21=26, PIX_FMT_ARGB=27, PIX_FMT_RGBA=28, PIX_FMT_ABGR=29, PIX_FMT_BGRA=30, PIX_FMT_GRAY16BE=31, PIX_FMT_GRAY16LE=32, PIX_FMT_YUV440P=33, PIX_FMT_YUVJ440P=34, PIX_FMT_YUVA420P=35, PIX_FMT_VDPAU_H264=36, PIX_FMT_VDPAU_MPEG1=37, PIX_FMT_VDPAU_MPEG2=38, PIX_FMT_VDPAU_WMV3=39, PIX_FMT_VDPAU_VC1=40, PIX_FMT_RGB48BE=41, PIX_FMT_RGB48LE=42, PIX_FMT_RGB565BE=43, PIX_FMT_RGB565LE=44, PIX_FMT_RGB555BE=45, PIX_FMT_RGB555LE=46, PIX_FMT_BGR565BE=47, PIX_FMT_BGR565LE=48, PIX_FMT_BGR555BE=49, PIX_FMT_BGR555LE=50, PIX_FMT_VAAPI_MOCO=51, PIX_FMT_VAAPI_IDCT=52, PIX_FMT_VAAPI_VLD=53, PIX_FMT_YUV420P16LE=54, PIX_FMT_YUV420P16BE=55, PIX_FMT_YUV422P16LE=56, PIX_FMT_YUV422P16BE=57, PIX_FMT_YUV444P16LE=58, PIX_FMT_YUV444P16BE=59, PIX_FMT_VDPAU_MPEG4=60, PIX_FMT_DXVA2_VLD=61, PIX_FMT_RGB444LE=62, PIX_FMT_RGB444BE=63, PIX_FMT_BGR444LE=64, PIX_FMT_BGR444BE=65, PIX_FMT_GRAY8A=66, PIX_FMT_BGR48BE=67, PIX_FMT_BGR48LE=68, PIX_FMT_YUV420P9BE=69, PIX_FMT_YUV420P9LE=70, PIX_FMT_YUV420P10BE=71, PIX_FMT_YUV420P10LE=72, PIX_FMT_YUV422P10BE=73, PIX_FMT_YUV422P10LE=74, PIX_FMT_YUV444P9BE=75, PIX_FMT_YUV444P9LE=76, PIX_FMT_YUV444P10BE=77, PIX_FMT_YUV444P10LE=78, PIX_FMT_YUV422P9BE=79, PIX_FMT_YUV422P9LE=80, PIX_FMT_VDA_VLD=81, PIX_FMT_GBRP=82, PIX_FMT_GBRP9BE=83, PIX_FMT_GBRP9LE=84, PIX_FMT_GBRP10BE=85, PIX_FMT_GBRP10LE=86, PIX_FMT_GBRP16BE=87, PIX_FMT_GBRP16LE=88, PIX_FMT_RGBA64BE=291, PIX_FMT_RGBA64LE=292, PIX_FMT_BGRA64BE=293, PIX_FMT_BGRA64LE=294, PIX_FMT_0RGB=295, PIX_FMT_RGB0=296, PIX_FMT_0BGR=297, PIX_FMT_BGR0=298, PIX_FMT_YUVA444P=299, PIX_FMT_YUVA422P=300, PIX_FMT_YUV420P12BE=301, PIX_FMT_YUV420P12LE=302, PIX_FMT_YUV420P14BE=303, PIX_FMT_YUV420P14LE=304, PIX_FMT_YUV422P12BE=305, PIX_FMT_YUV422P12LE=306, PIX_FMT_YUV422P14BE=307, PIX_FMT_YUV422P14LE=308, PIX_FMT_YUV444P12BE=309, PIX_FMT_YUV444P12LE=310, PIX_FMT_YUV444P14BE=311, PIX_FMT_YUV444P14LE=312, PIX_FMT_GBRP12BE=313, PIX_FMT_GBRP12LE=314, PIX_FMT_GBRP14BE=315, PIX_FMT_GBRP14LE=316, PIX_FMT_NB=317 };

// tag-AVProbeData
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 448
struct AVProbeData;

// tag-AVProfile
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3460
struct AVProfile;

// tag-AVProgram
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1198
struct AVProgram;

// tag-AVRational
// file /usr/include/x86_64-linux-gnu/libavutil/rational.h line 43
struct AVRational;

// tag-AVSampleFormat
// file /usr/include/x86_64-linux-gnu/libavutil/samplefmt.h line 59
enum AVSampleFormat { AV_SAMPLE_FMT_NONE=-1, AV_SAMPLE_FMT_U8=0, AV_SAMPLE_FMT_S16=1, AV_SAMPLE_FMT_S32=2, AV_SAMPLE_FMT_FLT=3, AV_SAMPLE_FMT_DBL=4, AV_SAMPLE_FMT_U8P=5, AV_SAMPLE_FMT_S16P=6, AV_SAMPLE_FMT_S32P=7, AV_SAMPLE_FMT_FLTP=8, AV_SAMPLE_FMT_DBLP=9, AV_SAMPLE_FMT_NB=10 };

// tag-AVStream
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 834
struct AVStream;

// tag-AVStreamParseType
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 764
enum AVStreamParseType { AVSTREAM_PARSE_NONE=0, AVSTREAM_PARSE_FULL=1, AVSTREAM_PARSE_HEADERS=2, AVSTREAM_PARSE_TIMESTAMPS=3, AVSTREAM_PARSE_FULL_ONCE=4, AVSTREAM_PARSE_FULL_RAW=1463898624 };

// tag-AVSubtitle
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3467
struct AVSubtitle;

// tag-AVSubtitleRect
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3773
struct AVSubtitleRect;

// tag-AVSubtitleType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3753
enum AVSubtitleType { SUBTITLE_NONE=0, SUBTITLE_BITMAP=1, SUBTITLE_TEXT=2, SUBTITLE_ASS=3 };

// tag-FFFrac
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1174
struct FFFrac;

// tag-GrooveAudioFormat
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 114
struct GrooveAudioFormat;

// tag-GrooveBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 315
struct GrooveBuffer;

// tag-GrooveBufferPrivate
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/buffer.h line 17
struct GrooveBufferPrivate;

// tag-GrooveEncoder
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 22
struct GrooveEncoder;

// tag-GrooveEncoderPrivate
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 22
struct GrooveEncoderPrivate;

// tag-GrooveFile
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 133
struct GrooveFile;

// tag-GrooveFilePrivate
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.h line 16
struct GrooveFilePrivate;

// tag-GroovePlaylist
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 219
struct GroovePlaylist;

// tag-GroovePlaylistItem
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 193
struct GroovePlaylistItem;

// tag-GroovePlaylistPrivate
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 39
struct GroovePlaylistPrivate;

// tag-GrooveQueue
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 11
struct GrooveQueue;

// tag-GrooveQueuePrivate
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.c line 18
struct GrooveQueuePrivate;

// tag-GrooveSampleFormat
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 99
enum GrooveSampleFormat { GROOVE_SAMPLE_FMT_NONE=-1, GROOVE_SAMPLE_FMT_U8=0, GROOVE_SAMPLE_FMT_S16=1, GROOVE_SAMPLE_FMT_S32=2, GROOVE_SAMPLE_FMT_FLT=3, GROOVE_SAMPLE_FMT_DBL=4, GROOVE_SAMPLE_FMT_U8P=5, GROOVE_SAMPLE_FMT_S16P=6, GROOVE_SAMPLE_FMT_S32P=7, GROOVE_SAMPLE_FMT_FLTP=8, GROOVE_SAMPLE_FMT_DBLP=9 };

// tag-GrooveSink
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 354
struct GrooveSink;

// tag-GrooveSinkPrivate
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 21
struct GrooveSinkPrivate;

// tag-GrooveTag
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 148
struct GrooveTag;

// tag-ItemList
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.c line 13
struct ItemList;

// tag-MpegEncContext
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3571
struct MpegEncContext;

// tag-RcOverride
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 708
struct RcOverride;

// tag-SinkMap
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 33
struct SinkMap;

// tag-SinkStack
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 28
struct SinkStack;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// abs_diff
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 443
static signed int abs_diff(signed int a, signed int b);
// add_sink_to_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 785
static signed int add_sink_to_map(struct GroovePlaylist *playlist, struct GrooveSink *sink);
// any_sink_full
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 519
static signed int any_sink_full(struct GroovePlaylist *playlist);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// audio_decode_frame
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 154
static signed int audio_decode_frame(struct GroovePlaylist *playlist, struct GrooveFile *file);
// audioq_cleanup
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 269
static void audioq_cleanup(struct GrooveQueue *queue, void *obj);
// audioq_cleanup$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 631
static void audioq_cleanup$link1(struct GrooveQueue *queue$link1, void *obj$link1);
// audioq_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 286
static void audioq_get(struct GrooveQueue *queue, void *obj);
// audioq_get$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 614
static void audioq_get$link1(struct GrooveQueue *queue$link1, void *obj$link1);
// audioq_purge
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 261
static signed int audioq_purge(struct GrooveQueue *queue, void *obj);
// audioq_purge$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 641
static signed int audioq_purge$link1(struct GrooveQueue *queue$link1, void *obj$link1);
// audioq_put
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 278
static void audioq_put(struct GrooveQueue *queue, void *obj);
// audioq_put$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 606
static void audioq_put$link1(struct GrooveQueue *queue$link1, void *obj$link1);
// av_buffersink_get_frame
// file /usr/include/x86_64-linux-gnu/libavfilter/buffersink.h line 179
signed int av_buffersink_get_frame(struct AVFilterContext *, struct AVFrame *);
// av_buffersink_get_samples
// file /usr/include/x86_64-linux-gnu/libavfilter/buffersink.h line 198
signed int av_buffersink_get_samples(struct AVFilterContext *, struct AVFrame *, signed int);
// av_buffersrc_write_frame
// file /usr/include/x86_64-linux-gnu/libavfilter/buffersrc.h line 118
signed int av_buffersrc_write_frame(struct AVFilterContext *, const struct AVFrame *);
// av_codec_get_id
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2524
enum AVCodecID av_codec_get_id(struct AVCodecTag * const *, unsigned int);
// av_codec_get_tag
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2534
unsigned int av_codec_get_tag(struct AVCodecTag * const *, enum AVCodecID);
// av_dict_copy
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 166
void av_dict_copy(struct AVDictionary **, const struct AVDictionary *, signed int);
// av_dict_free
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 172
void av_dict_free(struct AVDictionary **);
// av_dict_get
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 104
struct AVDictionaryEntry * av_dict_get(const struct AVDictionary *, const char *, const struct AVDictionaryEntry *, signed int);
// av_dict_set
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 128
signed int av_dict_set(struct AVDictionary **, const char *, const char *, signed int);
// av_find_best_stream
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2149
signed int av_find_best_stream(struct AVFormatContext *, enum AVMediaType, signed int, signed int, struct AVCodec **, signed int);
// av_frame_alloc
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 630
struct AVFrame * av_frame_alloc(void);
// av_frame_free
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 639
void av_frame_free(struct AVFrame **);
// av_free
// file /usr/include/x86_64-linux-gnu/libavutil/mem.h line 195
void av_free(void *);
// av_free_packet
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4108
void av_free_packet(struct AVPacket *);
// av_get_bytes_per_sample
// file /usr/include/x86_64-linux-gnu/libavutil/samplefmt.h line 139
signed int av_get_bytes_per_sample(enum AVSampleFormat);
// av_get_channel_layout_nb_channels
// file /usr/include/x86_64-linux-gnu/libavutil/channel_layout.h line 167
signed int av_get_channel_layout_nb_channels(unsigned long int);
// av_get_channel_layout_string
// file /usr/include/x86_64-linux-gnu/libavutil/channel_layout.h line 156
void av_get_channel_layout_string(char *, signed int, signed int, unsigned long int);
// av_get_default_channel_layout
// file /usr/include/x86_64-linux-gnu/libavutil/channel_layout.h line 172
signed long int av_get_default_channel_layout(signed int);
// av_get_packed_sample_fmt
// file /usr/include/x86_64-linux-gnu/libavutil/samplefmt.h line 105
enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat);
// av_get_sample_fmt_name
// file /usr/include/x86_64-linux-gnu/libavutil/samplefmt.h line 80
const char * av_get_sample_fmt_name(enum AVSampleFormat);
// av_guess_codec
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2429
enum AVCodecID av_guess_codec(struct AVOutputFormat *, const char *, const char *, const char *, enum AVMediaType);
// av_guess_format
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2422
struct AVOutputFormat * av_guess_format(const char *, const char *, const char *);
// av_init_packet
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4040
void av_init_packet(struct AVPacket *);
// av_lockmgr_register
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 5560
signed int av_lockmgr_register(signed int (*)(void **, enum AVLockOp));
// av_log
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 234
void av_log(void *, signed int, const char *, ...);
// av_log_set_level
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 270
void av_log_set_level(signed int);
// av_malloc
// file /usr/include/x86_64-linux-gnu/libavutil/mem.h line 83
void * av_malloc(unsigned long int);
// av_mallocz
// file /usr/include/x86_64-linux-gnu/libavutil/mem.h line 205
void * av_mallocz(unsigned long int);
// av_q2d
// file /usr/include/x86_64-linux-gnu/libavutil/rational.h line 80
static inline double av_q2d(struct AVRational a);
// av_q2d$link1
// file /usr/include/x86_64-linux-gnu/libavutil/rational.h line 80
static inline double av_q2d$link1(struct AVRational a$link1);
// av_read_frame
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2180
signed int av_read_frame(struct AVFormatContext *, struct AVPacket *);
// av_read_pause
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2257
signed int av_read_pause(struct AVFormatContext *);
// av_read_play
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2250
signed int av_read_play(struct AVFormatContext *);
// av_register_all
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1884
void av_register_all(void);
// av_seek_frame
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2195
signed int av_seek_frame(struct AVFormatContext *, signed int, signed long int, signed int);
// av_strerror
// file /usr/include/x86_64-linux-gnu/libavutil/error.h line 97
signed int av_strerror(signed int, char *, unsigned long int);
// av_write_frame
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2324
signed int av_write_frame(struct AVFormatContext *, struct AVPacket *);
// av_write_trailer
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2408
signed int av_write_trailer(struct AVFormatContext *);
// avcodec_close
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4005
signed int avcodec_close(struct AVCodecContext *);
// avcodec_decode_audio4
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4446
signed int avcodec_decode_audio4(struct AVCodecContext *, struct AVFrame *, signed int *, const struct AVPacket *);
// avcodec_descriptor_get_by_name
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 5607
const struct AVCodecDescriptor * avcodec_descriptor_get_by_name(const char *);
// avcodec_encode_audio2
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4877
signed int avcodec_encode_audio2(struct AVCodecContext *, struct AVPacket *, const struct AVFrame *, signed int *);
// avcodec_find_encoder
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4798
struct AVCodec * avcodec_find_encoder(enum AVCodecID);
// avcodec_find_encoder_by_name
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4806
struct AVCodec * avcodec_find_encoder_by_name(const char *);
// avcodec_flush_buffers
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 5326
void avcodec_flush_buffers(struct AVCodecContext *);
// avcodec_open2
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3994
signed int avcodec_open2(struct AVCodecContext *, const struct AVCodec *, struct AVDictionary **);
// avcodec_register_all
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3850
void avcodec_register_all(void);
// avfilter_get_by_name
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1007
struct AVFilter * avfilter_get_by_name(const char *);
// avfilter_graph_alloc
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1255
struct AVFilterGraph * avfilter_graph_alloc(void);
// avfilter_graph_config
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1338
signed int avfilter_graph_config(struct AVFilterGraph *, void *);
// avfilter_graph_create_filter
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1312
signed int avfilter_graph_create_filter(struct AVFilterContext **, const struct AVFilter *, const char *, const char *, void *, struct AVFilterGraph *);
// avfilter_graph_free
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1344
void avfilter_graph_free(struct AVFilterGraph **);
// avfilter_link
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 878
signed int avfilter_link(struct AVFilterContext *, unsigned int, struct AVFilterContext *, unsigned int);
// avfilter_register_all
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 977
void avfilter_register_all(void);
// avformat_alloc_context
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1923
struct AVFormatContext * avformat_alloc_context(void);
// avformat_close_input
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2263
void avformat_close_input(struct AVFormatContext **);
// avformat_find_stream_info
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2111
signed int avformat_find_stream_info(struct AVFormatContext *, struct AVDictionary **);
// avformat_free_context
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1929
void avformat_free_context(struct AVFormatContext *);
// avformat_network_deinit
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1902
signed int avformat_network_deinit(void);
// avformat_network_init
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1897
signed int avformat_network_init(void);
// avformat_new_stream
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1958
struct AVStream * avformat_new_stream(struct AVFormatContext *, const struct AVCodec *);
// avformat_open_input
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2085
signed int avformat_open_input(struct AVFormatContext **, const char *, struct AVInputFormat *, struct AVDictionary **);
// avformat_write_header
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2292
signed int avformat_write_header(struct AVFormatContext *, struct AVDictionary **);
// avio_alloc_context
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 315
struct AVIOContext * avio_alloc_context(unsigned char *, signed int, signed int, void *, signed int (*)(void *, unsigned char *, signed int), signed int (*)(void *, unsigned char *, signed int), signed long int (*)(void *, signed long int, signed int));
// avio_closep
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 574
signed int avio_closep(struct AVIOContext **);
// avio_flush
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 427
void avio_flush(struct AVIOContext *);
// avio_open
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 528
signed int avio_open(struct AVIOContext **, const char *, signed int);
// cleanup_avcontext
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 99
static void cleanup_avcontext(struct GrooveEncoderPrivate *e);
// cleanup_save
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 199
static void cleanup_save(struct GrooveFile *file);
// closest_supported_channel_layout
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 520
static unsigned long int closest_supported_channel_layout(struct AVCodec *codec, unsigned long int target);
// closest_supported_sample_fmt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 460
static enum GrooveSampleFormat closest_supported_sample_fmt(struct AVCodec *codec, enum GrooveSampleFormat target);
// closest_supported_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 494
static signed int closest_supported_sample_rate(struct AVCodec *codec, signed int target);
// codec_supports_fmt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 448
static signed int codec_supports_fmt(struct AVCodec *codec, enum GrooveSampleFormat fmt);
// create_volume_filter
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 270
static signed int create_volume_filter(struct GroovePlaylistPrivate *p, struct AVFilterContext **audio_src_ctx, double vol, double amp_vol);
// decode_interrupt_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 13
static signed int decode_interrupt_cb(void *ctx);
// decode_one_frame
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 547
static signed int decode_one_frame(struct GroovePlaylist *playlist, struct GrooveFile *file);
// decode_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 661
static void * decode_thread(void *arg);
// encode_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 65
static signed int encode_buffer(struct GrooveEncoder *encoder, struct GrooveBuffer *buffer);
// encode_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 153
static void * encode_thread(void *arg);
// encoder_write_packet
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 298
static signed int encoder_write_packet(void *opaque, unsigned char *buf, signed int buf_size);
// every_sink
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 493
static signed int every_sink(struct GroovePlaylist *playlist, signed int (*func)(struct GrooveSink *), signed int default_value);
// every_sink::func$object
//
signed int func$object(struct GrooveSink *);
// every_sink_flush
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 543
static void every_sink_flush(struct GroovePlaylist *playlist);
// every_sink_full
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 515
static signed int every_sink_full(struct GroovePlaylist *playlist);
// every_sink_signal_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 529
static void every_sink_signal_end(struct GroovePlaylist *playlist);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// frame_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 107
static signed int frame_size(const struct AVFrame *frame);
// frame_to_groove_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 113
static struct GrooveBuffer * frame_to_groove_buffer(struct GroovePlaylist *playlist, struct GrooveSink *sink, struct AVFrame *frame);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gain_to_dB
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 266
static double gain_to_dB(double gain);
// groove_audio_formats_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 83
signed int groove_audio_formats_equal(struct GrooveAudioFormat *a, struct GrooveAudioFormat *b);
// groove_buffer_ref
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/buffer.c line 12
void groove_buffer_ref(struct GrooveBuffer *buffer);
// groove_buffer_unref
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 345
void groove_buffer_unref(struct GrooveBuffer *buffer);
// groove_channel_layout_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 71
signed int groove_channel_layout_count(unsigned long int channel_layout);
// groove_channel_layout_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 75
unsigned long int groove_channel_layout_default(signed int count);
// groove_encoder_attach
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 95
signed int groove_encoder_attach(struct GrooveEncoder *encoder, struct GroovePlaylist *playlist);
// groove_encoder_buffer_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 104
signed int groove_encoder_buffer_get(struct GrooveEncoder *encoder, struct GrooveBuffer **buffer, signed int block);
// groove_encoder_buffer_peek
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 690
signed int groove_encoder_buffer_peek(struct GrooveEncoder *encoder, signed int block);
// groove_encoder_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 87
struct GrooveEncoder * groove_encoder_create(void);
// groove_encoder_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 89
void groove_encoder_destroy(struct GrooveEncoder *encoder);
// groove_encoder_detach
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 97
signed int groove_encoder_detach(struct GrooveEncoder *encoder);
// groove_encoder_metadata_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 675
struct GrooveTag * groove_encoder_metadata_get(struct GrooveEncoder *encoder, const char *key, struct GrooveTag *prev, signed int flags);
// groove_encoder_metadata_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 117
signed int groove_encoder_metadata_set(struct GrooveEncoder *encoder, const char *key, const char *value, signed int flags);
// groove_encoder_position
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 695
void groove_encoder_position(struct GrooveEncoder *encoder, struct GroovePlaylistItem **item, double *seconds);
// groove_encoder_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 711
signed int groove_encoder_set_gain(struct GrooveEncoder *encoder, double gain);
// groove_file_audio_format
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 189
void groove_file_audio_format(struct GrooveFile *file, struct GrooveAudioFormat *audio_format);
// groove_file_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 157
void groove_file_close(struct GrooveFile *file);
// groove_file_duration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 139
double groove_file_duration(struct GrooveFile *file);
// groove_file_metadata_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 159
struct GrooveTag * groove_file_metadata_get(struct GrooveFile *file, const char *key, struct GrooveTag *prev, signed int flags);
// groove_file_metadata_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 164
signed int groove_file_metadata_set(struct GrooveFile *file, const char *key, const char *value, signed int flags);
// groove_file_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 156
struct GrooveFile * groove_file_open(const char *filename);
// groove_file_save
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 215
signed int groove_file_save(struct GrooveFile *file);
// groove_file_short_names
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 134
const char * groove_file_short_names(struct GrooveFile *file);
// groove_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 27
void groove_finish(void);
// groove_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 23
signed int groove_init(void);
// groove_playlist_clear
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1206
void groove_playlist_clear(struct GroovePlaylist *playlist);
// groove_playlist_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 285
signed int groove_playlist_count(struct GroovePlaylist *playlist);
// groove_playlist_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 234
struct GroovePlaylist * groove_playlist_create(void);
// groove_playlist_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 238
void groove_playlist_destroy(struct GroovePlaylist *playlist);
// groove_playlist_insert
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 254
struct GroovePlaylistItem * groove_playlist_insert(struct GroovePlaylist *playlist, struct GrooveFile *file, double gain, double peak, struct GroovePlaylistItem *next);
// groove_playlist_pause
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1075
void groove_playlist_pause(struct GroovePlaylist *playlist);
// groove_playlist_play
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1066
void groove_playlist_play(struct GroovePlaylist *playlist);
// groove_playlist_playing
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1283
signed int groove_playlist_playing(struct GroovePlaylist *playlist);
// groove_playlist_position
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1252
void groove_playlist_position(struct GroovePlaylist *playlist, struct GroovePlaylistItem **item, double *seconds);
// groove_playlist_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 262
void groove_playlist_remove(struct GroovePlaylist *playlist, struct GroovePlaylistItem *item);
// groove_playlist_seek
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1084
void groove_playlist_seek(struct GroovePlaylist *playlist, struct GroovePlaylistItem *item, double seconds);
// groove_playlist_set_fill_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1355
void groove_playlist_set_fill_mode(struct GroovePlaylist *playlist, signed int mode);
// groove_playlist_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1273
void groove_playlist_set_gain(struct GroovePlaylist *playlist, double gain);
// groove_playlist_set_item_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1226
void groove_playlist_set_item_gain(struct GroovePlaylist *playlist, struct GroovePlaylistItem *item, double gain);
// groove_playlist_set_item_peak
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1239
void groove_playlist_set_item_peak(struct GroovePlaylist *playlist, struct GroovePlaylistItem *item, double peak);
// groove_queue_abort
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 26
void groove_queue_abort(struct GrooveQueue *queue);
// groove_queue_cleanup_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.c line 219
void groove_queue_cleanup_default(struct GrooveQueue *queue, void *obj);
// groove_queue_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 20
struct GrooveQueue * groove_queue_create(void);
// groove_queue_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 24
void groove_queue_destroy(struct GrooveQueue *queue);
// groove_queue_flush
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 22
void groove_queue_flush(struct GrooveQueue *queue);
// groove_queue_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 32
signed int groove_queue_get(struct GrooveQueue *queue, void **obj_ptr, signed int block);
// groove_queue_peek
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 34
signed int groove_queue_peek(struct GrooveQueue *queue, signed int block);
// groove_queue_purge
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 36
void groove_queue_purge(struct GrooveQueue *queue);
// groove_queue_put
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 29
signed int groove_queue_put(struct GrooveQueue *queue, void *obj);
// groove_queue_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 27
void groove_queue_reset(struct GrooveQueue *queue);
// groove_sample_format_bytes_per_sample
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 79
signed int groove_sample_format_bytes_per_sample(enum GrooveSampleFormat format);
// groove_set_logging
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 35
void groove_set_logging(signed int level);
// groove_sink_attach
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 414
signed int groove_sink_attach(struct GrooveSink *sink, struct GroovePlaylist *playlist);
// groove_sink_buffer_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 423
signed int groove_sink_buffer_get(struct GrooveSink *sink, struct GrooveBuffer **buffer, signed int block);
// groove_sink_buffer_peek
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 924
signed int groove_sink_buffer_peek(struct GrooveSink *sink, signed int block);
// groove_sink_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 408
struct GrooveSink * groove_sink_create(void);
// groove_sink_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 409
void groove_sink_destroy(struct GrooveSink *sink);
// groove_sink_detach
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 416
signed int groove_sink_detach(struct GrooveSink *sink);
// groove_sink_pause
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 840
static signed int groove_sink_pause(struct GrooveSink *sink);
// groove_sink_play
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 833
static signed int groove_sink_play(struct GrooveSink *sink);
// groove_sink_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 435
signed int groove_sink_set_gain(struct GrooveSink *sink, double gain);
// groove_tag_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 150
const char * groove_tag_key(struct GrooveTag *tag);
// groove_tag_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 151
const char * groove_tag_value(struct GrooveTag *tag);
// groove_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 89
const char * groove_version(void);
// groove_version_major
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 93
signed int groove_version_major(void);
// groove_version_minor
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 97
signed int groove_version_minor(void);
// groove_version_patch
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 101
signed int groove_version_patch(void);
// init_avcontext
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 118
static signed int init_avcontext(struct GrooveEncoder *encoder);
// init_filter_graph
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 326
static signed int init_filter_graph(struct GroovePlaylist *playlist, struct GrooveFile *file);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// log_audio_fmt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 550
static void log_audio_fmt(struct GrooveAudioFormat *fmt);
// maybe_init_filter_graph
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 471
static signed int maybe_init_filter_graph(struct GroovePlaylist *playlist, struct GrooveFile *file);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// my_lockmgr_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 18
static signed int my_lockmgr_cb(void **mutex, enum AVLockOp op);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$1 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$1 *, const union anonymous$6 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$1 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$1 *, union anonymous$0 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$0 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$0 *, const union anonymous$6 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$0 *);
// purge_sink
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1155
static signed int purge_sink(struct GrooveSink *sink);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// remove_sink_from_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 743
static signed int remove_sink_from_map(struct GrooveSink *sink);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// sink_flush
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 246
static void sink_flush(struct GrooveSink *sink);
// sink_flush$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 533
static signed int sink_flush$link1(struct GrooveSink *sink$link1);
// sink_formats_compatible
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 722
static signed int sink_formats_compatible(struct GrooveSink *example_sink, struct GrooveSink *test_sink);
// sink_is_full
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 510
static signed int sink_is_full(struct GrooveSink *sink);
// sink_purge
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 229
static void sink_purge(struct GrooveSink *sink, struct GroovePlaylistItem *item);
// sink_signal_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 523
static signed int sink_signal_end(struct GrooveSink *sink);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// tempfileify
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 182
static signed int tempfileify(char *str, unsigned long int max_len);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// update_playlist_volume
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 652
static void update_playlist_volume(struct GroovePlaylist *playlist);
// usage
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/example/transcode.c line 9
static signed int usage(char *arg0);

struct anonymous
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$4
{
  // last_dts
  signed long int last_dts;
  // duration_gcd
  signed long int duration_gcd;
  // duration_count
  signed int duration_count;
  // rfps_duration_sum
  signed long int rfps_duration_sum;
  // duration_error
  double (*duration_error)[2l][399l];
  // codec_info_duration
  signed long int codec_info_duration;
  // codec_info_duration_fields
  signed long int codec_info_duration_fields;
  // found_decoder
  signed int found_decoder;
  // last_duration
  signed long int last_duration;
  // fps_first_dts
  signed long int fps_first_dts;
  // fps_first_dts_idx
  signed int fps_first_dts_idx;
  // fps_last_dts
  signed long int fps_last_dts;
  // fps_last_dts_idx
  signed int fps_last_dts_idx;
};

union anonymous$6
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct AVRational
{
  // num
  signed int num;
  // den
  signed int den;
};

union anonymous$2
{
  // i64
  signed long int i64;
  // dbl
  double dbl;
  // str
  const char *str;
  // q
  struct AVRational q;
};

union anonymous$1
{
  // __data
  struct anonymous __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct AVBufferRef
{
  // buffer
  struct AVBuffer *buffer;
  // data
  unsigned char *data;
  // size
  signed int size;
};

struct AVChapter
{
  // id
  signed int id;
  // time_base
  struct AVRational time_base;
  // start
  signed long int start;
  // end
  signed long int end;
  // metadata
  struct AVDictionary *metadata;
};

struct AVClass
{
  // class_name
  const char *class_name;
  // item_name
  const char * (*item_name)(void *);
  // option
  struct AVOption *option;
  // version
  signed int version;
  // log_level_offset_offset
  signed int log_level_offset_offset;
  // parent_log_context_offset
  signed int parent_log_context_offset;
  // child_next
  void * (*child_next)(void *, void *);
  // child_class_next
  struct AVClass * (*child_class_next)(struct AVClass *);
  // category
  enum anonymous$5 category;
  // get_category
  enum anonymous$5 (*get_category)(void *);
  // query_ranges
  signed int (*query_ranges)(struct AVOptionRanges **, void *, const char *, signed int);
};

struct AVCodec
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // type
  enum AVMediaType type;
  // id
  enum AVCodecID id;
  // capabilities
  signed int capabilities;
  // supported_framerates
  const struct AVRational *supported_framerates;
  // pix_fmts
  const enum AVPixelFormat *pix_fmts;
  // supported_samplerates
  const signed int *supported_samplerates;
  // sample_fmts
  const enum AVSampleFormat *sample_fmts;
  // channel_layouts
  const unsigned long int *channel_layouts;
  // max_lowres
  unsigned char max_lowres;
  // priv_class
  const struct AVClass *priv_class;
  // profiles
  const struct AVProfile *profiles;
  // priv_data_size
  signed int priv_data_size;
  // next
  struct AVCodec *next;
  // init_thread_copy
  signed int (*init_thread_copy)(struct AVCodecContext *);
  // update_thread_context
  signed int (*update_thread_context)(struct AVCodecContext *, const struct AVCodecContext *);
  // defaults
  const struct AVCodecDefault *defaults;
  // init_static_data
  void (*init_static_data)(struct AVCodec *);
  // init
  signed int (*init)(struct AVCodecContext *);
  // encode_sub
  signed int (*encode_sub)(struct AVCodecContext *, unsigned char *, signed int, struct AVSubtitle *);
  // encode2
  signed int (*encode2)(struct AVCodecContext *, struct AVPacket *, const struct AVFrame *, signed int *);
  // decode
  signed int (*decode)(struct AVCodecContext *, void *, signed int *, struct AVPacket *);
  // close
  signed int (*close)(struct AVCodecContext *);
  // flush
  void (*flush)(struct AVCodecContext *);
  // caps_internal
  signed int caps_internal;
};

struct AVCodecContext
{
  // av_class
  const struct AVClass *av_class;
  // log_level_offset
  signed int log_level_offset;
  // codec_type
  enum AVMediaType codec_type;
  // codec
  struct AVCodec *codec;
  // codec_name
  char codec_name[32l];
  // codec_id
  enum AVCodecID codec_id;
  // codec_tag
  unsigned int codec_tag;
  // stream_codec_tag
  unsigned int stream_codec_tag;
  // priv_data
  void *priv_data;
  // internal
  struct AVCodecInternal *internal;
  // opaque
  void *opaque;
  // bit_rate
  signed int bit_rate;
  // bit_rate_tolerance
  signed int bit_rate_tolerance;
  // global_quality
  signed int global_quality;
  // compression_level
  signed int compression_level;
  // flags
  signed int flags;
  // flags2
  signed int flags2;
  // extradata
  unsigned char *extradata;
  // extradata_size
  signed int extradata_size;
  // time_base
  struct AVRational time_base;
  // ticks_per_frame
  signed int ticks_per_frame;
  // delay
  signed int delay;
  // width
  signed int width;
  // height
  signed int height;
  // coded_width
  signed int coded_width;
  // coded_height
  signed int coded_height;
  // gop_size
  signed int gop_size;
  // pix_fmt
  enum AVPixelFormat pix_fmt;
  // me_method
  signed int me_method;
  // draw_horiz_band
  void (*draw_horiz_band)(struct AVCodecContext *, const struct AVFrame *, signed int *, signed int, signed int, signed int);
  // get_format
  enum AVPixelFormat (*get_format)(struct AVCodecContext *, const enum AVPixelFormat *);
  // max_b_frames
  signed int max_b_frames;
  // b_quant_factor
  float b_quant_factor;
  // rc_strategy
  signed int rc_strategy;
  // b_frame_strategy
  signed int b_frame_strategy;
  // b_quant_offset
  float b_quant_offset;
  // has_b_frames
  signed int has_b_frames;
  // mpeg_quant
  signed int mpeg_quant;
  // i_quant_factor
  float i_quant_factor;
  // i_quant_offset
  float i_quant_offset;
  // lumi_masking
  float lumi_masking;
  // temporal_cplx_masking
  float temporal_cplx_masking;
  // spatial_cplx_masking
  float spatial_cplx_masking;
  // p_masking
  float p_masking;
  // dark_masking
  float dark_masking;
  // slice_count
  signed int slice_count;
  // prediction_method
  signed int prediction_method;
  // slice_offset
  signed int *slice_offset;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // me_cmp
  signed int me_cmp;
  // me_sub_cmp
  signed int me_sub_cmp;
  // mb_cmp
  signed int mb_cmp;
  // ildct_cmp
  signed int ildct_cmp;
  // dia_size
  signed int dia_size;
  // last_predictor_count
  signed int last_predictor_count;
  // pre_me
  signed int pre_me;
  // me_pre_cmp
  signed int me_pre_cmp;
  // pre_dia_size
  signed int pre_dia_size;
  // me_subpel_quality
  signed int me_subpel_quality;
  // dtg_active_format
  signed int dtg_active_format;
  // me_range
  signed int me_range;
  // intra_quant_bias
  signed int intra_quant_bias;
  // inter_quant_bias
  signed int inter_quant_bias;
  // slice_flags
  signed int slice_flags;
  // xvmc_acceleration
  signed int xvmc_acceleration;
  // mb_decision
  signed int mb_decision;
  // intra_matrix
  unsigned short int *intra_matrix;
  // inter_matrix
  unsigned short int *inter_matrix;
  // scenechange_threshold
  signed int scenechange_threshold;
  // noise_reduction
  signed int noise_reduction;
  // me_threshold
  signed int me_threshold;
  // mb_threshold
  signed int mb_threshold;
  // intra_dc_precision
  signed int intra_dc_precision;
  // skip_top
  signed int skip_top;
  // skip_bottom
  signed int skip_bottom;
  // border_masking
  float border_masking;
  // mb_lmin
  signed int mb_lmin;
  // mb_lmax
  signed int mb_lmax;
  // me_penalty_compensation
  signed int me_penalty_compensation;
  // bidir_refine
  signed int bidir_refine;
  // brd_scale
  signed int brd_scale;
  // keyint_min
  signed int keyint_min;
  // refs
  signed int refs;
  // chromaoffset
  signed int chromaoffset;
  // scenechange_factor
  signed int scenechange_factor;
  // mv0_threshold
  signed int mv0_threshold;
  // b_sensitivity
  signed int b_sensitivity;
  // color_primaries
  enum AVColorPrimaries color_primaries;
  // color_trc
  enum AVColorTransferCharacteristic color_trc;
  // colorspace
  enum AVColorSpace colorspace;
  // color_range
  enum AVColorRange color_range;
  // chroma_sample_location
  enum AVChromaLocation chroma_sample_location;
  // slices
  signed int slices;
  // field_order
  enum AVFieldOrder field_order;
  // sample_rate
  signed int sample_rate;
  // channels
  signed int channels;
  // sample_fmt
  enum AVSampleFormat sample_fmt;
  // frame_size
  signed int frame_size;
  // frame_number
  signed int frame_number;
  // block_align
  signed int block_align;
  // cutoff
  signed int cutoff;
  // request_channels
  signed int request_channels;
  // channel_layout
  unsigned long int channel_layout;
  // request_channel_layout
  unsigned long int request_channel_layout;
  // audio_service_type
  enum AVAudioServiceType audio_service_type;
  // request_sample_fmt
  enum AVSampleFormat request_sample_fmt;
  // get_buffer
  signed int (*get_buffer)(struct AVCodecContext *, struct AVFrame *);
  // release_buffer
  void (*release_buffer)(struct AVCodecContext *, struct AVFrame *);
  // reget_buffer
  signed int (*reget_buffer)(struct AVCodecContext *, struct AVFrame *);
  // get_buffer2
  signed int (*get_buffer2)(struct AVCodecContext *, struct AVFrame *, signed int);
  // refcounted_frames
  signed int refcounted_frames;
  // qcompress
  float qcompress;
  // qblur
  float qblur;
  // qmin
  signed int qmin;
  // qmax
  signed int qmax;
  // max_qdiff
  signed int max_qdiff;
  // rc_qsquish
  float rc_qsquish;
  // rc_qmod_amp
  float rc_qmod_amp;
  // rc_qmod_freq
  signed int rc_qmod_freq;
  // rc_buffer_size
  signed int rc_buffer_size;
  // rc_override_count
  signed int rc_override_count;
  // rc_override
  struct RcOverride *rc_override;
  // rc_eq
  const char *rc_eq;
  // rc_max_rate
  signed int rc_max_rate;
  // rc_min_rate
  signed int rc_min_rate;
  // rc_buffer_aggressivity
  float rc_buffer_aggressivity;
  // rc_initial_cplx
  float rc_initial_cplx;
  // rc_max_available_vbv_use
  float rc_max_available_vbv_use;
  // rc_min_vbv_overflow_use
  float rc_min_vbv_overflow_use;
  // rc_initial_buffer_occupancy
  signed int rc_initial_buffer_occupancy;
  // coder_type
  signed int coder_type;
  // context_model
  signed int context_model;
  // lmin
  signed int lmin;
  // lmax
  signed int lmax;
  // frame_skip_threshold
  signed int frame_skip_threshold;
  // frame_skip_factor
  signed int frame_skip_factor;
  // frame_skip_exp
  signed int frame_skip_exp;
  // frame_skip_cmp
  signed int frame_skip_cmp;
  // trellis
  signed int trellis;
  // min_prediction_order
  signed int min_prediction_order;
  // max_prediction_order
  signed int max_prediction_order;
  // timecode_frame_start
  signed long int timecode_frame_start;
  // rtp_callback
  void (*rtp_callback)(struct AVCodecContext *, void *, signed int, signed int);
  // rtp_payload_size
  signed int rtp_payload_size;
  // mv_bits
  signed int mv_bits;
  // header_bits
  signed int header_bits;
  // i_tex_bits
  signed int i_tex_bits;
  // p_tex_bits
  signed int p_tex_bits;
  // i_count
  signed int i_count;
  // p_count
  signed int p_count;
  // skip_count
  signed int skip_count;
  // misc_bits
  signed int misc_bits;
  // frame_bits
  signed int frame_bits;
  // stats_out
  char *stats_out;
  // stats_in
  char *stats_in;
  // workaround_bugs
  signed int workaround_bugs;
  // strict_std_compliance
  signed int strict_std_compliance;
  // error_concealment
  signed int error_concealment;
  // debug
  signed int debug;
  // debug_mv
  signed int debug_mv;
  // err_recognition
  signed int err_recognition;
  // reordered_opaque
  signed long int reordered_opaque;
  // hwaccel
  struct AVHWAccel *hwaccel;
  // hwaccel_context
  void *hwaccel_context;
  // error
  unsigned long int error[8l];
  // dct_algo
  signed int dct_algo;
  // idct_algo
  signed int idct_algo;
  // bits_per_coded_sample
  signed int bits_per_coded_sample;
  // bits_per_raw_sample
  signed int bits_per_raw_sample;
  // lowres
  signed int lowres;
  // coded_frame
  struct AVFrame *coded_frame;
  // thread_count
  signed int thread_count;
  // thread_type
  signed int thread_type;
  // active_thread_type
  signed int active_thread_type;
  // thread_safe_callbacks
  signed int thread_safe_callbacks;
  // execute
  signed int (*execute)(struct AVCodecContext *, signed int (*)(struct AVCodecContext *, void *), void *, signed int *, signed int, signed int);
  // execute2
  signed int (*execute2)(struct AVCodecContext *, signed int (*)(struct AVCodecContext *, void *, signed int, signed int), void *, signed int *, signed int);
  // thread_opaque
  void *thread_opaque;
  // nsse_weight
  signed int nsse_weight;
  // profile
  signed int profile;
  // level
  signed int level;
  // skip_loop_filter
  enum AVDiscard skip_loop_filter;
  // skip_idct
  enum AVDiscard skip_idct;
  // skip_frame
  enum AVDiscard skip_frame;
  // subtitle_header
  unsigned char *subtitle_header;
  // subtitle_header_size
  signed int subtitle_header_size;
  // error_rate
  signed int error_rate;
  // pkt
  struct AVPacket *pkt;
  // vbv_delay
  unsigned long int vbv_delay;
  // side_data_only_packets
  signed int side_data_only_packets;
  // initial_padding
  signed int initial_padding;
  // framerate
  struct AVRational framerate;
  // sw_pix_fmt
  enum AVPixelFormat sw_pix_fmt;
  // pkt_timebase
  struct AVRational pkt_timebase;
  // codec_descriptor
  const struct AVCodecDescriptor *codec_descriptor;
  // pts_correction_num_faulty_pts
  signed long int pts_correction_num_faulty_pts;
  // pts_correction_num_faulty_dts
  signed long int pts_correction_num_faulty_dts;
  // pts_correction_last_pts
  signed long int pts_correction_last_pts;
  // pts_correction_last_dts
  signed long int pts_correction_last_dts;
  // sub_charenc
  char *sub_charenc;
  // sub_charenc_mode
  signed int sub_charenc_mode;
  // skip_alpha
  signed int skip_alpha;
  // seek_preroll
  signed int seek_preroll;
  // chroma_intra_matrix
  unsigned short int *chroma_intra_matrix;
  // dump_separator
  unsigned char *dump_separator;
  // codec_whitelist
  char *codec_whitelist;
  // properties
  unsigned int properties;
};

struct AVCodecDescriptor
{
  // id
  enum AVCodecID id;
  // type
  enum AVMediaType type;
  // name
  const char *name;
  // long_name
  const char *long_name;
  // props
  signed int props;
  // mime_types
  const char * const *mime_types;
};

struct AVCodecParser
{
  // codec_ids
  signed int codec_ids[5l];
  // priv_data_size
  signed int priv_data_size;
  // parser_init
  signed int (*parser_init)(struct AVCodecParserContext *);
  // parser_parse
  signed int (*parser_parse)(struct AVCodecParserContext *, struct AVCodecContext *, const unsigned char **, signed int *, const unsigned char *, signed int);
  // parser_close
  void (*parser_close)(struct AVCodecParserContext *);
  // split
  signed int (*split)(struct AVCodecContext *, const unsigned char *, signed int);
  // next
  struct AVCodecParser *next;
};

struct AVCodecParserContext
{
  // priv_data
  void *priv_data;
  // parser
  struct AVCodecParser *parser;
  // frame_offset
  signed long int frame_offset;
  // cur_offset
  signed long int cur_offset;
  // next_frame_offset
  signed long int next_frame_offset;
  // pict_type
  signed int pict_type;
  // repeat_pict
  signed int repeat_pict;
  // pts
  signed long int pts;
  // dts
  signed long int dts;
  // last_pts
  signed long int last_pts;
  // last_dts
  signed long int last_dts;
  // fetch_timestamp
  signed int fetch_timestamp;
  // cur_frame_start_index
  signed int cur_frame_start_index;
  // cur_frame_offset
  signed long int cur_frame_offset[4l];
  // cur_frame_pts
  signed long int cur_frame_pts[4l];
  // cur_frame_dts
  signed long int cur_frame_dts[4l];
  // flags
  signed int flags;
  // offset
  signed long int offset;
  // cur_frame_end
  signed long int cur_frame_end[4l];
  // key_frame
  signed int key_frame;
  // convergence_duration
  signed long int convergence_duration;
  // dts_sync_point
  signed int dts_sync_point;
  // dts_ref_dts_delta
  signed int dts_ref_dts_delta;
  // pts_dts_delta
  signed int pts_dts_delta;
  // cur_frame_pos
  signed long int cur_frame_pos[4l];
  // pos
  signed long int pos;
  // last_pos
  signed long int last_pos;
  // duration
  signed int duration;
  // field_order
  enum AVFieldOrder field_order;
  // picture_structure
  enum AVPictureStructure picture_structure;
  // output_picture_number
  signed int output_picture_number;
  // width
  signed int width;
  // height
  signed int height;
  // coded_width
  signed int coded_width;
  // coded_height
  signed int coded_height;
  // format
  signed int format;
};

struct AVDictionaryEntry
{
  // key
  char *key;
  // value
  char *value;
};

struct AVFilter
{
  // name
  const char *name;
  // description
  const char *description;
  // inputs
  const struct AVFilterPad *inputs;
  // outputs
  const struct AVFilterPad *outputs;
  // priv_class
  const struct AVClass *priv_class;
  // flags
  signed int flags;
  // init
  signed int (*init)(struct AVFilterContext *);
  // init_dict
  signed int (*init_dict)(struct AVFilterContext *, struct AVDictionary **);
  // uninit
  void (*uninit)(struct AVFilterContext *);
  // query_formats
  signed int (*query_formats)(struct AVFilterContext *);
  // priv_size
  signed int priv_size;
  // next
  struct AVFilter *next;
  // process_command
  signed int (*process_command)(struct AVFilterContext *, const char *, const char *, char *, signed int, signed int);
  // init_opaque
  signed int (*init_opaque)(struct AVFilterContext *, void *);
};

struct AVFilterBuffer
{
  // data
  unsigned char *data[8l];
  // extended_data
  unsigned char **extended_data;
  // linesize
  signed int linesize[8l];
  // priv
  void *priv;
  // free
  void (*free)(struct AVFilterBuffer *);
  // format
  signed int format;
  // w
  signed int w;
  // h
  signed int h;
  // refcount
  unsigned int refcount;
};

struct AVFilterBufferRef
{
  // buf
  struct AVFilterBuffer *buf;
  // data
  unsigned char *data[8l];
  // extended_data
  unsigned char **extended_data;
  // linesize
  signed int linesize[8l];
  // video
  struct AVFilterBufferRefVideoProps *video;
  // audio
  struct AVFilterBufferRefAudioProps *audio;
  // pts
  signed long int pts;
  // pos
  signed long int pos;
  // format
  signed int format;
  // perms
  signed int perms;
  // type
  enum AVMediaType type;
  // metadata
  struct AVDictionary *metadata;
};

struct AVFilterBufferRefAudioProps
{
  // channel_layout
  unsigned long int channel_layout;
  // nb_samples
  signed int nb_samples;
  // sample_rate
  signed int sample_rate;
  // channels
  signed int channels;
};

struct AVFilterBufferRefVideoProps
{
  // w
  signed int w;
  // h
  signed int h;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // interlaced
  signed int interlaced;
  // top_field_first
  signed int top_field_first;
  // pict_type
  enum AVPictureType pict_type;
  // key_frame
  signed int key_frame;
  // qp_table_linesize
  signed int qp_table_linesize;
  // qp_table_size
  signed int qp_table_size;
  // qp_table
  signed char *qp_table;
};

struct AVFilterContext
{
  // av_class
  const struct AVClass *av_class;
  // filter
  const struct AVFilter *filter;
  // name
  char *name;
  // input_pads
  struct AVFilterPad *input_pads;
  // inputs
  struct AVFilterLink **inputs;
  // input_count
  unsigned int input_count;
  // nb_inputs
  unsigned int nb_inputs;
  // output_pads
  struct AVFilterPad *output_pads;
  // outputs
  struct AVFilterLink **outputs;
  // output_count
  unsigned int output_count;
  // nb_outputs
  unsigned int nb_outputs;
  // priv
  void *priv;
  // graph
  struct AVFilterGraph *graph;
  // thread_type
  signed int thread_type;
  // internal
  struct AVFilterInternal *internal;
  // command_queue
  struct AVFilterCommand *command_queue;
  // enable_str
  char *enable_str;
  // enable
  void *enable;
  // var_values
  double *var_values;
  // is_disabled
  signed int is_disabled;
};

struct AVFilterGraph
{
  // av_class
  const struct AVClass *av_class;
  // filter_count_unused
  unsigned int filter_count_unused;
  // filters
  struct AVFilterContext **filters;
  // scale_sws_opts
  char *scale_sws_opts;
  // resample_lavr_opts
  char *resample_lavr_opts;
  // nb_filters
  unsigned int nb_filters;
  // thread_type
  signed int thread_type;
  // nb_threads
  signed int nb_threads;
  // internal
  struct AVFilterGraphInternal *internal;
  // opaque
  void *opaque;
  // execute
  signed int (*execute)(struct AVFilterContext *, signed int (*)(struct AVFilterContext *, void *, signed int, signed int), void *, signed int *, signed int);
  // aresample_swr_opts
  char *aresample_swr_opts;
  // sink_links
  struct AVFilterLink **sink_links;
  // sink_links_count
  signed int sink_links_count;
  // disable_auto_convert
  unsigned int disable_auto_convert;
};

struct AVFilterLink
{
  // src
  struct AVFilterContext *src;
  // srcpad
  struct AVFilterPad *srcpad;
  // dst
  struct AVFilterContext *dst;
  // dstpad
  struct AVFilterPad *dstpad;
  // type
  enum AVMediaType type;
  // w
  signed int w;
  // h
  signed int h;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // channel_layout
  unsigned long int channel_layout;
  // sample_rate
  signed int sample_rate;
  // format
  signed int format;
  // time_base
  struct AVRational time_base;
  // in_formats
  struct AVFilterFormats *in_formats;
  // out_formats
  struct AVFilterFormats *out_formats;
  // in_samplerates
  struct AVFilterFormats *in_samplerates;
  // out_samplerates
  struct AVFilterFormats *out_samplerates;
  // in_channel_layouts
  struct AVFilterChannelLayouts *in_channel_layouts;
  // out_channel_layouts
  struct AVFilterChannelLayouts *out_channel_layouts;
  // request_samples
  signed int request_samples;
  // init_state
  enum anonymous$3 init_state;
  // pool
  struct AVFilterPool *pool;
  // graph
  struct AVFilterGraph *graph;
  // current_pts
  signed long int current_pts;
  // age_index
  signed int age_index;
  // frame_rate
  struct AVRational frame_rate;
  // partial_buf
  struct AVFrame *partial_buf;
  // partial_buf_size
  signed int partial_buf_size;
  // min_samples
  signed int min_samples;
  // max_samples
  signed int max_samples;
  // cur_buf_copy
  struct AVFilterBufferRef *cur_buf_copy;
  // closed
  signed int closed;
  // channels
  signed int channels;
  // frame_requested
  unsigned int frame_requested;
  // flags
  unsigned int flags;
  // frame_count
  signed long int frame_count;
};

struct AVFilterPad
{
  // name
  const char *name;
  // type
  enum AVMediaType type;
  // min_perms
  signed int min_perms;
  // rej_perms
  signed int rej_perms;
  // start_frame
  signed int (*start_frame)(struct AVFilterLink *, struct AVFilterBufferRef *);
  // get_video_buffer
  struct AVFrame * (*get_video_buffer)(struct AVFilterLink *, signed int, signed int);
  // get_audio_buffer
  struct AVFrame * (*get_audio_buffer)(struct AVFilterLink *, signed int);
  // end_frame
  signed int (*end_frame)(struct AVFilterLink *);
  // draw_slice
  signed int (*draw_slice)(struct AVFilterLink *, signed int, signed int, signed int);
  // filter_frame
  signed int (*filter_frame)(struct AVFilterLink *, struct AVFrame *);
  // poll_frame
  signed int (*poll_frame)(struct AVFilterLink *);
  // request_frame
  signed int (*request_frame)(struct AVFilterLink *);
  // config_props
  signed int (*config_props)(struct AVFilterLink *);
  // needs_fifo
  signed int needs_fifo;
  // needs_writable
  signed int needs_writable;
};

struct AVIOInterruptCB
{
  // callback
  signed int (*callback)(void *);
  // opaque
  void *opaque;
};

struct AVFormatContext
{
  // av_class
  const struct AVClass *av_class;
  // iformat
  struct AVInputFormat *iformat;
  // oformat
  struct AVOutputFormat *oformat;
  // priv_data
  void *priv_data;
  // pb
  struct AVIOContext *pb;
  // ctx_flags
  signed int ctx_flags;
  // nb_streams
  unsigned int nb_streams;
  // streams
  struct AVStream **streams;
  // filename
  char filename[1024l];
  // start_time
  signed long int start_time;
  // duration
  signed long int duration;
  // bit_rate
  signed int bit_rate;
  // packet_size
  unsigned int packet_size;
  // max_delay
  signed int max_delay;
  // flags
  signed int flags;
  // probesize
  unsigned int probesize;
  // max_analyze_duration
  signed int max_analyze_duration;
  // key
  const unsigned char *key;
  // keylen
  signed int keylen;
  // nb_programs
  unsigned int nb_programs;
  // programs
  struct AVProgram **programs;
  // video_codec_id
  enum AVCodecID video_codec_id;
  // audio_codec_id
  enum AVCodecID audio_codec_id;
  // subtitle_codec_id
  enum AVCodecID subtitle_codec_id;
  // max_index_size
  unsigned int max_index_size;
  // max_picture_buffer
  unsigned int max_picture_buffer;
  // nb_chapters
  unsigned int nb_chapters;
  // chapters
  struct AVChapter **chapters;
  // metadata
  struct AVDictionary *metadata;
  // start_time_realtime
  signed long int start_time_realtime;
  // fps_probe_size
  signed int fps_probe_size;
  // error_recognition
  signed int error_recognition;
  // interrupt_callback
  struct AVIOInterruptCB interrupt_callback;
  // debug
  signed int debug;
  // max_interleave_delta
  signed long int max_interleave_delta;
  // strict_std_compliance
  signed int strict_std_compliance;
  // event_flags
  signed int event_flags;
  // max_ts_probe
  signed int max_ts_probe;
  // avoid_negative_ts
  signed int avoid_negative_ts;
  // ts_id
  signed int ts_id;
  // audio_preload
  signed int audio_preload;
  // max_chunk_duration
  signed int max_chunk_duration;
  // max_chunk_size
  signed int max_chunk_size;
  // use_wallclock_as_timestamps
  signed int use_wallclock_as_timestamps;
  // avio_flags
  signed int avio_flags;
  // duration_estimation_method
  enum AVDurationEstimationMethod duration_estimation_method;
  // skip_initial_bytes
  signed long int skip_initial_bytes;
  // correct_ts_overflow
  unsigned int correct_ts_overflow;
  // seek2any
  signed int seek2any;
  // flush_packets
  signed int flush_packets;
  // probe_score
  signed int probe_score;
  // format_probesize
  signed int format_probesize;
  // codec_whitelist
  char *codec_whitelist;
  // format_whitelist
  char *format_whitelist;
  // internal
  struct AVFormatInternal *internal;
  // io_repositioned
  signed int io_repositioned;
  // video_codec
  struct AVCodec *video_codec;
  // audio_codec
  struct AVCodec *audio_codec;
  // subtitle_codec
  struct AVCodec *subtitle_codec;
  // data_codec
  struct AVCodec *data_codec;
  // metadata_header_padding
  signed int metadata_header_padding;
  // opaque
  void *opaque;
  // control_message_cb
  signed int (*control_message_cb)(struct AVFormatContext *, signed int, void *, unsigned long int);
  // output_ts_offset
  signed long int output_ts_offset;
  // max_analyze_duration2
  signed long int max_analyze_duration2;
  // probesize2
  signed long int probesize2;
  // dump_separator
  unsigned char *dump_separator;
  // data_codec_id
  enum AVCodecID data_codec_id;
  // open_cb
  signed int (*open_cb)(struct AVFormatContext *, struct AVIOContext **, const char *, signed int, const struct AVIOInterruptCB *, struct AVDictionary **);
};

struct AVFrac
{
  // val
  signed long int val;
  // num
  signed long int num;
  // den
  signed long int den;
};

struct AVFrame
{
  // data
  unsigned char *data[8l];
  // linesize
  signed int linesize[8l];
  // extended_data
  unsigned char **extended_data;
  // width
  signed int width;
  // height
  signed int height;
  // nb_samples
  signed int nb_samples;
  // format
  signed int format;
  // key_frame
  signed int key_frame;
  // pict_type
  enum AVPictureType pict_type;
  // base
  unsigned char *base[8l];
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // pts
  signed long int pts;
  // pkt_pts
  signed long int pkt_pts;
  // pkt_dts
  signed long int pkt_dts;
  // coded_picture_number
  signed int coded_picture_number;
  // display_picture_number
  signed int display_picture_number;
  // quality
  signed int quality;
  // reference
  signed int reference;
  // qscale_table
  signed char *qscale_table;
  // qstride
  signed int qstride;
  // qscale_type
  signed int qscale_type;
  // mbskip_table
  unsigned char *mbskip_table;
  // motion_val
  signed short int (*motion_val[2l])[2l];
  // mb_type
  unsigned int *mb_type;
  // dct_coeff
  signed short int *dct_coeff;
  // ref_index
  signed char *ref_index[2l];
  // opaque
  void *opaque;
  // error
  unsigned long int error[8l];
  // type
  signed int type;
  // repeat_pict
  signed int repeat_pict;
  // interlaced_frame
  signed int interlaced_frame;
  // top_field_first
  signed int top_field_first;
  // palette_has_changed
  signed int palette_has_changed;
  // buffer_hints
  signed int buffer_hints;
  // pan_scan
  struct AVPanScan *pan_scan;
  // reordered_opaque
  signed long int reordered_opaque;
  // hwaccel_picture_private
  void *hwaccel_picture_private;
  // owner
  struct AVCodecContext *owner;
  // thread_opaque
  void *thread_opaque;
  // motion_subsample_log2
  unsigned char motion_subsample_log2;
  // sample_rate
  signed int sample_rate;
  // channel_layout
  unsigned long int channel_layout;
  // buf
  struct AVBufferRef *buf[8l];
  // extended_buf
  struct AVBufferRef **extended_buf;
  // nb_extended_buf
  signed int nb_extended_buf;
  // side_data
  struct AVFrameSideData **side_data;
  // nb_side_data
  signed int nb_side_data;
  // flags
  signed int flags;
  // color_range
  enum AVColorRange color_range;
  // color_primaries
  enum AVColorPrimaries color_primaries;
  // color_trc
  enum AVColorTransferCharacteristic color_trc;
  // colorspace
  enum AVColorSpace colorspace;
  // chroma_location
  enum AVChromaLocation chroma_location;
  // best_effort_timestamp
  signed long int best_effort_timestamp;
  // pkt_pos
  signed long int pkt_pos;
  // pkt_duration
  signed long int pkt_duration;
  // metadata
  struct AVDictionary *metadata;
  // decode_error_flags
  signed int decode_error_flags;
  // channels
  signed int channels;
  // pkt_size
  signed int pkt_size;
  // qp_table_buf
  struct AVBufferRef *qp_table_buf;
};

struct AVFrameSideData
{
  // type
  enum AVFrameSideDataType type;
  // data
  unsigned char *data;
  // size
  signed int size;
  // metadata
  struct AVDictionary *metadata;
  // buf
  struct AVBufferRef *buf;
};

struct AVHWAccel
{
  // name
  const char *name;
  // type
  enum AVMediaType type;
  // id
  enum AVCodecID id;
  // pix_fmt
  enum AVPixelFormat pix_fmt;
  // capabilities
  signed int capabilities;
  // next
  struct AVHWAccel *next;
  // alloc_frame
  signed int (*alloc_frame)(struct AVCodecContext *, struct AVFrame *);
  // start_frame
  signed int (*start_frame)(struct AVCodecContext *, const unsigned char *, unsigned int);
  // decode_slice
  signed int (*decode_slice)(struct AVCodecContext *, const unsigned char *, unsigned int);
  // end_frame
  signed int (*end_frame)(struct AVCodecContext *);
  // frame_priv_data_size
  signed int frame_priv_data_size;
  // decode_mb
  void (*decode_mb)(struct MpegEncContext *);
  // init
  signed int (*init)(struct AVCodecContext *);
  // uninit
  signed int (*uninit)(struct AVCodecContext *);
  // priv_data_size
  signed int priv_data_size;
};

struct AVIOContext
{
  // av_class
  const struct AVClass *av_class;
  // buffer
  unsigned char *buffer;
  // buffer_size
  signed int buffer_size;
  // buf_ptr
  unsigned char *buf_ptr;
  // buf_end
  unsigned char *buf_end;
  // opaque
  void *opaque;
  // read_packet
  signed int (*read_packet)(void *, unsigned char *, signed int);
  // write_packet
  signed int (*write_packet)(void *, unsigned char *, signed int);
  // seek
  signed long int (*seek)(void *, signed long int, signed int);
  // pos
  signed long int pos;
  // must_flush
  signed int must_flush;
  // eof_reached
  signed int eof_reached;
  // write_flag
  signed int write_flag;
  // max_packet_size
  signed int max_packet_size;
  // checksum
  unsigned long int checksum;
  // checksum_ptr
  unsigned char *checksum_ptr;
  // update_checksum
  unsigned long int (*update_checksum)(unsigned long int, const unsigned char *, unsigned int);
  // error
  signed int error;
  // read_pause
  signed int (*read_pause)(void *, signed int);
  // read_seek
  signed long int (*read_seek)(void *, signed int, signed long int, signed int);
  // seekable
  signed int seekable;
  // maxsize
  signed long int maxsize;
  // direct
  signed int direct;
  // bytes_read
  signed long int bytes_read;
  // seek_count
  signed int seek_count;
  // writeout_count
  signed int writeout_count;
  // orig_buffer_size
  signed int orig_buffer_size;
  // short_seek_threshold
  signed int short_seek_threshold;
};

struct AVIndexEntry
{
  // pos
  signed long int pos;
  // timestamp
  signed long int timestamp;
  // flags
  signed int flags : 2;
  // size
  signed int size : 30;
  // min_distance
  signed int min_distance;
};

struct AVInputFormat
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // flags
  signed int flags;
  // extensions
  const char *extensions;
  // codec_tag
  struct AVCodecTag * const *codec_tag;
  // priv_class
  const struct AVClass *priv_class;
  // mime_type
  const char *mime_type;
  // next
  struct AVInputFormat *next;
  // raw_codec_id
  signed int raw_codec_id;
  // priv_data_size
  signed int priv_data_size;
  // read_probe
  signed int (*read_probe)(struct AVProbeData *);
  // read_header
  signed int (*read_header)(struct AVFormatContext *);
  // read_packet
  signed int (*read_packet)(struct AVFormatContext *, struct AVPacket *);
  // read_close
  signed int (*read_close)(struct AVFormatContext *);
  // read_seek
  signed int (*read_seek)(struct AVFormatContext *, signed int, signed long int, signed int);
  // read_timestamp
  signed long int (*read_timestamp)(struct AVFormatContext *, signed int, signed long int *, signed long int);
  // read_play
  signed int (*read_play)(struct AVFormatContext *);
  // read_pause
  signed int (*read_pause)(struct AVFormatContext *);
  // read_seek2
  signed int (*read_seek2)(struct AVFormatContext *, signed int, signed long int, signed long int, signed long int, signed int);
  // get_device_list
  signed int (*get_device_list)(struct AVFormatContext *, struct AVDeviceInfoList *);
  // create_device_capabilities
  signed int (*create_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // free_device_capabilities
  signed int (*free_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
};

struct AVOption
{
  // name
  const char *name;
  // help
  const char *help;
  // offset
  signed int offset;
  // type
  enum AVOptionType type;
  // default_val
  union anonymous$2 default_val;
  // min
  double min;
  // max
  double max;
  // flags
  signed int flags;
  // unit
  const char *unit;
};

struct AVOptionRange
{
  // str
  const char *str;
  // value_min
  double value_min;
  // value_max
  double value_max;
  // component_min
  double component_min;
  // component_max
  double component_max;
  // is_range
  signed int is_range;
};

struct AVOptionRanges
{
  // range
  struct AVOptionRange **range;
  // nb_ranges
  signed int nb_ranges;
  // nb_components
  signed int nb_components;
};

struct AVOutputFormat
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // mime_type
  const char *mime_type;
  // extensions
  const char *extensions;
  // audio_codec
  enum AVCodecID audio_codec;
  // video_codec
  enum AVCodecID video_codec;
  // subtitle_codec
  enum AVCodecID subtitle_codec;
  // flags
  signed int flags;
  // codec_tag
  struct AVCodecTag * const *codec_tag;
  // priv_class
  const struct AVClass *priv_class;
  // next
  struct AVOutputFormat *next;
  // priv_data_size
  signed int priv_data_size;
  // write_header
  signed int (*write_header)(struct AVFormatContext *);
  // write_packet
  signed int (*write_packet)(struct AVFormatContext *, struct AVPacket *);
  // write_trailer
  signed int (*write_trailer)(struct AVFormatContext *);
  // interleave_packet
  signed int (*interleave_packet)(struct AVFormatContext *, struct AVPacket *, struct AVPacket *, signed int);
  // query_codec
  signed int (*query_codec)(enum AVCodecID, signed int);
  // get_output_timestamp
  void (*get_output_timestamp)(struct AVFormatContext *, signed int, signed long int *, signed long int *);
  // control_message
  signed int (*control_message)(struct AVFormatContext *, signed int, void *, unsigned long int);
  // write_uncoded_frame
  signed int (*write_uncoded_frame)(struct AVFormatContext *, signed int, struct AVFrame **, unsigned int);
  // get_device_list
  signed int (*get_device_list)(struct AVFormatContext *, struct AVDeviceInfoList *);
  // create_device_capabilities
  signed int (*create_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // free_device_capabilities
  signed int (*free_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // data_codec
  enum AVCodecID data_codec;
};

struct AVPacket
{
  // buf
  struct AVBufferRef *buf;
  // pts
  signed long int pts;
  // dts
  signed long int dts;
  // data
  unsigned char *data;
  // size
  signed int size;
  // stream_index
  signed int stream_index;
  // flags
  signed int flags;
  // side_data
  struct AVPacketSideData *side_data;
  // side_data_elems
  signed int side_data_elems;
  // duration
  signed int duration;
  // destruct
  void (*destruct)(struct AVPacket *);
  // priv
  void *priv;
  // pos
  signed long int pos;
  // convergence_duration
  signed long int convergence_duration;
};

struct AVPacketList
{
  // pkt
  struct AVPacket pkt;
  // next
  struct AVPacketList *next;
};

struct AVPacketSideData
{
  // data
  unsigned char *data;
  // size
  signed int size;
  // type
  enum AVPacketSideDataType type;
};

struct AVPanScan
{
  // id
  signed int id;
  // width
  signed int width;
  // height
  signed int height;
  // position
  signed short int position[3l][2l];
};

struct AVPicture
{
  // data
  unsigned char *data[8l];
  // linesize
  signed int linesize[8l];
};

struct AVProbeData
{
  // filename
  const char *filename;
  // buf
  unsigned char *buf;
  // buf_size
  signed int buf_size;
  // mime_type
  const char *mime_type;
};

struct AVProfile
{
  // profile
  signed int profile;
  // name
  const char *name;
};

struct AVProgram
{
  // id
  signed int id;
  // flags
  signed int flags;
  // discard
  enum AVDiscard discard;
  // stream_index
  unsigned int *stream_index;
  // nb_stream_indexes
  unsigned int nb_stream_indexes;
  // metadata
  struct AVDictionary *metadata;
  // program_num
  signed int program_num;
  // pmt_pid
  signed int pmt_pid;
  // pcr_pid
  signed int pcr_pid;
  // start_time
  signed long int start_time;
  // end_time
  signed long int end_time;
  // pts_wrap_reference
  signed long int pts_wrap_reference;
  // pts_wrap_behavior
  signed int pts_wrap_behavior;
};

struct AVStream
{
  // index
  signed int index;
  // id
  signed int id;
  // codec
  struct AVCodecContext *codec;
  // priv_data
  void *priv_data;
  // pts
  struct AVFrac pts;
  // time_base
  struct AVRational time_base;
  // start_time
  signed long int start_time;
  // duration
  signed long int duration;
  // nb_frames
  signed long int nb_frames;
  // disposition
  signed int disposition;
  // discard
  enum AVDiscard discard;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // metadata
  struct AVDictionary *metadata;
  // avg_frame_rate
  struct AVRational avg_frame_rate;
  // attached_pic
  struct AVPacket attached_pic;
  // side_data
  struct AVPacketSideData *side_data;
  // nb_side_data
  signed int nb_side_data;
  // event_flags
  signed int event_flags;
  // info
  struct anonymous$4 *info;
  // pts_wrap_bits
  signed int pts_wrap_bits;
  // first_dts
  signed long int first_dts;
  // cur_dts
  signed long int cur_dts;
  // last_IP_pts
  signed long int last_IP_pts;
  // last_IP_duration
  signed int last_IP_duration;
  // probe_packets
  signed int probe_packets;
  // codec_info_nb_frames
  signed int codec_info_nb_frames;
  // need_parsing
  enum AVStreamParseType need_parsing;
  // parser
  struct AVCodecParserContext *parser;
  // last_in_packet_buffer
  struct AVPacketList *last_in_packet_buffer;
  // probe_data
  struct AVProbeData probe_data;
  // pts_buffer
  signed long int pts_buffer[17l];
  // index_entries
  struct AVIndexEntry *index_entries;
  // nb_index_entries
  signed int nb_index_entries;
  // index_entries_allocated_size
  unsigned int index_entries_allocated_size;
  // r_frame_rate
  struct AVRational r_frame_rate;
  // stream_identifier
  signed int stream_identifier;
  // interleaver_chunk_size
  signed long int interleaver_chunk_size;
  // interleaver_chunk_duration
  signed long int interleaver_chunk_duration;
  // request_probe
  signed int request_probe;
  // skip_to_keyframe
  signed int skip_to_keyframe;
  // skip_samples
  signed int skip_samples;
  // start_skip_samples
  signed long int start_skip_samples;
  // first_discard_sample
  signed long int first_discard_sample;
  // last_discard_sample
  signed long int last_discard_sample;
  // nb_decoded_frames
  signed int nb_decoded_frames;
  // mux_ts_offset
  signed long int mux_ts_offset;
  // pts_wrap_reference
  signed long int pts_wrap_reference;
  // pts_wrap_behavior
  signed int pts_wrap_behavior;
  // update_initial_durations_done
  signed int update_initial_durations_done;
  // pts_reorder_error
  signed long int pts_reorder_error[17l];
  // pts_reorder_error_count
  unsigned char pts_reorder_error_count[17l];
  // last_dts_for_order_check
  signed long int last_dts_for_order_check;
  // dts_ordered
  unsigned char dts_ordered;
  // dts_misordered
  unsigned char dts_misordered;
  // inject_global_side_data
  signed int inject_global_side_data;
  // recommended_encoder_configuration
  char *recommended_encoder_configuration;
  // display_aspect_ratio
  struct AVRational display_aspect_ratio;
  // priv_pts
  struct FFFrac *priv_pts;
};

struct AVSubtitle
{
  // format
  unsigned short int format;
  // start_display_time
  unsigned int start_display_time;
  // end_display_time
  unsigned int end_display_time;
  // num_rects
  unsigned int num_rects;
  // rects
  struct AVSubtitleRect **rects;
  // pts
  signed long int pts;
};

struct AVSubtitleRect
{
  // x
  signed int x;
  // y
  signed int y;
  // w
  signed int w;
  // h
  signed int h;
  // nb_colors
  signed int nb_colors;
  // pict
  struct AVPicture pict;
  // type
  enum AVSubtitleType type;
  // text
  char *text;
  // ass
  char *ass;
  // flags
  signed int flags;
};

struct GrooveAudioFormat
{
  // sample_rate
  signed int sample_rate;
  // channel_layout
  unsigned long int channel_layout;
  // sample_fmt
  enum GrooveSampleFormat sample_fmt;
};

struct GrooveBuffer
{
  // data
  unsigned char **data;
  // format
  struct GrooveAudioFormat format;
  // frame_count
  signed int frame_count;
  // item
  struct GroovePlaylistItem *item;
  // pos
  double pos;
  // size
  signed int size;
  // pts
  unsigned long int pts;
};

struct GrooveBufferPrivate
{
  // externals
  struct GrooveBuffer externals;
  // frame
  struct AVFrame *frame;
  // is_packet
  signed int is_packet;
  // ref_count
  signed int ref_count;
  // mutex
  union anonymous$0 mutex;
  // data
  unsigned char *data;
};

struct GrooveEncoder
{
  // target_audio_format
  struct GrooveAudioFormat target_audio_format;
  // bit_rate
  signed int bit_rate;
  // format_short_name
  const char *format_short_name;
  // codec_short_name
  const char *codec_short_name;
  // filename
  const char *filename;
  // mime_type
  const char *mime_type;
  // sink_buffer_size
  signed int sink_buffer_size;
  // encoded_buffer_size
  signed int encoded_buffer_size;
  // gain
  double gain;
  // playlist
  struct GroovePlaylist *playlist;
  // actual_audio_format
  struct GrooveAudioFormat actual_audio_format;
};

struct GrooveEncoderPrivate
{
  // externals
  struct GrooveEncoder externals;
  // audioq
  struct GrooveQueue *audioq;
  // sink
  struct GrooveSink *sink;
  // fmt_ctx
  struct AVFormatContext *fmt_ctx;
  // oformat
  struct AVOutputFormat *oformat;
  // codec
  struct AVCodec *codec;
  // stream
  struct AVStream *stream;
  // pkt
  struct AVPacket pkt;
  // audioq_size
  signed int audioq_size;
  // abort_request
  signed int abort_request;
  // purge_item
  struct GroovePlaylistItem *purge_item;
  // encode_head_mutex
  union anonymous$0 encode_head_mutex;
  // encode_head_mutex_inited
  char encode_head_mutex_inited;
  // drain_cond
  union anonymous$1 drain_cond;
  // drain_cond_inited
  char drain_cond_inited;
  // encode_head
  struct GroovePlaylistItem *encode_head;
  // encode_pos
  double encode_pos;
  // encode_pts
  unsigned long int encode_pts;
  // encode_format
  struct GrooveAudioFormat encode_format;
  // thread_id
  unsigned long int thread_id;
  // avio
  struct AVIOContext *avio;
  // avio_buf
  unsigned char *avio_buf;
  // sent_header
  signed int sent_header;
  // strbuf
  char strbuf[512l];
  // metadata
  struct AVDictionary *metadata;
  // next_pts
  unsigned long int next_pts;
};

struct GrooveFile
{
  // dirty
  signed int dirty;
  // filename
  const char *filename;
};

struct GrooveFilePrivate
{
  // externals
  struct GrooveFile externals;
  // audio_stream_index
  signed int audio_stream_index;
  // abort_request
  signed int abort_request;
  // ic
  struct AVFormatContext *ic;
  // decoder
  struct AVCodec *decoder;
  // audio_st
  struct AVStream *audio_st;
  // seek_mutex
  union anonymous$0 seek_mutex;
  // seek_pos
  signed long int seek_pos;
  // seek_flush
  signed int seek_flush;
  // eof
  signed int eof;
  // audio_clock
  double audio_clock;
  // audio_pkt
  struct AVPacket audio_pkt;
  // oc
  struct AVFormatContext *oc;
  // tempfile_exists
  signed int tempfile_exists;
  // paused
  signed int paused;
};

struct GroovePlaylist
{
  // head
  struct GroovePlaylistItem *head;
  // tail
  struct GroovePlaylistItem *tail;
  // gain
  double gain;
};

struct GroovePlaylistItem
{
  // file
  struct GrooveFile *file;
  // gain
  double gain;
  // peak
  double peak;
  // prev
  struct GroovePlaylistItem *prev;
  // next
  struct GroovePlaylistItem *next;
};

struct GroovePlaylistPrivate
{
  // externals
  struct GroovePlaylist externals;
  // thread_id
  unsigned long int thread_id;
  // abort_request
  signed int abort_request;
  // audio_pkt_temp
  struct AVPacket audio_pkt_temp;
  // in_frame
  struct AVFrame *in_frame;
  // paused
  signed int paused;
  // in_sample_rate
  signed int in_sample_rate;
  // in_channel_layout
  unsigned long int in_channel_layout;
  // in_sample_fmt
  enum AVSampleFormat in_sample_fmt;
  // in_time_base
  struct AVRational in_time_base;
  // strbuf
  char strbuf[512l];
  // filter_graph
  struct AVFilterGraph *filter_graph;
  // abuffer_ctx
  struct AVFilterContext *abuffer_ctx;
  // volume_filter
  struct AVFilter *volume_filter;
  // compand_filter
  struct AVFilter *compand_filter;
  // abuffer_filter
  struct AVFilter *abuffer_filter;
  // asplit_filter
  struct AVFilter *asplit_filter;
  // aformat_filter
  struct AVFilter *aformat_filter;
  // abuffersink_filter
  struct AVFilter *abuffersink_filter;
  // drain_cond_mutex
  union anonymous$0 drain_cond_mutex;
  // drain_cond_mutex_inited
  signed int drain_cond_mutex_inited;
  // decode_head_mutex
  union anonymous$0 decode_head_mutex;
  // decode_head_mutex_inited
  signed int decode_head_mutex_inited;
  // decode_head_cond
  union anonymous$1 decode_head_cond;
  // decode_head_cond_inited
  signed int decode_head_cond_inited;
  // sink_drain_cond
  union anonymous$1 sink_drain_cond;
  // sink_drain_cond_inited
  signed int sink_drain_cond_inited;
  // decode_head
  struct GroovePlaylistItem *decode_head;
  // volume
  double volume;
  // peak
  double peak;
  // rebuild_filter_graph_flag
  signed int rebuild_filter_graph_flag;
  // sink_map
  struct SinkMap *sink_map;
  // sink_map_count
  signed int sink_map_count;
  // filter_volume
  double filter_volume;
  // filter_peak
  double filter_peak;
  // sent_end_of_q
  signed int sent_end_of_q;
  // purge_item
  struct GroovePlaylistItem *purge_item;
  // detect_full_sinks
  signed int (*detect_full_sinks)(struct GroovePlaylist *);
};

struct GrooveQueue
{
  // context
  void *context;
  // cleanup
  void (*cleanup)(struct GrooveQueue *, void *);
  // put
  void (*put)(struct GrooveQueue *, void *);
  // get
  void (*get)(struct GrooveQueue *, void *);
  // purge
  signed int (*purge)(struct GrooveQueue *, void *);
};

struct GrooveQueuePrivate
{
  // externals
  struct GrooveQueue externals;
  // first
  struct ItemList *first;
  // last
  struct ItemList *last;
  // mutex
  union anonymous$0 mutex;
  // cond
  union anonymous$1 cond;
  // abort_request
  signed int abort_request;
};

struct GrooveSink
{
  // audio_format
  struct GrooveAudioFormat audio_format;
  // disable_resample
  signed int disable_resample;
  // buffer_sample_count
  signed int buffer_sample_count;
  // buffer_size
  signed int buffer_size;
  // gain
  double gain;
  // userdata
  void *userdata;
  // flush
  void (*flush)(struct GrooveSink *);
  // purge
  void (*purge)(struct GrooveSink *, struct GroovePlaylistItem *);
  // pause
  void (*pause)(struct GrooveSink *);
  // play
  void (*play)(struct GrooveSink *);
  // playlist
  struct GroovePlaylist *playlist;
  // bytes_per_sec
  signed int bytes_per_sec;
};

struct GrooveSinkPrivate
{
  // externals
  struct GrooveSink externals;
  // audioq
  struct GrooveQueue *audioq;
  // audioq_size
  signed int audioq_size;
  // min_audioq_size
  signed int min_audioq_size;
};

struct ItemList
{
  // obj
  void *obj;
  // next
  struct ItemList *next;
};

struct RcOverride
{
  // start_frame
  signed int start_frame;
  // end_frame
  signed int end_frame;
  // qscale
  signed int qscale;
  // quality_factor
  float quality_factor;
};

struct SinkMap
{
  // stack_head
  struct SinkStack *stack_head;
  // abuffersink_ctx
  struct AVFilterContext *abuffersink_ctx;
  // next
  struct SinkMap *next;
};

struct SinkStack
{
  // sink
  struct GrooveSink *sink;
  // next
  struct SinkStack *next;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};


// dB_scale
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 264
static const double dB_scale = 0.1151292546497023;
// end_of_q_sentinel
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 63
static struct GrooveBuffer *end_of_q_sentinel = (struct GrooveBuffer *)(void *)0;
// end_of_q_sentinel$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 105
static struct GrooveBuffer *end_of_q_sentinel$link1 = (struct GrooveBuffer *)(void *)0;
// should_deinit_network
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 16
static signed int should_deinit_network = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// abs_diff
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 443
static signed int abs_diff(signed int a, signed int b)
{
  signed int n = a - b;
  return n >= 0 ? n : -n;
}

// add_sink_to_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 785
static signed int add_sink_to_map(struct GroovePlaylist *playlist, struct GrooveSink *sink)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  struct SinkStack *stack_entry;
  void *return_value_av_mallocz$1;
  return_value_av_mallocz$1=av_mallocz(sizeof(struct SinkStack) /*16ul*/ );
  stack_entry = (struct SinkStack *)return_value_av_mallocz$1;
  if(stack_entry == ((struct SinkStack *)NULL))
    return -1;

  else
  {
    stack_entry->sink = sink;
    struct SinkMap *map_item = p->sink_map;
    while(!(map_item == ((struct SinkMap *)NULL)))
    {
      struct GrooveSink *example_sink = map_item->stack_head->sink;
      signed int return_value_sink_formats_compatible$2;
      return_value_sink_formats_compatible$2=sink_formats_compatible(example_sink, sink);
      if(!(return_value_sink_formats_compatible$2 == 0))
      {
        stack_entry->next = map_item->stack_head->next;
        map_item->stack_head->next = stack_entry;
        return 0;
      }

      signed int return_value_sink_formats_compatible$3;
      return_value_sink_formats_compatible$3=sink_formats_compatible(sink, example_sink);
      if(!(return_value_sink_formats_compatible$3 == 0))
      {
        stack_entry->next = map_item->stack_head;
        map_item->stack_head = stack_entry;
        p->rebuild_filter_graph_flag = 1;
        return 0;
      }

      map_item = map_item->next;
    }
    struct SinkMap *map_entry;
    void *return_value_av_mallocz$4;
    return_value_av_mallocz$4=av_mallocz(sizeof(struct SinkMap) /*24ul*/ );
    map_entry = (struct SinkMap *)return_value_av_mallocz$4;
    map_entry->stack_head = stack_entry;
    if(map_entry == ((struct SinkMap *)NULL))
    {
      av_free((void *)stack_entry);
      return -1;
    }

    else
    {
      if(!(p->sink_map == ((struct SinkMap *)NULL)))
      {
        map_entry->next = p->sink_map;
        p->sink_map = map_entry;
      }

      else
        p->sink_map = map_entry;
      p->rebuild_filter_graph_flag = 1;
      p->sink_map_count = p->sink_map_count + 1;
      return 0;
    }
  }
}

// any_sink_full
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 519
static signed int any_sink_full(struct GroovePlaylist *playlist)
{
  signed int return_value_every_sink$1;
  return_value_every_sink$1=every_sink(playlist, sink_is_full, 0);
  return return_value_every_sink$1;
}

// audio_decode_frame
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 154
static signed int audio_decode_frame(struct GroovePlaylist *playlist, struct GrooveFile *file)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  struct AVPacket *pkt = &f->audio_pkt;
  struct AVCodecContext *dec = f->audio_st->codec;
  struct AVPacket *pkt_temp = &p->audio_pkt_temp;
  *pkt_temp = *pkt;
  double return_value_av_q2d$1;
  if(!(pkt->pts == -9223372036854775808l))
  {
    return_value_av_q2d$1=av_q2d$link1(f->audio_st->time_base);
    f->audio_clock = return_value_av_q2d$1 * (double)pkt->pts;
  }

  signed int max_data_size = 0;
  signed int len1;
  signed int got_frame;
  signed int new_packet = 1;
  struct AVFrame *in_frame = p->in_frame;
  signed int tmp_if_expr$4;
  signed int return_value_av_buffersink_get_frame$2;
  signed int return_value_av_buffersink_get_samples$3;
  while((_Bool)1)
  {
    if(!(pkt_temp->size >= 1))
    {
      if(pkt_temp->data == ((unsigned char *)NULL))
      {
        if(new_packet == 0)
          goto __CPROVER_DUMP_L3;

      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        goto __CPROVER_DUMP_L24;
      }
    }

    new_packet = 0;
    len1=avcodec_decode_audio4(dec, in_frame, &got_frame, pkt_temp);
    if(!(len1 >= 0))
    {
      pkt_temp->size = 0;
      return -1;
    }

    pkt_temp->data = pkt_temp->data + (signed long int)len1;
    pkt_temp->size = pkt_temp->size - len1;
    if(got_frame == 0)
    {
      if(pkt_temp->data == ((unsigned char *)NULL))
      {
        if(!((32 & dec->codec->capabilities) == 0))
          return 0;

      }

    }

    else
    {
      signed int audio_decode_frame$$1$$1$$err;
      audio_decode_frame$$1$$1$$err=av_buffersrc_write_frame(p->abuffer_ctx, in_frame);
      if(!(audio_decode_frame$$1$$1$$err >= 0))
      {
        av_strerror(audio_decode_frame$$1$$1$$err, p->strbuf, sizeof(char [512l]) /*512ul*/ );
        av_log((void *)0, 16, "error writing frame to buffersrc: %s\n", (const void *)p->strbuf);
        return -1;
      }

      struct SinkMap *map_item = p->sink_map;
      double clock_adjustment = (double)0;
      while(!(map_item == ((struct SinkMap *)NULL)))
      {
        struct GrooveSink *example_sink = map_item->stack_head->sink;
        signed int data_size = 0;
        do
        {
          struct AVFrame *oframe;
          oframe=av_frame_alloc();
          signed int err;
          if(example_sink->buffer_sample_count == 0)
          {
            return_value_av_buffersink_get_frame$2=av_buffersink_get_frame(map_item->abuffersink_ctx, oframe);
            tmp_if_expr$4 = return_value_av_buffersink_get_frame$2;
          }

          else
          {
            return_value_av_buffersink_get_samples$3=av_buffersink_get_samples(map_item->abuffersink_ctx, oframe, example_sink->buffer_sample_count);
            tmp_if_expr$4 = return_value_av_buffersink_get_samples$3;
          }
          err = tmp_if_expr$4;
          if(err == -541478725 || err == -11)
          {
            av_frame_free(&oframe);
            break;
          }

          if(!(err >= 0))
          {
            av_frame_free(&oframe);
            av_log((void *)0, 16, "error reading buffer from buffersink\n");
            return -1;
          }

          struct GrooveBuffer *buffer;
          buffer=frame_to_groove_buffer(playlist, example_sink, oframe);
          if(buffer == ((struct GrooveBuffer *)NULL))
          {
            av_frame_free(&oframe);
            return -1;
          }

          data_size = data_size + buffer->size;
          struct SinkStack *stack_item = map_item->stack_head;
          groove_buffer_ref(buffer);
          while(!(stack_item == ((struct SinkStack *)NULL)))
          {
            struct GrooveSink *sink = stack_item->sink;
            struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
            groove_buffer_ref(buffer);
            signed int return_value_groove_queue_put$5;
            return_value_groove_queue_put$5=groove_queue_put(s->audioq, (void *)buffer);
            if(!(return_value_groove_queue_put$5 >= 0))
            {
              av_log((void *)0, 16, "unable to put buffer in queue\n");
              groove_buffer_unref(buffer);
            }

            stack_item = stack_item->next;
          }
          groove_buffer_unref(buffer);
        }
        while((_Bool)1);
        if(!(max_data_size >= data_size))
        {
          max_data_size = data_size;
          clock_adjustment = (double)data_size / (double)example_sink->bytes_per_sec;
        }

        map_item = map_item->next;
      }
      if(pkt->pts == -9223372036854775808l)
        f->audio_clock = f->audio_clock + clock_adjustment;

      return max_data_size;
    }
  }

__CPROVER_DUMP_L24:
  ;
  return max_data_size;
}

// audioq_cleanup
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 269
static void audioq_cleanup(struct GrooveQueue *queue, void *obj)
{
  struct GrooveBuffer *buffer = (struct GrooveBuffer *)obj;
  if(!(buffer == end_of_q_sentinel))
  {
    struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)queue->context;
    e->audioq_size = e->audioq_size - buffer->size;
    groove_buffer_unref(buffer);
  }

}

// audioq_cleanup$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 631
static void audioq_cleanup$link1(struct GrooveQueue *queue$link1, void *obj$link1)
{
  struct GrooveBuffer *buffer$link1 = (struct GrooveBuffer *)obj$link1;
  if(!(buffer$link1 == end_of_q_sentinel$link1))
  {
    struct GrooveSink *sink = (struct GrooveSink *)queue$link1->context;
    struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
    s->audioq_size = s->audioq_size - buffer$link1->size;
    groove_buffer_unref(buffer$link1);
  }

}

// audioq_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 286
static void audioq_get(struct GrooveQueue *queue, void *obj)
{
  struct GrooveBuffer *buffer = (struct GrooveBuffer *)obj;
  if(!(buffer == end_of_q_sentinel))
  {
    struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)queue->context;
    struct GrooveEncoder *encoder = &e->externals;
    e->audioq_size = e->audioq_size - buffer->size;
    if(!(e->audioq_size >= encoder->encoded_buffer_size))
      pthread_cond_signal(&e->drain_cond);

  }

}

// audioq_get$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 614
static void audioq_get$link1(struct GrooveQueue *queue$link1, void *obj$link1)
{
  struct GrooveBuffer *buffer$link1 = (struct GrooveBuffer *)obj$link1;
  if(!(buffer$link1 == end_of_q_sentinel$link1))
  {
    struct GrooveSink *sink = (struct GrooveSink *)queue$link1->context;
    struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
    s->audioq_size = s->audioq_size - buffer$link1->size;
    struct GroovePlaylist *playlist = sink->playlist;
    struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
    if(!(s->audioq_size >= s->min_audioq_size))
    {
      pthread_mutex_lock(&p->drain_cond_mutex);
      pthread_cond_signal(&p->sink_drain_cond);
      pthread_mutex_unlock(&p->drain_cond_mutex);
    }

  }

}

// audioq_purge
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 261
static signed int audioq_purge(struct GrooveQueue *queue, void *obj)
{
  struct GrooveBuffer *buffer = (struct GrooveBuffer *)obj;
  if(buffer == end_of_q_sentinel)
    return 0;

  else
  {
    struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)queue->context;
    return (signed int)(buffer->item == e->purge_item);
  }
}

// audioq_purge$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 641
static signed int audioq_purge$link1(struct GrooveQueue *queue$link1, void *obj$link1)
{
  struct GrooveBuffer *buffer$link1 = (struct GrooveBuffer *)obj$link1;
  if(buffer$link1 == end_of_q_sentinel$link1)
    return 0;

  else
  {
    struct GrooveSink *sink = (struct GrooveSink *)queue$link1->context;
    struct GroovePlaylist *playlist = sink->playlist;
    struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
    struct GroovePlaylistItem *item = p->purge_item;
    return (signed int)(buffer$link1->item == item);
  }
}

// audioq_put
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 278
static void audioq_put(struct GrooveQueue *queue, void *obj)
{
  struct GrooveBuffer *buffer = (struct GrooveBuffer *)obj;
  if(!(buffer == end_of_q_sentinel))
  {
    struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)queue->context;
    e->audioq_size = e->audioq_size + buffer->size;
  }

}

// audioq_put$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 606
static void audioq_put$link1(struct GrooveQueue *queue$link1, void *obj$link1)
{
  struct GrooveBuffer *buffer$link1 = (struct GrooveBuffer *)obj$link1;
  if(!(buffer$link1 == end_of_q_sentinel$link1))
  {
    struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)queue$link1->context;
    s->audioq_size = s->audioq_size + buffer$link1->size;
  }

}

// av_q2d
// file /usr/include/x86_64-linux-gnu/libavutil/rational.h line 80
static inline double av_q2d(struct AVRational a)
{
  return (double)a.num / (double)a.den;
}

// av_q2d$link1
// file /usr/include/x86_64-linux-gnu/libavutil/rational.h line 80
static inline double av_q2d$link1(struct AVRational a$link1)
{
  return (double)a$link1.num / (double)a$link1.den;
}

// cleanup_avcontext
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 99
static void cleanup_avcontext(struct GrooveEncoderPrivate *e)
{
  if(!(e->stream == ((struct AVStream *)NULL)))
  {
    avcodec_close(e->stream->codec);
    e->stream = (struct AVStream *)(void *)0;
  }

  if(!(e->fmt_ctx == ((struct AVFormatContext *)NULL)))
  {
    avformat_free_context(e->fmt_ctx);
    e->fmt_ctx = (struct AVFormatContext *)(void *)0;
  }

  e->sent_header = 0;
  e->encode_head = (struct GroovePlaylistItem *)(void *)0;
  e->encode_pos = -1.0;
  e->encode_pts = (unsigned long int)0;
  e->next_pts = (unsigned long int)0;
}

// cleanup_save
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 199
static void cleanup_save(struct GrooveFile *file)
{
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  av_free_packet(&f->audio_pkt);
  avio_closep(&f->oc->pb);
  if(!(f->tempfile_exists == 0))
  {
    signed int return_value_remove$1;
    return_value_remove$1=remove(f->oc->filename);
    if(!(return_value_remove$1 == 0))
      av_log((void *)0, 24, "Error deleting temp file during cleanup\n");

    f->tempfile_exists = 0;
  }

  if(!(f->oc == ((struct AVFormatContext *)NULL)))
  {
    avformat_free_context(f->oc);
    f->oc = (struct AVFormatContext *)(void *)0;
  }

}

// closest_supported_channel_layout
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 520
static unsigned long int closest_supported_channel_layout(struct AVCodec *codec, unsigned long int target)
{
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  signed int return_value_abs_diff$1;
  signed int return_value_abs_diff$2;
  if(codec->channel_layouts == ((const unsigned long int *)NULL))
    return target;

  else
  {
    signed int target_count;
    target_count=av_get_channel_layout_nb_channels(target);
    const unsigned long int *p = codec->channel_layouts;
    unsigned long int best = *p;
    signed int best_count;
    best_count=av_get_channel_layout_nb_channels(best);
    while(!(*p == 0ul))
    {
      if(*p == target)
        return target;

      signed int count;
      count=av_get_channel_layout_nb_channels(*p);
      if(!(best_count >= count) && !(best_count >= target_count))
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        if(count >= target_count)
        {
          return_value_abs_diff$1=abs_diff(target_count, count);
          return_value_abs_diff$2=abs_diff(target_count, best_count);
          tmp_if_expr$3 = return_value_abs_diff$1 < return_value_abs_diff$2 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
      {
        best_count = count;
        best = *p;
      }

      p = p + (signed long int)1;
    }
    return best;
  }
}

// closest_supported_sample_fmt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 460
static enum GrooveSampleFormat closest_supported_sample_fmt(struct AVCodec *codec, enum GrooveSampleFormat target)
{
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  signed int return_value_abs_diff$1;
  signed int return_value_abs_diff$2;
  if(codec->sample_fmts == ((const enum AVSampleFormat *)NULL))
    return target;

  else
  {
    signed int target_size;
    target_size=av_get_bytes_per_sample((enum AVSampleFormat)target);
    const enum GrooveSampleFormat *p = (enum GrooveSampleFormat *)codec->sample_fmts;
    enum GrooveSampleFormat best = *p;
    signed int best_size;
    best_size=av_get_bytes_per_sample((enum AVSampleFormat)best);
    while(!((signed int)*p == GROOVE_SAMPLE_FMT_NONE))
    {
      if(*p == target)
        return target;

      signed int size;
      size=av_get_bytes_per_sample((enum AVSampleFormat)*p);
      if(!(best_size >= size) && !(best_size >= target_size))
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        if(size >= target_size)
        {
          return_value_abs_diff$1=abs_diff(target_size, size);
          return_value_abs_diff$2=abs_diff(target_size, best_size);
          tmp_if_expr$3 = return_value_abs_diff$1 < return_value_abs_diff$2 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
      {
        best_size = size;
        best = *p;
      }

      p = p + (signed long int)1;
    }
    enum GrooveSampleFormat packed_best;
    enum AVSampleFormat return_value_av_get_packed_sample_fmt$5;
    return_value_av_get_packed_sample_fmt$5=av_get_packed_sample_fmt((enum AVSampleFormat)best);
    packed_best = (enum GrooveSampleFormat)return_value_av_get_packed_sample_fmt$5;
    signed int return_value_codec_supports_fmt$6;
    return_value_codec_supports_fmt$6=codec_supports_fmt(codec, packed_best);
    return (enum GrooveSampleFormat)(return_value_codec_supports_fmt$6 != 0 ? (signed int)packed_best : (signed int)best);
  }
}

// closest_supported_sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 494
static signed int closest_supported_sample_rate(struct AVCodec *codec, signed int target)
{
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  signed int return_value_abs_diff$2;
  signed int return_value_abs_diff$3;
  if(codec->supported_samplerates == ((const signed int *)NULL))
    return target;

  else
  {
    const signed int *p = codec->supported_samplerates;
    signed int best = *p;
    while(!(*p == 0))
    {
      if(*p == target)
        return target;

      if(!(best >= target))
        tmp_if_expr$1 = *p > best ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        if(*p >= target)
        {
          return_value_abs_diff$2=abs_diff(target, *p);
          return_value_abs_diff$3=abs_diff(target, best);
          tmp_if_expr$4 = return_value_abs_diff$2 < return_value_abs_diff$3 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$4 = (_Bool)0;
        tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        best = *p;

      p = p + (signed long int)1;
    }
    return best;
  }
}

// codec_supports_fmt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 448
static signed int codec_supports_fmt(struct AVCodec *codec, enum GrooveSampleFormat fmt)
{
  const enum GrooveSampleFormat *p = (enum GrooveSampleFormat *)codec->sample_fmts;
  for( ; !((signed int)*p == GROOVE_SAMPLE_FMT_NONE); p = p + (signed long int)1)
    if(*p == fmt)
      return 1;

  return 0;
}

// create_volume_filter
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 270
static signed int create_volume_filter(struct GroovePlaylistPrivate *p, struct AVFilterContext **audio_src_ctx, double vol, double amp_vol)
{
  signed int err;
  if(vol < 0.0)
    vol = 0.0;

  if(amp_vol < 1.0)
  {
    snprintf(p->strbuf, sizeof(char [512l]) /*512ul*/ , "volume=%f", vol);
    av_log((void *)0, 32, "volume: %s\n", (const void *)p->strbuf);
    struct AVFilterContext *volume_ctx;
    err=avfilter_graph_create_filter(&volume_ctx, p->volume_filter, (const char *)(void *)0, p->strbuf, (void *)0, p->filter_graph);
    if(!(err >= 0))
    {
      av_log((void *)0, 16, "error initializing volume filter\n");
      return err;
    }

    err=avfilter_link(*audio_src_ctx, (unsigned int)0, volume_ctx, (unsigned int)0);
    if(!(err >= 0))
    {
      av_strerror(err, p->strbuf, sizeof(char [512l]) /*512ul*/ );
      av_log((void *)0, 16, "unable to link volume filter: %s\n", (const void *)p->strbuf);
      return err;
    }

    *audio_src_ctx = volume_ctx;
  }

  else
    if(amp_vol > 1.0)
    {
      double attack = 0.1;
      double decay = 0.2;
      const char *points = "-2/-2";
      double soft_knee = 0.02;
      double gain;
      gain=gain_to_dB(vol);
      double volume_param = 0.0;
      double delay = 0.2;
      snprintf(p->strbuf, sizeof(char [512l]) /*512ul*/ , "%f:%f:%s:%f:%f:%f:%f", attack, decay, points, soft_knee, gain, volume_param, delay);
      av_log((void *)0, 32, "compand: %s\n", (const void *)p->strbuf);
      struct AVFilterContext *compand_ctx;
      err=avfilter_graph_create_filter(&compand_ctx, p->compand_filter, (const char *)(void *)0, p->strbuf, (void *)0, p->filter_graph);
      if(!(err >= 0))
      {
        av_log((void *)0, 16, "error initializing compand filter\n");
        return err;
      }

      err=avfilter_link(*audio_src_ctx, (unsigned int)0, compand_ctx, (unsigned int)0);
      if(!(err >= 0))
      {
        av_strerror(err, p->strbuf, sizeof(char [512l]) /*512ul*/ );
        av_log((void *)0, 16, "unable to link compand filter: %s\n", (const void *)p->strbuf);
        return err;
      }

      *audio_src_ctx = compand_ctx;
    }

  return 0;
}

// decode_interrupt_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 13
static signed int decode_interrupt_cb(void *ctx)
{
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)ctx;
  signed int tmp_if_expr$1;
  if(!(f == ((struct GrooveFilePrivate *)NULL)))
    tmp_if_expr$1 = f->abort_request;

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// decode_one_frame
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 547
static signed int decode_one_frame(struct GroovePlaylist *playlist, struct GrooveFile *file)
{
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  struct AVPacket *pkt = &f->audio_pkt;
  if(!(f->abort_request == 0))
    return -1;

  else
  {
    signed int return_value_maybe_init_filter_graph$1;
    return_value_maybe_init_filter_graph$1=maybe_init_filter_graph(playlist, file);
    if(!(return_value_maybe_init_filter_graph$1 >= 0))
      return -1;

    else
    {
      pthread_mutex_lock(&f->seek_mutex);
      if(f->seek_pos >= 0l)
      {
        signed int return_value_av_seek_frame$2;
        return_value_av_seek_frame$2=av_seek_frame(f->ic, f->audio_stream_index, f->seek_pos, 0);
        if(!(return_value_av_seek_frame$2 >= 0))
          av_log((void *)0, 16, "%s: error while seeking\n", (const void *)f->ic->filename);

        else
          if(!(f->seek_flush == 0))
            every_sink_flush(playlist);

        avcodec_flush_buffers(f->audio_st->codec);
        f->seek_pos = (signed long int)-1;
        f->eof = 0;
      }

      pthread_mutex_unlock(&f->seek_mutex);
      if(!(f->eof == 0))
      {
        if(!((32 & f->audio_st->codec->codec->capabilities) == 0))
        {
          av_init_packet(pkt);
          pkt->data = (unsigned char *)(void *)0;
          pkt->size = 0;
          pkt->stream_index = f->audio_stream_index;
          signed int return_value_audio_decode_frame$3;
          return_value_audio_decode_frame$3=audio_decode_frame(playlist, file);
          if(return_value_audio_decode_frame$3 >= 1)
            return 0;

        }

        return -1;
      }

      else
      {
        signed int err;
        err=av_read_frame(f->ic, pkt);
        if(!(err >= 0))
        {
          if(!(err == -541478725))
            av_log((void *)0, 24, "error reading frames\n");

          f->eof = 1;
          return 0;
        }

        else
          if(!(pkt->stream_index == f->audio_stream_index))
          {
            av_free_packet(pkt);
            return 0;
          }

          else
          {
            audio_decode_frame(playlist, file);
            av_free_packet(pkt);
            return 0;
          }
      }
    }
  }
}

// decode_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 661
static void * decode_thread(void *arg)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)arg;
  struct GroovePlaylist *playlist = &p->externals;
  _Bool tmp_if_expr$1;
  while(p->abort_request == 0)
  {
    pthread_mutex_lock(&p->decode_head_mutex);
    if(p->decode_head == ((struct GroovePlaylistItem *)NULL))
    {
      if(p->sent_end_of_q == 0)
      {
        every_sink_signal_end(playlist);
        p->sent_end_of_q = 1;
      }

      pthread_cond_wait(&p->decode_head_cond, &p->decode_head_mutex);
      pthread_mutex_unlock(&p->decode_head_mutex);
    }

    else
    {
      p->sent_end_of_q = 0;
      struct GrooveFile *file = p->decode_head->file;
      struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
      pthread_mutex_lock(&p->drain_cond_mutex);
      signed int return_value;
      return_value=p->detect_full_sinks(playlist);
      if(!(return_value == 0))
      {
        if(!(f->seek_pos >= 0l))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = !(f->seek_flush != 0) ? (_Bool)1 : (_Bool)0;
        if(f->paused == 0)
        {
          av_read_pause(f->ic);
          f->paused = 1;
        }

        pthread_mutex_unlock(&p->decode_head_mutex);
        pthread_cond_wait(&p->sink_drain_cond, &p->drain_cond_mutex);
        pthread_mutex_unlock(&p->drain_cond_mutex);
      }

      else
      {
        pthread_mutex_unlock(&p->drain_cond_mutex);
        if(!(f->paused == 0))
        {
          av_read_play(f->ic);
          f->paused = 0;
        }

        update_playlist_volume(playlist);
        signed int return_value_decode_one_frame$2;
        return_value_decode_one_frame$2=decode_one_frame(playlist, file);
        if(!(return_value_decode_one_frame$2 >= 0))
        {
          p->decode_head = p->decode_head->next;
          if(!(p->decode_head == ((struct GroovePlaylistItem *)NULL)))
          {
            struct GrooveFile *next_file = p->decode_head->file;
            struct GrooveFilePrivate *next_f = (struct GrooveFilePrivate *)next_file;
            pthread_mutex_lock(&next_f->seek_mutex);
            next_f->seek_pos = (signed long int)0;
            next_f->seek_flush = 0;
            pthread_mutex_unlock(&next_f->seek_mutex);
          }

        }

        pthread_mutex_unlock(&p->decode_head_mutex);
      }
    }
  }
  return (void *)0;
}

// encode_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 65
static signed int encode_buffer(struct GrooveEncoder *encoder, struct GrooveBuffer *buffer)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  av_init_packet(&e->pkt);
  struct AVFrame *frame = (struct AVFrame *)(void *)0;
  if(!(buffer == ((struct GrooveBuffer *)NULL)))
  {
    e->encode_head = buffer->item;
    e->encode_pos = buffer->pos;
    e->encode_format = buffer->format;
    struct GrooveBufferPrivate *b = (struct GrooveBufferPrivate *)buffer;
    frame = b->frame;
    frame->pts = (signed long int)e->next_pts;
    e->encode_pts = e->next_pts;
    e->next_pts = e->next_pts + (unsigned long int)(buffer->frame_count + 1);
  }

  signed int got_packet = 0;
  signed int errcode;
  errcode=avcodec_encode_audio2(e->stream->codec, &e->pkt, frame, &got_packet);
  if(!(errcode >= 0))
  {
    av_strerror(errcode, e->strbuf, sizeof(char [512l]) /*512ul*/ );
    av_log((void *)0, 16, "error encoding audio frame: %s\n", (const void *)e->strbuf);
    return -1;
  }

  else
    if(got_packet == 0)
      return -1;

    else
    {
      av_write_frame(e->fmt_ctx, &e->pkt);
      av_free_packet(&e->pkt);
      return 0;
    }
}

// encode_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 153
static void * encode_thread(void *arg)
{
  struct GrooveEncoder *encoder = (struct GrooveEncoder *)arg;
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  struct GrooveBuffer *buffer;
  signed int return_value_encode_buffer$1;
  signed int return_value_av_write_frame$2;
  while(e->abort_request == 0)
  {
    pthread_mutex_lock(&e->encode_head_mutex);
    if(e->audioq_size >= encoder->encoded_buffer_size)
    {
      pthread_cond_wait(&e->drain_cond, &e->encode_head_mutex);
      pthread_mutex_unlock(&e->encode_head_mutex);
    }

    else
    {
      pthread_mutex_unlock(&e->encode_head_mutex);
      signed int result;
      result=groove_sink_buffer_get(e->sink, &buffer, 1);
      pthread_mutex_lock(&e->encode_head_mutex);
      if(result == 2)
      {
        do
        {
          return_value_encode_buffer$1=encode_buffer(encoder, (struct GrooveBuffer *)(void *)0);
          if(!(return_value_encode_buffer$1 >= 0))
            break;

        }
        while((_Bool)1);
        do
        {
          return_value_av_write_frame$2=av_write_frame(e->fmt_ctx, (struct AVPacket *)(void *)0);
          if(!(return_value_av_write_frame$2 == 0))
            break;

        }
        while((_Bool)1);
        avio_flush(e->avio);
        av_log((void *)0, 32, "encoder: writing trailer\n");
        signed int return_value_av_write_trailer$3;
        return_value_av_write_trailer$3=av_write_trailer(e->fmt_ctx);
        if(!(return_value_av_write_trailer$3 >= 0))
          av_log((void *)0, 16, "could not write trailer\n");

        avio_flush(e->avio);
        groove_queue_put(e->audioq, (void *)end_of_q_sentinel);
        cleanup_avcontext(e);
        init_avcontext(encoder);
        pthread_mutex_unlock(&e->encode_head_mutex);
        continue;
      }

      if(!(result == 1))
      {
        pthread_mutex_unlock(&e->encode_head_mutex);
        break;
      }

      if(e->sent_header == 0)
      {
        avio_flush(e->avio);
        av_dict_free(&e->fmt_ctx->metadata);
        struct AVDictionaryEntry *tag = (struct AVDictionaryEntry *)(void *)0;
        do
        {
          tag=av_dict_get(e->metadata, "", tag, 2);
          if(tag == ((struct AVDictionaryEntry *)NULL))
            break;

          av_dict_set(&e->fmt_ctx->metadata, tag->key, tag->value, 2);
        }
        while((_Bool)1);
        av_log((void *)0, 32, "encoder: writing header\n");
        signed int return_value_avformat_write_header$4;
        return_value_avformat_write_header$4=avformat_write_header(e->fmt_ctx, (struct AVDictionary **)(void *)0);
        if(!(return_value_avformat_write_header$4 >= 0))
          av_log((void *)0, 16, "could not write header\n");

        avio_flush(e->avio);
        e->sent_header = 1;
      }

      encode_buffer(encoder, buffer);
      pthread_mutex_unlock(&e->encode_head_mutex);
      groove_buffer_unref(buffer);
    }
  }
  return (void *)0;
}

// encoder_write_packet
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 298
static signed int encoder_write_packet(void *opaque, unsigned char *buf, signed int buf_size)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)opaque;
  struct GrooveBufferPrivate *b;
  void *return_value_av_mallocz$1;
  return_value_av_mallocz$1=av_mallocz(sizeof(struct GrooveBufferPrivate) /*136ul*/ );
  b = (struct GrooveBufferPrivate *)return_value_av_mallocz$1;
  if(b == ((struct GrooveBufferPrivate *)NULL))
  {
    av_log((void *)0, 16, "unable to allocate buffer\n");
    return -1;
  }

  else
  {
    struct GrooveBuffer *buffer = &b->externals;
    signed int return_value_pthread_mutex_init$2;
    return_value_pthread_mutex_init$2=pthread_mutex_init(&b->mutex, (const union anonymous$6 *)(void *)0);
    if(!(return_value_pthread_mutex_init$2 == 0))
    {
      av_free((void *)b);
      av_log((void *)0, 16, "unable to create mutex\n");
      return -1;
    }

    else
    {
      buffer->item = e->encode_head;
      buffer->pos = e->encode_pos;
      buffer->pts = e->encode_pts;
      buffer->format = e->encode_format;
      b->is_packet = 1;
      void *return_value_av_malloc$3;
      return_value_av_malloc$3=av_malloc((unsigned long int)buf_size);
      b->data = (unsigned char *)return_value_av_malloc$3;
      if(b->data == ((unsigned char *)NULL))
      {
        av_free((void *)buffer);
        av_free((void *)b);
        pthread_mutex_destroy(&b->mutex);
        av_log((void *)0, 16, "unable to create data buffer\n");
        return -1;
      }

      else
      {
        memcpy((void *)b->data, (const void *)buf, (unsigned long int)buf_size);
        buffer->data = &b->data;
        buffer->size = buf_size;
        b->ref_count = 1;
        groove_queue_put(e->audioq, (void *)buffer);
        return 0;
      }
    }
  }
}

// every_sink
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 493
static signed int every_sink(struct GroovePlaylist *playlist, signed int (*func)(struct GrooveSink *), signed int default_value)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  struct SinkMap *map_item = p->sink_map;
  while(!(map_item == ((struct SinkMap *)NULL)))
  {
    struct SinkStack *stack_item = map_item->stack_head;
    if(!(stack_item == ((struct SinkStack *)NULL)))
    {
      struct GrooveSink *sink = stack_item->sink;
      signed int value;
      value=func(sink);
      if(!(value == default_value))
        return value;

      stack_item = stack_item->next;
    }

    map_item = map_item->next;
  }
  return default_value;
}

// every_sink_flush
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 543
static void every_sink_flush(struct GroovePlaylist *playlist)
{
  every_sink(playlist, sink_flush$link1, 0);
}

// every_sink_full
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 515
static signed int every_sink_full(struct GroovePlaylist *playlist)
{
  signed int return_value_every_sink$1;
  return_value_every_sink$1=every_sink(playlist, sink_is_full, 1);
  return return_value_every_sink$1;
}

// every_sink_signal_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 529
static void every_sink_signal_end(struct GroovePlaylist *playlist)
{
  every_sink(playlist, sink_signal_end, 0);
}

// frame_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 107
static signed int frame_size(const struct AVFrame *frame)
{
  signed int return_value_av_get_channel_layout_nb_channels$1;
  return_value_av_get_channel_layout_nb_channels$1=av_get_channel_layout_nb_channels(frame->channel_layout);
  signed int return_value_av_get_bytes_per_sample$2;
  return_value_av_get_bytes_per_sample$2=av_get_bytes_per_sample((enum AVSampleFormat)frame->format);
  return return_value_av_get_channel_layout_nb_channels$1 * return_value_av_get_bytes_per_sample$2 * frame->nb_samples;
}

// frame_to_groove_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 113
static struct GrooveBuffer * frame_to_groove_buffer(struct GroovePlaylist *playlist, struct GrooveSink *sink, struct AVFrame *frame)
{
  struct GrooveBufferPrivate *b;
  void *return_value_av_mallocz$1;
  return_value_av_mallocz$1=av_mallocz(sizeof(struct GrooveBufferPrivate) /*136ul*/ );
  b = (struct GrooveBufferPrivate *)return_value_av_mallocz$1;
  if(b == ((struct GrooveBufferPrivate *)NULL))
  {
    av_log((void *)0, 16, "unable to allocate buffer\n");
    return (struct GrooveBuffer *)(void *)0;
  }

  else
  {
    struct GrooveBuffer *buffer = &b->externals;
    signed int return_value_pthread_mutex_init$2;
    return_value_pthread_mutex_init$2=pthread_mutex_init(&b->mutex, (const union anonymous$6 *)(void *)0);
    if(!(return_value_pthread_mutex_init$2 == 0))
    {
      av_free((void *)b);
      av_log((void *)0, 16, "unable to create mutex\n");
      return (struct GrooveBuffer *)(void *)0;
    }

    else
    {
      struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
      struct GrooveFile *file = p->decode_head->file;
      struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
      buffer->item = p->decode_head;
      buffer->pos = f->audio_clock;
      buffer->data = frame->extended_data;
      buffer->frame_count = frame->nb_samples;
      buffer->format.channel_layout = frame->channel_layout;
      buffer->format.sample_fmt = (enum GrooveSampleFormat)frame->format;
      buffer->format.sample_rate = frame->sample_rate;
      buffer->size=frame_size(frame);
      buffer->pts = (unsigned long int)frame->pts;
      b->frame = frame;
      return buffer;
    }
  }
}

// gain_to_dB
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 266
static double gain_to_dB(double gain)
{
  double return_value_log$1;
  return_value_log$1=log(gain);
  return return_value_log$1 / dB_scale;
}

// groove_audio_formats_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 83
signed int groove_audio_formats_equal(struct GrooveAudioFormat *a, struct GrooveAudioFormat *b)
{
  _Bool tmp_if_expr$1;
  if(a->sample_rate == b->sample_rate)
    tmp_if_expr$1 = a->channel_layout == b->channel_layout ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = a->sample_fmt == b->sample_fmt ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  return (signed int)tmp_if_expr$2;
}

// groove_buffer_ref
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/buffer.c line 12
void groove_buffer_ref(struct GrooveBuffer *buffer)
{
  struct GrooveBufferPrivate *b = (struct GrooveBufferPrivate *)buffer;
  pthread_mutex_lock(&b->mutex);
  b->ref_count = b->ref_count + 1;
  pthread_mutex_unlock(&b->mutex);
}

// groove_buffer_unref
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 345
void groove_buffer_unref(struct GrooveBuffer *buffer)
{
  _Bool tmp_if_expr$1;
  if(!(buffer == ((struct GrooveBuffer *)NULL)))
  {
    struct GrooveBufferPrivate *b = (struct GrooveBufferPrivate *)buffer;
    pthread_mutex_lock(&b->mutex);
    b->ref_count = b->ref_count - 1;
    signed int free = (signed int)(b->ref_count == 0);
    pthread_mutex_unlock(&b->mutex);
    if(!(free == 0))
    {
      pthread_mutex_destroy(&b->mutex);
      if(!(b->is_packet == 0))
        tmp_if_expr$1 = b->data != ((unsigned char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        av_free((void *)b->data);

      else
        if(!(b->frame == ((struct AVFrame *)NULL)))
          av_frame_free(&b->frame);

      av_free((void *)b);
    }

  }

}

// groove_channel_layout_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 71
signed int groove_channel_layout_count(unsigned long int channel_layout)
{
  signed int return_value_av_get_channel_layout_nb_channels$1;
  return_value_av_get_channel_layout_nb_channels$1=av_get_channel_layout_nb_channels(channel_layout);
  return return_value_av_get_channel_layout_nb_channels$1;
}

// groove_channel_layout_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 75
unsigned long int groove_channel_layout_default(signed int count)
{
  signed long int return_value_av_get_default_channel_layout$1;
  return_value_av_get_default_channel_layout$1=av_get_default_channel_layout(count);
  return (unsigned long int)return_value_av_get_default_channel_layout$1;
}

// groove_encoder_attach
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 95
signed int groove_encoder_attach(struct GrooveEncoder *encoder, struct GroovePlaylist *playlist)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  encoder->playlist = playlist;
  groove_queue_reset(e->audioq);
  e->oformat=av_guess_format(encoder->format_short_name, encoder->filename, encoder->mime_type);
  signed int tmp_if_expr$1;
  if(e->oformat == ((struct AVOutputFormat *)NULL))
  {
    groove_encoder_detach(encoder);
    av_log((void *)0, 16, "unable to determine format\n");
    return -1;
  }

  else
  {
    struct AVCodec *codec = (struct AVCodec *)(void *)0;
    if(!(encoder->codec_short_name == ((const char *)NULL)))
    {
      codec=avcodec_find_encoder_by_name(encoder->codec_short_name);
      if(codec == ((struct AVCodec *)NULL))
      {
        const struct AVCodecDescriptor *desc;
        desc=avcodec_descriptor_get_by_name(encoder->codec_short_name);
        if(!(desc == ((const struct AVCodecDescriptor *)NULL)))
          codec=avcodec_find_encoder(desc->id);

      }

    }

    if(codec == ((struct AVCodec *)NULL))
    {
      enum AVCodecID codec_id;
      codec_id=av_guess_codec(e->oformat, encoder->codec_short_name, encoder->filename, encoder->mime_type, (enum AVMediaType)AVMEDIA_TYPE_AUDIO);
      codec=avcodec_find_encoder(codec_id);
      if(codec == ((struct AVCodec *)NULL))
      {
        groove_encoder_detach(encoder);
        av_log((void *)0, 16, "unable to find encoder\n");
        return -1;
      }

    }

    e->codec = codec;
    av_log((void *)0, 32, "encoder: using codec: %s\n", codec->long_name);
    encoder->actual_audio_format.sample_fmt=closest_supported_sample_fmt(codec, encoder->target_audio_format.sample_fmt);
    encoder->actual_audio_format.sample_rate=closest_supported_sample_rate(codec, encoder->target_audio_format.sample_rate);
    encoder->actual_audio_format.channel_layout=closest_supported_channel_layout(codec, encoder->target_audio_format.channel_layout);
    log_audio_fmt(&encoder->actual_audio_format);
    signed int err;
    err=init_avcontext(encoder);
    if(!(err >= 0))
    {
      groove_encoder_detach(encoder);
      return err;
    }

    else
    {
      e->sink->audio_format = encoder->actual_audio_format;
      e->sink->buffer_size = encoder->sink_buffer_size;
      if(!((65536 & codec->capabilities) == 0))
        tmp_if_expr$1 = 0;

      else
        tmp_if_expr$1 = e->stream->codec->frame_size;
      e->sink->buffer_sample_count = tmp_if_expr$1;
      e->sink->gain = encoder->gain;
      signed int return_value_groove_sink_attach$2;
      return_value_groove_sink_attach$2=groove_sink_attach(e->sink, playlist);
      if(!(return_value_groove_sink_attach$2 >= 0))
      {
        groove_encoder_detach(encoder);
        av_log((void *)0, 16, "unable to attach sink\n");
        return -1;
      }

      else
      {
        signed int return_value_pthread_create$3;
        return_value_pthread_create$3=pthread_create(&e->thread_id, (const union pthread_attr_t *)(void *)0, encode_thread, (void *)encoder);
        if(!(return_value_pthread_create$3 == 0))
        {
          groove_encoder_detach(encoder);
          av_log((void *)0, 16, "unable to create encoder thread\n");
          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// groove_encoder_buffer_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 104
signed int groove_encoder_buffer_get(struct GrooveEncoder *encoder, struct GrooveBuffer **buffer, signed int block)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  signed int return_value_groove_queue_get$1;
  return_value_groove_queue_get$1=groove_queue_get(e->audioq, (void **)buffer, block);
  if(return_value_groove_queue_get$1 == 1)
  {
    if(*buffer == end_of_q_sentinel)
    {
      *buffer = (struct GrooveBuffer *)(void *)0;
      return 2;
    }

    else
      return 1;
  }

  else
  {
    *buffer = (struct GrooveBuffer *)(void *)0;
    return 0;
  }
}

// groove_encoder_buffer_peek
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 690
signed int groove_encoder_buffer_peek(struct GrooveEncoder *encoder, signed int block)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  signed int return_value_groove_queue_peek$1;
  return_value_groove_queue_peek$1=groove_queue_peek(e->audioq, block);
  return return_value_groove_queue_peek$1;
}

// groove_encoder_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 87
struct GrooveEncoder * groove_encoder_create(void)
{
  struct GrooveEncoderPrivate *e;
  void *return_value_av_mallocz$1;
  return_value_av_mallocz$1=av_mallocz(sizeof(struct GrooveEncoderPrivate) /*984ul*/ );
  e = (struct GrooveEncoderPrivate *)return_value_av_mallocz$1;
  if(e == ((struct GrooveEncoderPrivate *)NULL))
  {
    av_log((void *)0, 16, "unable to allocate encoder\n");
    return (struct GrooveEncoder *)(void *)0;
  }

  else
  {
    struct GrooveEncoder *encoder = &e->externals;
    const signed int buffer_size = 4 * 1024;
    void *return_value_av_malloc$2;
    return_value_av_malloc$2=av_malloc((unsigned long int)buffer_size);
    e->avio_buf = (unsigned char *)return_value_av_malloc$2;
    if(e->avio_buf == ((unsigned char *)NULL))
    {
      groove_encoder_destroy(encoder);
      av_log((void *)0, 16, "unable to allocate avio buffer\n");
      return (struct GrooveEncoder *)(void *)0;
    }

    else
    {
      e->avio=avio_alloc_context(e->avio_buf, buffer_size, 1, (void *)encoder, (signed int (*)(void *, unsigned char *, signed int))(void *)0, encoder_write_packet, (signed long int (*)(void *, signed long int, signed int))(void *)0);
      if(e->avio == ((struct AVIOContext *)NULL))
      {
        groove_encoder_destroy(encoder);
        av_log((void *)0, 16, "unable to allocate avio context\n");
        return (struct GrooveEncoder *)(void *)0;
      }

      else
      {
        signed int return_value_pthread_mutex_init$3;
        return_value_pthread_mutex_init$3=pthread_mutex_init(&e->encode_head_mutex, (const union anonymous$6 *)(void *)0);
        if(!(return_value_pthread_mutex_init$3 == 0))
        {
          groove_encoder_destroy(encoder);
          av_log((void *)0, 16, "unable to create mutex\n");
          return (struct GrooveEncoder *)(void *)0;
        }

        else
        {
          e->encode_head_mutex_inited = (char)1;
          signed int return_value_pthread_cond_init$4;
          return_value_pthread_cond_init$4=pthread_cond_init(&e->drain_cond, (const union anonymous$6 *)(void *)0);
          if(!(return_value_pthread_cond_init$4 == 0))
          {
            groove_encoder_destroy(encoder);
            av_log((void *)0, 16, "unable to create mutex condition\n");
            return (struct GrooveEncoder *)(void *)0;
          }

          else
          {
            e->drain_cond_inited = (char)1;
            e->audioq=groove_queue_create();
            if(e->audioq == ((struct GrooveQueue *)NULL))
            {
              groove_encoder_destroy(encoder);
              av_log((void *)0, 16, "unable to allocate queue\n");
              return (struct GrooveEncoder *)(void *)0;
            }

            else
            {
              e->audioq->context = (void *)encoder;
              e->audioq->cleanup = audioq_cleanup;
              e->audioq->put = audioq_put;
              e->audioq->get = audioq_get;
              e->audioq->purge = audioq_purge;
              e->sink=groove_sink_create();
              if(e->sink == ((struct GrooveSink *)NULL))
              {
                groove_encoder_destroy(encoder);
                av_log((void *)0, 16, "unable to allocate sink\n");
                return (struct GrooveEncoder *)(void *)0;
              }

              else
              {
                e->sink->userdata = (void *)encoder;
                e->sink->purge = sink_purge;
                e->sink->flush = sink_flush;
                encoder->bit_rate = 256 * 1000;
                encoder->target_audio_format.sample_rate = 44100;
                encoder->target_audio_format.sample_fmt = (enum GrooveSampleFormat)GROOVE_SAMPLE_FMT_S16;
                encoder->target_audio_format.channel_layout = (unsigned long int)(0x00000001 | 0x00000002);
                encoder->sink_buffer_size = e->sink->buffer_size;
                encoder->encoded_buffer_size = 16 * 1024;
                encoder->gain = e->sink->gain;
                return encoder;
              }
            }
          }
        }
      }
    }
  }
}

// groove_encoder_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 89
void groove_encoder_destroy(struct GrooveEncoder *encoder)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  if(!(e->sink == ((struct GrooveSink *)NULL)))
    groove_sink_destroy(e->sink);

  if(!(e->audioq == ((struct GrooveQueue *)NULL)))
    groove_queue_destroy(e->audioq);

  if(!(e->encode_head_mutex_inited == 0))
    pthread_mutex_destroy(&e->encode_head_mutex);

  if(!(e->drain_cond_inited == 0))
    pthread_cond_destroy(&e->drain_cond);

  if(!(e->avio == ((struct AVIOContext *)NULL)))
    av_free((void *)e->avio);

  if(!(e->avio_buf == ((unsigned char *)NULL)))
    av_free((void *)e->avio_buf);

  if(!(e->metadata == ((struct AVDictionary *)NULL)))
    av_dict_free(&e->metadata);

  av_free((void *)e);
}

// groove_encoder_detach
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 97
signed int groove_encoder_detach(struct GrooveEncoder *encoder)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  e->abort_request = 1;
  groove_sink_detach(e->sink);
  groove_queue_flush(e->audioq);
  groove_queue_abort(e->audioq);
  pthread_cond_signal(&e->drain_cond);
  pthread_join(e->thread_id, (void **)(void *)0);
  e->abort_request = 0;
  cleanup_avcontext(e);
  e->oformat = (struct AVOutputFormat *)(void *)0;
  e->codec = (struct AVCodec *)(void *)0;
  encoder->playlist = (struct GroovePlaylist *)(void *)0;
  return 0;
}

// groove_encoder_metadata_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 675
struct GrooveTag * groove_encoder_metadata_get(struct GrooveEncoder *encoder, const char *key, struct GrooveTag *prev, signed int flags)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  const struct AVDictionaryEntry *entry = (const struct AVDictionaryEntry *)prev;
  struct AVDictionaryEntry *return_value_av_dict_get$1;
  return_value_av_dict_get$1=av_dict_get(e->metadata, key, entry, flags | 2);
  return (struct GrooveTag *)return_value_av_dict_get$1;
}

// groove_encoder_metadata_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.h line 117
signed int groove_encoder_metadata_set(struct GrooveEncoder *encoder, const char *key, const char *value, signed int flags)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  signed int return_value_av_dict_set$1;
  return_value_av_dict_set$1=av_dict_set(&e->metadata, key, value, flags | 2);
  return return_value_av_dict_set$1;
}

// groove_encoder_position
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 695
void groove_encoder_position(struct GrooveEncoder *encoder, struct GroovePlaylistItem **item, double *seconds)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  pthread_mutex_lock(&e->encode_head_mutex);
  if(!(item == ((struct GroovePlaylistItem **)NULL)))
    *item = e->encode_head;

  if(!(seconds == ((double *)NULL)))
    *seconds = e->encode_pos;

  pthread_mutex_unlock(&e->encode_head_mutex);
}

// groove_encoder_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 711
signed int groove_encoder_set_gain(struct GrooveEncoder *encoder, double gain)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  encoder->gain = gain;
  signed int return_value_groove_sink_set_gain$1;
  return_value_groove_sink_set_gain$1=groove_sink_set_gain(e->sink, gain);
  return return_value_groove_sink_set_gain$1;
}

// groove_file_audio_format
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 189
void groove_file_audio_format(struct GrooveFile *file, struct GrooveAudioFormat *audio_format)
{
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  struct AVCodecContext *codec_ctx = f->audio_st->codec;
  audio_format->sample_rate = codec_ctx->sample_rate;
  audio_format->channel_layout = codec_ctx->channel_layout;
  audio_format->sample_fmt = (enum GrooveSampleFormat)codec_ctx->sample_fmt;
}

// groove_file_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 157
void groove_file_close(struct GrooveFile *file)
{
  if(!(file == ((struct GrooveFile *)NULL)))
  {
    struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
    f->abort_request = 1;
    if(f->audio_stream_index >= 0)
    {
      struct AVCodecContext *avctx = f->ic->streams[(signed long int)f->audio_stream_index]->codec;
      av_free_packet(&f->audio_pkt);
      f->ic->streams[(signed long int)f->audio_stream_index]->discard = (enum AVDiscard)AVDISCARD_ALL;
      avcodec_close(avctx);
      f->audio_st = (struct AVStream *)(void *)0;
      f->audio_stream_index = -1;
    }

    f->abort_request = 0;
    if(!(f->ic == ((struct AVFormatContext *)NULL)))
      avformat_close_input(&f->ic);

    pthread_mutex_destroy(&f->seek_mutex);
    av_free((void *)f);
  }

}

// groove_file_duration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 139
double groove_file_duration(struct GrooveFile *file)
{
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  double time_base;
  time_base=av_q2d(f->audio_st->time_base);
  return time_base * (double)f->audio_st->duration;
}

// groove_file_metadata_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 159
struct GrooveTag * groove_file_metadata_get(struct GrooveFile *file, const char *key, struct GrooveTag *prev, signed int flags)
{
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  const struct AVDictionaryEntry *e = (const struct AVDictionaryEntry *)prev;
  if(!(key == ((const char *)NULL)))
  {
    if((signed int)*key == 0)
      flags = flags | 2;

  }

  struct AVDictionaryEntry *return_value_av_dict_get$1;
  return_value_av_dict_get$1=av_dict_get(f->ic->metadata, key, e, flags);
  return (struct GrooveTag *)return_value_av_dict_get$1;
}

// groove_file_metadata_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 164
signed int groove_file_metadata_set(struct GrooveFile *file, const char *key, const char *value, signed int flags)
{
  file->dirty = 1;
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  signed int return_value_av_dict_set$1;
  return_value_av_dict_set$1=av_dict_set(&f->ic->metadata, key, value, flags);
  return return_value_av_dict_set$1;
}

// groove_file_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 156
struct GrooveFile * groove_file_open(const char *filename)
{
  struct GrooveFilePrivate *f;
  void *return_value_av_mallocz$1;
  return_value_av_mallocz$1=av_mallocz(sizeof(struct GrooveFilePrivate) /*224ul*/ );
  f = (struct GrooveFilePrivate *)return_value_av_mallocz$1;
  signed long int return_value_av_get_default_channel_layout$4;
  if(f == ((struct GrooveFilePrivate *)NULL))
  {
    av_log((void *)0, 16, "unable to allocate file context\n");
    return (struct GrooveFile *)(void *)0;
  }

  else
  {
    struct GrooveFile *file = &f->externals;
    f->audio_stream_index = -1;
    f->seek_pos = (signed long int)-1;
    signed int return_value_pthread_mutex_init$2;
    return_value_pthread_mutex_init$2=pthread_mutex_init(&f->seek_mutex, (const union anonymous$6 *)(void *)0);
    if(!(return_value_pthread_mutex_init$2 == 0))
    {
      av_free((void *)f);
      av_log((void *)0, 16, "unable to create seek mutex\n");
      return (struct GrooveFile *)(void *)0;
    }

    else
    {
      f->ic=avformat_alloc_context();
      if(f->ic == ((struct AVFormatContext *)NULL))
      {
        groove_file_close(file);
        av_log((void *)0, 16, "unable to allocate format context\n");
        return (struct GrooveFile *)(void *)0;
      }

      else
      {
        file->filename = f->ic->filename;
        f->ic->interrupt_callback.callback = decode_interrupt_cb;
        f->ic->interrupt_callback.opaque = (void *)file;
        signed int err;
        err=avformat_open_input(&f->ic, filename, (struct AVInputFormat *)(void *)0, (struct AVDictionary **)(void *)0);
        if(!(err >= 0))
        {
          groove_file_close(file);
          av_log((void *)0, 32, "%s: unrecognized format\n", filename);
          return (struct GrooveFile *)(void *)0;
        }

        else
        {
          err=avformat_find_stream_info(f->ic, (struct AVDictionary **)(void *)0);
          if(!(err >= 0))
          {
            groove_file_close(file);
            av_log((void *)0, 16, "%s: could not find codec parameters\n", filename);
            return (struct GrooveFile *)(void *)0;
          }

          else
          {
            signed int i = 0;
            for( ; !((unsigned int)i >= f->ic->nb_streams); i = i + 1)
              f->ic->streams[(signed long int)i]->discard = (enum AVDiscard)AVDISCARD_ALL;
            f->audio_stream_index=av_find_best_stream(f->ic, (enum AVMediaType)AVMEDIA_TYPE_AUDIO, -1, -1, &f->decoder, 0);
            if(!(f->audio_stream_index >= 0))
            {
              groove_file_close(file);
              av_log((void *)0, 32, "%s: no audio stream found\n", filename);
              return (struct GrooveFile *)(void *)0;
            }

            else
              if(f->decoder == ((struct AVCodec *)NULL))
              {
                groove_file_close(file);
                av_log((void *)0, 16, "%s: no decoder found\n", filename);
                return (struct GrooveFile *)(void *)0;
              }

              else
              {
                f->audio_st = f->ic->streams[(signed long int)f->audio_stream_index];
                f->audio_st->discard = (enum AVDiscard)AVDISCARD_DEFAULT;
                struct AVCodecContext *avctx = f->audio_st->codec;
                signed int return_value_avcodec_open2$3;
                return_value_avcodec_open2$3=avcodec_open2(avctx, f->decoder, (struct AVDictionary **)(void *)0);
                if(!(return_value_avcodec_open2$3 >= 0))
                {
                  groove_file_close(file);
                  av_log((void *)0, 16, "unable to open decoder\n");
                  return (struct GrooveFile *)(void *)0;
                }

                else
                {
                  if(avctx->channel_layout == 0ul)
                  {
                    return_value_av_get_default_channel_layout$4=av_get_default_channel_layout(avctx->channels);
                    avctx->channel_layout = (unsigned long int)return_value_av_get_default_channel_layout$4;
                  }

                  if(avctx->channel_layout == 0ul)
                  {
                    groove_file_close(file);
                    av_log((void *)0, 16, "unable to guess channel layout\n");
                    return (struct GrooveFile *)(void *)0;
                  }

                  else
                  {
                    av_dict_copy(&f->ic->metadata, f->audio_st->metadata, 0);
                    return file;
                  }
                }
              }
          }
        }
      }
    }
  }
}

// groove_file_save
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 215
signed int groove_file_save(struct GrooveFile *file)
{
  _Bool tmp_if_expr$4;
  enum AVCodecID return_value_av_codec_get_id$3;
  _Bool tmp_if_expr$6;
  unsigned int return_value_av_codec_get_tag$5;
  struct AVRational tmp_if_expr$9;
  struct AVRational tmp_if_expr$8;
  if(file->dirty == 0)
    return 0;

  else
  {
    struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
    struct AVOutputFormat *ofmt;
    ofmt=av_guess_format(f->ic->iformat->name, f->ic->filename, (const char *)(void *)0);
    if(ofmt == ((struct AVOutputFormat *)NULL))
    {
      av_log((void *)0, 16, "Could not deduce output format to use.\n");
      return -1;
    }

    else
    {
      f->oc=avformat_alloc_context();
      if(f->oc == ((struct AVFormatContext *)NULL))
      {
        cleanup_save(file);
        av_log((void *)0, 16, "Could not create output context: out of memory\n");
        return -1;
      }

      else
      {
        f->oc->oformat = ofmt;
        snprintf(f->oc->filename, sizeof(char [1024l]) /*1024ul*/ , "%s", (const void *)f->ic->filename);
        signed int return_value_tempfileify$1;
        return_value_tempfileify$1=tempfileify(f->oc->filename, sizeof(char [1024l]) /*1024ul*/ );
        if(!(return_value_tempfileify$1 >= 0))
        {
          cleanup_save(file);
          av_log((void *)0, 16, "could not create temp file - filename too long\n");
          return -1;
        }

        else
        {
          if((0x0001 & ofmt->flags) == 0)
          {
            signed int return_value_avio_open$2;
            return_value_avio_open$2=avio_open(&f->oc->pb, f->oc->filename, 2);
            if(!(return_value_avio_open$2 >= 0))
            {
              cleanup_save(file);
              av_log((void *)0, 16, "could not open '%s'\n", (const void *)f->oc->filename);
              return -1;
            }

            f->tempfile_exists = 1;
          }

          signed int i = 0;
          for( ; !((unsigned int)i >= f->ic->nb_streams); i = i + 1)
          {
            struct AVStream *in_stream = f->ic->streams[(signed long int)i];
            struct AVStream *out_stream;
            out_stream=avformat_new_stream(f->oc, (const struct AVCodec *)(void *)0);
            if(out_stream == ((struct AVStream *)NULL))
            {
              cleanup_save(file);
              av_log((void *)0, 16, "error allocating output stream\n");
              return -1;
            }

            out_stream->id = in_stream->id;
            out_stream->disposition = in_stream->disposition;
            out_stream->time_base = in_stream->time_base;
            struct AVCodecContext *icodec = in_stream->codec;
            struct AVCodecContext *ocodec = out_stream->codec;
            ocodec->bits_per_raw_sample = icodec->bits_per_raw_sample;
            ocodec->chroma_sample_location = icodec->chroma_sample_location;
            ocodec->codec_id = icodec->codec_id;
            ocodec->codec_type = icodec->codec_type;
            if(ocodec->codec_tag == 0u)
            {
              if(f->oc->oformat->codec_tag == ((struct AVCodecTag * const *)NULL))
                tmp_if_expr$4 = (_Bool)1;

              else
              {
                return_value_av_codec_get_id$3=av_codec_get_id(f->oc->oformat->codec_tag, icodec->codec_tag);
                tmp_if_expr$4 = return_value_av_codec_get_id$3 == ocodec->codec_id ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$4)
                tmp_if_expr$6 = (_Bool)1;

              else
              {
                return_value_av_codec_get_tag$5=av_codec_get_tag(f->oc->oformat->codec_tag, icodec->codec_id);
                tmp_if_expr$6 = return_value_av_codec_get_tag$5 <= (unsigned int)0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$6)
                ocodec->codec_tag = icodec->codec_tag;

            }

            ocodec->bit_rate = icodec->bit_rate;
            ocodec->rc_max_rate = icodec->rc_max_rate;
            ocodec->rc_buffer_size = icodec->rc_buffer_size;
            ocodec->field_order = icodec->field_order;
            unsigned long int extra_size = (unsigned long int)icodec->extradata_size + (unsigned long int)32;
            if(extra_size >= 2147483648ul)
            {
              cleanup_save(file);
              av_log((void *)0, 16, "codec extra size too big\n");
              return -22;
            }

            void *return_value_av_mallocz$7;
            return_value_av_mallocz$7=av_mallocz(extra_size);
            ocodec->extradata = (unsigned char *)return_value_av_mallocz$7;
            if(ocodec->extradata == ((unsigned char *)NULL))
            {
              cleanup_save(file);
              av_log((void *)0, 16, "could not allocate codec extradata: out of memory\n");
              return -12;
            }

            memcpy((void *)ocodec->extradata, (const void *)icodec->extradata, (unsigned long int)icodec->extradata_size);
            ocodec->extradata_size = icodec->extradata_size;
            switch((signed int)ocodec->codec_type)
            {
              case AVMEDIA_TYPE_AUDIO:
              {
                ocodec->channel_layout = icodec->channel_layout;
                ocodec->sample_rate = icodec->sample_rate;
                ocodec->channels = icodec->channels;
                ocodec->frame_size = icodec->frame_size;
                ocodec->audio_service_type = icodec->audio_service_type;
                ocodec->block_align = icodec->block_align;
                break;
              }
              case AVMEDIA_TYPE_VIDEO:
              {
                ocodec->pix_fmt = icodec->pix_fmt;
                ocodec->width = icodec->width;
                ocodec->height = icodec->height;
                ocodec->has_b_frames = icodec->has_b_frames;
                if(ocodec->sample_aspect_ratio.num == 0)
                {
                  if(!(in_stream->sample_aspect_ratio.num == 0))
                    tmp_if_expr$9 = in_stream->sample_aspect_ratio;

                  else
                  {
                    if(!(icodec->sample_aspect_ratio.num == 0))
                      tmp_if_expr$8 = icodec->sample_aspect_ratio;

                    else
                      tmp_if_expr$8 = (struct AVRational){ .num=0, .den=1 };
                    tmp_if_expr$9 = tmp_if_expr$8;
                  }
                  out_stream->sample_aspect_ratio = tmp_if_expr$9;
                  ocodec->sample_aspect_ratio = out_stream->sample_aspect_ratio;
                }

                break;
              }
              case AVMEDIA_TYPE_SUBTITLE:
              {
                ocodec->width = icodec->width;
                ocodec->height = icodec->height;
                break;
              }
              case AVMEDIA_TYPE_DATA:

              case AVMEDIA_TYPE_ATTACHMENT:
                break;
              default:
              {
                cleanup_save(file);
                av_log((void *)0, 16, "unrecognized stream type\n");
                return -1;
              }
            }
          }
          av_dict_copy(&f->oc->metadata, f->ic->metadata, 0);
          signed int return_value_avformat_write_header$10;
          return_value_avformat_write_header$10=avformat_write_header(f->oc, (struct AVDictionary **)(void *)0);
          if(!(return_value_avformat_write_header$10 >= 0))
          {
            cleanup_save(file);
            av_log((void *)0, 16, "could not write header\n");
            return -1;
          }

          else
          {
            struct AVPacket *pkt = &f->audio_pkt;
            do
            {
              signed int err;
              err=av_read_frame(f->ic, pkt);
              if(err == -541478725)
                break;

              else
                if(!(err >= 0))
                {
                  cleanup_save(file);
                  av_log((void *)0, 16, "error reading frame\n");
                  return -1;
                }

              signed int return_value_av_write_frame$11;
              return_value_av_write_frame$11=av_write_frame(f->oc, pkt);
              if(!(return_value_av_write_frame$11 >= 0))
              {
                cleanup_save(file);
                av_log((void *)0, 16, "error writing frame\n");
                return -1;
              }

              av_free_packet(pkt);
            }
            while((_Bool)1);
            signed int return_value_av_write_trailer$12;
            return_value_av_write_trailer$12=av_write_trailer(f->oc);
            if(!(return_value_av_write_trailer$12 >= 0))
            {
              cleanup_save(file);
              av_log((void *)0, 16, "could not write trailer\n");
              return -1;
            }

            else
            {
              signed int return_value_rename$13;
              return_value_rename$13=rename(f->oc->filename, f->ic->filename);
              if(!(return_value_rename$13 == 0))
              {
                cleanup_save(file);
                av_log((void *)0, 16, "error renaming tmp file to original file\n");
                return -1;
              }

              else
              {
                f->tempfile_exists = 0;
                cleanup_save(file);
                file->dirty = 0;
                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// groove_file_short_names
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 134
const char * groove_file_short_names(struct GrooveFile *file)
{
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  return f->ic->iformat->name;
}

// groove_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 27
void groove_finish(void)
{
  if(!(should_deinit_network == 0))
  {
    avformat_network_deinit();
    should_deinit_network = 0;
  }

}

// groove_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 23
signed int groove_init(void)
{
  av_lockmgr_register(my_lockmgr_cb);
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  srand((unsigned int)return_value_time$1);
  avcodec_register_all();
  av_register_all();
  avformat_network_init();
  avfilter_register_all();
  should_deinit_network = 1;
  av_log_set_level(-8);
  return 0;
}

// groove_playlist_clear
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1206
void groove_playlist_clear(struct GroovePlaylist *playlist)
{
  struct GroovePlaylistItem *node = playlist->head;
  if(!(node == ((struct GroovePlaylistItem *)NULL)))
    while(!(node == ((struct GroovePlaylistItem *)NULL)))
    {
      struct GroovePlaylistItem *next = node->next;
      groove_playlist_remove(playlist, node);
      node = next;
    }

}

// groove_playlist_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 285
signed int groove_playlist_count(struct GroovePlaylist *playlist)
{
  struct GroovePlaylistItem *node = playlist->head;
  signed int count = 0;
  for( ; !(node == ((struct GroovePlaylistItem *)NULL)); node = node->next)
    count = count + 1;
  return count;
}

// groove_playlist_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 234
struct GroovePlaylist * groove_playlist_create(void)
{
  struct GroovePlaylistPrivate *p;
  void *return_value_av_mallocz$1;
  return_value_av_mallocz$1=av_mallocz(sizeof(struct GroovePlaylistPrivate) /*1048ul*/ );
  p = (struct GroovePlaylistPrivate *)return_value_av_mallocz$1;
  if(p == ((struct GroovePlaylistPrivate *)NULL))
  {
    av_log((void *)0, 16, "unable to allocate playlist\n");
    return (struct GroovePlaylist *)(void *)0;
  }

  else
  {
    struct GroovePlaylist *playlist = &p->externals;
    playlist->gain = 1.0;
    p->volume = 1.0;
    p->sent_end_of_q = 1;
    p->detect_full_sinks = every_sink_full;
    signed int return_value_pthread_mutex_init$2;
    return_value_pthread_mutex_init$2=pthread_mutex_init(&p->decode_head_mutex, (const union anonymous$6 *)(void *)0);
    if(!(return_value_pthread_mutex_init$2 == 0))
    {
      groove_playlist_destroy(playlist);
      av_log((void *)0, 16, "unable to allocate decode head mutex\n");
      return (struct GroovePlaylist *)(void *)0;
    }

    else
    {
      p->decode_head_mutex_inited = 1;
      signed int return_value_pthread_mutex_init$3;
      return_value_pthread_mutex_init$3=pthread_mutex_init(&p->drain_cond_mutex, (const union anonymous$6 *)(void *)0);
      if(!(return_value_pthread_mutex_init$3 == 0))
      {
        groove_playlist_destroy(playlist);
        av_log((void *)0, 16, "unable to allocate drain cond mutex\n");
        return (struct GroovePlaylist *)(void *)0;
      }

      else
      {
        p->drain_cond_mutex_inited = 1;
        signed int return_value_pthread_cond_init$4;
        return_value_pthread_cond_init$4=pthread_cond_init(&p->decode_head_cond, (const union anonymous$6 *)(void *)0);
        if(!(return_value_pthread_cond_init$4 == 0))
        {
          groove_playlist_destroy(playlist);
          av_log((void *)0, 16, "unable to allocate decode head mutex condition\n");
          return (struct GroovePlaylist *)(void *)0;
        }

        else
        {
          p->decode_head_cond_inited = 1;
          signed int return_value_pthread_cond_init$5;
          return_value_pthread_cond_init$5=pthread_cond_init(&p->sink_drain_cond, (const union anonymous$6 *)(void *)0);
          if(!(return_value_pthread_cond_init$5 == 0))
          {
            groove_playlist_destroy(playlist);
            av_log((void *)0, 16, "unable to allocate sink drain mutex condition\n");
            return (struct GroovePlaylist *)(void *)0;
          }

          else
          {
            p->sink_drain_cond_inited = 1;
            p->in_frame=av_frame_alloc();
            if(p->in_frame == ((struct AVFrame *)NULL))
            {
              groove_playlist_destroy(playlist);
              av_log((void *)0, 16, "unable to allocate frame\n");
              return (struct GroovePlaylist *)(void *)0;
            }

            else
            {
              signed int return_value_pthread_create$6;
              return_value_pthread_create$6=pthread_create(&p->thread_id, (const union pthread_attr_t *)(void *)0, decode_thread, (void *)playlist);
              if(!(return_value_pthread_create$6 == 0))
              {
                groove_playlist_destroy(playlist);
                av_log((void *)0, 16, "unable to create playlist thread\n");
                return (struct GroovePlaylist *)(void *)0;
              }

              else
              {
                p->volume_filter=avfilter_get_by_name("volume");
                if(p->volume_filter == ((struct AVFilter *)NULL))
                {
                  groove_playlist_destroy(playlist);
                  av_log((void *)0, 16, "unable to get volume filter\n");
                  return (struct GroovePlaylist *)(void *)0;
                }

                else
                {
                  p->compand_filter=avfilter_get_by_name("compand");
                  if(p->compand_filter == ((struct AVFilter *)NULL))
                  {
                    groove_playlist_destroy(playlist);
                    av_log((void *)0, 16, "unable to get compand filter\n");
                    return (struct GroovePlaylist *)(void *)0;
                  }

                  else
                  {
                    p->abuffer_filter=avfilter_get_by_name("abuffer");
                    if(p->abuffer_filter == ((struct AVFilter *)NULL))
                    {
                      groove_playlist_destroy(playlist);
                      av_log((void *)0, 16, "unable to get abuffer filter\n");
                      return (struct GroovePlaylist *)(void *)0;
                    }

                    else
                    {
                      p->asplit_filter=avfilter_get_by_name("asplit");
                      if(p->asplit_filter == ((struct AVFilter *)NULL))
                      {
                        groove_playlist_destroy(playlist);
                        av_log((void *)0, 16, "unable to get asplit filter\n");
                        return (struct GroovePlaylist *)(void *)0;
                      }

                      else
                      {
                        p->aformat_filter=avfilter_get_by_name("aformat");
                        if(p->aformat_filter == ((struct AVFilter *)NULL))
                        {
                          groove_playlist_destroy(playlist);
                          av_log((void *)0, 16, "unable to get aformat filter\n");
                          return (struct GroovePlaylist *)(void *)0;
                        }

                        else
                        {
                          p->abuffersink_filter=avfilter_get_by_name("abuffersink");
                          if(p->abuffersink_filter == ((struct AVFilter *)NULL))
                          {
                            groove_playlist_destroy(playlist);
                            av_log((void *)0, 16, "unable to get abuffersink filter\n");
                            return (struct GroovePlaylist *)(void *)0;
                          }

                          else
                            return playlist;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// groove_playlist_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 238
void groove_playlist_destroy(struct GroovePlaylist *playlist)
{
  groove_playlist_clear(playlist);
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  p->abort_request = 1;
  pthread_cond_signal(&p->decode_head_cond);
  pthread_cond_signal(&p->sink_drain_cond);
  pthread_join(p->thread_id, (void **)(void *)0);
  every_sink(playlist, groove_sink_detach, 0);
  avfilter_graph_free(&p->filter_graph);
  av_frame_free(&p->in_frame);
  if(!(p->decode_head_mutex_inited == 0))
    pthread_mutex_destroy(&p->decode_head_mutex);

  if(!(p->drain_cond_mutex_inited == 0))
    pthread_mutex_destroy(&p->drain_cond_mutex);

  if(!(p->decode_head_cond_inited == 0))
    pthread_cond_destroy(&p->decode_head_cond);

  if(!(p->sink_drain_cond_inited == 0))
    pthread_cond_destroy(&p->sink_drain_cond);

  av_free((void *)p);
}

// groove_playlist_insert
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 254
struct GroovePlaylistItem * groove_playlist_insert(struct GroovePlaylist *playlist, struct GrooveFile *file, double gain, double peak, struct GroovePlaylistItem *next)
{
  struct GroovePlaylistItem *item;
  void *return_value_av_mallocz$1;
  return_value_av_mallocz$1=av_mallocz(sizeof(struct GroovePlaylistItem) /*40ul*/ );
  item = (struct GroovePlaylistItem *)return_value_av_mallocz$1;
  if(item == ((struct GroovePlaylistItem *)NULL))
    return (struct GroovePlaylistItem *)(void *)0;

  else
  {
    item->file = file;
    item->next = next;
    item->gain = gain;
    item->peak = peak;
    struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
    struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
    pthread_mutex_lock(&p->decode_head_mutex);
    if(!(next == ((struct GroovePlaylistItem *)NULL)))
    {
      if(!(next->prev == ((struct GroovePlaylistItem *)NULL)))
      {
        item->prev = next->prev;
        item->prev->next = item;
        next->prev = item;
      }

      else
        playlist->head = item;
    }

    else
      if(playlist->head == ((struct GroovePlaylistItem *)NULL))
      {
        playlist->head = item;
        playlist->tail = item;
        pthread_mutex_lock(&f->seek_mutex);
        f->seek_pos = (signed long int)0;
        f->seek_flush = 0;
        pthread_mutex_unlock(&f->seek_mutex);
        p->decode_head = playlist->head;
        pthread_cond_signal(&p->decode_head_cond);
      }

      else
      {
        item->prev = playlist->tail;
        playlist->tail->next = item;
        playlist->tail = item;
      }
    pthread_mutex_unlock(&p->decode_head_mutex);
    return item;
  }
}

// groove_playlist_pause
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1075
void groove_playlist_pause(struct GroovePlaylist *playlist)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  if(!(p->paused == 1))
  {
    p->paused = 1;
    every_sink(playlist, groove_sink_pause, 0);
  }

}

// groove_playlist_play
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1066
void groove_playlist_play(struct GroovePlaylist *playlist)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  if(!(p->paused == 0))
  {
    p->paused = 0;
    every_sink(playlist, groove_sink_play, 0);
  }

}

// groove_playlist_playing
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1283
signed int groove_playlist_playing(struct GroovePlaylist *playlist)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  return (signed int)!(p->paused != 0);
}

// groove_playlist_position
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1252
void groove_playlist_position(struct GroovePlaylist *playlist, struct GroovePlaylistItem **item, double *seconds)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  pthread_mutex_lock(&p->decode_head_mutex);
  if(!(item == ((struct GroovePlaylistItem **)NULL)))
    *item = p->decode_head;

  if(!(seconds == ((double *)NULL)))
  {
    if(!(p->decode_head == ((struct GroovePlaylistItem *)NULL)))
    {
      struct GrooveFile *file = p->decode_head->file;
      struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
      *seconds = f->audio_clock;
    }

    else
      *seconds = -1.0;
  }

  pthread_mutex_unlock(&p->decode_head_mutex);
}

// groove_playlist_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 262
void groove_playlist_remove(struct GroovePlaylist *playlist, struct GroovePlaylistItem *item)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  pthread_mutex_lock(&p->decode_head_mutex);
  if(item == p->decode_head)
    p->decode_head = item->next;

  if(!(item->prev == ((struct GroovePlaylistItem *)NULL)))
    item->prev->next = item->next;

  else
    playlist->head = item->next;
  if(!(item->next == ((struct GroovePlaylistItem *)NULL)))
    item->next->prev = item->prev;

  else
    playlist->tail = item->prev;
  p->purge_item = item;
  every_sink(playlist, purge_sink, 0);
  p->purge_item = (struct GroovePlaylistItem *)(void *)0;
  pthread_mutex_lock(&p->drain_cond_mutex);
  pthread_cond_signal(&p->sink_drain_cond);
  pthread_mutex_unlock(&p->drain_cond_mutex);
  pthread_mutex_unlock(&p->decode_head_mutex);
  av_free((void *)item);
}

// groove_playlist_seek
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1084
void groove_playlist_seek(struct GroovePlaylist *playlist, struct GroovePlaylistItem *item, double seconds)
{
  struct GrooveFile *file = item->file;
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  signed long int ts = (signed long int)((seconds * (double)f->audio_st->time_base.den) / (double)f->audio_st->time_base.num);
  if(!(f->ic->start_time == -9223372036854775808l))
    ts = ts + f->ic->start_time;

  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  pthread_mutex_lock(&p->decode_head_mutex);
  pthread_mutex_lock(&f->seek_mutex);
  f->seek_pos = ts;
  f->seek_flush = 1;
  pthread_mutex_unlock(&f->seek_mutex);
  p->decode_head = item;
  pthread_cond_signal(&p->decode_head_cond);
  pthread_mutex_unlock(&p->decode_head_mutex);
}

// groove_playlist_set_fill_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1355
void groove_playlist_set_fill_mode(struct GroovePlaylist *playlist, signed int mode)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  pthread_mutex_lock(&p->decode_head_mutex);
  if(mode == 0)
    p->detect_full_sinks = every_sink_full;

  else
    p->detect_full_sinks = any_sink_full;
  pthread_mutex_unlock(&p->decode_head_mutex);
}

// groove_playlist_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1273
void groove_playlist_set_gain(struct GroovePlaylist *playlist, double gain)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  pthread_mutex_lock(&p->decode_head_mutex);
  playlist->gain = gain;
  if(!(p->decode_head == ((struct GroovePlaylistItem *)NULL)))
    update_playlist_volume(playlist);

  pthread_mutex_unlock(&p->decode_head_mutex);
}

// groove_playlist_set_item_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1226
void groove_playlist_set_item_gain(struct GroovePlaylist *playlist, struct GroovePlaylistItem *item, double gain)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  pthread_mutex_lock(&p->decode_head_mutex);
  item->gain = gain;
  if(item == p->decode_head)
    update_playlist_volume(playlist);

  pthread_mutex_unlock(&p->decode_head_mutex);
}

// groove_playlist_set_item_peak
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1239
void groove_playlist_set_item_peak(struct GroovePlaylist *playlist, struct GroovePlaylistItem *item, double peak)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  pthread_mutex_lock(&p->decode_head_mutex);
  item->peak = peak;
  if(item == p->decode_head)
    update_playlist_volume(playlist);

  pthread_mutex_unlock(&p->decode_head_mutex);
}

// groove_queue_abort
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 26
void groove_queue_abort(struct GrooveQueue *queue)
{
  struct GrooveQueuePrivate *q = (struct GrooveQueuePrivate *)queue;
  pthread_mutex_lock(&q->mutex);
  q->abort_request = 1;
  pthread_cond_signal(&q->cond);
  pthread_mutex_unlock(&q->mutex);
}

// groove_queue_cleanup_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.c line 219
void groove_queue_cleanup_default(struct GrooveQueue *queue, void *obj)
{
  av_free(obj);
}

// groove_queue_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 20
struct GrooveQueue * groove_queue_create(void)
{
  struct GrooveQueuePrivate *q;
  void *return_value_av_mallocz$1;
  return_value_av_mallocz$1=av_mallocz(sizeof(struct GrooveQueuePrivate) /*152ul*/ );
  q = (struct GrooveQueuePrivate *)return_value_av_mallocz$1;
  if(q == ((struct GrooveQueuePrivate *)NULL))
    return (struct GrooveQueue *)(void *)0;

  else
  {
    signed int return_value_pthread_mutex_init$2;
    return_value_pthread_mutex_init$2=pthread_mutex_init(&q->mutex, (const union anonymous$6 *)(void *)0);
    if(!(return_value_pthread_mutex_init$2 == 0))
    {
      av_free((void *)q);
      return (struct GrooveQueue *)(void *)0;
    }

    else
    {
      signed int return_value_pthread_cond_init$3;
      return_value_pthread_cond_init$3=pthread_cond_init(&q->cond, (const union anonymous$6 *)(void *)0);
      if(!(return_value_pthread_cond_init$3 == 0))
      {
        av_free((void *)q);
        pthread_mutex_destroy(&q->mutex);
        return (struct GrooveQueue *)(void *)0;
      }

      else
      {
        struct GrooveQueue *queue = &q->externals;
        queue->cleanup = groove_queue_cleanup_default;
        return queue;
      }
    }
  }
}

// groove_queue_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 24
void groove_queue_destroy(struct GrooveQueue *queue)
{
  groove_queue_flush(queue);
  struct GrooveQueuePrivate *q = (struct GrooveQueuePrivate *)queue;
  pthread_mutex_destroy(&q->mutex);
  pthread_cond_destroy(&q->cond);
  av_free((void *)q);
}

// groove_queue_flush
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 22
void groove_queue_flush(struct GrooveQueue *queue)
{
  struct GrooveQueuePrivate *q = (struct GrooveQueuePrivate *)queue;
  pthread_mutex_lock(&q->mutex);
  struct ItemList *el;
  struct ItemList *el1;
  el = q->first;
  for( ; !(el == ((struct ItemList *)NULL)); el = el1)
  {
    el1 = el->next;
    if(!(queue->cleanup == ((void (*)(struct GrooveQueue *, void *))NULL)))
      queue->cleanup(queue, el->obj);

    av_free((void *)el);
  }
  q->first = (struct ItemList *)(void *)0;
  q->last = (struct ItemList *)(void *)0;
  pthread_mutex_unlock(&q->mutex);
}

// groove_queue_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 32
signed int groove_queue_get(struct GrooveQueue *queue, void **obj_ptr, signed int block)
{
  struct ItemList *ev1;
  signed int ret;
  struct GrooveQueuePrivate *q = (struct GrooveQueuePrivate *)queue;
  pthread_mutex_lock(&q->mutex);
  while((_Bool)1)
  {
    if(!(q->abort_request == 0))
    {
      ret = -1;
      goto __CPROVER_DUMP_L8;
    }

    ev1 = q->first;
    if(!(ev1 == ((struct ItemList *)NULL)))
    {
      q->first = ev1->next;
      if(q->first == ((struct ItemList *)NULL))
        q->last = (struct ItemList *)(void *)0;

      if(!(queue->get == ((void (*)(struct GrooveQueue *, void *))NULL)))
        queue->get(queue, ev1->obj);

      *obj_ptr = ev1->obj;
      av_free((void *)ev1);
      ret = 1;
      break;
    }

    else
      if(block == 0)
      {
        ret = 0;
        break;
      }

      else
        pthread_cond_wait(&q->cond, &q->mutex);
  }

__CPROVER_DUMP_L8:
  ;
  pthread_mutex_unlock(&q->mutex);
  return ret;
}

// groove_queue_peek
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 34
signed int groove_queue_peek(struct GrooveQueue *queue, signed int block)
{
  signed int ret;
  struct GrooveQueuePrivate *q = (struct GrooveQueuePrivate *)queue;
  pthread_mutex_lock(&q->mutex);
  while((_Bool)1)
  {
    if(!(q->abort_request == 0))
    {
      ret = -1;
      goto __CPROVER_DUMP_L6;
    }

    if(!(q->first == ((struct ItemList *)NULL)))
    {
      ret = 1;
      break;
    }

    else
      if(block == 0)
      {
        ret = 0;
        break;
      }

      else
        pthread_cond_wait(&q->cond, &q->mutex);
  }

__CPROVER_DUMP_L6:
  ;
  pthread_mutex_unlock(&q->mutex);
  return ret;
}

// groove_queue_purge
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 36
void groove_queue_purge(struct GrooveQueue *queue)
{
  struct GrooveQueuePrivate *q = (struct GrooveQueuePrivate *)queue;
  pthread_mutex_lock(&q->mutex);
  struct ItemList *node = q->first;
  struct ItemList *prev = (struct ItemList *)(void *)0;
  if(!(node == ((struct ItemList *)NULL)))
  {
    signed int return_value;
    return_value=queue->purge(queue, node->obj);
    if(!(return_value == 0))
    {
      if(!(prev == ((struct ItemList *)NULL)))
      {
        prev->next = node->next;
        if(!(queue->cleanup == ((void (*)(struct GrooveQueue *, void *))NULL)))
          queue->cleanup(queue, node->obj);

        av_free((void *)node);
        node = prev->next;
        if(node == ((struct ItemList *)NULL))
          q->last = prev;

      }

      else
      {
        struct ItemList *next = node->next;
        if(!(queue->cleanup == ((void (*)(struct GrooveQueue *, void *))NULL)))
          queue->cleanup(queue, node->obj);

        av_free((void *)node);
        q->first = next;
        node = next;
        if(node == ((struct ItemList *)NULL))
          q->last = (struct ItemList *)(void *)0;

      }
    }

    else
    {
      prev = node;
      node = node->next;
    }
  }

  pthread_mutex_unlock(&q->mutex);
}

// groove_queue_put
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 29
signed int groove_queue_put(struct GrooveQueue *queue, void *obj)
{
  struct ItemList *el1;
  void *return_value_av_mallocz$1;
  return_value_av_mallocz$1=av_mallocz(sizeof(struct ItemList) /*16ul*/ );
  el1 = (struct ItemList *)return_value_av_mallocz$1;
  if(el1 == ((struct ItemList *)NULL))
    return -1;

  else
  {
    el1->obj = obj;
    struct GrooveQueuePrivate *q = (struct GrooveQueuePrivate *)queue;
    pthread_mutex_lock(&q->mutex);
    if(q->last == ((struct ItemList *)NULL))
      q->first = el1;

    else
      q->last->next = el1;
    q->last = el1;
    if(!(queue->put == ((void (*)(struct GrooveQueue *, void *))NULL)))
      queue->put(queue, obj);

    pthread_cond_signal(&q->cond);
    pthread_mutex_unlock(&q->mutex);
    return 0;
  }
}

// groove_queue_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/queue.h line 27
void groove_queue_reset(struct GrooveQueue *queue)
{
  struct GrooveQueuePrivate *q = (struct GrooveQueuePrivate *)queue;
  pthread_mutex_lock(&q->mutex);
  q->abort_request = 0;
  pthread_mutex_unlock(&q->mutex);
}

// groove_sample_format_bytes_per_sample
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 79
signed int groove_sample_format_bytes_per_sample(enum GrooveSampleFormat format)
{
  signed int return_value_av_get_bytes_per_sample$1;
  return_value_av_get_bytes_per_sample$1=av_get_bytes_per_sample((enum AVSampleFormat)format);
  return return_value_av_get_bytes_per_sample$1;
}

// groove_set_logging
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 35
void groove_set_logging(signed int level)
{
  av_log_set_level(level);
}

// groove_sink_attach
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 414
signed int groove_sink_attach(struct GrooveSink *sink, struct GroovePlaylist *playlist)
{
  struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
  signed int channel_count;
  channel_count=av_get_channel_layout_nb_channels(sink->audio_format.channel_layout);
  signed int bytes_per_frame;
  signed int return_value_av_get_bytes_per_sample$1;
  return_value_av_get_bytes_per_sample$1=av_get_bytes_per_sample((enum AVSampleFormat)sink->audio_format.sample_fmt);
  bytes_per_frame = channel_count * return_value_av_get_bytes_per_sample$1;
  sink->bytes_per_sec = bytes_per_frame * sink->audio_format.sample_rate;
  s->min_audioq_size = sink->buffer_size * bytes_per_frame;
  av_log((void *)0, 32, "audio queue size: %d\n", s->min_audioq_size);
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  sink->playlist = playlist;
  pthread_mutex_lock(&p->decode_head_mutex);
  signed int err;
  err=add_sink_to_map(playlist, sink);
  pthread_mutex_lock(&p->drain_cond_mutex);
  pthread_cond_signal(&p->sink_drain_cond);
  pthread_mutex_unlock(&p->drain_cond_mutex);
  pthread_mutex_unlock(&p->decode_head_mutex);
  if(!(err >= 0))
  {
    sink->playlist = (struct GroovePlaylist *)(void *)0;
    av_log((void *)0, 16, "unable to attach device: out of memory\n");
    return err;
  }

  else
  {
    groove_queue_reset(s->audioq);
    return 0;
  }
}

// groove_sink_buffer_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 423
signed int groove_sink_buffer_get(struct GrooveSink *sink, struct GrooveBuffer **buffer, signed int block)
{
  struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
  signed int return_value_groove_queue_get$1;
  return_value_groove_queue_get$1=groove_queue_get(s->audioq, (void **)buffer, block);
  if(return_value_groove_queue_get$1 == 1)
  {
    if(*buffer == end_of_q_sentinel$link1)
    {
      *buffer = (struct GrooveBuffer *)(void *)0;
      return 2;
    }

    else
      return 1;
  }

  else
  {
    *buffer = (struct GrooveBuffer *)(void *)0;
    return 0;
  }
}

// groove_sink_buffer_peek
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 924
signed int groove_sink_buffer_peek(struct GrooveSink *sink, signed int block)
{
  struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
  signed int return_value_groove_queue_peek$1;
  return_value_groove_queue_peek$1=groove_queue_peek(s->audioq, block);
  return return_value_groove_queue_peek$1;
}

// groove_sink_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 408
struct GrooveSink * groove_sink_create(void)
{
  struct GrooveSinkPrivate *s;
  void *return_value_av_mallocz$1;
  return_value_av_mallocz$1=av_mallocz(sizeof(struct GrooveSinkPrivate) /*120ul*/ );
  s = (struct GrooveSinkPrivate *)return_value_av_mallocz$1;
  if(s == ((struct GrooveSinkPrivate *)NULL))
  {
    av_log((void *)0, 16, "could not create sink: out of memory\n");
    return (struct GrooveSink *)(void *)0;
  }

  else
  {
    struct GrooveSink *sink = &s->externals;
    sink->buffer_size = 8192;
    sink->gain = 1.0;
    s->audioq=groove_queue_create();
    if(s->audioq == ((struct GrooveQueue *)NULL))
    {
      groove_sink_destroy(sink);
      av_log((void *)0, 16, "could not create audio buffer: out of memory\n");
      return (struct GrooveSink *)(void *)0;
    }

    else
    {
      s->audioq->context = (void *)sink;
      s->audioq->cleanup = audioq_cleanup$link1;
      s->audioq->put = audioq_put$link1;
      s->audioq->get = audioq_get$link1;
      s->audioq->purge = audioq_purge$link1;
      return sink;
    }
  }
}

// groove_sink_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 409
void groove_sink_destroy(struct GrooveSink *sink)
{
  if(!(sink == ((struct GrooveSink *)NULL)))
  {
    struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
    if(!(s->audioq == ((struct GrooveQueue *)NULL)))
      groove_queue_destroy(s->audioq);

    av_free((void *)s);
  }

}

// groove_sink_detach
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 416
signed int groove_sink_detach(struct GrooveSink *sink)
{
  struct GroovePlaylist *playlist = sink->playlist;
  if(playlist == ((struct GroovePlaylist *)NULL))
    return -1;

  else
  {
    struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
    if(!(s->audioq == ((struct GrooveQueue *)NULL)))
    {
      groove_queue_abort(s->audioq);
      groove_queue_flush(s->audioq);
    }

    struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
    pthread_mutex_lock(&p->decode_head_mutex);
    signed int err;
    err=remove_sink_from_map(sink);
    pthread_mutex_unlock(&p->decode_head_mutex);
    sink->playlist = (struct GroovePlaylist *)(void *)0;
    return err;
  }
}

// groove_sink_pause
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 840
static signed int groove_sink_pause(struct GrooveSink *sink)
{
  if(!(sink->pause == ((void (*)(struct GrooveSink *))NULL)))
    sink->pause(sink);

  return 0;
}

// groove_sink_play
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 833
static signed int groove_sink_play(struct GrooveSink *sink)
{
  if(!(sink->play == ((void (*)(struct GrooveSink *))NULL)))
    sink->play(sink);

  return 0;
}

// groove_sink_set_gain
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 435
signed int groove_sink_set_gain(struct GrooveSink *sink, double gain)
{
  struct GroovePlaylist *playlist = sink->playlist;
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  pthread_mutex_lock(&p->decode_head_mutex);
  sink->gain = gain;
  signed int err;
  err=remove_sink_from_map(sink);
  if(!(err == 0))
  {
    pthread_mutex_unlock(&p->decode_head_mutex);
    return err;
  }

  else
  {
    err=add_sink_to_map(playlist, sink);
    if(!(err == 0))
    {
      pthread_mutex_unlock(&p->decode_head_mutex);
      return err;
    }

    else
    {
      p->rebuild_filter_graph_flag = 1;
      pthread_mutex_unlock(&p->decode_head_mutex);
      return 0;
    }
  }
}

// groove_tag_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 150
const char * groove_tag_key(struct GrooveTag *tag)
{
  struct AVDictionaryEntry *e = (struct AVDictionaryEntry *)tag;
  return e->key;
}

// groove_tag_value
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/groove.h line 151
const char * groove_tag_value(struct GrooveTag *tag)
{
  struct AVDictionaryEntry *e = (struct AVDictionaryEntry *)tag;
  return e->value;
}

// groove_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 89
const char * groove_version(void)
{
  return "4.3.0";
}

// groove_version_major
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 93
signed int groove_version_major(void)
{
  return 4;
}

// groove_version_minor
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 97
signed int groove_version_minor(void)
{
  return 3;
}

// groove_version_patch
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 101
signed int groove_version_patch(void)
{
  return 0;
}

// init_avcontext
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 118
static signed int init_avcontext(struct GrooveEncoder *encoder)
{
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  e->fmt_ctx=avformat_alloc_context();
  if(e->fmt_ctx == ((struct AVFormatContext *)NULL))
  {
    av_log((void *)0, 16, "unable to allocate format context\n");
    return -1;
  }

  else
  {
    e->fmt_ctx->pb = e->avio;
    e->fmt_ctx->oformat = e->oformat;
    e->stream=avformat_new_stream(e->fmt_ctx, e->codec);
    if(e->stream == ((struct AVStream *)NULL))
    {
      av_log((void *)0, 16, "unable to create output stream\n");
      return -1;
    }

    else
    {
      struct AVCodecContext *codec_ctx = e->stream->codec;
      codec_ctx->bit_rate = encoder->bit_rate;
      codec_ctx->sample_fmt = (enum AVSampleFormat)encoder->actual_audio_format.sample_fmt;
      codec_ctx->sample_rate = encoder->actual_audio_format.sample_rate;
      codec_ctx->channel_layout = encoder->actual_audio_format.channel_layout;
      codec_ctx->channels=av_get_channel_layout_nb_channels(encoder->actual_audio_format.channel_layout);
      codec_ctx->strict_std_compliance = -2;
      signed int err;
      err=avcodec_open2(codec_ctx, e->codec, (struct AVDictionary **)(void *)0);
      if(!(err >= 0))
      {
        av_strerror(err, e->strbuf, sizeof(char [512l]) /*512ul*/ );
        av_log((void *)0, 16, "unable to open codec: %s\n", (const void *)e->strbuf);
        return -1;
      }

      else
      {
        e->stream->codec = codec_ctx;
        return 0;
      }
    }
  }
}

// init_filter_graph
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 326
static signed int init_filter_graph(struct GroovePlaylist *playlist, struct GrooveFile *file)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  avfilter_graph_free(&p->filter_graph);
  p->filter_graph=avfilter_graph_alloc();
  double tmp_if_expr$2;
  if(p->filter_graph == ((struct AVFilterGraph *)NULL))
  {
    av_log((void *)0, 16, "unable to create filter graph: out of memory\n");
    return -1;
  }

  else
  {
    signed int err;
    struct AVCodecContext *avctx = f->audio_st->codec;
    struct AVRational time_base = f->audio_st->time_base;
    const char *return_value_av_get_sample_fmt_name$1;
    return_value_av_get_sample_fmt_name$1=av_get_sample_fmt_name(avctx->sample_fmt);
    snprintf(p->strbuf, sizeof(char [512l]) /*512ul*/ , "time_base=%d/%d:sample_rate=%d:sample_fmt=%s:channel_layout=0x%lx", time_base.num, time_base.den, avctx->sample_rate, return_value_av_get_sample_fmt_name$1, avctx->channel_layout);
    av_log((void *)0, 32, "abuffer: %s\n", (const void *)p->strbuf);
    p->in_sample_rate = avctx->sample_rate;
    p->in_channel_layout = avctx->channel_layout;
    p->in_sample_fmt = avctx->sample_fmt;
    p->in_time_base = time_base;
    err=avfilter_graph_create_filter(&p->abuffer_ctx, p->abuffer_filter, (const char *)(void *)0, p->strbuf, (void *)0, p->filter_graph);
    if(!(err >= 0))
    {
      av_log((void *)0, 16, "error initializing abuffer filter\n");
      return err;
    }

    else
    {
      struct AVFilterContext *audio_src_ctx = p->abuffer_ctx;
      p->filter_volume = p->volume;
      p->filter_peak = p->peak;
      double vol = p->volume;
      double amp_vol;
      if(p->peak > 1.0)
        tmp_if_expr$2 = 1.0;

      else
        tmp_if_expr$2 = p->peak;
      amp_vol = vol * tmp_if_expr$2;
      err=create_volume_filter(p, &audio_src_ctx, vol, amp_vol);
      if(!(err >= 0))
        return err;

      else
      {
        if(p->sink_map_count >= 2)
        {
          struct AVFilterContext *asplit_ctx;
          snprintf(p->strbuf, sizeof(char [512l]) /*512ul*/ , "%d", p->sink_map_count);
          av_log((void *)0, 32, "asplit: %s\n", (const void *)p->strbuf);
          err=avfilter_graph_create_filter(&asplit_ctx, p->asplit_filter, (const char *)(void *)0, p->strbuf, (void *)0, p->filter_graph);
          if(!(err >= 0))
          {
            av_log((void *)0, 16, "unable to create asplit filter\n");
            return err;
          }

          err=avfilter_link(audio_src_ctx, (unsigned int)0, asplit_ctx, (unsigned int)0);
          if(!(err >= 0))
          {
            av_log((void *)0, 16, "unable to link to asplit\n");
            return err;
          }

          audio_src_ctx = asplit_ctx;
        }

        struct SinkMap *map_item = p->sink_map;
        signed int pad_index = 0;
        while(!(map_item == ((struct SinkMap *)NULL)))
        {
          struct GrooveSink *example_sink = map_item->stack_head->sink;
          struct GrooveAudioFormat *audio_format = &example_sink->audio_format;
          struct AVFilterContext *inner_audio_src_ctx = audio_src_ctx;
          err=create_volume_filter(p, &inner_audio_src_ctx, example_sink->gain, example_sink->gain);
          if(!(err >= 0))
            return err;

          if(example_sink->disable_resample == 0)
          {
            struct AVFilterContext *aformat_ctx;
            const char *return_value_av_get_sample_fmt_name$3;
            return_value_av_get_sample_fmt_name$3=av_get_sample_fmt_name((enum AVSampleFormat)audio_format->sample_fmt);
            snprintf(p->strbuf, sizeof(char [512l]) /*512ul*/ , "sample_fmts=%s:sample_rates=%d:channel_layouts=0x%lx", return_value_av_get_sample_fmt_name$3, audio_format->sample_rate, audio_format->channel_layout);
            av_log((void *)0, 32, "aformat: %s\n", (const void *)p->strbuf);
            err=avfilter_graph_create_filter(&aformat_ctx, p->aformat_filter, (const char *)(void *)0, p->strbuf, (void *)0, p->filter_graph);
            if(!(err >= 0))
            {
              av_strerror(err, p->strbuf, sizeof(char [512l]) /*512ul*/ );
              av_log((void *)0, 16, "unable to create aformat filter: %s\n", (const void *)p->strbuf);
              return err;
            }

            err=avfilter_link(inner_audio_src_ctx, (unsigned int)pad_index, aformat_ctx, (unsigned int)0);
            if(!(err >= 0))
            {
              av_strerror(err, p->strbuf, sizeof(char [512l]) /*512ul*/ );
              av_log((void *)0, 16, "unable to link aformat filter: %s\n", (const void *)p->strbuf);
              return err;
            }

            inner_audio_src_ctx = aformat_ctx;
          }

          err=avfilter_graph_create_filter(&map_item->abuffersink_ctx, p->abuffersink_filter, (const char *)(void *)0, (const char *)(void *)0, (void *)0, p->filter_graph);
          if(!(err >= 0))
          {
            av_log((void *)0, 16, "unable to create abuffersink filter\n");
            return err;
          }

          err=avfilter_link(inner_audio_src_ctx, (unsigned int)0, map_item->abuffersink_ctx, (unsigned int)0);
          if(!(err >= 0))
          {
            av_strerror(err, p->strbuf, sizeof(char [512l]) /*512ul*/ );
            av_log((void *)0, 16, "unable to link abuffersink filter: %s\n", (const void *)p->strbuf);
            return err;
          }

          pad_index = pad_index + 1;
          map_item = map_item->next;
        }
        err=avfilter_graph_config(p->filter_graph, (void *)0);
        if(!(err >= 0))
        {
          av_strerror(err, p->strbuf, sizeof(char [512l]) /*512ul*/ );
          av_log((void *)0, 16, "error configuring the filter graph: %s\n", (const void *)p->strbuf);
          return err;
        }

        else
        {
          p->rebuild_filter_graph_flag = 0;
          return 0;
        }
      }
    }
  }
}

// log_audio_fmt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 550
static void log_audio_fmt(struct GrooveAudioFormat *fmt)
{
  char buf[128l];
  av_get_channel_layout_string(buf, (signed int)sizeof(char [128l]) /*128ul*/ , 0, fmt->channel_layout);
  const char *return_value_av_get_sample_fmt_name$1;
  return_value_av_get_sample_fmt_name$1=av_get_sample_fmt_name((enum AVSampleFormat)fmt->sample_fmt);
  av_log((void *)0, 32, "encoder: using audio format: %s, %d Hz, %s\n", return_value_av_get_sample_fmt_name$1, fmt->sample_rate, (const void *)buf);
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/example/transcode.c line 14
signed int main(signed int argc, char **argv)
{
  signed int bit_rate_k = 320;
  char *format = (char *)(void *)0;
  char *codec = (char *)(void *)0;
  char *mime = (char *)(void *)0;
  char *output_file_name = (char *)(void *)0;
  groove_init();
  atexit(groove_finish);
  groove_set_logging(32);
  struct GroovePlaylist *playlist;
  playlist=groove_playlist_create();
  signed int i = 1;
  _Bool tmp_if_expr$8;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  for( ; !(i >= argc); i = i + 1)
  {
    char *arg = argv[(signed long int)i];
    if((signed int)*arg == 45)
      tmp_if_expr$8 = (signed int)arg[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
    {
      arg = arg + (signed long int)2;
      if(1 + i >= argc)
      {
        signed int return_value_usage$1;
        return_value_usage$1=usage(argv[(signed long int)0]);
        return return_value_usage$1;
      }

      else
      {
        return_value_strcmp$7=strcmp(arg, "bitrate");
        if(return_value_strcmp$7 == 0)
        {
          i = i + 1;
          bit_rate_k=atoi(argv[(signed long int)i]);
        }

        else
        {
          return_value_strcmp$6=strcmp(arg, "format");
          if(return_value_strcmp$6 == 0)
          {
            i = i + 1;
            format = argv[(signed long int)i];
          }

          else
          {
            return_value_strcmp$5=strcmp(arg, "codec");
            if(return_value_strcmp$5 == 0)
            {
              i = i + 1;
              codec = argv[(signed long int)i];
            }

            else
            {
              return_value_strcmp$4=strcmp(arg, "mime");
              if(return_value_strcmp$4 == 0)
              {
                i = i + 1;
                mime = argv[(signed long int)i];
              }

              else
              {
                return_value_strcmp$3=strcmp(arg, "output");
                if(return_value_strcmp$3 == 0)
                {
                  i = i + 1;
                  output_file_name = argv[(signed long int)i];
                }

                else
                {
                  signed int return_value_usage$2;
                  return_value_usage$2=usage(argv[(signed long int)0]);
                  return return_value_usage$2;
                }
              }
            }
          }
        }
      }
    }

    else
    {
      struct GrooveFile *main$$1$$1$$1$$2$$file;
      main$$1$$1$$1$$2$$file=groove_file_open(arg);
      if(main$$1$$1$$1$$2$$file == ((struct GrooveFile *)NULL))
      {
        fprintf(stderr, "Error opening input file %s\n", arg);
        return 1;
      }

      groove_playlist_insert(playlist, main$$1$$1$$1$$2$$file, 1.0, 1.0, (struct GroovePlaylistItem *)(void *)0);
    }
  }
  signed int return_value_usage$9;
  signed int return_value_groove_encoder_buffer_get$14;
  if(output_file_name == ((char *)NULL))
  {
    return_value_usage$9=usage(argv[(signed long int)0]);
    return return_value_usage$9;
  }

  else
  {
    struct GrooveEncoder *encoder;
    encoder=groove_encoder_create();
    encoder->bit_rate = bit_rate_k * 1000;
    encoder->format_short_name = format;
    encoder->codec_short_name = codec;
    encoder->filename = output_file_name;
    encoder->mime_type = mime;
    signed int return_value_groove_playlist_count$12;
    return_value_groove_playlist_count$12=groove_playlist_count(playlist);
    if(return_value_groove_playlist_count$12 == 1)
    {
      groove_file_audio_format(playlist->head->file, &encoder->target_audio_format);
      struct GrooveTag *tag = (struct GrooveTag *)(void *)0;
      do
      {
        tag=groove_file_metadata_get(playlist->head->file, "", tag, 0);
        if(tag == ((struct GrooveTag *)NULL))
          break;

        const char *return_value_groove_tag_key$10;
        return_value_groove_tag_key$10=groove_tag_key(tag);
        const char *return_value_groove_tag_value$11;
        return_value_groove_tag_value$11=groove_tag_value(tag);
        groove_encoder_metadata_set(encoder, return_value_groove_tag_key$10, return_value_groove_tag_value$11, 0);
      }
      while((_Bool)1);
    }

    signed int return_value_groove_encoder_attach$13;
    return_value_groove_encoder_attach$13=groove_encoder_attach(encoder, playlist);
    if(!(return_value_groove_encoder_attach$13 >= 0))
    {
      fprintf(stderr, "error attaching encoder\n");
      return 1;
    }

    else
    {
      struct _IO_FILE *f;
      f=fopen(output_file_name, "wb");
      if(f == ((struct _IO_FILE *)NULL))
      {
        fprintf(stderr, "Error opening output file %s\n", output_file_name);
        return 1;
      }

      else
      {
        struct GrooveBuffer *buffer;
        do
        {
          return_value_groove_encoder_buffer_get$14=groove_encoder_buffer_get(encoder, &buffer, 1);
          if(!(return_value_groove_encoder_buffer_get$14 == 1))
            break;

          fwrite((const void *)buffer->data[(signed long int)0], (unsigned long int)1, (unsigned long int)buffer->size, f);
          groove_buffer_unref(buffer);
        }
        while((_Bool)1);
        fclose(f);
        groove_encoder_detach(encoder);
        groove_encoder_destroy(encoder);
        struct GroovePlaylistItem *item = playlist->head;
        while(!(item == ((struct GroovePlaylistItem *)NULL)))
        {
          struct GrooveFile *file = item->file;
          struct GroovePlaylistItem *next = item->next;
          groove_playlist_remove(playlist, item);
          groove_file_close(file);
          item = next;
        }
        groove_playlist_destroy(playlist);
        return 0;
      }
    }
  }
}

// maybe_init_filter_graph
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 471
static signed int maybe_init_filter_graph(struct GroovePlaylist *playlist, struct GrooveFile *file)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  struct GrooveFilePrivate *f = (struct GrooveFilePrivate *)file;
  struct AVCodecContext *avctx = f->audio_st->codec;
  struct AVRational time_base = f->audio_st->time_base;
  _Bool tmp_if_expr$2;
  if(p->filter_graph == ((struct AVFilterGraph *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = p->rebuild_filter_graph_flag != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = p->in_sample_rate != avctx->sample_rate ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = p->in_channel_layout != avctx->channel_layout ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = p->in_sample_fmt != avctx->sample_fmt ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$6;
  if(tmp_if_expr$5)
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = p->in_time_base.num != time_base.num ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$7;
  if(tmp_if_expr$6)
    tmp_if_expr$7 = (_Bool)1;

  else
    tmp_if_expr$7 = p->in_time_base.den != time_base.den ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$7)
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = IEEE_FLOAT_NOTEQUAL(p->volume, p->filter_volume) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$9;
  if(tmp_if_expr$8)
    tmp_if_expr$9 = (_Bool)1;

  else
    tmp_if_expr$9 = IEEE_FLOAT_NOTEQUAL(p->peak, p->filter_peak) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$9)
  {
    signed int return_value_init_filter_graph$1;
    return_value_init_filter_graph$1=init_filter_graph(playlist, file);
    return return_value_init_filter_graph$1;
  }

  return 0;
}

// my_lockmgr_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/global.c line 18
static signed int my_lockmgr_cb(void **mutex, enum AVLockOp op)
{
  void *return_value_av_mallocz$1;
  signed int return_value_pthread_mutex_init$2;
  signed int return_value_pthread_mutex_lock$3;
  signed int return_value_pthread_mutex_unlock$4;
  signed int err;
  if(mutex == ((void **)NULL))
    return -1;

  else
  {
    union anonymous$0 *pmutex;
    switch((signed int)op)
    {
      case AV_LOCK_CREATE:
      {
        return_value_av_mallocz$1=av_mallocz(sizeof(union anonymous$0) /*40ul*/ );
        pmutex = (union anonymous$0 *)return_value_av_mallocz$1;
        *mutex = (void *)pmutex;
        return_value_pthread_mutex_init$2=pthread_mutex_init(pmutex, (const union anonymous$6 *)(void *)0);
        return return_value_pthread_mutex_init$2;
      }
      case AV_LOCK_OBTAIN:
      {
        pmutex = (union anonymous$0 *)*mutex;
        return_value_pthread_mutex_lock$3=pthread_mutex_lock(pmutex);
        return return_value_pthread_mutex_lock$3;
      }
      case AV_LOCK_RELEASE:
      {
        pmutex = (union anonymous$0 *)*mutex;
        return_value_pthread_mutex_unlock$4=pthread_mutex_unlock(pmutex);
        return return_value_pthread_mutex_unlock$4;
      }
      case AV_LOCK_DESTROY:
      {
        pmutex = (union anonymous$0 *)*mutex;
        err=pthread_mutex_destroy(pmutex);
        av_free((void *)pmutex);
        *mutex = (void *)0;
        return err;
      }
      default:
        return 0;
    }
  }
}

// purge_sink
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 1155
static signed int purge_sink(struct GrooveSink *sink)
{
  struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
  groove_queue_purge(s->audioq);
  struct GroovePlaylist *playlist = sink->playlist;
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  struct GroovePlaylistItem *item = p->purge_item;
  if(!(sink->purge == ((void (*)(struct GrooveSink *, struct GroovePlaylistItem *))NULL)))
    sink->purge(sink, item);

  return 0;
}

// remove_sink_from_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 743
static signed int remove_sink_from_map(struct GrooveSink *sink)
{
  struct GroovePlaylist *playlist = sink->playlist;
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  struct SinkMap *map_item = p->sink_map;
  struct SinkMap *prev_map_item = (struct SinkMap *)(void *)0;
  while(!(map_item == ((struct SinkMap *)NULL)))
  {
    struct SinkMap *next_map_item = map_item->next;
    struct SinkStack *stack_item = map_item->stack_head;
    struct SinkStack *prev_stack_item = (struct SinkStack *)(void *)0;
    while(!(stack_item == ((struct SinkStack *)NULL)))
    {
      struct SinkStack *next_stack_item = stack_item->next;
      struct GrooveSink *item_sink = stack_item->sink;
      if(item_sink == sink)
      {
        av_free((void *)stack_item);
        if(!(prev_stack_item == ((struct SinkStack *)NULL)))
          prev_stack_item->next = next_stack_item;

        else
          if(!(next_stack_item == ((struct SinkStack *)NULL)))
            map_item->stack_head = next_stack_item;

          else
          {
            av_free((void *)map_item);
            p->sink_map_count = p->sink_map_count - 1;
            if(!(prev_map_item == ((struct SinkMap *)NULL)))
              prev_map_item->next = next_map_item;

            else
              p->sink_map = next_map_item;
          }
        return 0;
      }

      prev_stack_item = stack_item;
      stack_item = next_stack_item;
    }
    prev_map_item = map_item;
    map_item = next_map_item;
  }
  return -1;
}

// sink_flush
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 246
static void sink_flush(struct GrooveSink *sink)
{
  struct GrooveEncoder *encoder = (struct GrooveEncoder *)sink->userdata;
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  pthread_mutex_lock(&e->encode_head_mutex);
  groove_queue_flush(e->audioq);
  cleanup_avcontext(e);
  init_avcontext(encoder);
  groove_queue_put(e->audioq, (void *)end_of_q_sentinel);
  pthread_cond_signal(&e->drain_cond);
  pthread_mutex_unlock(&e->encode_head_mutex);
}

// sink_flush$link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 533
static signed int sink_flush$link1(struct GrooveSink *sink$link1)
{
  struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink$link1;
  groove_queue_flush(s->audioq);
  if(!(sink$link1->flush == ((void (*)(struct GrooveSink *))NULL)))
    sink$link1->flush(sink$link1);

  return 0;
}

// sink_formats_compatible
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 722
static signed int sink_formats_compatible(struct GrooveSink *example_sink, struct GrooveSink *test_sink)
{
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(!(test_sink->buffer_sample_count == 0))
  {
    if(example_sink->buffer_sample_count == test_sink->buffer_sample_count)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(IEEE_FLOAT_NOTEQUAL(example_sink->gain, test_sink->gain))
      return 0;

    else
      if(test_sink->disable_resample == 0)
      {
        if(!(example_sink->audio_format.sample_rate == test_sink->audio_format.sample_rate))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = example_sink->audio_format.channel_layout != test_sink->audio_format.channel_layout ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = example_sink->audio_format.sample_fmt != test_sink->audio_format.sample_fmt ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$2)
          goto __CPROVER_DUMP_L7;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        return 1;
      }
  }
}

// sink_is_full
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 510
static signed int sink_is_full(struct GrooveSink *sink)
{
  struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
  return (signed int)(s->audioq_size >= s->min_audioq_size);
}

// sink_purge
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/encoder.c line 229
static void sink_purge(struct GrooveSink *sink, struct GroovePlaylistItem *item)
{
  struct GrooveEncoder *encoder = (struct GrooveEncoder *)sink->userdata;
  struct GrooveEncoderPrivate *e = (struct GrooveEncoderPrivate *)encoder;
  pthread_mutex_lock(&e->encode_head_mutex);
  e->purge_item = item;
  groove_queue_purge(e->audioq);
  e->purge_item = (struct GroovePlaylistItem *)(void *)0;
  if(e->encode_head == item)
  {
    e->encode_head = (struct GroovePlaylistItem *)(void *)0;
    e->encode_pos = -1.0;
  }

  pthread_cond_signal(&e->drain_cond);
  pthread_mutex_unlock(&e->encode_head_mutex);
}

// sink_signal_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 523
static signed int sink_signal_end(struct GrooveSink *sink)
{
  struct GrooveSinkPrivate *s = (struct GrooveSinkPrivate *)sink;
  groove_queue_put(s->audioq, (void *)end_of_q_sentinel$link1);
  return 0;
}

// tempfileify
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/file.c line 182
static signed int tempfileify(char *str, unsigned long int max_len)
{
  unsigned long int len;
  len=strlen(str);
  if(!(max_len >= 10ul + len))
    return -1;

  else
  {
    char prepend[11l];
    signed int n;
    signed int return_value_rand$1;
    return_value_rand$1=rand();
    n = return_value_rand$1 % 99999;
    snprintf(prepend, (unsigned long int)11, ".tmp%05d-", n);
    char *slash;
    slash=strrchr(str, 47);
    char *pos = slash != ((char *)NULL) ? slash + (signed long int)1 : str;
    unsigned long int orig_len = len - (unsigned long int)(pos - str);
    memmove((void *)(pos + (signed long int)10), (const void *)pos, orig_len);
    strncpy(pos, prepend, (unsigned long int)10);
    return 0;
  }
}

// update_playlist_volume
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/groove/playlist.c line 652
static void update_playlist_volume(struct GroovePlaylist *playlist)
{
  struct GroovePlaylistPrivate *p = (struct GroovePlaylistPrivate *)playlist;
  struct GroovePlaylistItem *item = p->decode_head;
  p->volume = playlist->gain * item->gain;
  p->peak = item->peak;
}

// usage
// file /srv/jenkins-slave/workspace/sid-goto-cc-libgroove/libgroove-4.3.0/example/transcode.c line 9
static signed int usage(char *arg0)
{
  fprintf(stderr, "Usage: %s file1 [file2 ...] --output outputfile [--bitrate 320] [--format name] [--codec name] [--mime mimetype]\n", arg0);
  return 1;
}
