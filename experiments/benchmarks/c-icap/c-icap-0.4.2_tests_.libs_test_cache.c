// tag-#anon#ST[*{S8}$S8$'TEMPLATE_NAME'|*{S8}$S8$'SERVICE_NAME'|*{S8}$S8$'LANGUAGE'|*{SYM#tag-ci_membuf#}$SYM#tag-ci_membuf#$'data'|S64'last_used'|S64'loaded'|S64'modified'|S32'locked'|S32'must_free'|S32'non_cached'|U32'$pad0']
// file txtTemplate.c line 42
struct anonymous$20;

// tag-#anon#ST[*{SYM#tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']#}$SYM#tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']#$'sem']
// file include/proc_mutex.h line 74
struct anonymous$17;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$5;

// tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}$U8$'__pad1'|U64'__pad2'|U32'__flags'|U32'$pad0']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous$9;

// tag-#anon#ST[S32'fd']
// file include/proc_mutex.h line 79
struct anonymous$18;

// tag-#anon#ST[S32'id']
// file include/proc_mutex.h line 69
struct anonymous$16;

// tag-#anon#UN[*{SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#}$SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#$'mutex'|*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}$U8$'__pad1'|U64'__pad2'|U32'__flags'|U32'$pad0']#'__data'|ARR56{S8}$S8$'__size'|S64'__align']#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}$U8$'__pad1'|U64'__pad2'|U32'__flags'|U32'$pad0']#'__data'|ARR56{S8}$S8$'__size'|S64'__align']#$'rwlock']
// file os/unix/threads.c line 30
union anonymous$11;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'|ARR8{U16}$U16$'__u6_addr16'|ARR4{U32}$U32$'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous$12;

// tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous$1;

// tag-#anon#UN[ARR4{S8}$S8$'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$4;

// tag-#anon#UN[ARR8{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 224
union anonymous$7;

// tag-#anon#UN[F64'__align'|ARR1{S8}$S8$'ptr']
// file mem.c line 100
union anonymous$14;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$6;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}$U8$'__pad1'|U64'__pad2'|U32'__flags'|U32'$pad0']#'__data'|ARR56{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous$10;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'id']#'sysv'|SYM#tag-#anon#ST[*{SYM#tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']#}$SYM#tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']#$'sem']#'posix'|SYM#tag-#anon#ST[S32'fd']#'file']
// file include/proc_mutex.h line 67
union anonymous$2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$8;

// tag-#anon#UN[SYM#tag-ci_proc_mutex#'proc_mutex'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'thread_mutex']
// file cache.c line 90
union anonymous$15;

// tag-#anon#UN[SYM#tag-posix#'posix'|SYM#tag-sysv#'sysv'|S32'id_']
// file include/shared_mem.h line 58
union anonymous$3;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$0;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$13;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_ci_align_test
// file include/c-icap.h line 131
struct _ci_align_test;

// tag-acl_cmp_uint64_data
// file acl.c line 175
struct acl_cmp_uint64_data;

// tag-acl_time_data
// file acl.c line 264
struct acl_time_data;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-check_reg_data
// file registry.c line 102
struct check_reg_data;

// tag-ci_MD5Context
// file include/md5.h line 6
struct ci_MD5Context;

// tag-ci_access_entry
// file include/acl.h line 143
struct ci_access_entry;

// tag-ci_acl_data
// file include/acl.h line 96
struct ci_acl_data;

// tag-ci_acl_regex
// file types_ops.c line 227
struct ci_acl_regex;

// tag-ci_acl_spec
// file include/acl.h line 111
struct ci_acl_spec;

// tag-ci_acl_type
// file include/acl.h line 47
struct ci_acl_type;

// tag-ci_acl_type_list
// file include/acl.h line 81
struct ci_acl_type_list;

// tag-ci_array
// file include/array.h line 54
struct ci_array;

// tag-ci_array_item
// file include/array.h line 37
struct ci_array_item;

// tag-ci_buf
// file include/request.h line 60
struct ci_buf;

// tag-ci_cache
// file ../include/cache.h line 35
struct ci_cache;

// tag-ci_cache_entry
// file cache.c line 78
struct ci_cache_entry;

// tag-ci_cache_type
// file ../include/cache.h line 42
struct ci_cache_type;

// tag-ci_cached_file
// file include/body.h line 78
struct ci_cached_file;

// tag-ci_conf_entry
// file ../include/cfg_param.h line 85
struct ci_conf_entry;

// tag-ci_connection
// file include/net_io.h line 107
struct ci_connection;

// tag-ci_data_group
// file include/filetype.h line 49
struct ci_data_group;

// tag-ci_data_type
// file include/filetype.h line 43
struct ci_data_type;

// tag-ci_dyn_array
// file include/array.h line 309
struct ci_dyn_array;

// tag-ci_encaps_entity
// file include/header.h line 82
struct ci_encaps_entity;

// tag-ci_error_code
// file include/c-icap.h line 153
struct ci_error_code;

// tag-ci_fmt_entry
// file include/txt_format.h line 41
struct ci_fmt_entry;

// tag-ci_hash_entry
// file include/hash.h line 32
struct ci_hash_entry;

// tag-ci_hash_table
// file include/hash.h line 40
struct ci_hash_table;

// tag-ci_headers_list
// file include/header.h line 71
struct ci_headers_list;

// tag-ci_ip
// file include/net_io.h line 101
struct ci_ip;

// tag-ci_list
// file include/array.h line 598
struct ci_list;

// tag-ci_list_item
// file include/array.h line 585
struct ci_list_item;

// tag-ci_local_cache_data
// file cache.c line 96
struct ci_local_cache_data;

// tag-ci_lookup_table
// file include/lookup_table.h line 43
struct ci_lookup_table;

// tag-ci_lookup_table_type
// file include/lookup_table.h line 44
struct ci_lookup_table_type;

// tag-ci_magic
// file include/filetype.h line 55
struct ci_magic;

// tag-ci_magic_record
// file filetype.c line 57
struct ci_magic_record;

// tag-ci_magics_db
// file include/cfg_param.h line 30
struct ci_magics_db;

// tag-ci_mem_allocator
// file ../include/mem.h line 32
struct ci_mem_allocator;

// tag-ci_membuf
// file include/body.h line 44
struct ci_membuf;

// tag-ci_options_entry
// file ../include/cfg_param.h line 109
struct ci_options_entry;

// tag-ci_proc_mutex
// file include/proc_mutex.h line 44
struct ci_proc_mutex;

// tag-ci_proc_mutex_scheme
// file include/proc_mutex.h line 46
struct ci_proc_mutex_scheme;

// tag-ci_regex_match
// file include/ci_regex.h line 32
struct ci_regex_match;

// tag-ci_regex_replace_part
// file include/ci_regex.h line 37
struct ci_regex_replace_part;

// tag-ci_request
// file include/service.h line 62
struct ci_request;

// tag-ci_ring_buf
// file include/body.h line 161
struct ci_ring_buf;

// tag-ci_server_conf
// file ../include/cfg_param.h line 46
struct ci_server_conf;

// tag-ci_service_module
// file include/service.h line 64
struct ci_service_module;

// tag-ci_service_xdata
// file include/service.h line 76
struct ci_service_xdata;

// tag-ci_shared_mem_id
// file include/shared_mem.h line 35
struct ci_shared_mem_id;

// tag-ci_shared_mem_scheme
// file include/shared_mem.h line 37
struct ci_shared_mem_scheme;

// tag-ci_simple_file
// file include/body.h line 114
struct ci_simple_file;

// tag-ci_sockaddr
// file include/net_io.h line 50
struct ci_sockaddr;

// tag-ci_specs_list
// file include/acl.h line 121
struct ci_specs_list;

// tag-ci_type_ops
// file ../include/types_ops.h line 31
struct ci_type_ops;

// tag-ci_vector
// file ../include/array.h line 448
struct ci_vector;

// tag-common_module
// file ../include/module.h line 58
struct common_module;

// tag-common_mutex
// file cache.c line 88
struct common_mutex;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-kbs
// file include/stats.h line 31
struct kbs;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 383
struct linger;

// tag-mem_block_item
// file mem.c line 760
struct mem_block_item;

// tag-mem_buffer_block
// file mem.c line 97
struct mem_buffer_block;

// tag-mutex_itm
// file os/unix/threads.c line 23
struct mutex_itm;

// tag-pack_allocator
// file mem.c line 573
struct pack_allocator;

// tag-pcre_extra
// file /usr/include/pcre.h line 376
struct pcre_extra;

// tag-pool_allocator
// file mem.c line 765
struct pool_allocator;

// tag-posix
// file include/shared_mem.h line 60
struct posix;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-real_pcre
// file /usr/include/pcre.h line 324
struct real_pcre;

// tag-sembuf
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 41
struct sembuf;

// tag-semid_ds
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 38
struct semid_ds;

// tag-seminfo
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 72
struct seminfo;

// tag-semun
// file os/unix/proc_mutex.c line 47
union semun;

// tag-serial_allocator
// file mem.c line 445
struct serial_allocator;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stat_area
// file include/stats.h line 45
struct stat_area;

// tag-stat_entry
// file include/stats.h line 52
struct stat_entry;

// tag-stat_entry_list
// file include/stats.h line 58
struct stat_entry_list;

// tag-stat_groups_list
// file include/stats.h line 64
struct stat_groups_list;

// tag-stat_memblock
// file include/stats.h line 37
struct stat_memblock;

// tag-sysv
// file include/shared_mem.h line 65
struct sysv;

// tag-text_table
// file lookup_file_table.c line 49
struct text_table;

// tag-text_table_entry
// file lookup_file_table.c line 43
struct text_table_entry;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// MD5Transform
// file md5.c line 168
static void MD5Transform(unsigned int *buf, unsigned int *in);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __intl_free$object
//
void __intl_free$object(void *);
// __intl_malloc$object
//
void * __intl_malloc$object(signed int);
// __log_error$object
//
void __log_error$object(void *, const char *, ...);
// _os_free
// file request_common.c line 35
static void _os_free(void *ptr);
// _os_malloc
// file request_common.c line 30
static void * _os_malloc(signed int size);
// acl_cmp_uint64_dup
// file acl.c line 182
void * acl_cmp_uint64_dup(const char *str, struct ci_mem_allocator *allocator);
// acl_cmp_uint64_equal
// file acl.c line 187
signed int acl_cmp_uint64_equal(const void *key1, const void *key2);
// acl_cmp_uint64_free
// file acl.c line 202
void acl_cmp_uint64_free(void *key, struct ci_mem_allocator *allocator);
// acl_load_defaults
// file acl.c line 776
static signed int acl_load_defaults();
// acl_time_dup
// file acl.c line 270
void * acl_time_dup(const char *str, struct ci_mem_allocator *allocator);
// acl_time_equal
// file acl.c line 373
signed int acl_time_equal(const void *key1, const void *key2);
// acl_time_free
// file acl.c line 389
void acl_time_free(void *tmd, struct ci_mem_allocator *allocator);
// add_mutex
// file os/unix/threads.c line 66
static struct mutex_itm * add_mutex(void *pmutex, signed int type);
// alloc_a_buffer
// file decode.c line 198
static void * alloc_a_buffer(void *op, unsigned int items, unsigned int size);
// alloc_mem_allocator_struct
// file mem.c line 79
static struct ci_mem_allocator * alloc_mem_allocator_struct();
// alloc_text_table_entry
// file lookup_file_table.c line 55
struct text_table_entry * alloc_text_table_entry(signed int val_num, struct ci_mem_allocator *allocator);
// asctime_r
// file /usr/include/time.h line 272
extern char * asctime_r(struct tm *, char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$13, unsigned int);
// byteReverse
// file md5.c line 28
static void byteReverse(unsigned char *buf, unsigned int longs);
// check_ascii
// file filetype.c line 419
signed int check_ascii(unsigned char *buf, signed int buflen);
// check_directive
// file txt_format.c line 200
signed int check_directive(const char *var, const char *directive, signed int *directive_len);
// check_magics
// file filetype.c line 368
signed int check_magics(struct ci_magics_db *db, const char *buf, signed int buflen);
// check_realloc
// file request_common.c line 874
static signed int check_realloc(char **buf, signed int *size, signed int used, signed int mustadded);
// check_reg
// file registry.c line 108
static signed int check_reg(void *data, const char *name, const void *val);
// check_tables
// file txt_format.c line 218
struct ci_fmt_entry * check_tables(const char *var, struct ci_fmt_entry *u_table, signed int *directive_len, unsigned int *width, signed int *left_align, char *parameter);
// check_unicode
// file filetype.c line 495
signed int check_unicode(unsigned char *buf, signed int buflen);
// ci_MD5Final
// file md5.c line 107
void ci_MD5Final(unsigned char *digest, struct ci_MD5Context *ctx);
// ci_MD5Init
// file md5.c line 44
void ci_MD5Init(struct ci_MD5Context *ctx);
// ci_MD5Update
// file md5.c line 59
void ci_MD5Update(struct ci_MD5Context *ctx, const unsigned char *buf, unsigned long int len);
// ci_access_entry_add_acl
// file acl.c line 468
const struct ci_acl_spec * ci_access_entry_add_acl(struct ci_access_entry *access_entry, const struct ci_acl_spec *acl, signed int negate);
// ci_access_entry_add_acl_by_name
// file acl.c line 492
signed int ci_access_entry_add_acl_by_name(struct ci_access_entry *access_entry, const char *acl_name);
// ci_access_entry_match_request
// file acl.c line 751
signed int ci_access_entry_match_request(struct ci_access_entry *access_entry, struct ci_request *req);
// ci_access_entry_new
// file acl.c line 419
struct ci_access_entry * ci_access_entry_new(struct ci_access_entry **list, signed int type);
// ci_access_entry_release
// file acl.c line 445
void ci_access_entry_release(struct ci_access_entry *list);
// ci_acl_add_data
// file acl.c line 824
signed int ci_acl_add_data(const char *name, const char *type, const char *data);
// ci_acl_init
// file acl.c line 796
void ci_acl_init();
// ci_acl_reset
// file acl.c line 803
void ci_acl_reset();
// ci_acl_search
// file acl.c line 811
const struct ci_acl_spec * ci_acl_search(const char *name);
// ci_acl_spec_list_release
// file acl.c line 615
void ci_acl_spec_list_release(struct ci_acl_spec *spec);
// ci_acl_spec_new
// file acl.c line 514
struct ci_acl_spec * ci_acl_spec_new(const char *name, const char *type, const char *param, struct ci_acl_type_list *list, struct ci_acl_spec **spec_list);
// ci_acl_spec_new_data
// file acl.c line 552
struct ci_acl_data * ci_acl_spec_new_data(struct ci_acl_spec *spec, const char *val);
// ci_acl_spec_release
// file acl.c line 601
void ci_acl_spec_release(struct ci_acl_spec *cur);
// ci_acl_spec_search
// file acl.c line 583
struct ci_acl_spec * ci_acl_spec_search(struct ci_acl_spec *list, const char *name);
// ci_acl_type_add
// file acl.c line 819
signed int ci_acl_type_add(const struct ci_acl_type *type);
// ci_acl_type_search
// file acl.c line 815
const struct ci_acl_type * ci_acl_type_search(const char *name);
// ci_acl_typelist_add
// file acl.c line 638
signed int ci_acl_typelist_add(struct ci_acl_type_list *list, const struct ci_acl_type *type);
// ci_acl_typelist_init
// file acl.c line 630
signed int ci_acl_typelist_init(struct ci_acl_type_list *list);
// ci_acl_typelist_release
// file acl.c line 681
signed int ci_acl_typelist_release(struct ci_acl_type_list *list);
// ci_acl_typelist_reset
// file acl.c line 689
signed int ci_acl_typelist_reset(struct ci_acl_type_list *list);
// ci_acl_typelist_search
// file acl.c line 671
const struct ci_acl_type * ci_acl_typelist_search(struct ci_acl_type_list *list, const char *name);
// ci_args_apply
// file ../include/cfg_param.h line 200
signed int ci_args_apply(signed int argc, char **argv, struct ci_options_entry *options);
// ci_args_usage
// file ../include/cfg_param.h line 199
void ci_args_usage(const char *progname, struct ci_options_entry *options);
// ci_array_add
// file include/array.h line 118
const struct ci_array_item * ci_array_add(struct ci_array *array, const char *name, const void *value, unsigned long int size);
// ci_array_destroy
// file include/array.h line 107
void ci_array_destroy(struct ci_array *array);
// ci_array_get_item
// file array.c line 144
const struct ci_array_item * ci_array_get_item(struct ci_array *array, signed int pos);
// ci_array_iterate
// file array.c line 116
void ci_array_iterate(const struct ci_array *array, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_array_iterate::fn$object
//
//signed int fn$object(void *, const char *, const void *);
// ci_array_new
// file include/array.h line 90
struct ci_array * ci_array_new(unsigned long int size);
// ci_array_new2
// file array.c line 60
struct ci_array * ci_array_new2(unsigned long int items, unsigned long int item_size);
// ci_array_pop
// file array.c line 125
const struct ci_array_item * ci_array_pop(struct ci_array *array);
// ci_array_search
// file include/array.h line 135
const void * ci_array_search(struct ci_array *array, const char *name);
// ci_atol_ext
// file util.c line 78
signed long int ci_atol_ext(const char *str, const char **error);
// ci_base64_decode
// file decode.c line 54
signed int ci_base64_decode(const char *encoded, char *decoded, signed int len);
// ci_base64_decode_dup
// file decode.c line 88
char * ci_base64_decode_dup(const char *encoded);
// ci_base64_encode
// file decode.c line 111
signed int ci_base64_encode(const unsigned char *data, unsigned long int len, char *out, unsigned long int outlen);
// ci_belongs_to_group
// file filetype.c line 153
signed int ci_belongs_to_group(struct ci_magics_db *db, signed int type, signed int group);
// ci_buf_init
// file request_common.c line 45
void ci_buf_init(struct ci_buf *buf);
// ci_buf_mem_alloc
// file request_common.c line 56
signed int ci_buf_mem_alloc(struct ci_buf *buf, signed int size);
// ci_buf_mem_free
// file request_common.c line 65
void ci_buf_mem_free(struct ci_buf *buf);
// ci_buf_reset
// file request_common.c line 52
void ci_buf_reset(struct ci_buf *buf);
// ci_buf_reset_size
// file request_common.c line 83
signed int ci_buf_reset_size(struct ci_buf *buf, signed int req_size);
// ci_buf_write
// file request_common.c line 74
signed int ci_buf_write(struct ci_buf *buf, char *data, signed int len);
// ci_buffer_alloc
// file include/mem.h line 66
void * ci_buffer_alloc(signed int block_size);
// ci_buffer_blocksize
// file mem.c line 204
unsigned long int ci_buffer_blocksize(const void *data);
// ci_buffer_free
// file ../include/mem.h line 68
void ci_buffer_free(void *data);
// ci_buffer_realloc
// file include/mem.h line 67
void * ci_buffer_realloc(void *data, signed int block_size);
// ci_buffers_destroy
// file mem.c line 166
void ci_buffers_destroy();
// ci_buffers_init
// file mem.c line 112
signed int ci_buffers_init();
// ci_cache_build
// file ../include/cache.h line 88
struct ci_cache * ci_cache_build(const char *name, const char *cache_type, unsigned int cache_size, unsigned int max_object_size, signed int ttl, const struct ci_type_ops *key_ops);
// ci_cache_destroy
// file ../include/cache.h line 124
void ci_cache_destroy(struct ci_cache *cache);
// ci_cache_read_vector_val
// file ../include/cache.h line 133
void * ci_cache_read_vector_val(const void *val, unsigned long int val_size, void *o);
// ci_cache_search
// file ../include/cache.h line 107
const void * ci_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *));
// ci_cache_search::dup_from_cache$object
//
void * dup_from_cache$object(const void *, unsigned long int, void *);
// ci_cache_store_vector_size
// file ../include/cache.h line 131
unsigned long int ci_cache_store_vector_size(struct ci_vector *v);
// ci_cache_store_vector_val
// file ../include/cache.h line 132
void * ci_cache_store_vector_val(void *buf, const void *val, unsigned long int buf_size);
// ci_cache_type_get
// file cache.c line 42
static const struct ci_cache_type * ci_cache_type_get(const char *name);
// ci_cache_type_register
// file cache.c line 37
void ci_cache_type_register(struct ci_cache_type *type);
// ci_cache_update
// file ../include/cache.h line 118
signed int ci_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int));
// ci_cache_update::copy_to_cache$object
//
void * copy_to_cache$object(void *, const void *, unsigned long int);
// ci_cached_file_destroy
// file body.c line 423
void ci_cached_file_destroy(struct ci_cached_file *body);
// ci_cached_file_new
// file body.c line 360
struct ci_cached_file * ci_cached_file_new(signed int size);
// ci_cached_file_read
// file body.c line 520
signed int ci_cached_file_read(struct ci_cached_file *body, char *buf, signed int len);
// ci_cached_file_release
// file body.c line 442
void ci_cached_file_release(struct ci_cached_file *body);
// ci_cached_file_reset
// file body.c line 398
void ci_cached_file_reset(struct ci_cached_file *body, signed int new_size);
// ci_cached_file_write
// file body.c line 461
signed int ci_cached_file_write(struct ci_cached_file *body, const char *buf, signed int len, signed int iseof);
// ci_cfg_alloc_mem
// file cfg_lib.c line 44
void * ci_cfg_alloc_mem(signed int size);
// ci_cfg_disable
// file cfg_lib.c line 192
signed int ci_cfg_disable(const char *directive, const char **argv, void *setdata);
// ci_cfg_enable
// file cfg_lib.c line 203
signed int ci_cfg_enable(const char *directive, const char **argv, void *setdata);
// ci_cfg_lib_init
// file ../include/cfg_param.h line 150
void ci_cfg_lib_init();
// ci_cfg_lib_reset
// file cfg_lib.c line 39
void ci_cfg_lib_reset();
// ci_cfg_onoff
// file cfg_lib.c line 169
signed int ci_cfg_onoff(const char *directive, const char **argv, void *setdata);
// ci_cfg_set_int
// file ../include/cfg_param.h line 164
signed int ci_cfg_set_int(const char *directive, const char **argv, void *setdata);
// ci_cfg_set_str
// file ../include/cfg_param.h line 158
signed int ci_cfg_set_str(const char *directive, const char **argv, void *setdata);
// ci_cfg_size_long
// file cfg_lib.c line 245
signed int ci_cfg_size_long(const char *directive, const char **argv, void *setdata);
// ci_cfg_size_off
// file cfg_lib.c line 213
signed int ci_cfg_size_off(const char *directive, const char **argv, void *setdata);
// ci_client_connect_to
// file request_common.c line 984
struct ci_connection * ci_client_connect_to(char *servername, signed int port, signed int proto);
// ci_client_get_server_options
// file request_common.c line 962
signed int ci_client_get_server_options(struct ci_request *req, signed int timeout);
// ci_client_http_headers_completed
// file request_common.c line 1422
signed int ci_client_http_headers_completed(struct ci_request *req);
// ci_client_icapfilter
// file request_common.c line 1303
signed int ci_client_icapfilter(struct ci_request *req, signed int timeout, struct ci_headers_list *req_headers, struct ci_headers_list *resp_headers, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int));
// ci_client_icapfilter::dest_write$object
//
signed int dest_write$object(void *, char *, signed int);
// ci_client_icapfilter::source_read$object
//
signed int source_read$object(void *, char *, signed int);
// ci_client_request
// file request_common.c line 662
struct ci_request * ci_client_request(struct ci_connection *conn, char *server, char *service);
// ci_client_request_reuse
// file request_common.c line 679
void ci_client_request_reuse(struct ci_request *req);
// ci_connection_destroy
// file net_io.c line 191
void ci_connection_destroy(struct ci_connection *connection);
// ci_copy_connection
// file net_io.c line 162
void ci_copy_connection(struct ci_connection *dest, struct ci_connection *src);
// ci_copy_sockaddr
// file net_io.c line 68
void ci_copy_sockaddr(struct ci_sockaddr *dest, struct ci_sockaddr *src);
// ci_create_os_allocator
// file mem.c line 424
struct ci_mem_allocator * ci_create_os_allocator();
// ci_create_pack_allocator
// file mem.c line 687
struct ci_mem_allocator * ci_create_pack_allocator(char *memblock, unsigned long int size);
// ci_create_pack_allocator_on_memblock
// file mem.c line 704
struct ci_mem_allocator * ci_create_pack_allocator_on_memblock(char *memblock, unsigned long int size);
// ci_create_pool_allocator
// file mem.c line 888
struct ci_mem_allocator * ci_create_pool_allocator(signed int items_size);
// ci_create_serial_allocator
// file include/mem.h line 48
struct ci_mem_allocator * ci_create_serial_allocator(signed int size);
// ci_dyn_array_add
// file array.c line 269
const struct ci_array_item * ci_dyn_array_add(struct ci_dyn_array *array, const char *name, const void *value, unsigned long int size);
// ci_dyn_array_destroy
// file array.c line 260
void ci_dyn_array_destroy(struct ci_dyn_array *array);
// ci_dyn_array_iterate
// file array.c line 329
void ci_dyn_array_iterate(const struct ci_dyn_array *array, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_dyn_array_iterate::fn$object
//
//signed int fn$object(void *, const char *, const void *);
// ci_dyn_array_new
// file array.c line 212
struct ci_dyn_array * ci_dyn_array_new(unsigned long int size);
// ci_dyn_array_new2
// file array.c line 225
struct ci_dyn_array * ci_dyn_array_new2(unsigned long int items, unsigned long int item_size);
// ci_dyn_array_search
// file array.c line 317
const void * ci_dyn_array_search(struct ci_dyn_array *array, const char *name);
// ci_extend_filetype
// file filetype.c line 661
signed int ci_extend_filetype(struct ci_magics_db *db, struct ci_request *req, const char *buf, signed int len, signed int *iscompressed);
// ci_filetype
// file filetype.c line 541
signed int ci_filetype(struct ci_magics_db *db, const char *buf, signed int buflen);
// ci_fill_ip_t
// file net_io.c line 75
void ci_fill_ip_t(struct ci_ip *ip_dest, struct ci_sockaddr *src);
// ci_fill_sockaddr
// file include/net_io.h line 115
void ci_fill_sockaddr(struct ci_sockaddr *addr);
// ci_format_text
// file txt_format.c line 240
signed int ci_format_text(struct ci_request *req_data, const char *fmt, char *buffer, signed int len, struct ci_fmt_entry *user_table);
// ci_get_data_group_id
// file filetype.c line 143
signed int ci_get_data_group_id(struct ci_magics_db *db, const char *group);
// ci_get_data_type_id
// file filetype.c line 133
signed int ci_get_data_type_id(struct ci_magics_db *db, const char *name);
// ci_hard_close
// file os/unix/net_io.c line 359
signed int ci_hard_close(signed int fd);
// ci_hash_add
// file include/hash.h line 54
void * ci_hash_add(struct ci_hash_table *htable, const void *key, const void *val);
// ci_hash_build
// file include/hash.h line 49
struct ci_hash_table * ci_hash_build(unsigned int hash_size, const struct ci_type_ops *ops, struct ci_mem_allocator *allocator);
// ci_hash_compute
// file include/hash.h line 48
unsigned int ci_hash_compute(unsigned long int hash_max_value, const void *key, signed int len);
// ci_hash_destroy
// file include/hash.h line 52
void ci_hash_destroy(struct ci_hash_table *htable);
// ci_hash_search
// file include/hash.h line 53
const void * ci_hash_search(struct ci_hash_table *htable, const void *key);
// ci_headers_add
// file header.c line 220
const char * ci_headers_add(struct ci_headers_list *h, const char *line);
// ci_headers_addheaders
// file header.c line 269
signed int ci_headers_addheaders(struct ci_headers_list *h, const struct ci_headers_list *headers);
// ci_headers_copy_value
// file header.c line 343
const char * ci_headers_copy_value(struct ci_headers_list *h, const char *header, char *buf, unsigned long int len);
// ci_headers_create
// file header.c line 156
struct ci_headers_list * ci_headers_create();
// ci_headers_destroy
// file header.c line 186
void ci_headers_destroy(struct ci_headers_list *h);
// ci_headers_iterate
// file header.c line 424
signed int ci_headers_iterate(struct ci_headers_list *h, void *data, void (*fn)(void *, const char *, const char *));
// ci_headers_iterate::fn$object
//
void fn$object(void *, const char *, const char *);
// ci_headers_pack
// file header.c line 451
void ci_headers_pack(struct ci_headers_list *h);
// ci_headers_remove
// file header.c line 369
signed int ci_headers_remove(struct ci_headers_list *h, const char *header);
// ci_headers_replace
// file header.c line 414
const char * ci_headers_replace(struct ci_headers_list *h, const char *header, const char *newval);
// ci_headers_reset
// file header.c line 213
void ci_headers_reset(struct ci_headers_list *h);
// ci_headers_search
// file header.c line 318
const char * ci_headers_search(struct ci_headers_list *h, const char *header);
// ci_headers_setsize
// file header.c line 195
signed int ci_headers_setsize(struct ci_headers_list *h, signed int size);
// ci_headers_unpack
// file header.c line 478
signed int ci_headers_unpack(struct ci_headers_list *h);
// ci_headers_value
// file header.c line 328
const char * ci_headers_value(struct ci_headers_list *h, const char *header);
// ci_host_to_sockaddr_t
// file include/net_io.h line 136
signed int ci_host_to_sockaddr_t(const char *servername, struct ci_sockaddr *addr, signed int proto);
// ci_http_client_ip
// file simple_api.c line 301
const struct ci_ip * ci_http_client_ip(struct ci_request *req);
// ci_http_content_length
// file simple_api.c line 207
signed long int ci_http_content_length(struct ci_request *req);
// ci_http_request
// file simple_api.c line 234
const char * ci_http_request(struct ci_request *req);
// ci_http_request_add_header
// file simple_api.c line 152
const char * ci_http_request_add_header(struct ci_request *req, const char *header);
// ci_http_request_create
// file simple_api.c line 119
signed int ci_http_request_create(struct ci_request *req, signed int has_body);
// ci_http_request_get_header
// file simple_api.c line 195
const char * ci_http_request_get_header(struct ci_request *req, const char *head_name);
// ci_http_request_headers
// file simple_api.c line 52
struct ci_headers_list * ci_http_request_headers(struct ci_request *req);
// ci_http_request_remove_header
// file simple_api.c line 173
signed int ci_http_request_remove_header(struct ci_request *req, const char *header);
// ci_http_request_reset_headers
// file simple_api.c line 79
signed int ci_http_request_reset_headers(struct ci_request *req);
// ci_http_request_url
// file simple_api.c line 257
signed int ci_http_request_url(struct ci_request *req, char *buf, signed int buf_size);
// ci_http_response_add_header
// file simple_api.c line 141
const char * ci_http_response_add_header(struct ci_request *req, const char *header);
// ci_http_response_create
// file simple_api.c line 96
signed int ci_http_response_create(struct ci_request *req, signed int has_reshdr, signed int has_body);
// ci_http_response_get_header
// file simple_api.c line 184
const char * ci_http_response_get_header(struct ci_request *req, const char *head_name);
// ci_http_response_headers
// file simple_api.c line 39
struct ci_headers_list * ci_http_response_headers(struct ci_request *req);
// ci_http_response_remove_header
// file simple_api.c line 162
signed int ci_http_response_remove_header(struct ci_request *req, const char *header);
// ci_http_response_reset_headers
// file simple_api.c line 70
signed int ci_http_response_reset_headers(struct ci_request *req);
// ci_icap_add_xheader
// file simple_api.c line 246
const char * ci_icap_add_xheader(struct ci_request *req, const char *header);
// ci_icap_append_xheaders
// file simple_api.c line 251
signed int ci_icap_append_xheaders(struct ci_request *req, struct ci_headers_list *headers);
// ci_inet_aton
// file include/net_io.h line 119
signed int ci_inet_aton(signed int af, const char *cp, void *addr);
// ci_inet_ntoa
// file include/net_io.h line 120
const char * ci_inet_ntoa(signed int af, const void *src, char *dst, signed int cnt);
// ci_internal_time
// file cache.c line 32
signed long int ci_internal_time();
// ci_linger_close
// file os/unix/net_io.c line 338
signed int ci_linger_close(signed int fd, signed int timeout);
// ci_list_cmp_handler
// file array.c line 536
void ci_list_cmp_handler(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int));
// ci_list_cmp_handler::cmp_func$object
//
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_list_copy_handler
// file array.c line 546
void ci_list_copy_handler(struct ci_list *list, signed int (*copy_func)(void *, const void *));
// ci_list_copy_handler::copy_func$object
//
signed int copy_func$object(void *, const void *);
// ci_list_create
// file array.c line 507
struct ci_list * ci_list_create(unsigned long int init_size, unsigned long int obj_size);
// ci_list_destroy
// file array.c line 530
void ci_list_destroy(struct ci_list *list);
// ci_list_free_handler
// file array.c line 541
void ci_list_free_handler(struct ci_list *list, void (*free_func)(void *));
// ci_list_free_handler::free_func$object
//
void free_func$object(void *);
// ci_list_iterate
// file array.c line 551
void ci_list_iterate(struct ci_list *list, void *data, signed int (*fn)(void *, const void *));
// ci_list_iterate::fn$object
//
//signed int fn$object(void *, const void *);
// ci_list_pop
// file array.c line 617
void * ci_list_pop(struct ci_list *list, void *data);
// ci_list_pop_back
// file array.c line 647
void * ci_list_pop_back(struct ci_list *list, void *data);
// ci_list_push
// file array.c line 589
const void * ci_list_push(struct ci_list *list, const void *data);
// ci_list_push_back
// file array.c line 603
const void * ci_list_push_back(struct ci_list *list, const void *data);
// ci_list_remove
// file array.c line 690
signed int ci_list_remove(struct ci_list *list, const void *obj);
// ci_list_remove::1::cmp_func$object
//
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_list_search
// file array.c line 723
const void * ci_list_search(struct ci_list *list, const void *data);
// ci_list_search2
// file array.c line 742
const void * ci_list_search2(struct ci_list *list, const void *data, signed int (*cmp_func)(const void *, const void *, unsigned long int));
// ci_list_search2::cmp_func$object
//
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_list_search::1::cmp_func$object
//
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_list_sort
// file array.c line 752
void ci_list_sort(struct ci_list *list);
// ci_list_sort2
// file array.c line 766
void ci_list_sort2(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int));
// ci_list_sort2::cmp_func$object
//
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_list_sort::1::cmp_func$object
//
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_local_cache_destroy
// file cache.c line 217
void ci_local_cache_destroy(struct ci_cache *cache);
// ci_local_cache_init
// file cache.c line 135
signed int ci_local_cache_init(struct ci_cache *cache, const char *name);
// ci_local_cache_search
// file cache.c line 238
const void * ci_local_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *));
// ci_local_cache_search::dup_from_cache$object
//
void * dup_from_cache$object(const void *, unsigned long int, void *);
// ci_local_cache_update
// file cache.c line 277
signed int ci_local_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int));
// ci_local_cache_update::copy_to_cache$object
//
void * copy_to_cache$object(void *, const void *, unsigned long int);
// ci_lookup_table_create
// file lookup_table.c line 144
struct ci_lookup_table * ci_lookup_table_create(const char *table);
// ci_lookup_table_create_ext
// file lookup_table.c line 69
struct ci_lookup_table * ci_lookup_table_create_ext(const char *table, const struct ci_type_ops *key_ops, const struct ci_type_ops *val_ops, struct ci_mem_allocator *allocator);
// ci_lookup_table_destroy
// file lookup_table.c line 158
void ci_lookup_table_destroy(struct ci_lookup_table *lt);
// ci_lookup_table_get_row
// file lookup_table.c line 228
const char * ci_lookup_table_get_row(struct ci_lookup_table *table, const char *key, const char **columns, char ***vals);
// ci_lookup_table_open
// file lookup_table.c line 172
void * ci_lookup_table_open(struct ci_lookup_table *table);
// ci_lookup_table_release_result
// file lookup_table.c line 196
void ci_lookup_table_release_result(struct ci_lookup_table *table, void **val);
// ci_lookup_table_search
// file lookup_table.c line 181
const char * ci_lookup_table_search(struct ci_lookup_table *table, const char *key, char ***vals);
// ci_lookup_table_type_register
// file lookup_table.c line 36
struct ci_lookup_table_type * ci_lookup_table_type_register(struct ci_lookup_table_type *lt_type);
// ci_lookup_table_type_search
// file lookup_table.c line 58
struct ci_lookup_table_type * ci_lookup_table_type_search(const char *type);
// ci_lookup_table_type_unregister
// file lookup_table.c line 46
void ci_lookup_table_type_unregister(struct ci_lookup_table_type *lt_type);
// ci_magic_data_type
// file filetype.c line 711
signed int ci_magic_data_type(const char *buf, signed int len);
// ci_magic_data_type_ext
// file filetype.c line 720
signed int ci_magic_data_type_ext(struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed);
// ci_magic_db_free
// file filetype.c line 685
void ci_magic_db_free();
// ci_magic_db_load
// file filetype.c line 674
struct ci_magics_db * ci_magic_db_load(const char *filename);
// ci_magic_group_check
// file filetype.c line 745
signed int ci_magic_group_check(signed int type, signed int group);
// ci_magic_group_id
// file filetype.c line 737
signed int ci_magic_group_id(const char *group);
// ci_magic_group_name
// file filetype.c line 783
char * ci_magic_group_name(signed int group);
// ci_magic_groups_count
// file filetype.c line 760
signed int ci_magic_groups_count();
// ci_magic_req_data_type
// file filetype.c line 694
signed int ci_magic_req_data_type(struct ci_request *req, signed int *isencoded);
// ci_magic_type_descr
// file filetype.c line 774
char * ci_magic_type_descr(signed int type);
// ci_magic_type_id
// file filetype.c line 729
signed int ci_magic_type_id(const char *name);
// ci_magic_type_name
// file filetype.c line 765
char * ci_magic_type_name(signed int type);
// ci_magic_types_count
// file filetype.c line 754
signed int ci_magic_types_count();
// ci_magics_db_build
// file filetype.c line 358
struct ci_magics_db * ci_magics_db_build(const char *filename);
// ci_magics_db_file_add
// file filetype.c line 302
signed int ci_magics_db_file_add(struct ci_magics_db *db, const char *filename);
// ci_magics_db_init
// file filetype.c line 267
struct ci_magics_db * ci_magics_db_init();
// ci_magics_db_release
// file filetype.c line 294
void ci_magics_db_release(struct ci_magics_db *db);
// ci_mem_allocator_destroy
// file mem.c line 62
void ci_mem_allocator_destroy(struct ci_mem_allocator *allocator);
// ci_membuf_attr_add
// file body.c line 244
signed int ci_membuf_attr_add(struct ci_membuf *body, const char *attr, const void *val, unsigned long int val_size);
// ci_membuf_attr_get
// file body.c line 256
const void * ci_membuf_attr_get(struct ci_membuf *body, const char *attr);
// ci_membuf_free
// file body.c line 147
void ci_membuf_free(struct ci_membuf *b);
// ci_membuf_from_content
// file body.c line 108
struct ci_membuf * ci_membuf_from_content(char *buf, unsigned long int buf_size, unsigned long int content_size, unsigned int flags);
// ci_membuf_new
// file body.c line 82
struct ci_membuf * ci_membuf_new();
// ci_membuf_new_sized
// file body.c line 87
struct ci_membuf * ci_membuf_new_sized(signed int size);
// ci_membuf_read
// file body.c line 225
signed int ci_membuf_read(struct ci_membuf *b, char *data, signed int len);
// ci_membuf_set_flag
// file body.c line 158
unsigned int ci_membuf_set_flag(struct ci_membuf *body, unsigned int flag);
// ci_membuf_truncate
// file body.c line 263
signed int ci_membuf_truncate(struct ci_membuf *body, signed int new_size);
// ci_membuf_write
// file body.c line 167
signed int ci_membuf_write(struct ci_membuf *b, const char *data, signed int len, signed int iseof);
// ci_mktemp_file
// file include/util.h line 34
signed int ci_mktemp_file(char *dir, char *template, char *filename);
// ci_module_load
// file ../include/dlib.h line 40
void * ci_module_load(const char *module_file, const char *default_path);
// ci_module_sym
// file ../include/dlib.h line 41
void * ci_module_sym(void *handle, const char *symbol);
// ci_module_unload
// file os/unix/dlib.c line 65
signed int ci_module_unload(void *handle, const char *name);
// ci_netio_init
// file include/net_io.h line 149
signed int ci_netio_init(signed int fd);
// ci_object_pool_alloc
// file include/mem.h line 73
void * ci_object_pool_alloc(signed int id);
// ci_object_pool_free
// file include/mem.h line 74
void ci_object_pool_free(void *ptr);
// ci_object_pool_register
// file include/mem.h line 71
signed int ci_object_pool_register(const char *name, signed int size);
// ci_object_pool_unregister
// file include/mem.h line 72
void ci_object_pool_unregister(signed int id);
// ci_object_pools_destroy
// file mem.c line 310
void ci_object_pools_destroy();
// ci_object_pools_init
// file mem.c line 305
signed int ci_object_pools_init();
// ci_pack_allocator_alloc
// file mem.c line 604
void * ci_pack_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// ci_pack_allocator_alloc_from_rear
// file mem.c line 610
void * ci_pack_allocator_alloc_from_rear(struct ci_mem_allocator *allocator, signed int size);
// ci_pack_allocator_alloc_unaligned
// file mem.c line 582
void * ci_pack_allocator_alloc_unaligned(struct ci_mem_allocator *allocator, unsigned long int size);
// ci_pack_allocator_data_size
// file mem.c line 722
signed int ci_pack_allocator_data_size(struct ci_mem_allocator *allocator);
// ci_pack_allocator_destroy
// file mem.c line 647
void ci_pack_allocator_destroy(struct ci_mem_allocator *allocator);
// ci_pack_allocator_free
// file mem.c line 633
void ci_pack_allocator_free(struct ci_mem_allocator *allocator, void *p);
// ci_pack_allocator_required_size
// file mem.c line 730
unsigned long int ci_pack_allocator_required_size();
// ci_pack_allocator_reset
// file mem.c line 638
void ci_pack_allocator_reset(struct ci_mem_allocator *allocator);
// ci_pack_allocator_set_end_pos
// file mem.c line 746
void ci_pack_allocator_set_end_pos(struct ci_mem_allocator *allocator, void *p);
// ci_pack_allocator_set_start_pos
// file mem.c line 737
void ci_pack_allocator_set_start_pos(struct ci_mem_allocator *allocator, void *p);
// ci_parse_key_value_list
// file util.c line 163
struct ci_dyn_array * ci_parse_key_value_list(const char *str, char sep);
// ci_proc_mutex_default_scheme
// file os/unix/proc_mutex.c line 254
const struct ci_proc_mutex_scheme * ci_proc_mutex_default_scheme();
// ci_proc_mutex_destroy
// file os/unix/proc_mutex.c line 292
signed int ci_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// ci_proc_mutex_init
// file os/unix/proc_mutex.c line 283
signed int ci_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// ci_proc_mutex_lock
// file os/unix/proc_mutex.c line 299
signed int ci_proc_mutex_lock(struct ci_proc_mutex *mutex);
// ci_proc_mutex_set_scheme
// file os/unix/proc_mutex.c line 259
signed int ci_proc_mutex_set_scheme(const char *scheme);
// ci_proc_mutex_unlock
// file os/unix/proc_mutex.c line 306
signed int ci_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// ci_ptr_array_add
// file array.c line 165
const struct ci_array_item * ci_ptr_array_add(struct ci_array *ptr_array, const char *name, void *value);
// ci_ptr_array_new2
// file array.c line 151
struct ci_array * ci_ptr_array_new2(unsigned long int items);
// ci_ptr_array_pop
// file array.c line 189
const struct ci_array_item * ci_ptr_array_pop(struct ci_array *ptr_array);
// ci_ptr_array_pop_value
// file array.c line 200
void * ci_ptr_array_pop_value(struct ci_array *ptr_array, char *name, unsigned long int name_size);
// ci_ptr_array_search
// file array.c line 160
void * ci_ptr_array_search(struct ci_array *array, const char *name);
// ci_ptr_dyn_array_add
// file array.c line 336
const struct ci_array_item * ci_ptr_dyn_array_add(struct ci_dyn_array *array, const char *name, void *value);
// ci_ptr_vector_add
// file array.c line 479
void * ci_ptr_vector_add(struct ci_vector *vector, void *value);
// ci_read
// file os/unix/net_io.c line 253
signed int ci_read(signed int fd, void *buf, unsigned long int count, signed int timeout);
// ci_read_nonblock
// file include/net_io.h line 152
signed int ci_read_nonblock(signed int fd, void *buf, unsigned long int count);
// ci_regex_apply
// file include/ci_regex.h line 46
signed int ci_regex_apply(void * const regex, const char *str, signed int len, signed int recurs, struct ci_list *matches, const void *user_data);
// ci_regex_build
// file include/ci_regex.h line 44
void * ci_regex_build(const char *regex_str, signed int regex_flags);
// ci_regex_free
// file include/ci_regex.h line 45
void ci_regex_free(void *regex);
// ci_regex_parse
// file include/ci_regex.h line 43
char * ci_regex_parse(const char *str, signed int *flags, signed int *recursive);
// ci_registry_add_item
// file include/registry.h line 34
signed int ci_registry_add_item(const char *name, const char *label, const void *obj);
// ci_registry_clean
// file registry.c line 49
void ci_registry_clean();
// ci_registry_create
// file registry.c line 29
signed int ci_registry_create(const char *name);
// ci_registry_get_id
// file registry.c line 119
signed int ci_registry_get_id(const char *name);
// ci_registry_get_item
// file include/registry.h line 35
const void * ci_registry_get_item(const char *name, const char *label);
// ci_registry_id_get_item
// file registry.c line 147
const void * ci_registry_id_get_item(signed int reg_id, const char *label);
// ci_registry_id_iterate
// file registry.c line 135
signed int ci_registry_id_iterate(signed int reg_id, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_registry_id_iterate::fn$object
//
//signed int fn$object(void *, const char *, const void *);
// ci_registry_iterate
// file registry.c line 65
signed int ci_registry_iterate(const char *name, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_registry_iterate::fn$object
//
//signed int fn$object(void *, const char *, const void *);
// ci_request_206_origin_body
// file request_common.c line 436
signed int ci_request_206_origin_body(struct ci_request *req, unsigned long int offset);
// ci_request_alloc
// file request_common.c line 231
struct ci_request * ci_request_alloc(struct ci_connection *connection);
// ci_request_alloc_entity
// file include/request.h line 174
struct ci_encaps_entity * ci_request_alloc_entity(struct ci_request *req, signed int type, signed int val);
// ci_request_destroy
// file request_common.c line 378
void ci_request_destroy(struct ci_request *req);
// ci_request_pack
// file request_common.c line 152
void ci_request_pack(struct ci_request *req);
// ci_request_release_entity
// file include/request.h line 175
signed int ci_request_release_entity(struct ci_request *req, signed int pos);
// ci_request_reset
// file request_common.c line 308
void ci_request_reset(struct ci_request *req);
// ci_request_set_log_str
// file request_common.c line 405
char * ci_request_set_log_str(struct ci_request *req, char *logstr);
// ci_request_set_str_attribute
// file request_common.c line 419
signed int ci_request_set_str_attribute(struct ci_request *req, const char *name, const char *value);
// ci_request_t_pack
// file request_common.c line 92
void ci_request_t_pack(struct ci_request *req, signed int is_request);
// ci_response_pack
// file request_common.c line 156
void ci_response_pack(struct ci_request *req);
// ci_ring_buf_consume
// file body.c line 931
void ci_ring_buf_consume(struct ci_ring_buf *buf, signed int len);
// ci_ring_buf_destroy
// file body.c line 882
void ci_ring_buf_destroy(struct ci_ring_buf *buf);
// ci_ring_buf_is_empty
// file body.c line 888
signed int ci_ring_buf_is_empty(struct ci_ring_buf *buf);
// ci_ring_buf_new
// file body.c line 863
struct ci_ring_buf * ci_ring_buf_new(signed int size);
// ci_ring_buf_produce
// file body.c line 942
void ci_ring_buf_produce(struct ci_ring_buf *buf, signed int len);
// ci_ring_buf_read
// file body.c line 975
signed int ci_ring_buf_read(struct ci_ring_buf *buf, char *data, signed int size);
// ci_ring_buf_read_block
// file body.c line 912
signed int ci_ring_buf_read_block(struct ci_ring_buf *buf, char **rb, signed int *len);
// ci_ring_buf_write
// file body.c line 955
signed int ci_ring_buf_write(struct ci_ring_buf *buf, const char *data, signed int size);
// ci_ring_buf_write_block
// file body.c line 893
signed int ci_ring_buf_write_block(struct ci_ring_buf *buf, char **wb, signed int *len);
// ci_service_add_xincludes
// file service_lib.c line 125
void ci_service_add_xincludes(struct ci_service_xdata *srv_xdata, char **xincludes);
// ci_service_add_xopts
// file service_lib.c line 118
void ci_service_add_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts);
// ci_service_data_read_lock
// file service_lib.c line 25
void ci_service_data_read_lock(struct ci_service_xdata *srv_xdata);
// ci_service_data_read_unlock
// file service_lib.c line 30
void ci_service_data_read_unlock(struct ci_service_xdata *srv_xdata);
// ci_service_enable_204
// file service_lib.c line 82
void ci_service_enable_204(struct ci_service_xdata *srv_xdata);
// ci_service_enable_206
// file service_lib.c line 89
void ci_service_enable_206(struct ci_service_xdata *srv_xdata);
// ci_service_set_istag
// file service_lib.c line 35
void ci_service_set_istag(struct ci_service_xdata *srv_xdata, const char *istag);
// ci_service_set_max_connections
// file service_lib.c line 97
void ci_service_set_max_connections(struct ci_service_xdata *srv_xdata, signed int max_connections);
// ci_service_set_options_ttl
// file service_lib.c line 104
void ci_service_set_options_ttl(struct ci_service_xdata *srv_xdata, signed int ttl);
// ci_service_set_preview
// file service_lib.c line 75
void ci_service_set_preview(struct ci_service_xdata *srv_xdata, signed int preview);
// ci_service_set_transfer_complete
// file service_lib.c line 64
void ci_service_set_transfer_complete(struct ci_service_xdata *srv_xdata, const char *complete);
// ci_service_set_transfer_ignore
// file service_lib.c line 54
void ci_service_set_transfer_ignore(struct ci_service_xdata *srv_xdata, const char *ignore);
// ci_service_set_transfer_preview
// file service_lib.c line 44
void ci_service_set_transfer_preview(struct ci_service_xdata *srv_xdata, const char *preview);
// ci_service_set_xopts
// file service_lib.c line 111
void ci_service_set_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts);
// ci_shared_mem_attach
// file os/unix/shared_mem.c line 262
void * ci_shared_mem_attach(struct ci_shared_mem_id *id);
// ci_shared_mem_create
// file os/unix/shared_mem.c line 252
void * ci_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// ci_shared_mem_destroy
// file os/unix/shared_mem.c line 276
signed int ci_shared_mem_destroy(struct ci_shared_mem_id *id);
// ci_shared_mem_detach
// file os/unix/shared_mem.c line 269
signed int ci_shared_mem_detach(struct ci_shared_mem_id *id);
// ci_shared_mem_set_scheme
// file os/unix/shared_mem.c line 227
signed int ci_shared_mem_set_scheme(const char *name);
// ci_simple_file_destroy
// file body.c line 643
void ci_simple_file_destroy(struct ci_simple_file *body);
// ci_simple_file_named_new
// file body.c line 601
struct ci_simple_file * ci_simple_file_named_new(char *dir, char *filename, signed long int maxsize);
// ci_simple_file_new
// file body.c line 571
struct ci_simple_file * ci_simple_file_new(signed long int maxsize);
// ci_simple_file_read
// file body.c line 750
signed int ci_simple_file_read(struct ci_simple_file *body, char *buf, signed int len);
// ci_simple_file_release
// file body.c line 665
void ci_simple_file_release(struct ci_simple_file *body);
// ci_simple_file_to_const_string
// file body.c line 824
const char * ci_simple_file_to_const_string(struct ci_simple_file *body);
// ci_simple_file_to_membuf
// file body.c line 848
struct ci_membuf * ci_simple_file_to_membuf(struct ci_simple_file *body, unsigned int flags);
// ci_simple_file_truncate
// file body.c line 797
signed int ci_simple_file_truncate(struct ci_simple_file *body, signed long int new_size);
// ci_simple_file_write
// file body.c line 686
signed int ci_simple_file_write(struct ci_simple_file *body, const char *buf, signed int len, signed int iseof);
// ci_sockaddr_set_port
// file include/net_io.h line 131
void ci_sockaddr_set_port(struct ci_sockaddr *addr, signed int port);
// ci_sockaddr_t_to_host
// file include/net_io.h line 135
const char * ci_sockaddr_t_to_host(struct ci_sockaddr *addr, char *hname, signed int maxhostlen);
// ci_sockaddr_t_to_ip
// file include/net_io.h line 123
const char * ci_sockaddr_t_to_ip(struct ci_sockaddr *addr, char *ip, signed int maxlen);
// ci_stat_area_construct
// file stats.c line 198
struct stat_area * ci_stat_area_construct(void *mem_block, signed int size, void (*release_mem)(void *));
// ci_stat_area_construct::release_mem$object
//
void release_mem$object(void *);
// ci_stat_area_destroy
// file stats.c line 236
void ci_stat_area_destroy(struct stat_area *area);
// ci_stat_area_kbs_inc
// file stats.c line 257
void ci_stat_area_kbs_inc(struct stat_area *area, signed int ID, signed int count);
// ci_stat_area_merge
// file stats.c line 322
void ci_stat_area_merge(struct stat_area *dest, struct stat_area *src);
// ci_stat_area_reset
// file stats.c line 221
void ci_stat_area_reset(struct stat_area *area);
// ci_stat_area_uint64_inc
// file stats.c line 245
void ci_stat_area_uint64_inc(struct stat_area *area, signed int ID, signed int count);
// ci_stat_attach_mem
// file stats.c line 152
void ci_stat_attach_mem(void *mem_block, signed int size, void (*release_mem)(void *));
// ci_stat_attach_mem::release_mem$object
//
void release_mem$object(void *);
// ci_stat_entry_register
// file stats.c line 129
signed int ci_stat_entry_register(char *label, signed int type, char *group);
// ci_stat_entry_release_lists
// file stats.c line 146
void ci_stat_entry_release_lists();
// ci_stat_kbs_inc
// file stats.c line 179
void ci_stat_kbs_inc(signed int ID, signed int count);
// ci_stat_memblock_merge
// file stats.c line 303
void ci_stat_memblock_merge(struct stat_memblock *dest_block, struct stat_memblock *mem_block);
// ci_stat_memblock_reset
// file stats.c line 292
void ci_stat_memblock_reset(struct stat_memblock *block);
// ci_stat_memblock_size
// file stats.c line 33
signed int ci_stat_memblock_size(void);
// ci_stat_release
// file stats.c line 160
void ci_stat_release();
// ci_stat_uint64_inc
// file stats.c line 168
void ci_stat_uint64_inc(signed int ID, signed int count);
// ci_str_trim
// file util.c line 108
void ci_str_trim(char *str);
// ci_str_trim2
// file util.c line 131
char * ci_str_trim2(char *s);
// ci_str_vector_iterate
// file array.c line 461
void ci_str_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const char *));
// ci_str_vector_iterate::fn$object
//
//signed int fn$object(void *, const char *);
// ci_str_vector_search
// file include/array.h line 549
const char * ci_str_vector_search(struct ci_vector *vector, const char *item);
// ci_strcasestr
// file util.c line 43
const char * ci_strcasestr(const char *str, const char *find);
// ci_strerror
// file include/util.h line 57
char * ci_strerror(signed int error, char *buf, unsigned long int buflen);
// ci_strncasestr
// file util.c line 59
const char * ci_strncasestr(const char *s, const char *find, unsigned long int slen);
// ci_strnstr
// file include/util.h line 44
const char * ci_strnstr(const char *s, const char *find, unsigned long int slen);
// ci_strtime
// file os/unix/utilfunc.c line 51
void ci_strtime(char *buf);
// ci_strtime_rfc822
// file os/unix/utilfunc.c line 61
void ci_strtime_rfc822(char *buf);
// ci_thread_cond_destroy
// file os/unix/threads.c line 196
signed int ci_thread_cond_destroy(union anonymous$6 *pcond);
// ci_thread_cond_init
// file os/unix/threads.c line 191
signed int ci_thread_cond_init(union anonymous$6 *pcond);
// ci_thread_create
// file os/unix/threads.c line 201
signed int ci_thread_create(unsigned long int *pthread_id, void * (*pfunc)(void *), void *parg);
// ci_thread_create::pfunc$object
//
void * pfunc$object(void *);
// ci_thread_join
// file os/unix/threads.c line 206
signed int ci_thread_join(unsigned long int thread_id);
// ci_thread_mutex_destroy
// file include/ci_threads.h line 40
signed int ci_thread_mutex_destroy(union anonymous$8 *pmutex);
// ci_thread_mutex_init
// file include/ci_threads.h line 39
signed int ci_thread_mutex_init(union anonymous$8 *pmutex);
// ci_thread_rwlock_destroy
// file os/unix/threads.c line 154
signed int ci_thread_rwlock_destroy(union anonymous$10 *rwlock);
// ci_thread_rwlock_init
// file os/unix/threads.c line 144
signed int ci_thread_rwlock_init(union anonymous$10 *rwlock);
// ci_txt_template_build_content
// file txtTemplate.c line 396
struct ci_membuf * ci_txt_template_build_content(const struct ci_request *req, const char *SERVICE_NAME, const char *TEMPLATE_NAME, struct ci_fmt_entry *user_table);
// ci_txt_template_close
// file txtTemplate.c line 192
void ci_txt_template_close(void);
// ci_txt_template_init
// file txtTemplate.c line 77
signed int ci_txt_template_init(void);
// ci_txt_template_reset
// file txtTemplate.c line 181
void ci_txt_template_reset(void);
// ci_txt_template_set_default_lang
// file txtTemplate.c line 104
void ci_txt_template_set_default_lang(const char *lang);
// ci_txt_template_set_dir
// file txtTemplate.c line 99
void ci_txt_template_set_dir(const char *dir);
// ci_uncompress_preview
// file decode.c line 313
signed int ci_uncompress_preview(signed int compress_method, const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len);
// ci_usleep
// file os/unix/utilfunc.c line 85
signed int ci_usleep(unsigned long int usec);
// ci_vector_add
// file ../include/array.h line 480
void * ci_vector_add(struct ci_vector *vector, const void *value, unsigned long int size);
// ci_vector_cast_from_voidvoid
// file array.c line 386
struct ci_vector * ci_vector_cast_from_voidvoid(const void **p);
// ci_vector_cast_to_voidvoid
// file array.c line 381
const void ** ci_vector_cast_to_voidvoid(struct ci_vector *vector);
// ci_vector_create
// file ../include/array.h line 463
struct ci_vector * ci_vector_create(unsigned long int max_size);
// ci_vector_destroy
// file ../include/array.h line 470
void ci_vector_destroy(struct ci_vector *vector);
// ci_vector_iterate
// file array.c line 452
void ci_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const void *));
// ci_vector_iterate::fn$object
//
//signed int fn$object(void *, const void *);
// ci_vector_pop
// file array.c line 427
void * ci_vector_pop(struct ci_vector *vector);
// ci_wait_for_data
// file include/net_io.h line 144
signed int ci_wait_for_data(signed int fd, signed int secs, signed int what_wait);
// ci_write
// file include/net_io.h line 151
signed int ci_write(signed int fd, const void *buf, unsigned long int count, signed int timeout);
// ci_write_nonblock
// file include/net_io.h line 153
signed int ci_write_nonblock(signed int fd, const void *buf, unsigned long int count);
// ci_writen
// file request_common.c line 801
static signed int ci_writen(signed int fd, char *buf, signed int len, signed int timeout);
// client_build_headers
// file request_common.c line 1281
static signed int client_build_headers(struct ci_request *req, signed int has_reqhdr, signed int has_reshdr, signed int has_body);
// client_create_request
// file request_common.c line 724
static signed int client_create_request(struct ci_request *req, char *servername, char *service, signed int reqtype);
// client_parse_encaps_header
// file request_common.c line 921
static signed int client_parse_encaps_header(struct ci_request *req, struct ci_headers_list *h, signed int size);
// client_parse_icap_header
// file request_common.c line 891
static signed int client_parse_icap_header(struct ci_request *req, struct ci_headers_list *h);
// client_parse_incoming_data
// file request_common.c line 1082
static signed int client_parse_incoming_data(struct ci_request *req, void *data_dest, signed int (*dest_write)(void *, char *, signed int));
// client_parse_incoming_data::dest_write$object
//
signed int dest_write$object(void *, char *, signed int);
// client_prepere_body_chunk
// file request_common.c line 1052
static signed int client_prepere_body_chunk(struct ci_request *req, void *data, signed int (*readdata)(void *, char *, signed int));
// client_prepere_body_chunk::readdata$object
//
signed int readdata$object(void *, char *, signed int);
// client_send_get_data
// file request_common.c line 1200
static signed int client_send_get_data(struct ci_request *req, signed int timeout, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int));
// client_send_get_data::dest_write$object
//
signed int dest_write$object(void *, char *, signed int);
// client_send_get_data::source_read$object
//
signed int source_read$object(void *, char *, signed int);
// client_send_request_headers
// file request_common.c line 816
static signed int client_send_request_headers(struct ci_request *req, signed int has_eof, signed int timeout);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// common_mutex_destroy
// file cache.c line 114
signed int common_mutex_destroy(struct common_mutex *mtx);
// common_mutex_init
// file cache.c line 105
signed int common_mutex_init(struct common_mutex *mtx, signed int proc_mtx);
// common_mutex_lock
// file cache.c line 121
signed int common_mutex_lock(struct common_mutex *mtx);
// common_mutex_unlock
// file cache.c line 128
signed int common_mutex_unlock(struct common_mutex *mtx);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$13, unsigned int);
// datatype_cmp
// file types_ops.c line 330
signed int datatype_cmp(const void *key1, const void *key2);
// datatype_dup
// file types_ops.c line 311
void * datatype_dup(const char *str, struct ci_mem_allocator *allocator);
// datatype_equal
// file types_ops.c line 348
signed int datatype_equal(const void *key1, const void *key2);
// datatype_free
// file types_ops.c line 371
void datatype_free(void *key, struct ci_mem_allocator *allocator);
// datatype_len
// file types_ops.c line 366
unsigned long int datatype_len(const void *key);
// default_cmp
// file array.c line 680
static signed int default_cmp(const void *obj1, const void *obj2, unsigned long int size);
// del_mutex
// file os/unix/threads.c line 105
static void del_mutex(void *pmutex);
// destroy_encaps_entity
// file header.c line 563
void destroy_encaps_entity(struct ci_encaps_entity *e);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// do_close
// file body.c line 318
void do_close(signed int fd);
// do_open
// file body.c line 308
signed int do_open(const char *pathname, signed int flags);
// do_read
// file body.c line 292
signed int do_read(signed int fd, void *buf, unsigned long int count);
// do_write
// file body.c line 282
signed int do_write(signed int fd, const void *buf, unsigned long int count);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// extend_object_type
// file filetype.c line 559
signed int extend_object_type(struct ci_magics_db *db, struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_proc_mutex_destroy
// file os/unix/proc_mutex.c line 195
static signed int file_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// file_proc_mutex_init
// file os/unix/proc_mutex.c line 185
static signed int file_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// file_proc_mutex_lock
// file os/unix/proc_mutex.c line 203
static signed int file_proc_mutex_lock(struct ci_proc_mutex *mutex);
// file_proc_mutex_print_info
// file os/unix/proc_mutex.c line 228
static signed int file_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size);
// file_proc_mutex_unlock
// file os/unix/proc_mutex.c line 216
static signed int file_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// file_table_close
// file lookup_file_table.c line 264
void file_table_close(struct ci_lookup_table *table);
// file_table_open
// file lookup_file_table.c line 247
void * file_table_open(struct ci_lookup_table *table);
// file_table_release_result
// file lookup_file_table.c line 316
void file_table_release_result(struct ci_lookup_table *table_data, void **val);
// file_table_search
// file lookup_file_table.c line 294
void * file_table_search(struct ci_lookup_table *table, void *key, void ***vals);
// fmt_gmttime
// file txt_format.c line 399
signed int fmt_gmttime(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_http_req_head_o
// file txt_format.c line 474
signed int fmt_http_req_head_o(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_http_req_url_o
// file txt_format.c line 466
signed int fmt_http_req_url_o(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_http_res_head_o
// file txt_format.c line 497
signed int fmt_http_res_head_o(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_httpclientip
// file txt_format.c line 429
signed int fmt_httpclientip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_httpserverip
// file txt_format.c line 448
signed int fmt_httpserverip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icap_req_head
// file txt_format.c line 525
signed int fmt_icap_req_head(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icap_res_head
// file txt_format.c line 549
signed int fmt_icap_res_head(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icapmethod
// file txt_format.c line 338
signed int fmt_icapmethod(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icapstatus
// file txt_format.c line 416
signed int fmt_icapstatus(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_localip
// file txt_format.c line 327
signed int fmt_localip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_localtime
// file txt_format.c line 382
signed int fmt_localtime(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_logstr
// file txt_format.c line 645
signed int fmt_logstr(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_none
// file txt_format.c line 142
signed int fmt_none(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_percent
// file txt_format.c line 151
signed int fmt_percent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_remoteip
// file txt_format.c line 316
signed int fmt_remoteip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_attribute
// file txt_format.c line 659
signed int fmt_req_attribute(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_body_bytes_rcv
// file txt_format.c line 593
signed int fmt_req_body_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_body_bytes_sent
// file txt_format.c line 597
signed int fmt_req_body_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_bytes_rcv
// file txt_format.c line 577
signed int fmt_req_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_bytes_sent
// file txt_format.c line 581
signed int fmt_req_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_http_bytes_rcv
// file txt_format.c line 585
signed int fmt_req_http_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_http_bytes_sent
// file txt_format.c line 589
signed int fmt_req_http_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_preview_hex
// file txt_format.c line 601
signed int fmt_req_preview_hex(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_preview_len
// file txt_format.c line 633
signed int fmt_req_preview_len(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_request
// file txt_format.c line 365
signed int fmt_request(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_seconds
// file txt_format.c line 422
signed int fmt_seconds(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_service
// file txt_format.c line 347
signed int fmt_service(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_username
// file txt_format.c line 356
signed int fmt_username(struct ci_request *req, char *buf, signed int len, const char *param);
// fopen64
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen64(const char *, const char *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_a_buffer
// file decode.c line 203
static void free_a_buffer(void *op, void *ptr);
// free_cmp_uint64_data
// file acl.c line 997
void free_cmp_uint64_data(struct ci_request *req, void *param);
// free_data_type
// file acl.c line 976
void free_data_type(struct ci_request *req, void *param);
// free_http_req_header
// file acl.c line 938
void free_http_req_header(struct ci_request *req, void *param);
// free_http_resp_header
// file acl.c line 952
void free_http_resp_header(struct ci_request *req, void *param);
// free_icap_header
// file acl.c line 911
void free_icap_header(struct ci_request *req, void *param);
// free_icap_response_header
// file acl.c line 925
void free_icap_response_header(struct ci_request *req, void *param);
// free_records_group
// file filetype.c line 167
void free_records_group(struct ci_magic_record *record);
// free_time_data
// file acl.c line 394
void free_time_data(struct ci_request *req, void *param);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fstat64
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat64(signed int, struct stat *);
// ftruncate64
// file /usr/include/unistd.h line 1022
extern signed int ftruncate64(signed int, signed long int);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_client_ip
// file acl.c line 60
void * get_client_ip(struct ci_request *req, char *param);
// get_content_length
// file acl.c line 980
void * get_content_length(struct ci_request *req, char *param);
// get_data_type
// file acl.c line 961
void * get_data_type(struct ci_request *req, char *param);
// get_encaps_type
// file header.c line 573
signed int get_encaps_type(const char *buf, signed int *val, char **endpoint);
// get_header
// file acl.c line 872
const char * get_header(struct ci_headers_list *headers, char *head);
// get_http_client_ip
// file acl.c line 68
void * get_http_client_ip(struct ci_request *req, char *param);
// get_http_req_header
// file acl.c line 932
void * get_http_req_header(struct ci_request *req, char *param);
// get_http_resp_header
// file acl.c line 945
void * get_http_resp_header(struct ci_request *req, char *param);
// get_icap_header
// file acl.c line 904
void * get_icap_header(struct ci_request *req, char *param);
// get_icap_response_header
// file acl.c line 918
void * get_icap_response_header(struct ci_request *req, char *param);
// get_port
// file acl.c line 56
void * get_port(struct ci_request *req, char *param);
// get_reqtype
// file acl.c line 52
void * get_reqtype(struct ci_request *req, char *param);
// get_request_options
// file request_common.c line 757
static signed int get_request_options(struct ci_request *req, struct ci_headers_list *h);
// get_service
// file acl.c line 48
void * get_service(struct ci_request *req, char *param);
// get_srv_ip
// file acl.c line 64
void * get_srv_ip(struct ci_request *req, char *param);
// get_time_data
// file acl.c line 401
void * get_time_data(struct ci_request *req, char *param);
// get_user
// file acl.c line 44
void * get_user(struct ci_request *req, char *param);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, union anonymous$13, unsigned int *);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// groups_add
// file filetype.c line 104
signed int groups_add(struct ci_magics_db *db, const char *name, const char *descr);
// groups_init
// file filetype.c line 82
signed int groups_init(struct ci_magics_db *db);
// hash_table_close
// file lookup_file_table.c line 365
void hash_table_close(struct ci_lookup_table *table);
// hash_table_open
// file lookup_file_table.c line 339
void * hash_table_open(struct ci_lookup_table *table);
// hash_table_release_result
// file lookup_file_table.c line 396
void hash_table_release_result(struct ci_lookup_table *table_data, void **val);
// hash_table_search
// file lookup_file_table.c line 377
void * hash_table_search(struct ci_lookup_table *table, void *key, void ***vals);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// icap_init_server
// file os/unix/net_io.c line 87
signed int icap_init_server(char *address, signed int port, signed int *protocol_family, signed int secs_to_linger);
// icap_socket_opts
// file os/unix/net_io.c line 135
signed int icap_socket_opts(signed int fd, signed int secs_to_linger);
// index
// file /usr/include/strings.h line 72
extern char * index(const char *, signed int);
// inet_aton
// file /usr/include/arpa/inet.h line 73
extern signed int inet_aton(const char *, struct in_addr *);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// inflate
// file /usr/include/zlib.h line 392
extern signed int inflate(struct z_stream_s *, signed int);
// inflateEnd
// file /usr/include/zlib.h line 508
extern signed int inflateEnd(struct z_stream_s *);
// inflateInit2_
// file /usr/include/zlib.h line 1641
extern signed int inflateInit2_(struct z_stream_s *, signed int, const char *, signed int);
// init_body_system
// file body.c line 49
signed int init_body_system();
// init_child_mutexes
// file os/unix/threads.c line 46
static void init_child_mutexes();
// init_internal_lookup_tables
// file lookup_table.c line 241
void init_internal_lookup_tables();
// init_pack_allocator
// file mem.c line 661
struct ci_mem_allocator * init_pack_allocator(struct ci_mem_allocator *allocator, struct pack_allocator *pack_alloc, char *memblock, unsigned long int size, signed int free);
// int32_cmp
// file types_ops.c line 125
signed int int32_cmp(const void *key1, const void *key2);
// int32_dup
// file types_ops.c line 107
void * int32_dup(const char *str, struct ci_mem_allocator *allocator);
// int32_equal
// file types_ops.c line 138
signed int int32_equal(const void *key1, const void *key2);
// int32_free
// file types_ops.c line 151
void int32_free(void *key, struct ci_mem_allocator *allocator);
// int32_len
// file types_ops.c line 146
unsigned long int int32_len(const void *key);
// ip_cmp
// file types_ops.c line 520
signed int ip_cmp(const void *ref_key, const void *key_check);
// ip_dup
// file types_ops.c line 448
void * ip_dup(const char *value, struct ci_mem_allocator *allocator);
// ip_equal
// file types_ops.c line 525
signed int ip_equal(const void *ref_key, const void *key_check);
// ip_free
// file types_ops.c line 511
void ip_free(void *data, struct ci_mem_allocator *allocator);
// ip_len
// file types_ops.c line 515
unsigned long int ip_len(const void *key);
// ip_sockaddr_cmp
// file types_ops.c line 556
signed int ip_sockaddr_cmp(const void *ref_key, const void *key_check);
// ip_sockaddr_equal
// file types_ops.c line 561
signed int ip_sockaddr_equal(const void *ref_key, const void *key_check);
// isUTF8
// file filetype.c line 439
signed int isUTF8(unsigned char *c, signed int size);
// list_alloc_item
// file array.c line 562
static struct ci_list_item * list_alloc_item(struct ci_list *list, const void *data);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// load_module
// file test_cache.c line 16
signed int load_module(const char *directive, const char **argv, void *setdata);
// load_text_table
// file lookup_file_table.c line 205
signed int load_text_table(char *filename, struct ci_lookup_table *table);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_errors
// file test_cache.c line 46
void log_errors(void *unused, const char *format, ...);
// lookup_table_get_row
// file lookup_table.c line 205
static const void * lookup_table_get_row(struct ci_lookup_table *table, const void *key, const char **columns, void ***vals);
// lseek64
// file /usr/include/unistd.h line 340
extern signed long int lseek64(signed int, signed long int, signed int);
// magics_add
// file filetype.c line 116
signed int magics_add(struct ci_magics_db *db, signed int offset, unsigned char *magic, unsigned long int len, signed int type);
// magics_init
// file filetype.c line 83
signed int magics_init(struct ci_magics_db *db);
// makeTemplatePathFileName
// file txtTemplate.c line 70
static void makeTemplatePathFileName(char *path, signed int path_len, const char *service_name, const char *page_name, const char *lang);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mem_init
// file test_cache.c line 65
signed int mem_init();
// mem_reset
// file mem.c line 58
void mem_reset();
// memcmp
// file /usr/include/string.h line 65
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// mk_encaps_entity
// file header.c line 547
struct ci_encaps_entity * mk_encaps_entity(signed int type, signed int val);
// mkstemp64
// file /usr/include/stdlib.h line 622
extern signed int mkstemp64(char *);
// mmap64
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 61
extern void * mmap64(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mmap_shared_mem_attach
// file os/unix/shared_mem.c line 118
void * mmap_shared_mem_attach(struct ci_shared_mem_id *id);
// mmap_shared_mem_create
// file os/unix/shared_mem.c line 103
void * mmap_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// mmap_shared_mem_destroy
// file os/unix/shared_mem.c line 131
signed int mmap_shared_mem_destroy(struct ci_shared_mem_id *id);
// mmap_shared_mem_detach
// file os/unix/shared_mem.c line 124
signed int mmap_shared_mem_detach(struct ci_shared_mem_id *id);
// mmap_shared_mem_print_info
// file os/unix/shared_mem.c line 137
signed int mmap_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// net_data_read
// file request_common.c line 627
signed int net_data_read(struct ci_request *req);
// open64
// file /usr/include/fcntl.h line 159
extern signed int open64(const char *, signed int, ...);
// os_allocator_alloc
// file mem.c line 404
static void * os_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// os_allocator_destroy
// file mem.c line 419
static void os_allocator_destroy(struct ci_mem_allocator *allocator);
// os_allocator_free
// file mem.c line 409
static void os_allocator_free(struct ci_mem_allocator *allocator, void *p);
// os_allocator_reset
// file mem.c line 414
static void os_allocator_reset(struct ci_mem_allocator *allocator);
// parse_chunk_data
// file request_common.c line 492
signed int parse_chunk_data(struct ci_request *req, char **wdata);
// parse_directive
// file txt_format.c line 160
unsigned int parse_directive(const char *var, unsigned int *width, signed int *left_align, char *parameter);
// parse_record
// file filetype.c line 179
static signed int parse_record(char *line, struct ci_magic_record *record);
// pcre_compile
// file /usr/include/pcre.h line 540
extern struct real_pcre * pcre_compile(const char *, signed int, const char **, signed int *, const unsigned char *);
// pcre_exec
// file /usr/include/pcre.h line 573
extern signed int pcre_exec(const struct real_pcre *, const struct pcre_extra *, const char *, signed int, signed int, signed int, signed int *, signed int);
// pcre_free$object
//
void pcre_free$object(void *);
// pointers_cmp
// file array.c line 685
static signed int pointers_cmp(const void *obj1, const void *obj2, unsigned long int size);
// pool_allocator_alloc
// file mem.c line 796
static void * pool_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// pool_allocator_build
// file mem.c line 775
static struct pool_allocator * pool_allocator_build(signed int items_size, signed int strict);
// pool_allocator_destroy
// file mem.c line 880
static void pool_allocator_destroy(struct ci_mem_allocator *allocator);
// pool_allocator_free
// file mem.c line 829
static void pool_allocator_free(struct ci_mem_allocator *allocator, void *p);
// pool_allocator_reset
// file mem.c line 850
static void pool_allocator_reset(struct ci_mem_allocator *allocator);
// posix_proc_mutex_destroy
// file os/unix/proc_mutex.c line 139
static signed int posix_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// posix_proc_mutex_init
// file os/unix/proc_mutex.c line 118
static signed int posix_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// posix_proc_mutex_lock
// file os/unix/proc_mutex.c line 147
static signed int posix_proc_mutex_lock(struct ci_proc_mutex *mutex);
// posix_proc_mutex_print_info
// file os/unix/proc_mutex.c line 165
static signed int posix_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size);
// posix_proc_mutex_unlock
// file os/unix/proc_mutex.c line 156
static signed int posix_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// posix_shared_mem_attach
// file os/unix/shared_mem.c line 179
void * posix_shared_mem_attach(struct ci_shared_mem_id *id);
// posix_shared_mem_create
// file os/unix/shared_mem.c line 157
void * posix_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// posix_shared_mem_destroy
// file os/unix/shared_mem.c line 192
signed int posix_shared_mem_destroy(struct ci_shared_mem_id *id);
// posix_shared_mem_detach
// file os/unix/shared_mem.c line 184
signed int posix_shared_mem_detach(struct ci_shared_mem_id *id);
// posix_shared_mem_print_info
// file os/unix/shared_mem.c line 201
signed int posix_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_encapsulated
// file request_common.c line 456
signed int process_encapsulated(struct ci_request *req, const char *buf);
// pthread_atfork
// file /usr/include/pthread.h line 1145
extern signed int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
// pthread_cond_destroy
// file /usr/include/pthread.h line 973
extern signed int pthread_cond_destroy(union anonymous$6 *);
// pthread_cond_init
// file /usr/include/pthread.h line 968
extern signed int pthread_cond_init(union anonymous$6 *, const union anonymous$4 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 250
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous$8 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 749
extern signed int pthread_mutex_init(union anonymous$8 *, const union anonymous$4 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous$8 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous$8 *);
// pthread_rwlock_destroy
// file /usr/include/pthread.h line 893
extern signed int pthread_rwlock_destroy(union anonymous$10 *);
// pthread_rwlock_init
// file /usr/include/pthread.h line 888
extern signed int pthread_rwlock_init(union anonymous$10 *, const union anonymous$7 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 897
extern signed int pthread_rwlock_rdlock(union anonymous$10 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 927
extern signed int pthread_rwlock_unlock(union anonymous$10 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 912
extern signed int pthread_rwlock_wrlock(union anonymous$10 *);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// read_row
// file lookup_file_table.c line 102
signed int read_row(struct _IO_FILE *f, signed int cols, struct text_table_entry **e, struct ci_lookup_table *table);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// regex_cmp
// file types_ops.c line 271
signed int regex_cmp(const void *key1, const void *key2);
// regex_dup
// file types_ops.c line 238
void * regex_dup(const char *str, struct ci_mem_allocator *allocator);
// regex_equal
// file types_ops.c line 279
signed int regex_equal(const void *key1, const void *key2);
// regex_free
// file types_ops.c line 292
void regex_free(void *key, struct ci_mem_allocator *allocator);
// regex_len
// file types_ops.c line 287
unsigned long int regex_len(const void *key);
// regex_table_close
// file lookup_file_table.c line 440
void regex_table_close(struct ci_lookup_table *table);
// regex_table_open
// file lookup_file_table.c line 419
void * regex_table_open(struct ci_lookup_table *table);
// regex_table_release_result
// file lookup_file_table.c line 461
void regex_table_release_result(struct ci_lookup_table *table_data, void **val);
// regex_table_search
// file lookup_file_table.c line 451
void * regex_table_search(struct ci_lookup_table *table, void *key, void ***vals);
// release_body_system
// file body.c line 74
void release_body_system();
// release_header_value
// file acl.c line 898
void release_header_value(struct ci_headers_list *headers, char *head);
// release_text_table_entry
// file lookup_file_table.c line 81
void release_text_table_entry(struct text_table_entry *e, struct ci_lookup_table *table);
// request_match_specslist
// file acl.c line 716
signed int request_match_specslist(struct ci_request *req, struct ci_specs_list *spec_list);
// resize_buffer
// file body.c line 343
signed int resize_buffer(struct ci_cached_file *body, signed int new_size);
// search_options_table
// file cfg_lib.c line 76
struct ci_options_entry * search_options_table(const char *directive, struct ci_options_entry *options);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous *, struct anonymous *, struct anonymous *, struct timeval *);
// sem_open
// file /usr/include/semaphore.h line 42
extern union anonymous$1 * sem_open(const char *, signed int, ...);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous$1 *);
// sem_unlink
// file /usr/include/semaphore.h line 48
extern signed int sem_unlink(const char *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous$1 *);
// semctl
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 52
extern signed int semctl(signed int, signed int, signed int, ...);
// semget
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 55
extern signed int semget(signed int, signed int, signed int);
// semop
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 58
extern signed int semop(signed int, struct sembuf *, unsigned long int);
// serial_allocation
// file mem.c line 476
static void * serial_allocation(struct serial_allocator *serial_alloc, unsigned long int size);
// serial_allocator_alloc
// file mem.c line 499
static void * serial_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// serial_allocator_build
// file mem.c line 453
static struct serial_allocator * serial_allocator_build(signed int size);
// serial_allocator_destroy
// file mem.c line 530
static void serial_allocator_destroy(struct ci_mem_allocator *allocator);
// serial_allocator_free
// file mem.c line 508
static void serial_allocator_free(struct ci_mem_allocator *allocator, void *p);
// serial_allocator_reset
// file mem.c line 513
static void serial_allocator_reset(struct ci_mem_allocator *allocator);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shm_open
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 144
extern signed int shm_open(const char *, signed int, unsigned int);
// shm_unlink
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 147
extern signed int shm_unlink(const char *);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sizeof_pack_allocator
// file mem.c line 735
static unsigned long int sizeof_pack_allocator();
// sizeofencaps
// file header.c line 613
signed int sizeofencaps(struct ci_encaps_entity *e);
// sizeofheader
// file header.c line 600
signed int sizeofheader(struct ci_headers_list *h);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// spec_data_check
// file acl.c line 699
signed int spec_data_check(const struct ci_acl_spec *spec, const void *req_raw_data);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat64
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat64(const char *, struct stat *);
// stat_entry_add
// file stats.c line 40
signed int stat_entry_add(struct stat_entry_list *list, const char *label, signed int type, signed int gid);
// stat_entry_by_name
// file stats.c line 88
signed int stat_entry_by_name(struct stat_entry_list *list, const char *label);
// stat_entry_release_list
// file stats.c line 75
void stat_entry_release_list(struct stat_entry_list *list);
// stat_group_add
// file stats.c line 100
signed int stat_group_add(char *group);
// stat_memblock_fix
// file stats.c line 273
void stat_memblock_fix(struct stat_memblock *mem_block);
// stat_memblock_reconstruct
// file stats.c line 284
void stat_memblock_reconstruct(struct stat_memblock *mem_block);
// strcasecmp
// file /usr/include/strings.h line 112
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 368
extern char * strcasestr(const char *, const char *);
// strcat
// file /usr/include/string.h line 133
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// strerror_r
// file /usr/include/string.h line 433
extern char * strerror_r(signed int, char *, unsigned long int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_ext_cmp
// file types_ops.c line 73
signed int string_ext_cmp(const void *key1, const void *key2);
// string_ext_equal
// file types_ops.c line 84
signed int string_ext_equal(const void *key1, const void *key2);
// stringcmp
// file types_ops.c line 41
signed int stringcmp(const void *key1, const void *key2);
// stringdup
// file types_ops.c line 33
void * stringdup(const char *str, struct ci_mem_allocator *allocator);
// stringequal
// file types_ops.c line 48
signed int stringequal(const void *key1, const void *key2);
// stringfree
// file types_ops.c line 60
void stringfree(void *key, struct ci_mem_allocator *allocator);
// stringlen
// file types_ops.c line 55
unsigned long int stringlen(const void *key);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/strings.h line 116
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 136
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 337
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// sysv_proc_mutex_destroy
// file os/unix/proc_mutex.c line 74
static signed int sysv_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// sysv_proc_mutex_init
// file os/unix/proc_mutex.c line 56
static signed int sysv_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// sysv_proc_mutex_lock
// file os/unix/proc_mutex.c line 83
static signed int sysv_proc_mutex_lock(struct ci_proc_mutex *mutex);
// sysv_proc_mutex_print_info
// file os/unix/proc_mutex.c line 99
static signed int sysv_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size);
// sysv_proc_mutex_unlock
// file os/unix/proc_mutex.c line 91
static signed int sysv_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// sysv_shared_mem_attach
// file os/unix/shared_mem.c line 56
void * sysv_shared_mem_attach(struct ci_shared_mem_id *id);
// sysv_shared_mem_create
// file os/unix/shared_mem.c line 40
void * sysv_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// sysv_shared_mem_destroy
// file os/unix/shared_mem.c line 73
signed int sysv_shared_mem_destroy(struct ci_shared_mem_id *id);
// sysv_shared_mem_detach
// file os/unix/shared_mem.c line 64
signed int sysv_shared_mem_detach(struct ci_shared_mem_id *id);
// sysv_shared_mem_print_info
// file os/unix/shared_mem.c line 84
signed int sysv_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size);
// templateExpired
// file txtTemplate.c line 109
static signed int templateExpired(struct anonymous$20 *template);
// templateFind
// file txtTemplate.c line 208
static struct anonymous$20 * templateFind(const char *SERVICE_NAME, const char *TEMPLATE_NAME, const char *LANGUAGE);
// templateFindFree
// file txtTemplate.c line 228
static struct anonymous$20 * templateFindFree(void);
// templateFree
// file txtTemplate.c line 136
static void templateFree(struct anonymous$20 *template);
// templateLoadText
// file txtTemplate.c line 347
static struct anonymous$20 * templateLoadText(const struct ci_request *req, const char *service_name, const char *page_name);
// templateTryLoadText
// file txtTemplate.c line 251
static struct anonymous$20 * templateTryLoadText(const struct ci_request *req, const char *service_name, const char *page_name, const char *lang);
// template_release
// file txtTemplate.c line 152
static void template_release(struct anonymous$20 *template);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// types_add
// file filetype.c line 86
signed int types_add(struct ci_magics_db *db, const char *name, const char *descr, signed int *groups);
// types_init
// file filetype.c line 81
signed int types_init(struct ci_magics_db *db);
// uint64_cmp
// file types_ops.c line 183
signed int uint64_cmp(const void *key1, const void *key2);
// uint64_dup
// file types_ops.c line 166
void * uint64_dup(const char *str, struct ci_mem_allocator *allocator);
// uint64_equal
// file types_ops.c line 196
signed int uint64_equal(const void *key1, const void *key2);
// uint64_free
// file types_ops.c line 204
void uint64_free(void *key, struct ci_mem_allocator *allocator);
// uint64_len
// file types_ops.c line 209
unsigned long int uint64_len(const void *key);
// unlink
// file /usr/include/unistd.h line 829
extern signed int unlink(const char *);
// url_decoder
// file decode.c line 131
signed int url_decoder(const char *input, char *output, signed int output_len);
// url_decoder2
// file decode.c line 164
signed int url_decoder2(char *input);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);
// zlib_inflate
// file decode.c line 208
static signed int zlib_inflate(const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len);

struct anonymous$20
{
  // TEMPLATE_NAME
  char *TEMPLATE_NAME;
  // SERVICE_NAME
  char *SERVICE_NAME;
  // LANGUAGE
  char *LANGUAGE;
  // data
  struct ci_membuf *data;
  // last_used
  signed long int last_used;
  // loaded
  signed long int loaded;
  // modified
  signed long int modified;
  // locked
  signed int locked;
  // must_free
  signed int must_free;
  // non_cached
  signed int non_cached;
};

struct anonymous$17
{
  // sem
  union anonymous$1 *sem;
};

struct anonymous
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$5
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$9
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous$18
{
  // fd
  signed int fd;
};

struct anonymous$16
{
  // id
  signed int id;
};

union anonymous$11
{
  // mutex
  union anonymous$8 *mutex;
  // rwlock
  union anonymous$10 *rwlock;
};

union anonymous$12
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$1
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous$4
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$7
{
  // __size
  char __size[8l];
  // __align
  signed long int __align;
};

union anonymous$14
{
  // __align
  double __align;
  // ptr
  char ptr[1l];
};

union anonymous$6
{
  // __data
  struct anonymous$5 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous$10
{
  // __data
  struct anonymous$9 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

union anonymous$2
{
  // sysv
  struct anonymous$16 sysv;
  // posix
  struct anonymous$17 posix;
  // file
  struct anonymous$18 file;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$8
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ci_proc_mutex
{
  // name
  char name[64l];
  // scheme
  const struct ci_proc_mutex_scheme *scheme;
  // $anon0
  union anonymous$2 $anon0;
};

union anonymous$15
{
  // proc_mutex
  struct ci_proc_mutex proc_mutex;
  // thread_mutex
  union anonymous$8 thread_mutex;
};

struct posix
{
  // fd
  signed int fd;
};

struct sysv
{
  // id
  signed int id;
};

union anonymous$3
{
  // posix
  struct posix posix;
  // sysv
  struct sysv sysv;
  // id_
  signed int id_;
};

union anonymous$0
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$13
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _ci_align_test
{
  // n
  char n[1l];
  // d
  double d;
};

struct acl_cmp_uint64_data
{
  // data
  unsigned long int data;
  // operator
  signed int operator;
};

struct acl_time_data
{
  // days
  unsigned int days;
  // start_time
  unsigned int start_time;
  // end_time
  unsigned int end_time;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct check_reg_data
{
  // name
  const char *name;
  // found
  signed int found;
  // count
  signed int count;
};

struct ci_MD5Context
{
  // buf
  unsigned int buf[4l];
  // bits
  unsigned int bits[2l];
  // in
  unsigned char in[64l];
};

struct ci_access_entry
{
  // type
  signed int type;
  // spec_list
  struct ci_specs_list *spec_list;
  // next
  struct ci_access_entry *next;
};

struct ci_acl_data
{
  // data
  void *data;
  // next
  struct ci_acl_data *next;
};

struct ci_acl_regex
{
  // str
  char *str;
  // flags
  signed int flags;
  // preg
  void *preg;
};

struct ci_acl_spec
{
  // name
  char name[32l];
  // type
  const struct ci_acl_type *type;
  // parameter
  char *parameter;
  // data
  struct ci_acl_data *data;
  // next
  struct ci_acl_spec *next;
};

struct ci_acl_type
{
  // name
  char name[32l];
  // get_test_data
  void * (*get_test_data)(struct ci_request *, char *);
  // free_test_data
  void (*free_test_data)(struct ci_request *, void *);
  // type
  const struct ci_type_ops *type;
};

struct ci_acl_type_list
{
  // acl_type_list
  struct ci_acl_type *acl_type_list;
  // acl_type_list_size
  signed int acl_type_list_size;
  // acl_type_list_num
  signed int acl_type_list_num;
};

struct ci_array
{
  // items
  struct ci_array_item *items;
  // mem
  char *mem;
  // max_size
  unsigned long int max_size;
  // count
  unsigned int count;
  // alloc
  struct ci_mem_allocator *alloc;
};

struct ci_array_item
{
  // name
  char *name;
  // value
  void *value;
};

struct ci_buf
{
  // buf
  char *buf;
  // size
  signed int size;
  // used
  signed int used;
};

struct ci_cache
{
  // init
  signed int (*init)(struct ci_cache *, const char *);
  // search
  const void * (*search)(struct ci_cache *, const void *, void **, void *, void * (*)(const void *, unsigned long int, void *));
  // update
  signed int (*update)(struct ci_cache *, const void *, const void *, unsigned long int, void * (*)(void *, const void *, unsigned long int));
  // destroy
  void (*destroy)(struct ci_cache *);
  // ttl
  signed long int ttl;
  // mem_size
  unsigned int mem_size;
  // max_object_size
  unsigned int max_object_size;
  // flags
  unsigned int flags;
  // key_ops
  const struct ci_type_ops *key_ops;
  // _cache_type
  const struct ci_cache_type *_cache_type;
  // cache_data
  void *cache_data;
};

struct ci_cache_entry
{
  // hash
  unsigned int hash;
  // time
  signed long int time;
  // key
  void *key;
  // val
  void *val;
  // val_size
  signed int val_size;
  // qnext
  struct ci_cache_entry *qnext;
  // hnext
  struct ci_cache_entry *hnext;
};

struct ci_cache_type
{
  // init
  signed int (*init)(struct ci_cache *, const char *);
  // search
  const void * (*search)(struct ci_cache *, const void *, void **, void *, void * (*)(const void *, unsigned long int, void *));
  // update
  signed int (*update)(struct ci_cache *, const void *, const void *, unsigned long int, void * (*)(void *, const void *, unsigned long int));
  // destroy
  void (*destroy)(struct ci_cache *);
  // name
  const char *name;
};

struct ci_cached_file
{
  // endpos
  signed long int endpos;
  // readpos
  signed long int readpos;
  // bufsize
  signed int bufsize;
  // flags
  signed int flags;
  // unlocked
  signed long int unlocked;
  // buf
  char *buf;
  // fd
  signed int fd;
  // filename
  char filename[4097l];
  // attributes
  struct ci_array *attributes;
};

struct ci_conf_entry
{
  // name
  const char *name;
  // data
  void *data;
  // action
  signed int (*action)(const char *, const char **, void *);
  // msg
  const char *msg;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct ci_sockaddr
{
  // sockaddr
  struct sockaddr_in sockaddr;
  // ci_sin_family
  signed int ci_sin_family;
  // ci_sin_port
  signed int ci_sin_port;
  // ci_sin_addr
  void *ci_sin_addr;
  // ci_inaddr_len
  signed int ci_inaddr_len;
};

struct ci_connection
{
  // fd
  signed int fd;
  // claddr
  struct ci_sockaddr claddr;
  // srvaddr
  struct ci_sockaddr srvaddr;
};

struct ci_data_group
{
  // name
  char name[16l];
  // descr
  char descr[51l];
};

struct ci_data_type
{
  // name
  char name[16l];
  // descr
  char descr[51l];
  // groups
  signed int groups[64l];
};

struct ci_dyn_array
{
  // items
  struct ci_array_item **items;
  // count
  signed int count;
  // max_items
  signed int max_items;
  // alloc
  struct ci_mem_allocator *alloc;
};

struct ci_encaps_entity
{
  // start
  signed int start;
  // type
  signed int type;
  // entity
  void *entity;
};

struct ci_error_code
{
  // code
  signed int code;
  // str
  char *str;
};

struct ci_fmt_entry
{
  // directive
  const char *directive;
  // description
  const char *description;
  // format
  signed int (*format)(struct ci_request *, char *, signed int, const char *);
};

struct ci_hash_entry
{
  // hash
  unsigned int hash;
  // key
  const void *key;
  // val
  const void *val;
  // hnext
  struct ci_hash_entry *hnext;
};

struct ci_hash_table
{
  // hash_table
  struct ci_hash_entry **hash_table;
  // hash_table_size
  unsigned int hash_table_size;
  // ops
  const struct ci_type_ops *ops;
  // allocator
  struct ci_mem_allocator *allocator;
};

struct ci_headers_list
{
  // size
  signed int size;
  // used
  signed int used;
  // headers
  char **headers;
  // bufsize
  signed int bufsize;
  // bufused
  signed int bufused;
  // buf
  char *buf;
  // packed
  signed int packed;
};

struct ci_ip
{
  // address
  struct in_addr address;
  // netmask
  struct in_addr netmask;
  // family
  signed int family;
};

struct ci_list
{
  // items
  struct ci_list_item *items;
  // last
  struct ci_list_item *last;
  // trash
  struct ci_list_item *trash;
  // cursor
  struct ci_list_item *cursor;
  // tmp
  struct ci_list_item *tmp;
  // obj_size
  unsigned long int obj_size;
  // alloc
  struct ci_mem_allocator *alloc;
  // cmp_func
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  // copy_func
  signed int (*copy_func)(void *, const void *);
  // free_func
  void (*free_func)(void *);
};

struct ci_list_item
{
  // item
  void *item;
  // next
  struct ci_list_item *next;
};

struct common_mutex
{
  // isproc
  signed int isproc;
  // mtx
  union anonymous$15 mtx;
};

struct ci_local_cache_data
{
  // first_queue_entry
  struct ci_cache_entry *first_queue_entry;
  // last_queue_entry
  struct ci_cache_entry *last_queue_entry;
  // hash_table
  struct ci_cache_entry **hash_table;
  // hash_table_size
  unsigned int hash_table_size;
  // allocator
  struct ci_mem_allocator *allocator;
  // mtx
  struct common_mutex mtx;
};

struct ci_lookup_table
{
  // open
  void * (*open)(struct ci_lookup_table *);
  // close
  void (*close)(struct ci_lookup_table *);
  // search
  void * (*search)(struct ci_lookup_table *, void *, void ***);
  // release_result
  void (*release_result)(struct ci_lookup_table *, void **);
  // get_row
  const void * (*get_row)(struct ci_lookup_table *, const void *, const char **, void ***);
  // type
  char *type;
  // path
  char *path;
  // args
  char *args;
  // cols
  signed int cols;
  // col_names
  struct ci_vector *col_names;
  // key_ops
  const struct ci_type_ops *key_ops;
  // val_ops
  const struct ci_type_ops *val_ops;
  // allocator
  struct ci_mem_allocator *allocator;
  // _lt_type
  struct ci_lookup_table_type *_lt_type;
  // data
  void *data;
};

struct ci_lookup_table_type
{
  // open
  void * (*open)(struct ci_lookup_table *);
  // close
  void (*close)(struct ci_lookup_table *);
  // search
  void * (*search)(struct ci_lookup_table *, void *, void ***);
  // release_result
  void (*release_result)(struct ci_lookup_table *, void **);
  // get_row
  const void * (*get_row)(struct ci_lookup_table *, const void *, const char **, void ***);
  // type
  char *type;
};

struct ci_magic
{
  // offset
  signed int offset;
  // magic
  unsigned char magic[51l];
  // len
  unsigned long int len;
  // type
  unsigned int type;
};

struct ci_magic_record
{
  // offset
  signed int offset;
  // magic
  unsigned char magic[51l];
  // len
  unsigned long int len;
  // type
  char type[16l];
  // groups
  char *groups[65l];
  // descr
  char descr[51l];
};

struct ci_magics_db
{
  // types
  struct ci_data_type *types;
  // types_num
  signed int types_num;
  // types_size
  signed int types_size;
  // groups
  struct ci_data_group *groups;
  // groups_num
  signed int groups_num;
  // groups_size
  signed int groups_size;
  // magics
  struct ci_magic *magics;
  // magics_num
  signed int magics_num;
  // magics_size
  signed int magics_size;
};

struct ci_mem_allocator
{
  // alloc
  void * (*alloc)(struct ci_mem_allocator *, unsigned long int);
  // free
  void (*free)(struct ci_mem_allocator *, void *);
  // reset
  void (*reset)(struct ci_mem_allocator *);
  // destroy
  void (*destroy)(struct ci_mem_allocator *);
  // data
  void *data;
  // name
  char *name;
  // type
  signed int type;
  // must_free
  signed int must_free;
};

struct ci_membuf
{
  // endpos
  signed int endpos;
  // readpos
  signed int readpos;
  // bufsize
  signed int bufsize;
  // unlocked
  signed int unlocked;
  // flags
  unsigned int flags;
  // buf
  char *buf;
  // attributes
  struct ci_array *attributes;
};

struct ci_options_entry
{
  // name
  const char *name;
  // parameter
  const char *parameter;
  // data
  void *data;
  // action
  signed int (*action)(const char *, const char **, void *);
  // msg
  const char *msg;
};

struct ci_proc_mutex_scheme
{
  // proc_mutex_init
  signed int (*proc_mutex_init)(struct ci_proc_mutex *, const char *);
  // proc_mutex_destroy
  signed int (*proc_mutex_destroy)(struct ci_proc_mutex *);
  // proc_mutex_lock
  signed int (*proc_mutex_lock)(struct ci_proc_mutex *);
  // proc_mutex_unlock
  signed int (*proc_mutex_unlock)(struct ci_proc_mutex *);
  // proc_mutex_print_info
  signed int (*proc_mutex_print_info)(struct ci_proc_mutex *, char *, unsigned long int);
  // name
  const char *name;
};

struct ci_regex_match
{
  // s
  unsigned long int s;
  // e
  unsigned long int e;
};

struct ci_regex_replace_part
{
  // user_data
  const void *user_data;
  // matches
  struct ci_regex_match matches[10l];
};

struct ci_request
{
  // connection
  struct ci_connection *connection;
  // packed
  signed int packed;
  // type
  signed int type;
  // req_server
  char req_server[257l];
  // access_type
  signed int access_type;
  // user
  char user[256l];
  // service
  char service[64l];
  // args
  char args[255l];
  // preview
  signed int preview;
  // keepalive
  signed int keepalive;
  // allow204
  signed int allow204;
  // hasbody
  signed int hasbody;
  // responce_hasbody
  signed int responce_hasbody;
  // preview_data
  struct ci_buf preview_data;
  // current_service_mod
  struct ci_service_module *current_service_mod;
  // request_header
  struct ci_headers_list *request_header;
  // response_header
  struct ci_headers_list *response_header;
  // entities
  struct ci_encaps_entity *entities[5l];
  // trash_entities
  struct ci_encaps_entity *trash_entities[7l];
  // xheaders
  struct ci_headers_list *xheaders;
  // service_data
  void *service_data;
  // rbuf
  char rbuf[4096l];
  // wbuf
  char wbuf[4096l];
  // eof_received
  signed int eof_received;
  // data_locked
  signed int data_locked;
  // pstrblock_read
  char *pstrblock_read;
  // pstrblock_read_len
  signed int pstrblock_read_len;
  // current_chunk_len
  unsigned int current_chunk_len;
  // chunk_bytes_read
  unsigned int chunk_bytes_read;
  // write_to_module_pending
  unsigned int write_to_module_pending;
  // status
  signed int status;
  // return_code
  signed int return_code;
  // pstrblock_responce
  char *pstrblock_responce;
  // remain_send_block_bytes
  signed int remain_send_block_bytes;
  // preview_data_type
  signed int preview_data_type;
  // auth_required
  signed int auth_required;
  // log_str
  char *log_str;
  // attributes
  struct ci_array *attributes;
  // bytes_in
  unsigned long int bytes_in;
  // bytes_out
  unsigned long int bytes_out;
  // request_bytes_in
  unsigned long int request_bytes_in;
  // http_bytes_in
  unsigned long int http_bytes_in;
  // http_bytes_out
  unsigned long int http_bytes_out;
  // body_bytes_in
  unsigned long int body_bytes_in;
  // body_bytes_out
  unsigned long int body_bytes_out;
  // allow206
  signed int allow206;
  // i206_use_original_body
  signed long int i206_use_original_body;
  // xclient_ip
  struct ci_ip xclient_ip;
};

struct ci_ring_buf
{
  // buf
  char *buf;
  // end_buf
  char *end_buf;
  // read_pos
  char *read_pos;
  // write_pos
  char *write_pos;
  // full
  signed int full;
};

struct ci_server_conf
{
  // ADDRESS
  char *ADDRESS;
  // PORT
  signed int PORT;
  // PROTOCOL_FAMILY
  signed int PROTOCOL_FAMILY;
  // TMPDIR
  char *TMPDIR;
  // PIDFILE
  char *PIDFILE;
  // COMMANDS_SOCKET
  char *COMMANDS_SOCKET;
  // RUN_USER
  char *RUN_USER;
  // RUN_GROUP
  char *RUN_GROUP;
  // cfg_file
  char *cfg_file;
  // magics_file
  char *magics_file;
  // MAGIC_DB
  struct ci_magics_db *MAGIC_DB;
  // SERVICES_DIR
  char *SERVICES_DIR;
  // MODULES_DIR
  char *MODULES_DIR;
  // SERVER_ADMIN
  char *SERVER_ADMIN;
  // SERVER_NAME
  char *SERVER_NAME;
  // START_SERVERS
  signed int START_SERVERS;
  // MAX_SERVERS
  signed int MAX_SERVERS;
  // THREADS_PER_CHILD
  signed int THREADS_PER_CHILD;
  // MIN_SPARE_THREADS
  signed int MIN_SPARE_THREADS;
  // MAX_SPARE_THREADS
  signed int MAX_SPARE_THREADS;
};

struct ci_service_module
{
  // mod_name
  const char *mod_name;
  // mod_short_descr
  const char *mod_short_descr;
  // mod_type
  signed int mod_type;
  // mod_init_service
  signed int (*mod_init_service)(struct ci_service_xdata *, struct ci_server_conf *);
  // mod_post_init_service
  signed int (*mod_post_init_service)(struct ci_service_xdata *, struct ci_server_conf *);
  // mod_close_service
  void (*mod_close_service)();
  // mod_init_request_data
  void * (*mod_init_request_data)(struct ci_request *);
  // mod_release_request_data
  void (*mod_release_request_data)(void *);
  // mod_check_preview_handler
  signed int (*mod_check_preview_handler)(char *, signed int, struct ci_request *);
  // mod_end_of_data_handler
  signed int (*mod_end_of_data_handler)(struct ci_request *);
  // mod_service_io
  signed int (*mod_service_io)(char *, signed int *, char *, signed int *, signed int, struct ci_request *);
  // mod_conf_table
  struct ci_conf_entry *mod_conf_table;
  // mod_data
  void *mod_data;
};

struct ci_service_xdata
{
  // lock
  union anonymous$10 lock;
  // status
  signed int status;
  // intl_srv_conf_table
  struct ci_conf_entry *intl_srv_conf_table;
  // xopts
  unsigned long int xopts;
  // ISTag
  char ISTag[40l];
  // xincludes
  char xincludes[512l];
  // TransferPreview
  char TransferPreview[1024l];
  // TransferIgnore
  char TransferIgnore[1024l];
  // TransferComplete
  char TransferComplete[1024l];
  // preview_size
  signed int preview_size;
  // max_connections
  signed int max_connections;
  // options_ttl
  signed int options_ttl;
  // allow_204
  signed int allow_204;
  // allow_206
  signed int allow_206;
  // disable_206
  signed int disable_206;
  // stat_bytes_in
  signed int stat_bytes_in;
  // stat_bytes_out
  signed int stat_bytes_out;
  // stat_http_bytes_in
  signed int stat_http_bytes_in;
  // stat_http_bytes_out
  signed int stat_http_bytes_out;
  // stat_body_bytes_in
  signed int stat_body_bytes_in;
  // stat_body_bytes_out
  signed int stat_body_bytes_out;
  // stat_reqmods
  signed int stat_reqmods;
  // stat_respmods
  signed int stat_respmods;
  // stat_options
  signed int stat_options;
  // stat_allow204
  signed int stat_allow204;
};

struct ci_shared_mem_id
{
  // name
  char name[64l];
  // mem
  void *mem;
  // size
  unsigned long int size;
  // scheme
  const struct ci_shared_mem_scheme *scheme;
  // $anon0
  union anonymous$3 $anon0;
};

struct ci_shared_mem_scheme
{
  // shared_mem_create
  void * (*shared_mem_create)(struct ci_shared_mem_id *, const char *, signed int);
  // shared_mem_attach
  void * (*shared_mem_attach)(struct ci_shared_mem_id *);
  // shared_mem_detach
  signed int (*shared_mem_detach)(struct ci_shared_mem_id *);
  // shared_mem_destroy
  signed int (*shared_mem_destroy)(struct ci_shared_mem_id *);
  // shared_mem_print_info
  signed int (*shared_mem_print_info)(struct ci_shared_mem_id *, char *, unsigned long int);
  // name
  const char *name;
};

struct ci_simple_file
{
  // endpos
  signed long int endpos;
  // readpos
  signed long int readpos;
  // max_store_size
  signed long int max_store_size;
  // bytes_in
  signed long int bytes_in;
  // bytes_out
  signed long int bytes_out;
  // flags
  unsigned int flags;
  // unlocked
  signed long int unlocked;
  // fd
  signed int fd;
  // filename
  char filename[4097l];
  // attributes
  struct ci_array *attributes;
  // mmap_addr
  char *mmap_addr;
  // mmap_size
  signed long int mmap_size;
};

struct ci_specs_list
{
  // spec
  const struct ci_acl_spec *spec;
  // negate
  signed int negate;
  // next
  struct ci_specs_list *next;
};

struct ci_type_ops
{
  // dup
  void * (*dup)(const char *, struct ci_mem_allocator *);
  // free
  void (*free)(void *, struct ci_mem_allocator *);
  // compare
  signed int (*compare)(const void *, const void *);
  // size
  unsigned long int (*size)(const void *);
  // equal
  signed int (*equal)(const void *, const void *);
};

struct ci_vector
{
  // items
  void **items;
  // last
  void **last;
  // mem
  char *mem;
  // max_size
  unsigned long int max_size;
  // count
  signed int count;
  // alloc
  struct ci_mem_allocator *alloc;
};

struct common_module
{
  // name
  const char *name;
  // init_module
  signed int (*init_module)(struct ci_server_conf *);
  // post_init_module
  signed int (*post_init_module)(struct ci_server_conf *);
  // close_module
  void (*close_module)();
  // conf_table
  struct ci_conf_entry *conf_table;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct in6_addr
{
  // __in6_u
  union anonymous$12 __in6_u;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct kbs
{
  // kb
  unsigned long int kb;
  // bytes
  unsigned int bytes;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct mem_block_item
{
  // data
  void *data;
  // next
  struct mem_block_item *next;
};

struct mem_buffer_block
{
  // sig
  unsigned short int sig;
  // ID
  signed int ID;
  // data
  union anonymous$14 data;
};

struct mutex_itm
{
  // mtx
  union anonymous$11 mtx;
  // type
  signed int type;
  // next
  struct mutex_itm *next;
};

struct pack_allocator
{
  // memchunk
  void *memchunk;
  // curpos
  void *curpos;
  // endpos
  void *endpos;
  // end
  void *end;
  // must_free
  signed int must_free;
};

struct pcre_extra
{
  // flags
  unsigned long int flags;
  // study_data
  void *study_data;
  // match_limit
  unsigned long int match_limit;
  // callout_data
  void *callout_data;
  // tables
  const unsigned char *tables;
  // match_limit_recursion
  unsigned long int match_limit_recursion;
  // mark
  unsigned char **mark;
  // executable_jit
  void *executable_jit;
};

struct pool_allocator
{
  // items_size
  signed int items_size;
  // strict
  signed int strict;
  // alloc_count
  signed int alloc_count;
  // hits_count
  signed int hits_count;
  // mutex
  union anonymous$8 mutex;
  // free
  struct mem_block_item *free;
  // allocated
  struct mem_block_item *allocated;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sembuf
{
  // sem_num
  unsigned short int sem_num;
  // sem_op
  signed short int sem_op;
  // sem_flg
  signed short int sem_flg;
};

struct semid_ds
{
  // sem_perm
  struct ipc_perm sem_perm;
  // sem_otime
  signed long int sem_otime;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // sem_ctime
  signed long int sem_ctime;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
  // sem_nsems
  unsigned long int sem_nsems;
  // __glibc_reserved3
  unsigned long int __glibc_reserved3;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
};

struct seminfo
{
  // semmap
  signed int semmap;
  // semmni
  signed int semmni;
  // semmns
  signed int semmns;
  // semmnu
  signed int semmnu;
  // semmsl
  signed int semmsl;
  // semopm
  signed int semopm;
  // semume
  signed int semume;
  // semusz
  signed int semusz;
  // semvmx
  signed int semvmx;
  // semaem
  signed int semaem;
};

union semun
{
  // val
  signed int val;
  // buf
  struct semid_ds *buf;
  // array
  unsigned short int *array;
  // __buf
  struct seminfo *__buf;
};

struct serial_allocator
{
  // memchunk
  void *memchunk;
  // curpos
  void *curpos;
  // endpos
  void *endpos;
  // next
  struct serial_allocator *next;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct stat_area
{
  // mtx
  union anonymous$8 mtx;
  // release_mem
  void (*release_mem)(void *);
  // mem_block
  struct stat_memblock *mem_block;
};

struct stat_entry
{
  // label
  char *label;
  // type
  signed int type;
  // gid
  signed int gid;
};

struct stat_entry_list
{
  // entries
  struct stat_entry *entries;
  // size
  signed int size;
  // entries_num
  signed int entries_num;
};

struct stat_groups_list
{
  // groups
  char **groups;
  // size
  signed int size;
  // entries_num
  signed int entries_num;
};

struct stat_memblock
{
  // sig
  unsigned int sig;
  // counters64_size
  signed int counters64_size;
  // counterskbs_size
  signed int counterskbs_size;
  // counters64
  unsigned long int *counters64;
  // counterskbs
  struct kbs *counterskbs;
};

struct text_table
{
  // entries
  struct text_table_entry *entries;
  // hash_table
  struct ci_hash_table *hash_table;
  // rows
  signed int rows;
};

struct text_table_entry
{
  // key
  void *key;
  // vals
  void **vals;
  // next
  struct text_table_entry *next;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};


// CACHED_FILE_POOL
// file body.c line 45
static signed int CACHED_FILE_POOL = -1;
// CACHE_TYPE
// file test_cache.c line 54
char *CACHE_TYPE = (char *)(void *)0;
// CI_BODY_MAX_MEM
// file body.c line 334
signed int CI_BODY_MAX_MEM = 131072;
// CI_DEBUG_LEVEL
// file debug.c line 26
signed int CI_DEBUG_LEVEL = 1;
// CI_DEBUG_STDOUT
// file debug.c line 27
signed int CI_DEBUG_STDOUT = 0;
// CI_TMPDIR
// file body.c line 335
char *CI_TMPDIR = "/var/tmp/";
// GlobalTable
// file txt_format.c line 100
struct ci_fmt_entry GlobalTable[35l];
// GlobalTable
// file txt_format.c line 100
struct ci_fmt_entry GlobalTable[35l] = { { .directive="%a", .description="Remote IP-Address", .format=fmt_remoteip },
    { .directive="%la", .description="Local IP Address", .format=fmt_localip },
    { .directive="%lp", .description="Local port", .format=fmt_none },
    { .directive="%>a", .description="Http Client IP Address", .format=fmt_httpclientip },
    { .directive="%<A", .description="Http Server IP Address", .format=fmt_httpserverip },
    { .directive="%ts", .description="Seconds since epoch", .format=fmt_seconds },
    { .directive="%tl", .description="Local time", .format=fmt_localtime },
    { .directive="%tg", .description="GMT time", .format=fmt_gmttime },
    { .directive="%tr", .description="Response time", .format=fmt_none },
    { .directive="%>hi", .description="Http request header", .format=fmt_none },
    { .directive="%>ho", .description="Modified Http request header", .format=fmt_http_req_head_o },
    { .directive="%huo", .description="Modified Http request url", .format=fmt_http_req_url_o },
    { .directive="%hu", .description="Http request url", .format=fmt_none },
    { .directive="%<hi", .description="Http reply header", .format=fmt_none },
    { .directive="%<ho", .description="Modified Http reply header", .format=fmt_http_res_head_o },
    { .directive="%Hs", .description="Http reply status", .format=fmt_none },
    { .directive="%Hso", .description="Modified Http reply status", .format=fmt_none },
    { .directive="%iu", .description="Icap request url", .format=fmt_request },
    { .directive="%im", .description="Icap method", .format=fmt_icapmethod },
    { .directive="%is", .description="Icap status code", .format=fmt_icapstatus },
    { .directive="%>ih", .description="Icap request header", .format=fmt_icap_req_head },
    { .directive="%<ih", .description="Icap response header", .format=fmt_icap_res_head },
    { .directive="%ipl", .description="Icap preview length", .format=fmt_req_preview_len },
    { .directive="%Ih", .description="Http bytes received", .format=fmt_req_http_bytes_rcv },
    { .directive="%Oh", .description="Http bytes sent", .format=fmt_req_http_bytes_sent },
    { .directive="%Ib", .description="Http body bytes received", .format=fmt_req_body_bytes_rcv },
    { .directive="%Ob", .description="Http body bytes sent", .format=fmt_req_body_bytes_sent },
    { .directive="%I", .description="Bytes received", .format=fmt_req_bytes_rcv },
    { .directive="%O", .description="Bytes sent", .format=fmt_req_bytes_sent },
    { .directive="%bph", .description="Body data preview", .format=fmt_req_preview_hex },
    { .directive="%un", .description="Username", .format=fmt_username },
    { .directive="%Sl", .description="Service log string", .format=fmt_logstr },
    { .directive="%Sa", .description="Attribute set by service", .format=fmt_req_attribute },
    { .directive="%%", .description="% sign", .format=fmt_percent },
    { .directive=(const char *)(void *)0, .description=(const char *)(void *)0, .format=(signed int (*)(struct ci_request *, char *, signed int, const char *))(void *)0 } };
// MEMBUF_POOL
// file body.c line 44
static signed int MEMBUF_POOL = -1;
// MEM_ALLOCATOR_POOL
// file mem.c line 34
signed int MEM_ALLOCATOR_POOL = -1;
// PACK_ALLOCATOR_POOL
// file mem.c line 35
signed int PACK_ALLOCATOR_POOL = -1;
// REGISTRIES
// file registry.c line 26
static struct ci_array *REGISTRIES = (struct ci_array *)(void *)0;
// REG_ITEMS_COUNT
// file registry.c line 27
static signed int REG_ITEMS_COUNT = 0;
// RING_BUF_POOL
// file body.c line 47
static signed int RING_BUF_POOL = -1;
// SIMPLE_FILE_POOL
// file body.c line 46
static signed int SIMPLE_FILE_POOL = -1;
// STATS
// file stats.c line 29
struct stat_area *STATS = (struct stat_area *)(void *)0;
// STAT_GROUPS
// file stats.c line 27
struct stat_groups_list STAT_GROUPS = { .groups=(char **)(void *)0, .size=0, .entries_num=0 };
// STAT_INT64
// file stats.c line 25
struct stat_entry_list STAT_INT64 = { .entries=(struct stat_entry *)(void *)0, .size=0,
    .entries_num=0 };
// STAT_KBS
// file stats.c line 26
struct stat_entry_list STAT_KBS = { .entries=(struct stat_entry *)(void *)0, .size=0,
    .entries_num=0 };
// TEMPLATE_CACHE_SIZE
// file txtTemplate.c line 63
signed int TEMPLATE_CACHE_SIZE = 20;
// TEMPLATE_DEF_LANG
// file txtTemplate.c line 57
const char *TEMPLATE_DEF_LANG = "en";
// TEMPLATE_DIR
// file txtTemplate.c line 56
const char *TEMPLATE_DIR = (const char *)(void *)0;
// TEMPLATE_MEMBUF_SIZE
// file txtTemplate.c line 64
signed int TEMPLATE_MEMBUF_SIZE = 8192;
// TEMPLATE_RELOAD_TIME
// file txtTemplate.c line 58
signed int TEMPLATE_RELOAD_TIME = 360;
// _MAGIC_DB
// file filetype.c line 39
static struct ci_magics_db *_MAGIC_DB = (struct ci_magics_db *)(void *)0;
// __intl_free
// file request_common.c line 41
void (*__intl_free)(void *);
// __intl_free
// file request_common.c line 41
void (*__intl_free)(void *) = _os_free;
// __intl_malloc
// file request_common.c line 40
void * (*__intl_malloc)(signed int);
// __intl_malloc
// file request_common.c line 40
void * (*__intl_malloc)(signed int) = _os_malloc;
// __log_error
// file debug.c line 31
void (*__log_error)(void *, const char *, ...) = (void (*)(void *, const char *, ...))(void *)0;
// acl_cmp_uint64_ops
// file acl.c line 207
static const struct ci_type_ops acl_cmp_uint64_ops;
// acl_cmp_uint64_ops
// file acl.c line 207
static const struct ci_type_ops acl_cmp_uint64_ops = { .dup=acl_cmp_uint64_dup, .free=acl_cmp_uint64_free, .compare=(signed int (*)(const void *, const void *))(void *)0,
    .size=(unsigned long int (*)(const void *))(void *)0,
    .equal=acl_cmp_uint64_equal };
// acl_content_length
// file acl.c line 217
static struct ci_acl_type acl_content_length;
// acl_content_length
// file acl.c line 217
static struct ci_acl_type acl_content_length = { .name={ 'c', 'o', 'n', 't', 'e', 'n', 't', '_', 'l', 'e', 'n', 'g', 't', 'h', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_content_length,
    .free_test_data=free_cmp_uint64_data, .type=&acl_cmp_uint64_ops };
// acl_data_type
// file acl.c line 168
struct ci_acl_type acl_data_type;
// ci_datatype_ops
// file types_ops.c line 377
const struct ci_type_ops ci_datatype_ops;
// ci_datatype_ops
// file types_ops.c line 377
const struct ci_type_ops ci_datatype_ops = { .dup=datatype_dup, .free=datatype_free, .compare=datatype_cmp,
    .size=datatype_len, .equal=datatype_equal };
// acl_data_type
// file acl.c line 168
struct ci_acl_type acl_data_type = { .name={ 'd', 'a', 't', 'a', '_', 't', 'y', 'p', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_data_type,
    .free_test_data=free_data_type, .type=&ci_datatype_ops };
// acl_http_req_header
// file acl.c line 153
struct ci_acl_type acl_http_req_header;
// ci_regex_ops
// file types_ops.c line 301
const struct ci_type_ops ci_regex_ops;
// ci_regex_ops
// file types_ops.c line 301
const struct ci_type_ops ci_regex_ops = { .dup=regex_dup, .free=regex_free, .compare=regex_cmp, .size=regex_len,
    .equal=regex_equal };
// acl_http_req_header
// file acl.c line 153
struct ci_acl_type acl_http_req_header = { .name={ 'h', 't', 't', 'p', '_', 'r', 'e', 'q', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_http_req_header,
    .free_test_data=free_http_req_header, .type=&ci_regex_ops };
// acl_http_resp_header
// file acl.c line 160
struct ci_acl_type acl_http_resp_header;
// acl_http_resp_header
// file acl.c line 160
struct ci_acl_type acl_http_resp_header = { .name={ 'h', 't', 't', 'p', '_', 'r', 'e', 's', 'p', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_http_resp_header,
    .free_test_data=free_http_resp_header,
    .type=&ci_regex_ops };
// acl_icap_header
// file acl.c line 139
struct ci_acl_type acl_icap_header;
// acl_icap_header
// file acl.c line 139
struct ci_acl_type acl_icap_header = { .name={ 'i', 'c', 'a', 'p', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_icap_header,
    .free_test_data=free_icap_header, .type=&ci_regex_ops };
// acl_icap_resp_header
// file acl.c line 146
struct ci_acl_type acl_icap_resp_header;
// acl_icap_resp_header
// file acl.c line 146
struct ci_acl_type acl_icap_resp_header = { .name={ 'i', 'c', 'a', 'p', '_', 'r', 'e', 's', 'p', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_icap_response_header,
    .free_test_data=free_icap_response_header,
    .type=&ci_regex_ops };
// acl_req_type
// file acl.c line 103
struct ci_acl_type acl_req_type;
// ci_str_ops
// file types_ops.c line 65
const struct ci_type_ops ci_str_ops;
// ci_str_ops
// file types_ops.c line 65
const struct ci_type_ops ci_str_ops = { .dup=stringdup, .free=stringfree, .compare=stringcmp, .size=stringlen,
    .equal=stringequal };
// acl_req_type
// file acl.c line 103
struct ci_acl_type acl_req_type = { .name={ 't', 'y', 'p', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_reqtype,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_str_ops };
// acl_service
// file acl.c line 96
struct ci_acl_type acl_service;
// acl_service
// file acl.c line 96
struct ci_acl_type acl_service = { .name={ 's', 'e', 'r', 'v', 'i', 'c', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_service,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_str_ops };
// acl_tcp_port
// file acl.c line 110
struct ci_acl_type acl_tcp_port;
// ci_int32_ops
// file types_ops.c line 157
const struct ci_type_ops ci_int32_ops;
// ci_int32_ops
// file types_ops.c line 157
const struct ci_type_ops ci_int32_ops = { .dup=int32_dup, .free=int32_free, .compare=int32_cmp, .size=int32_len,
    .equal=int32_equal };
// acl_tcp_port
// file acl.c line 110
struct ci_acl_type acl_tcp_port = { .name={ 'p', 'o', 'r', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_port,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_int32_ops };
// acl_tcp_src
// file acl.c line 117
struct ci_acl_type acl_tcp_src;
// ci_ip_sockaddr_ops
// file types_ops.c line 604
const struct ci_type_ops ci_ip_sockaddr_ops;
// ci_ip_sockaddr_ops
// file types_ops.c line 604
const struct ci_type_ops ci_ip_sockaddr_ops = { .dup=ip_dup, .free=ip_free, .compare=ip_sockaddr_cmp, .size=ip_len,
    .equal=ip_sockaddr_equal };
// acl_tcp_src
// file acl.c line 117
struct ci_acl_type acl_tcp_src = { .name={ 's', 'r', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_client_ip,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_ip_sockaddr_ops };
// acl_tcp_srvip
// file acl.c line 124
struct ci_acl_type acl_tcp_srvip;
// acl_tcp_srvip
// file acl.c line 124
struct ci_acl_type acl_tcp_srvip = { .name={ 's', 'r', 'v', 'i', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_srv_ip,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_ip_sockaddr_ops };
// acl_tcp_xclientip
// file acl.c line 131
struct ci_acl_type acl_tcp_xclientip;
// ci_ip_ops
// file types_ops.c line 594
const struct ci_type_ops ci_ip_ops;
// ci_ip_ops
// file types_ops.c line 594
const struct ci_type_ops ci_ip_ops = { .dup=ip_dup, .free=ip_free, .compare=ip_cmp, .size=ip_len,
    .equal=ip_equal };
// acl_tcp_xclientip
// file acl.c line 131
struct ci_acl_type acl_tcp_xclientip = { .name={ 'h', 't', 't', 'p', '_', 'c', 'l', 'i', 'e', 'n', 't', '_', 'i', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_http_client_ip,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_ip_ops };
// acl_time
// file acl.c line 257
static struct ci_acl_type acl_time;
// acl_time_ops
// file acl.c line 246
static const struct ci_type_ops acl_time_ops;
// acl_time_ops
// file acl.c line 246
static const struct ci_type_ops acl_time_ops = { .dup=acl_time_dup, .free=acl_time_free, .compare=(signed int (*)(const void *, const void *))(void *)0,
    .size=(unsigned long int (*)(const void *))(void *)0,
    .equal=acl_time_equal };
// acl_time
// file acl.c line 257
static struct ci_acl_type acl_time = { .name={ 't', 'i', 'm', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_time_data,
    .free_test_data=free_time_data, .type=&acl_time_ops };
// acl_user
// file acl.c line 89
struct ci_acl_type acl_user;
// acl_user
// file acl.c line 89
struct ci_acl_type acl_user = { .name={ 'u', 's', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_user,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_str_ops };
// atol_err_conversion
// file util.c line 75
static const char *atol_err_conversion = "CONVERSION_ERROR";
// atol_err_erange
// file util.c line 74
static const char *atol_err_erange = "ERANGE";
// atol_err_nonumber
// file util.c line 76
static const char *atol_err_nonumber = "NO_DIGITS_ERROR";
// base64_table
// file decode.c line 34
unsigned char base64_table[256l] = { (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)62, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)63, (unsigned char)52, (unsigned char)53, (unsigned char)54, (unsigned char)55, (unsigned char)56, (unsigned char)57, (unsigned char)58, (unsigned char)59, (unsigned char)60, (unsigned char)61, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)0, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4, (unsigned char)5, (unsigned char)6, (unsigned char)7, (unsigned char)8, (unsigned char)9, (unsigned char)10, (unsigned char)11, (unsigned char)12, (unsigned char)13, (unsigned char)14, (unsigned char)15, (unsigned char)16, (unsigned char)17, (unsigned char)18, (unsigned char)19, (unsigned char)20, (unsigned char)21, (unsigned char)22, (unsigned char)23, (unsigned char)24, (unsigned char)25, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)26, (unsigned char)27, (unsigned char)28, (unsigned char)29, (unsigned char)30, (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35, (unsigned char)36, (unsigned char)37, (unsigned char)38, (unsigned char)39, (unsigned char)40, (unsigned char)41, (unsigned char)42, (unsigned char)43, (unsigned char)44, (unsigned char)45, (unsigned char)46, (unsigned char)47, (unsigned char)48, (unsigned char)49, (unsigned char)50, (unsigned char)51, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255 };
// cfg_params_allocator
// file cfg_lib.c line 32
struct ci_mem_allocator *cfg_params_allocator = (struct ci_mem_allocator *)(void *)0;
// ci_common_headers
// file header.c line 29
const char *ci_common_headers[8l] = { "Cache-Control", "Connection", "Date", "Expires", "Pragma", "Trailer", "Upgrade", "Encapsulated" };
// ci_encaps_entities
// file header.c line 128
const char *ci_encaps_entities[6l] = { "req-hdr", "res-hdr", "req-body", "res-body", "null-body", "opt-body" };
// ci_error_codes
// file header.c line 87
struct ci_error_code ci_error_codes[16l] = { { .code=100, .str="Continue" }, { .code=200, .str="OK" }, { .code=204, .str="Unmodified" }, { .code=206, .str="Partial Content" }, { .code=400, .str="Bad request" }, { .code=401, .str="Unauthorized" }, { .code=403, .str="Forbidden" }, { .code=404, .str="Service not found" },
    { .code=405, .str="Not allowed" }, { .code=407, .str="Authentication Required" },
    { .code=408, .str="Request timeout" }, { .code=500, .str="Server error" }, { .code=501, .str="Not implemented" }, { .code=502, .str="Bad Gateway" }, { .code=503, .str="Service overloaded" },
    { .code=505, .str="Unsupported version" } };
// ci_local_cache
// file cache.c line 70
struct ci_cache_type ci_local_cache;
// ci_local_cache
// file cache.c line 70
struct ci_cache_type ci_local_cache = { .init=ci_local_cache_init, .search=ci_local_cache_search, .update=ci_local_cache_update,
    .destroy=ci_local_cache_destroy, .name="local" };
// ci_methods
// file header.c line 43
const char *ci_methods[5l] = { "", "OPTIONS", "REQMOD", "", "RESPMOD" };
// ci_options_headers
// file header.c line 69
const char *ci_options_headers[14l] = { "Methods", "Service", "ISTag", "Encapsulated", "Opt-body-type", "Max-Connections", "Options-TTL", "Date", "Service-ID", "Allow", "Preview", "Transfer-Preview", "Transfer-Ignore", "Transfer-Complete" };
// ci_request_headers
// file header.c line 52
const char *ci_request_headers[7l] = { "Authorization", "Allow", "From", "Host", "Referer", "User-Agent", "Preview" };
// ci_responce_headers
// file header.c line 63
const char *ci_responce_headers[2l] = { "Server", "ISTag" };
// ci_str_ext_ops
// file types_ops.c line 96
const struct ci_type_ops ci_str_ext_ops;
// ci_str_ext_ops
// file types_ops.c line 96
const struct ci_type_ops ci_str_ext_ops = { .dup=stringdup, .free=stringfree, .compare=string_ext_cmp, .size=stringlen,
    .equal=string_ext_equal };
// ci_uint64_ops
// file types_ops.c line 214
const struct ci_type_ops ci_uint64_ops;
// ci_uint64_ops
// file types_ops.c line 214
const struct ci_type_ops ci_uint64_ops = { .dup=uint64_dup, .free=uint64_free, .compare=uint64_cmp, .size=uint64_len,
    .equal=uint64_equal };
// days
// file os/unix/utilfunc.c line 26
static const char *days[7l] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
// default_allocator
// file mem.c line 33
struct ci_mem_allocator *default_allocator = (struct ci_mem_allocator *)(void *)0;
// default_mutex_scheme
// file os/unix/proc_mutex.c line 245
const struct ci_proc_mutex_scheme *default_mutex_scheme;
// file_mutex_scheme
// file os/unix/proc_mutex.c line 233
static struct ci_proc_mutex_scheme file_mutex_scheme;
// file_mutex_scheme
// file os/unix/proc_mutex.c line 233
static struct ci_proc_mutex_scheme file_mutex_scheme = { .proc_mutex_init=file_proc_mutex_init, .proc_mutex_destroy=file_proc_mutex_destroy,
    .proc_mutex_lock=file_proc_mutex_lock,
    .proc_mutex_unlock=file_proc_mutex_unlock,
    .proc_mutex_print_info=file_proc_mutex_print_info,
    .name="file" };
// default_mutex_scheme
// file os/unix/proc_mutex.c line 245
const struct ci_proc_mutex_scheme *default_mutex_scheme = &file_mutex_scheme;
// default_scheme
// file os/unix/shared_mem.c line 218
const struct ci_shared_mem_scheme *default_scheme;
// posix_scheme
// file os/unix/shared_mem.c line 206
const struct ci_shared_mem_scheme posix_scheme;
// posix_scheme
// file os/unix/shared_mem.c line 206
const struct ci_shared_mem_scheme posix_scheme = { .shared_mem_create=posix_shared_mem_create, .shared_mem_attach=posix_shared_mem_attach,
    .shared_mem_detach=posix_shared_mem_detach,
    .shared_mem_destroy=posix_shared_mem_destroy,
    .shared_mem_print_info=posix_shared_mem_print_info,
    .name="posix" };
// default_scheme
// file os/unix/shared_mem.c line 218
const struct ci_shared_mem_scheme *default_scheme = &posix_scheme;
// eof_str
// file request_common.c line 1198
static const char *eof_str = "0\r\n\r\n";
// file_table_type
// file lookup_file_table.c line 34
struct ci_lookup_table_type file_table_type;
// file_table_type
// file lookup_file_table.c line 34
struct ci_lookup_table_type file_table_type = { .open=file_table_open, .close=file_table_close, .search=file_table_search,
    .release_result=file_table_release_result, .get_row=(const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))(void *)0,
    .type="file" };
// hash_table_type
// file lookup_file_table.c line 329
struct ci_lookup_table_type hash_table_type;
// hash_table_type
// file lookup_file_table.c line 329
struct ci_lookup_table_type hash_table_type = { .open=hash_table_open, .close=hash_table_close, .search=hash_table_search,
    .release_result=hash_table_release_result, .get_row=(const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))(void *)0,
    .type="hash" };
// init_child_mutexes_scheduled
// file os/unix/threads.c line 44
static signed int init_child_mutexes_scheduled = 0;
// last
// file os/unix/threads.c line 42
static struct mutex_itm *last = (struct mutex_itm *)(void *)0;
// long_buffer_sizes
// file mem.c line 158
signed int long_buffer_sizes[16l] = { 2048, 4096, 8192, 8192, 16384, 16384, 16384, 16384, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768 };
// long_buffers
// file mem.c line 110
struct ci_mem_allocator *long_buffers[16l];
// lookup_tables_types
// file lookup_table.c line 30
struct ci_lookup_table_type *lookup_tables_types[128l];
// lookup_tables_types_num
// file lookup_table.c line 31
signed int lookup_tables_types_num = 0;
// mmap_scheme
// file os/unix/shared_mem.c line 142
const struct ci_shared_mem_scheme mmap_scheme;
// mmap_scheme
// file os/unix/shared_mem.c line 142
const struct ci_shared_mem_scheme mmap_scheme = { .shared_mem_create=mmap_shared_mem_create, .shared_mem_attach=mmap_shared_mem_attach,
    .shared_mem_detach=mmap_shared_mem_detach,
    .shared_mem_destroy=mmap_shared_mem_destroy,
    .shared_mem_print_info=mmap_shared_mem_print_info,
    .name="mmap" };
// months
// file os/unix/utilfunc.c line 36
static const char *months[12l] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
// mutexes
// file os/unix/threads.c line 41
static struct mutex_itm *mutexes = (struct mutex_itm *)(void *)0;
// mutexes_lock
// file os/unix/threads.c line 40
union anonymous$8 mutexes_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// object_pools
// file mem.c line 301
struct ci_mem_allocator **object_pools = (struct ci_mem_allocator **)(void *)0;
// object_pools_size
// file mem.c line 302
signed int object_pools_size = 0;
// object_pools_used
// file mem.c line 303
signed int object_pools_used = 0;
// op_lock
// file os/unix/proc_mutex.c line 37
static struct sembuf op_lock[2l] = { { .sem_num=(unsigned short int)0, .sem_op=(signed short int)0, .sem_flg=(signed short int)0 },
    { .sem_num=(unsigned short int)0, .sem_op=(signed short int)1, .sem_flg=(signed short int)0x1000 } };
// op_unlock
// file os/unix/proc_mutex.c line 42
static struct sembuf op_unlock[1l] = { { .sem_num=(unsigned short int)0, .sem_op=(signed short int)-1, .sem_flg=(signed short int)(04000 | 0x1000) } };
// options
// file test_cache.c line 55
static struct ci_options_entry options[4l];
// options
// file test_cache.c line 55
static struct ci_options_entry options[4l] = { { .name="-d", .parameter="debug_level", .data=(void *)&CI_DEBUG_LEVEL, .action=ci_cfg_set_int,
    .msg="The debug level" },
    { .name="-m", .parameter="module", .data=(void *)0, .action=load_module,
    .msg="The path of the table" },
    { .name="-c", .parameter="cache", .data=(void *)&CACHE_TYPE, .action=ci_cfg_set_str,
    .msg="The type of cache to use" },
    { .name=(const char *)(void *)0, .parameter=(const char *)(void *)0, .data=(void *)0,
    .action=(signed int (*)(const char *, const char **, void *))(void *)0, .msg=(const char *)(void *)0 } };
// pcre_free
// file /usr/include/pcre.h line 490
extern void (*pcre_free)(void *);
// posix_mutex_scheme
// file os/unix/proc_mutex.c line 170
static struct ci_proc_mutex_scheme posix_mutex_scheme;
// posix_mutex_scheme
// file os/unix/proc_mutex.c line 170
static struct ci_proc_mutex_scheme posix_mutex_scheme = { .proc_mutex_init=posix_proc_mutex_init, .proc_mutex_destroy=posix_proc_mutex_destroy,
    .proc_mutex_lock=posix_proc_mutex_lock,
    .proc_mutex_unlock=posix_proc_mutex_unlock,
    .proc_mutex_print_info=posix_proc_mutex_print_info,
    .name="posix" };
// predefined_groups
// file filetype.c line 51
struct ci_data_group predefined_groups[3l] = { { .name={ 'T', 'E', 'X', 'T', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'A', 'l', 'l', ' ', 't', 'e', 'x', 't', 's', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'D', 'A', 'T', 'A', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'U', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'd', 'a', 't', 'a', ' ', 't', 'y', 'p', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } };
// predefined_types
// file filetype.c line 41
struct ci_data_type predefined_types[7l] = { { .name={ 'A', 'S', 'C', 'I', 'I', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'A', 'S', 'C', 'I', 'I', ' ', 't', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'I', 'S', 'O', '-', '8', '8', '5', '9', 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'I', 'S', 'O', '-', '8', '8', '5', '9', ' ', 't', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'E', 'X', 'T', '-', 'A', 'S', 'C', 'I', 'I', 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'E', 'x', 't', 'e', 'n', 'd', 'e', 'd', ' ', 'A', 'S', 'C', 'I', 'I', ' ', '(', 'M', 'a', 'c', ',', 'I', 'B', 'M', ' ', 'P', 'C', ' ', 'e', 't', 'c', '.', ')', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'U', 'T', 'F', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'U', 'n', 'i', 'c', 'o', 'd', 'e', ' ', 't', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'H', 'T', 'M', 'L', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'H', 'T', 'M', 'L', ' ', 't', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'B', 'I', 'N', 'A', 'R', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'd', 'a', 't', 'a', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } };
// regex_table_type
// file lookup_file_table.c line 409
struct ci_lookup_table_type regex_table_type;
// regex_table_type
// file lookup_file_table.c line 409
struct ci_lookup_table_type regex_table_type = { .open=regex_table_open, .close=regex_table_close, .search=regex_table_search,
    .release_result=regex_table_release_result, .get_row=(const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))(void *)0,
    .type="regex" };
// short_buffer_sizes
// file mem.c line 150
signed int short_buffer_sizes[16l] = { 64, 128, 256, 256, 512, 512, 512, 512, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };
// short_buffers
// file mem.c line 109
struct ci_mem_allocator *short_buffers[16l];
// specs_list
// file acl.c line 774
static struct ci_acl_spec *specs_list;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// sysv_mutex_scheme
// file os/unix/proc_mutex.c line 104
static struct ci_proc_mutex_scheme sysv_mutex_scheme;
// sysv_mutex_scheme
// file os/unix/proc_mutex.c line 104
static struct ci_proc_mutex_scheme sysv_mutex_scheme = { .proc_mutex_init=sysv_proc_mutex_init, .proc_mutex_destroy=sysv_proc_mutex_destroy,
    .proc_mutex_lock=sysv_proc_mutex_lock,
    .proc_mutex_unlock=sysv_proc_mutex_unlock,
    .proc_mutex_print_info=sysv_proc_mutex_print_info,
    .name="sysv" };
// sysv_scheme
// file os/unix/shared_mem.c line 89
const struct ci_shared_mem_scheme sysv_scheme;
// sysv_scheme
// file os/unix/shared_mem.c line 89
const struct ci_shared_mem_scheme sysv_scheme = { .shared_mem_create=sysv_shared_mem_create, .shared_mem_attach=sysv_shared_mem_attach,
    .shared_mem_detach=sysv_shared_mem_detach,
    .shared_mem_destroy=sysv_shared_mem_destroy,
    .shared_mem_print_info=sysv_shared_mem_print_info,
    .name="sysv" };
// templates
// file txtTemplate.c line 60
struct anonymous$20 *templates = (struct anonymous$20 *)(void *)0;
// templates_mutex
// file txtTemplate.c line 66
static union anonymous$8 templates_mutex;
// text_chars
// file filetype.c line 390
static const char text_chars[256l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)1, (const char)1, (const char)1, (const char)0, (const char)1, (const char)1, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)0, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)1, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2 };
// txtTemplateInited
// file txtTemplate.c line 61
signed int txtTemplateInited = 0;
// types_list
// file acl.c line 773
static struct ci_acl_type_list types_list;
// utf_boundaries
// file filetype.c line 436
static unsigned int utf_boundaries[7l] = { (unsigned int)0x0, (unsigned int)0x0, (unsigned int)0x07F, (unsigned int)0x7FF, (unsigned int)0xFFFF, (unsigned int)0x1FFFFF, (unsigned int)0x3FFFFFF };

// MD5Transform
// file md5.c line 168
static void MD5Transform(unsigned int *buf, unsigned int *in)
{
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  a = buf[(signed long int)0];
  b = buf[(signed long int)1];
  c = buf[(signed long int)2];
  d = buf[(signed long int)3];
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)0] + 0xd76aa478;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)1] + 0xe8c7b756;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)2] + (unsigned int)0x242070db;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)3] + 0xc1bdceee;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)4] + 0xf57c0faf;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)5] + (unsigned int)0x4787c62a;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)6] + 0xa8304613;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)7] + 0xfd469501;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x698098d8;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)9] + 0x8b44f7af;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)10] + 0xffff5bb1;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)11] + 0x895cd7be;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)12] + (unsigned int)0x6b901122;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)13] + 0xfd987193;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)14] + 0xa679438e;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)15] + (unsigned int)0x49b40821;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)1] + 0xf61e2562;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)6] + 0xc040b340;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)11] + (unsigned int)0x265e5a51;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)0] + 0xe9b6c7aa;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)5] + 0xd62f105d;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)10] + (unsigned int)0x02441453;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)15] + 0xd8a1e681;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)4] + 0xe7d3fbc8;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)14] + 0xc33707d6;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)3] + 0xf4d50d87;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x455a14ed;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)13] + 0xa9e3e905;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)2] + 0xfcefa3f8;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)7] + (unsigned int)0x676f02d9;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)12] + 0x8d2a4c8a;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)5] + 0xfffa3942;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)8] + 0x8771f681;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)14] + 0xfde5380c;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)1] + 0xa4beea44;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)7] + 0xf6bb4b60;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)10] + 0xbebfbc70;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)0] + 0xeaa127fa;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)3] + 0xd4ef3085;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)6] + (unsigned int)0x04881d05;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)9] + 0xd9d4d039;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)12] + 0xe6db99e5;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)2] + 0xc4ac5665;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)0] + 0xf4292244;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)7] + (unsigned int)0x432aff97;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)14] + 0xab9423a7;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)5] + 0xfc93a039;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)12] + (unsigned int)0x655b59c3;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)3] + 0x8f0ccc92;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)10] + 0xffeff47d;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)1] + 0x85845dd1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)15] + 0xfe2ce6e0;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)6] + 0xa3014314;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)4] + 0xf7537e82;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)11] + 0xbd3af235;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)9] + 0xeb86d391;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  buf[(signed long int)0] = buf[(signed long int)0] + a;
  buf[(signed long int)1] = buf[(signed long int)1] + b;
  buf[(signed long int)2] = buf[(signed long int)2] + c;
  buf[(signed long int)3] = buf[(signed long int)3] + d;
}

// _os_free
// file request_common.c line 35
static void _os_free(void *ptr)
{
  free(ptr);
}

// _os_malloc
// file request_common.c line 30
static void * _os_malloc(signed int size)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)size);
  return return_value_malloc$1;
}

// acl_cmp_uint64_dup
// file acl.c line 182
void * acl_cmp_uint64_dup(const char *str, struct ci_mem_allocator *allocator)
{
  void *return_value;
  return_value=ci_uint64_ops.dup(str, allocator);
  return return_value;
}

// acl_cmp_uint64_equal
// file acl.c line 187
signed int acl_cmp_uint64_equal(const void *key1, const void *key2)
{
  unsigned long int k1 = *((unsigned long int *)key1);
  struct acl_cmp_uint64_data *data = (struct acl_cmp_uint64_data *)key2;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
    {
      signed int tmp_if_expr$1;
      if(data->operator == 1)
        tmp_if_expr$1 = 62;

      else
        tmp_if_expr$1 = data->operator == 2 ? 60 : 61;
      __log_error((void *)0, "Acl content length check %llu %c %llu\n", (signed long long int)data->data, tmp_if_expr$1, (signed long long int)k1);
    }

    if(!(CI_DEBUG_STDOUT == 0))
    {
      signed int tmp_if_expr$2;
      if(data->operator == 1)
        tmp_if_expr$2 = 62;

      else
        tmp_if_expr$2 = data->operator == 2 ? 60 : 61;
      printf("Acl content length check %llu %c %llu\n", (signed long long int)data->data, tmp_if_expr$2, (signed long long int)k1);
    }

  }

  if(data->operator == 1)
    return (signed int)(data->data > k1);

  else
    if(data->operator == 2)
      return (signed int)(data->data < k1);

    else
      return (signed int)(k1 == data->data);
}

// acl_cmp_uint64_free
// file acl.c line 202
void acl_cmp_uint64_free(void *key, struct ci_mem_allocator *allocator)
{
  ci_uint64_ops.free(key, allocator);
}

// acl_load_defaults
// file acl.c line 776
static signed int acl_load_defaults()
{
  ci_acl_typelist_add(&types_list, &acl_tcp_port);
  ci_acl_typelist_add(&types_list, &acl_service);
  ci_acl_typelist_add(&types_list, &acl_req_type);
  ci_acl_typelist_add(&types_list, &acl_user);
  ci_acl_typelist_add(&types_list, &acl_tcp_src);
  ci_acl_typelist_add(&types_list, &acl_tcp_srvip);
  ci_acl_typelist_add(&types_list, &acl_icap_header);
  ci_acl_typelist_add(&types_list, &acl_icap_resp_header);
  ci_acl_typelist_add(&types_list, &acl_http_req_header);
  ci_acl_typelist_add(&types_list, &acl_http_resp_header);
  ci_acl_typelist_add(&types_list, &acl_data_type);
  ci_acl_typelist_add(&types_list, &acl_content_length);
  ci_acl_typelist_add(&types_list, &acl_time);
  ci_acl_typelist_add(&types_list, &acl_tcp_xclientip);
  return 1;
}

// acl_time_dup
// file acl.c line 270
void * acl_time_dup(const char *str, struct ci_mem_allocator *allocator)
{
  /* tag-#anon#lST[l*{cS8}$cS8$'day'|S32'id'|U32'$pad0'] */
struct anonymous$19
{
  // day
  const char *day;
  // id
  signed int id;
};

/* */
  ;
  struct anonymous$19 acl_time_dup$$1$$days[15l] = { { .day="Sunday", .id=0 }, { .day="Monday", .id=1 }, { .day="Tuesday", .id=2 }, { .day="Wednesday", .id=3 }, { .day="Thursday", .id=4 }, { .day="Friday", .id=5 }, { .day="Saturday", .id=6 }, { .day="S", .id=0 }, { .day="M", .id=1 }, { .day="T", .id=2 }, { .day="W", .id=3 }, { .day="H", .id=4 }, { .day="F", .id=5 }, { .day="A", .id=6 }, { .day=(const char *)(void *)0, .id=-1 } };
  signed int h1;
  signed int m1;
  signed int h2;
  signed int m2;
  signed int i;
  char *s;
  char *e;
  const char *error;
  char buf[1024l];
  struct acl_time_data *tmd;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct acl_time_data) /*12ul*/ );
  tmd = (struct acl_time_data *)return_value;
  tmd->days = (unsigned int)0;
  strncpy(buf, str, sizeof(char [1024l]) /*1024ul*/ );
  buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  s = buf;
  const unsigned short int **return_value___ctype_b_loc$4;
  return_value___ctype_b_loc$4=__ctype_b_loc();
  if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*s]) == 0)
  {
    if((signed int)*s == 44)
      s = s + 1l;

    i = 0;
    if(!(acl_time_dup$$1$$days[(signed long int)i].day == ((const char *)NULL)))
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(acl_time_dup$$1$$days[(signed long int)i].day);
      signed int return_value_strncasecmp$2;
      return_value_strncasecmp$2=strncasecmp(s, acl_time_dup$$1$$days[(signed long int)i].day, return_value_strlen$1);
      if(return_value_strncasecmp$2 == 0)
        tmd->days = tmd->days | (unsigned int)(1 << acl_time_dup$$1$$days[(signed long int)i].id);

      else
        i = i + 1;
    }

    if(acl_time_dup$$1$$days[(signed long int)i].day == ((const char *)NULL))
      error = s;

    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(acl_time_dup$$1$$days[(signed long int)i].day);
    s = s + (signed long int)return_value_strlen$3;
    if(!((signed int)*s == 47))
      error = s;

    if(!(*s == 0))
      s = s + 1l;

  }

  const unsigned short int **return_value___ctype_b_loc$5;
  return_value___ctype_b_loc$5=__ctype_b_loc();
  signed long int return_value_strtol$6;
  const unsigned short int **return_value___ctype_b_loc$7;
  signed long int return_value_strtol$9;
  const unsigned short int **return_value___ctype_b_loc$10;
  signed long int return_value_strtol$12;
  const unsigned short int **return_value___ctype_b_loc$13;
  signed long int return_value_strtol$15;
  if((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*s]) == 0)
    error = s;

  else
  {
    return_value_strtol$6=strtol(s, &e, 10);
    h1 = (signed int)return_value_strtol$6;
    if(h1 >= 25 || !(h1 >= 0))
      error = s;

    else
    {
      _Bool tmp_if_expr$8;
      if(!((signed int)*e == 58))
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$7=__ctype_b_loc();
        tmp_if_expr$8 = !(((signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)e[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$8)
        error = e;

      else
      {
        s = e + (signed long int)1;
        return_value_strtol$9=strtol(s, &e, 10);
        m1 = (signed int)return_value_strtol$9;
        if(m1 >= 60 || !(m1 >= 0))
          error = s;

        else
        {
          _Bool tmp_if_expr$11;
          if(!((signed int)*e == 45))
            tmp_if_expr$11 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$10=__ctype_b_loc();
            tmp_if_expr$11 = !(((signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)e[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$11)
            error = e;

          else
          {
            s = e + (signed long int)1;
            return_value_strtol$12=strtol(s, &e, 10);
            h2 = (signed int)return_value_strtol$12;
            if(h2 >= 25 || !(h2 >= 0))
              error = s;

            else
            {
              _Bool tmp_if_expr$14;
              if(!((signed int)*e == 58))
                tmp_if_expr$14 = (_Bool)1;

              else
              {
                return_value___ctype_b_loc$13=__ctype_b_loc();
                tmp_if_expr$14 = !(((signed int)(*return_value___ctype_b_loc$13)[(signed long int)(signed int)e[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$14)
                error = e;

              else
              {
                s = e + (signed long int)1;
                return_value_strtol$15=strtol(s, &e, 10);
                m2 = (signed int)return_value_strtol$15;
                if(m2 >= 60 || !(m2 >= 0))
                  error = s;

                else
                {
                  tmd->start_time = (unsigned int)(h1 * 60 + m1);
                  tmd->end_time = (unsigned int)(h2 * 60 + m2);
                  if(tmd->end_time >= tmd->start_time)
                  {
                    if(CI_DEBUG_LEVEL >= 5)
                    {
                      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                        __log_error((void *)0, "Acl time, adding days: %x,  start time %d, end time: %d!\n", tmd->days, tmd->start_time, tmd->end_time);

                      if(!(CI_DEBUG_STDOUT == 0))
                        printf("Acl time, adding days: %x,  start time %d, end time: %d!\n", tmd->days, tmd->start_time, tmd->end_time);

                    }

                    return (void *)tmd;
                  }

                  if(CI_DEBUG_LEVEL >= 1)
                  {
                    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                      __log_error((void *)0, "Acl '%s': end time is smaller than the start time!\n", str);

                    if(!(CI_DEBUG_STDOUT == 0))
                      printf("Acl '%s': end time is smaller than the start time!\n", str);

                  }

                  error = str;
                }
              }
            }
          }
        }
      }
    }
  }

acl_time_dup_fail:
  ;
  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Failed to parse acl time: %s (error on pos '...%s')\n", str, error);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Failed to parse acl time: %s (error on pos '...%s')\n", str, error);

  }

  allocator->free(allocator, (void *)tmd);
  return (void *)0;
}

// acl_time_equal
// file acl.c line 373
signed int acl_time_equal(const void *key1, const void *key2)
{
  struct acl_time_data *tmd_acl = (struct acl_time_data *)key1;
  struct acl_time_data *tmd_request = (struct acl_time_data *)key2;
  if(CI_DEBUG_LEVEL >= 9)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "acl_time_equal(key1=%p, key2=%p)\n", key1, key2);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("acl_time_equal(key1=%p, key2=%p)\n", key1, key2);

  }

  signed int matches;
  _Bool tmp_if_expr$1;
  if(!((tmd_acl->days & tmd_request->days) == 0u))
    tmp_if_expr$1 = tmd_request->start_time >= tmd_acl->start_time ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = tmd_request->start_time <= tmd_acl->end_time ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  matches = (signed int)tmp_if_expr$2;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "acl_time_equal: %x/%d-%d <> %x/%d-%d -> %d\n", tmd_acl->days, tmd_acl->start_time, tmd_acl->end_time, tmd_request->days, tmd_request->start_time, tmd_request->end_time, matches);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("acl_time_equal: %x/%d-%d <> %x/%d-%d -> %d\n", tmd_acl->days, tmd_acl->start_time, tmd_acl->end_time, tmd_request->days, tmd_request->start_time, tmd_request->end_time, matches);

  }

  return matches;
}

// acl_time_free
// file acl.c line 389
void acl_time_free(void *tmd, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, (void *)tmd);
}

// add_mutex
// file os/unix/threads.c line 66
static struct mutex_itm * add_mutex(void *pmutex, signed int type)
{
  struct mutex_itm *m;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct mutex_itm) /*24ul*/ );
  m = (struct mutex_itm *)return_value_malloc$1;
  if(m == ((struct mutex_itm *)NULL))
    return (struct mutex_itm *)(void *)0;

  else
  {
    switch(type)
    {
      case 0:
      {
        m->mtx.mutex = (union anonymous$8 *)pmutex;
        break;
      }
      case 1:
      {
        m->mtx.rwlock = (union anonymous$10 *)pmutex;
        break;
      }
      default:
      {
        free((void *)m);
        return (struct mutex_itm *)(void *)0;
      }
    }
    m->type = type;
    m->next = (struct mutex_itm *)(void *)0;
    pthread_mutex_lock(&mutexes_lock);
    if(mutexes == ((struct mutex_itm *)NULL))
    {
      mutexes = m;
      last = m;
    }

    else
    {
      last->next = m;
      last = last->next;
    }
    if(init_child_mutexes_scheduled == 0)
    {
      pthread_atfork((void (*)(void))(void *)0, (void (*)(void))(void *)0, (void (*)(void))init_child_mutexes);
      init_child_mutexes_scheduled = 1;
    }

    pthread_mutex_unlock(&mutexes_lock);
    return m;
  }
}

// alloc_a_buffer
// file decode.c line 198
static void * alloc_a_buffer(void *op, unsigned int items, unsigned int size)
{
  void *return_value_ci_buffer_alloc$1;
  return_value_ci_buffer_alloc$1=ci_buffer_alloc((signed int)(items * size));
  return return_value_ci_buffer_alloc$1;
}

// alloc_mem_allocator_struct
// file mem.c line 79
static struct ci_mem_allocator * alloc_mem_allocator_struct()
{
  struct ci_mem_allocator *alc;
  if(!(MEM_ALLOCATOR_POOL >= 0))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct ci_mem_allocator) /*56ul*/ );
    alc = (struct ci_mem_allocator *)return_value_malloc$1;
    alc->must_free = 1;
  }

  else
  {
    void *return_value_ci_object_pool_alloc$2;
    return_value_ci_object_pool_alloc$2=ci_object_pool_alloc(MEM_ALLOCATOR_POOL);
    alc = (struct ci_mem_allocator *)return_value_ci_object_pool_alloc$2;
    alc->must_free = 2;
  }
  return alc;
}

// alloc_text_table_entry
// file lookup_file_table.c line 55
struct text_table_entry * alloc_text_table_entry(signed int val_num, struct ci_mem_allocator *allocator)
{
  struct text_table_entry *e;
  signed int i;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct text_table_entry) /*24ul*/ );
  e = (struct text_table_entry *)return_value;
  e->key = (void *)0;
  e->next = (struct text_table_entry *)(void *)0;
  if(e == ((struct text_table_entry *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocating memory for table entry \n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocating memory for table entry \n");

    }

    return (struct text_table_entry *)(void *)0;
  }

  else
  {
    if(val_num >= 1)
    {
      void *return_value_1;
      return_value_1=allocator->alloc(allocator, (unsigned long int)(val_num + 1) * sizeof(void *) /*8ul*/ );
      e->vals = (void **)return_value_1;
      if(e->vals == ((void **)NULL))
      {
        allocator->free(allocator, (void *)e);
        e = (struct text_table_entry *)(void *)0;
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error allocating memory for values of  table entry.\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error allocating memory for values of  table entry.\n");

        }

        return (struct text_table_entry *)(void *)0;
      }

      i = 0;
      if(!(i >= 1 + val_num))
      {
        e->vals[(signed long int)i] = (void *)0;
        i = i + 1;
      }

    }

    else
      e->vals = (void **)(void *)0;
    return e;
  }
}

// byteReverse
// file md5.c line 28
static void byteReverse(unsigned char *buf, unsigned int longs)
{
  unsigned int t;
  do
  {
    t = (unsigned int)((unsigned int)buf[(signed long int)3] << 8 | (unsigned int)buf[(signed long int)2]) << 16 | (unsigned int)buf[(signed long int)1] << 8 | (unsigned int)buf[(signed long int)0];
    *((unsigned int *)buf) = t;
    buf = buf + (signed long int)4;
    longs = longs - 1u;
  }
  while(!(longs == 0u));
}

// check_ascii
// file filetype.c line 419
signed int check_ascii(unsigned char *buf, signed int buflen)
{
  unsigned int i;
  unsigned int res = (unsigned int)0;
  unsigned int type;
  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)buflen); i = i + 1u)
  {
    type = (unsigned int)text_chars[(signed long int)buf[(signed long int)i]];
    if(type == 0u)
      return -1;

    res = res | type;
  }
  if(!(res >= 2u))
    return 0;

  else
    if(!(res >= 4u))
      return 1;

    else
      return 2;
}

// check_directive
// file txt_format.c line 200
signed int check_directive(const char *var, const char *directive, signed int *directive_len)
{
  const char *s1;
  const char *s2;
  s1 = var;
  s2 = directive + (signed long int)1;
  *directive_len = 0;
  for( ; !(*s2 == 0); s2 = s2 + 1l)
  {
    if(s1 == ((const char *)NULL))
      return 0;

    if(!(*s1 == *s2))
      return 0;

    s1 = s1 + 1l;
  }
  *directive_len = (signed int)(s1 - var);
  return 1;
}

// check_magics
// file filetype.c line 368
signed int check_magics(struct ci_magics_db *db, const char *buf, signed int buflen)
{
  signed int i = 0;
  for( ; !(i >= db->magics_num); i = i + 1)
    if((unsigned long int)buflen >= (db->magics + (signed long int)i)->len + (unsigned long int)(db->magics + (signed long int)i)->offset)
    {
      signed int return_value_memcmp$1;
      return_value_memcmp$1=memcmp((const void *)(buf + (signed long int)(db->magics + (signed long int)i)->offset), (const void *)(db->magics + (signed long int)i)->magic, (db->magics + (signed long int)i)->len);
      if(return_value_memcmp$1 == 0)
        return (signed int)(db->magics + (signed long int)i)->type;

    }

  return -1;
}

// check_realloc
// file request_common.c line 874
static signed int check_realloc(char **buf, signed int *size, signed int used, signed int mustadded)
{
  char *newbuf;
  signed int len;
  while(!(*size + -used >= mustadded))
  {
    len = *size + 4096;
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)*buf, (unsigned long int)len);
    newbuf = (char *)return_value_realloc$1;
    if(newbuf == ((char *)NULL))
      return 11;

    *buf = newbuf;
    *size = *size + 4096;
  }
  return 1;
}

// check_reg
// file registry.c line 108
static signed int check_reg(void *data, const char *name, const void *val)
{
  struct check_reg_data *rdata = (struct check_reg_data *)data;
  rdata->count = rdata->count + 1;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(rdata->name, name);
  if(return_value_strcmp$1 == 0)
  {
    rdata->found = 1;
    return 1;
  }

  else
    return 0;
}

// check_tables
// file txt_format.c line 218
struct ci_fmt_entry * check_tables(const char *var, struct ci_fmt_entry *u_table, signed int *directive_len, unsigned int *width, signed int *left_align, char *parameter)
{
  signed int i;
  unsigned int params_len;
  params_len=parse_directive(var, width, left_align, parameter);
  i = 0;
  for( ; !(GlobalTable[(signed long int)i].directive == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_check_directive$1;
    return_value_check_directive$1=check_directive(var + (signed long int)params_len, GlobalTable[(signed long int)i].directive, directive_len);
    if(!(return_value_check_directive$1 == 0))
    {
      *directive_len = *directive_len + (signed int)params_len;
      return &GlobalTable[(signed long int)i];
    }

  }
  if(!(u_table == ((struct ci_fmt_entry *)NULL)))
  {
    i = 0;
    for( ; !((u_table + (signed long int)i)->directive == ((const char *)NULL)); i = i + 1)
    {
      signed int return_value_check_directive$2;
      return_value_check_directive$2=check_directive(var + (signed long int)params_len, (u_table + (signed long int)i)->directive, directive_len);
      if(!(return_value_check_directive$2 == 0))
      {
        *directive_len = *directive_len + (signed int)params_len;
        return &u_table[(signed long int)i];
      }

    }
  }

  return (struct ci_fmt_entry *)(void *)0;
}

// check_unicode
// file filetype.c line 495
signed int check_unicode(unsigned char *buf, signed int buflen)
{
  signed int i;
  signed int ret = 0;
  signed int endian = 0;
  i = 0;
  for( ; !(i >= buflen); i = i + ret)
  {
    ret=isUTF8(buf + (signed long int)i, buflen - i);
    if(!(ret >= 1))
      break;

  }
  if(i == 0 && !(ret >= 0))
    ret = 0;

  if(!(ret == 0))
    return 3;

  else
    if(!(buflen >= 2))
      return -1;

    else
    {
      _Bool tmp_if_expr$2;
      if((signed int)*buf == 0xff)
        tmp_if_expr$2 = (signed int)buf[(signed long int)1] == 0xfe ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        endian = 0;

      else
      {
        _Bool tmp_if_expr$1;
        if((signed int)*buf == 0xfe)
          tmp_if_expr$1 = (signed int)buf[(signed long int)1] == 0xff ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          endian = 1;

        else
          return -1;
      }
      i = 2;
      for( ; !(i >= buflen); i = i + 2)
        if(!(endian == 0))
        {
          if((signed int)buf[(signed long int)i] == 0)
          {
            if(!((signed int)buf[(signed long int)(1 + i)] >= 128))
            {
              if(!((signed int)text_chars[(signed long int)buf[(signed long int)(1 + i)]] == 1))
                return -1;

            }

          }

        }

        else
          if((signed int)buf[(signed long int)(1 + i)] == 0)
          {
            if(!((signed int)buf[(signed long int)i] >= 128))
            {
              if(!((signed int)text_chars[(signed long int)buf[(signed long int)i]] == 1))
                return -1;

            }

          }

      return 3;
    }
}

// ci_MD5Final
// file md5.c line 107
void ci_MD5Final(unsigned char *digest, struct ci_MD5Context *ctx)
{
  unsigned int count;
  unsigned char *p;
  unsigned int *uin;
  count = ctx->bits[(signed long int)0] >> 3 & (unsigned int)0x3F;
  p = ctx->in + (signed long int)count;
  unsigned char *tmp_post$1 = p;
  p = p + 1l;
  *tmp_post$1 = (unsigned char)0x80;
  count = (unsigned int)(64 - 1) - count;
  if(!(count >= 8u))
  {
    memset((void *)p, 0, (unsigned long int)count);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    memset((void *)ctx->in, 0, (unsigned long int)56);
  }

  else
    memset((void *)p, 0, (unsigned long int)(count - (unsigned int)8));
  byteReverse(ctx->in, (unsigned int)14);
  uin = (unsigned int *)ctx->in;
  uin[(signed long int)14] = ctx->bits[(signed long int)0];
  uin[(signed long int)15] = ctx->bits[(signed long int)1];
  MD5Transform(ctx->buf, (unsigned int *)ctx->in);
  byteReverse((unsigned char *)ctx->buf, (unsigned int)4);
  memcpy((void *)digest, (const void *)ctx->buf, (unsigned long int)16);
  memset((void *)ctx, 0, sizeof(struct ci_MD5Context) /*88ul*/ );
}

// ci_MD5Init
// file md5.c line 44
void ci_MD5Init(struct ci_MD5Context *ctx)
{
  ctx->buf[(signed long int)0] = (unsigned int)0x67452301;
  ctx->buf[(signed long int)1] = 0xefcdab89;
  ctx->buf[(signed long int)2] = 0x98badcfe;
  ctx->buf[(signed long int)3] = (unsigned int)0x10325476;
  ctx->bits[(signed long int)0] = (unsigned int)0;
  ctx->bits[(signed long int)1] = (unsigned int)0;
}

// ci_MD5Update
// file md5.c line 59
void ci_MD5Update(struct ci_MD5Context *ctx, const unsigned char *buf, unsigned long int len)
{
  unsigned int t = ctx->bits[(signed long int)0];
  ctx->bits[(signed long int)0] = t + ((unsigned int)len << 3);
  if(!(ctx->bits[0l] >= t))
    ctx->bits[(signed long int)1] = ctx->bits[(signed long int)1] + 1u;

  ctx->bits[(signed long int)1] = ctx->bits[(signed long int)1] + (unsigned int)(len >> 29);
  t = t >> 3 & (unsigned int)0x3f;
  if(!(t == 0u))
  {
    unsigned char *p = (unsigned char *)ctx->in + (signed long int)t;
    t = (unsigned int)64 - t;
    if(!(len >= (unsigned long int)t))
    {
      memcpy((void *)p, (const void *)buf, len);
      goto __CPROVER_DUMP_L5;
    }

    memcpy((void *)p, (const void *)buf, (unsigned long int)t);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    buf = buf + (signed long int)t;
    len = len - (unsigned long int)t;
  }

  for( ; len >= 64ul; len = len - (unsigned long int)64)
  {
    memcpy((void *)ctx->in, (const void *)buf, (unsigned long int)64);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    buf = buf + (signed long int)64;
  }
  memcpy((void *)ctx->in, (const void *)buf, len);

__CPROVER_DUMP_L5:
  ;
}

// ci_access_entry_add_acl
// file acl.c line 468
const struct ci_acl_spec * ci_access_entry_add_acl(struct ci_access_entry *access_entry, const struct ci_acl_spec *acl, signed int negate)
{
  struct ci_specs_list *spec_list;
  struct ci_specs_list *spec_entry;
  if(access_entry == ((struct ci_access_entry *)NULL))
    return (const struct ci_acl_spec *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct ci_specs_list) /*24ul*/ );
    spec_entry = (struct ci_specs_list *)return_value_malloc$1;
    if(spec_entry == ((struct ci_specs_list *)NULL))
      return (const struct ci_acl_spec *)(void *)0;

    else
    {
      spec_entry->next = (struct ci_specs_list *)(void *)0;
      spec_entry->negate = negate;
      spec_entry->spec = acl;
      if(access_entry->spec_list == ((struct ci_specs_list *)NULL))
        access_entry->spec_list = spec_entry;

      else
      {
        spec_list = access_entry->spec_list;
        for( ; !(spec_list->next == ((struct ci_specs_list *)NULL)); spec_list = spec_list->next)
          ;
        spec_list->next = spec_entry;
      }
      return acl;
    }
  }
}

// ci_access_entry_add_acl_by_name
// file acl.c line 492
signed int ci_access_entry_add_acl_by_name(struct ci_access_entry *access_entry, const char *acl_name)
{
  const struct ci_acl_spec *acl;
  signed int negate = 0;
  if((signed int)*acl_name == 33)
  {
    negate = 1;
    acl_name = acl_name + (signed long int)1;
  }

  acl=ci_acl_search(acl_name);
  if(acl == ((const struct ci_acl_spec *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "The acl spec %s does not exists!\n", acl_name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("The acl spec %s does not exists!\n", acl_name);

    }

    return 0;
  }

  else
  {
    const struct ci_acl_spec *return_value_ci_access_entry_add_acl$1;
    return_value_ci_access_entry_add_acl$1=ci_access_entry_add_acl(access_entry, acl, negate);
    if(return_value_ci_access_entry_add_acl$1 == ((const struct ci_acl_spec *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error adding acl spec %s to the access list!\n", acl_name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error adding acl spec %s to the access list!\n", acl_name);

      }

      return 0;
    }

    else
      return 1;
  }
}

// ci_access_entry_match_request
// file acl.c line 751
signed int ci_access_entry_match_request(struct ci_access_entry *access_entry, struct ci_request *req)
{
  struct ci_specs_list *spec_list;
  signed int return_value_request_match_specslist$1;
  if(access_entry == ((struct ci_access_entry *)NULL))
    return 1;

  else
  {
    while(!(access_entry == ((struct ci_access_entry *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Check request with an access entry\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Check request with an access entry\n");

      }

      spec_list = access_entry->spec_list;
      if(!(spec_list == ((struct ci_specs_list *)NULL)))
      {
        if(!(spec_list->spec == ((const struct ci_acl_spec *)NULL)))
        {
          return_value_request_match_specslist$1=request_match_specslist(req, spec_list);
          if(!(return_value_request_match_specslist$1 == 0))
            return access_entry->type;

        }

      }

      access_entry = access_entry->next;
    }
    return 0;
  }
}

// ci_access_entry_new
// file acl.c line 419
struct ci_access_entry * ci_access_entry_new(struct ci_access_entry **list, signed int type)
{
  struct ci_access_entry *access_entry;
  struct ci_access_entry *cur;
  if(list == ((struct ci_access_entry **)NULL))
    return (struct ci_access_entry *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct ci_access_entry) /*24ul*/ );
    access_entry = (struct ci_access_entry *)return_value_malloc$1;
    if(access_entry == ((struct ci_access_entry *)NULL))
      return (struct ci_access_entry *)(void *)0;

    else
    {
      access_entry->type = type;
      access_entry->spec_list = (struct ci_specs_list *)(void *)0;
      access_entry->next = (struct ci_access_entry *)(void *)0;
      if(*list == ((struct ci_access_entry *)NULL))
        *list = access_entry;

      else
      {
        cur = *list;
        for( ; !(cur->next == ((struct ci_access_entry *)NULL)); cur = cur->next)
          ;
        cur->next = access_entry;
      }
      return access_entry;
    }
  }
}

// ci_access_entry_release
// file acl.c line 445
void ci_access_entry_release(struct ci_access_entry *list)
{
  struct ci_access_entry *access_entry;
  struct ci_specs_list *spec_list;
  struct ci_specs_list *cur;
  if(!(list == ((struct ci_access_entry *)NULL)))
  {
    access_entry = list;
    while(!(list == ((struct ci_access_entry *)NULL)))
    {
      access_entry = list;
      list = list->next;
      spec_list = access_entry->spec_list;
      while(!(spec_list == ((struct ci_specs_list *)NULL)))
      {
        cur = spec_list;
        spec_list = spec_list->next;
        free((void *)cur);
      }
      free((void *)access_entry);
    }
  }

}

// ci_acl_add_data
// file acl.c line 824
signed int ci_acl_add_data(const char *name, const char *type, const char *data)
{
  struct ci_acl_spec *spec;
  const struct ci_acl_type *spec_type;
  char *s;
  char *param = (char *)(void *)0;
  char *acl_type;
  acl_type=strdup(type);
  if(acl_type == ((char *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "cfg_acl_add: error strduping!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("cfg_acl_add: error strduping!\n");

    }

    return 0;
  }

  else
  {
    s = acl_type;
    s=strchr(s, 123);
    if(!(s == ((char *)NULL)))
    {
      *s = (char)0;
      param = s + (signed long int)1;
      s=strchr(param, 125);
      if(!(s == ((char *)NULL)))
        *s = (char)0;

    }

    spec=ci_acl_spec_search(specs_list, name);
    if(!(spec == ((struct ci_acl_spec *)NULL)))
    {
      spec_type=ci_acl_type_search(acl_type);
      if(!(spec_type == spec->type))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "The acl type:%s does not match with type of existing acl \"%s\"", acl_type, name);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("The acl type:%s does not match with type of existing acl \"%s\"", acl_type, name);

        }

        free((void *)acl_type);
        return 0;
      }

    }

    else
      spec=ci_acl_spec_new(name, acl_type, param, &types_list, &specs_list);
    free((void *)acl_type);
    if(spec == ((struct ci_acl_spec *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error in acl:%s! Maybe the acl type \"%s\" does not exists!\n", name, acl_type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error in acl:%s! Maybe the acl type \"%s\" does not exists!\n", name, acl_type);

      }

      return 0;
    }

    else
    {
      ci_acl_spec_new_data(spec, data);
      return 1;
    }
  }
}

// ci_acl_init
// file acl.c line 796
void ci_acl_init()
{
  ci_acl_typelist_init(&types_list);
  acl_load_defaults();
  specs_list = (struct ci_acl_spec *)(void *)0;
}

// ci_acl_reset
// file acl.c line 803
void ci_acl_reset()
{
  ci_acl_spec_list_release(specs_list);
  specs_list = (struct ci_acl_spec *)(void *)0;
  ci_acl_typelist_reset(&types_list);
  acl_load_defaults();
}

// ci_acl_search
// file acl.c line 811
const struct ci_acl_spec * ci_acl_search(const char *name)
{
  struct ci_acl_spec *return_value_ci_acl_spec_search$1;
  return_value_ci_acl_spec_search$1=ci_acl_spec_search(specs_list, name);
  return (const struct ci_acl_spec *)return_value_ci_acl_spec_search$1;
}

// ci_acl_spec_list_release
// file acl.c line 615
void ci_acl_spec_list_release(struct ci_acl_spec *spec)
{
  struct ci_acl_spec *cur;
  while(!(spec == ((struct ci_acl_spec *)NULL)))
  {
    cur = spec;
    spec = spec->next;
    ci_acl_spec_release(cur);
  }
}

// ci_acl_spec_new
// file acl.c line 514
struct ci_acl_spec * ci_acl_spec_new(const char *name, const char *type, const char *param, struct ci_acl_type_list *list, struct ci_acl_spec **spec_list)
{
  struct ci_acl_spec *spec;
  struct ci_acl_spec *cur;
  const struct ci_acl_type *acl_type;
  acl_type=ci_acl_typelist_search(list, type);
  if(acl_type == ((const struct ci_acl_type *)NULL))
    return (struct ci_acl_spec *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct ci_acl_spec) /*64ul*/ );
    spec = (struct ci_acl_spec *)return_value_malloc$1;
    if(spec == ((struct ci_acl_spec *)NULL))
      return (struct ci_acl_spec *)(void *)0;

    else
    {
      strncpy(spec->name, name, (unsigned long int)31);
      spec->name[(signed long int)31] = (char)0;
      if(!(param == ((const char *)NULL)))
      {
        spec->parameter=strdup(param);
        if(spec->parameter == ((char *)NULL))
        {
          free((void *)spec);
          return (struct ci_acl_spec *)(void *)0;
        }

      }

      else
        spec->parameter = (char *)(void *)0;
      spec->type = acl_type;
      spec->data = (struct ci_acl_data *)(void *)0;
      spec->next = (struct ci_acl_spec *)(void *)0;
      if(!(spec_list == ((struct ci_acl_spec **)NULL)))
      {
        if(!(*spec_list == ((struct ci_acl_spec *)NULL)))
        {
          cur = *spec_list;
          for( ; !(cur->next == ((struct ci_acl_spec *)NULL)); cur = cur->next)
            ;
          cur->next = spec;
        }

        else
          *spec_list = spec;
      }

      return spec;
    }
  }
}

// ci_acl_spec_new_data
// file acl.c line 552
struct ci_acl_data * ci_acl_spec_new_data(struct ci_acl_spec *spec, const char *val)
{
  struct ci_acl_data *new_data;
  struct ci_acl_data *list;
  const struct ci_type_ops *ops;
  void *data;
  if(spec == ((struct ci_acl_spec *)NULL))
    return (struct ci_acl_data *)(void *)0;

  else
  {
    ops = spec->type->type;
    data=ops->dup(val, default_allocator);
    if(data == NULL)
      return (struct ci_acl_data *)(void *)0;

    else
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct ci_acl_data) /*16ul*/ );
      new_data = (struct ci_acl_data *)return_value_malloc$1;
      if(new_data == ((struct ci_acl_data *)NULL))
      {
        ops->free(data, default_allocator);
        return (struct ci_acl_data *)(void *)0;
      }

      else
      {
        new_data->data = data;
        new_data->next = (struct ci_acl_data *)(void *)0;
        list = spec->data;
        if(!(list == ((struct ci_acl_data *)NULL)))
        {
          if(!(list->next == ((struct ci_acl_data *)NULL)))
            list = list->next;

          list->next = new_data;
        }

        else
          spec->data = new_data;
        return new_data;
      }
    }
  }
}

// ci_acl_spec_release
// file acl.c line 601
void ci_acl_spec_release(struct ci_acl_spec *cur)
{
  struct ci_acl_data *dhead;
  struct ci_acl_data *dtmp;
  const struct ci_type_ops *ops;
  dhead = cur->data;
  ops = cur->type->type;
  if(!(dhead == ((struct ci_acl_data *)NULL)))
  {
    dtmp = dhead;
    dhead = dhead->next;
    ops->free(dtmp->data, default_allocator);
    free((void *)dtmp);
  }

}

// ci_acl_spec_search
// file acl.c line 583
struct ci_acl_spec * ci_acl_spec_search(struct ci_acl_spec *list, const char *name)
{
  struct ci_acl_spec *spec;
  if(CI_DEBUG_LEVEL >= 9)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "In search specs list %p,name %s\n", list, name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("In search specs list %p,name %s\n", list, name);

  }

  if(name == ((const char *)NULL) || list == ((struct ci_acl_spec *)NULL))
    return (struct ci_acl_spec *)(void *)0;

  else
  {
    spec = list;
    while(!(spec == ((struct ci_acl_spec *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Checking name:%s with specname %s\n", name, (const void *)spec->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Checking name:%s with specname %s\n", name, (const void *)spec->name);

      }

      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(spec->name, name);
      if(return_value_strcmp$1 == 0)
        return spec;

      spec = spec->next;
    }
    return (struct ci_acl_spec *)(void *)0;
  }
}

// ci_acl_type_add
// file acl.c line 819
signed int ci_acl_type_add(const struct ci_acl_type *type)
{
  signed int return_value_ci_acl_typelist_add$1;
  return_value_ci_acl_typelist_add$1=ci_acl_typelist_add(&types_list, type);
  return return_value_ci_acl_typelist_add$1;
}

// ci_acl_type_search
// file acl.c line 815
const struct ci_acl_type * ci_acl_type_search(const char *name)
{
  const struct ci_acl_type *return_value_ci_acl_typelist_search$1;
  return_value_ci_acl_typelist_search$1=ci_acl_typelist_search(&types_list, name);
  return return_value_ci_acl_typelist_search$1;
}

// ci_acl_typelist_add
// file acl.c line 638
signed int ci_acl_typelist_add(struct ci_acl_type_list *list, const struct ci_acl_type *type)
{
  struct ci_acl_type *cur;
  struct ci_acl_type *nl = (struct ci_acl_type *)(void *)0;
  {
    const struct ci_acl_type *return_value_ci_acl_typelist_search$1;
    return_value_ci_acl_typelist_search$1=ci_acl_typelist_search(list, type->name);
    if(!(return_value_ci_acl_typelist_search$1 == ((const struct ci_acl_type *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "The acl type %s already defined\n", (const void *)type->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("The acl type %s already defined\n", (const void *)type->name);

      }

      return 0;
    }

    else
    {
      if(list->acl_type_list_num == list->acl_type_list_size)
      {
        list->acl_type_list_size = list->acl_type_list_size + 32;
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)list->acl_type_list, (unsigned long int)list->acl_type_list_size * sizeof(struct ci_acl_type) /*56ul*/ );
        nl = (struct ci_acl_type *)return_value_realloc$2;
        if(nl == ((struct ci_acl_type *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Failed to allocate more space for new ci_acl_typr_t\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Failed to allocate more space for new ci_acl_typr_t\n");

          }

          return 0;
        }

        list->acl_type_list = nl;
      }

      cur = &list->acl_type_list[(signed long int)list->acl_type_list_num];
      strncpy(cur->name, type->name, (unsigned long int)31);
      cur->name[(signed long int)31] = (char)0;
      cur->type = type->type;
      cur->get_test_data = type->get_test_data;
      list->acl_type_list_num = list->acl_type_list_num + 1;
      return 1;
    }
  }
}

// ci_acl_typelist_init
// file acl.c line 630
signed int ci_acl_typelist_init(struct ci_acl_type_list *list)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)32 * sizeof(struct ci_acl_type) /*56ul*/ );
  list->acl_type_list = (struct ci_acl_type *)return_value_malloc$1;
  list->acl_type_list_size = 32;
  list->acl_type_list_num = 0;
  return 1;
}

// ci_acl_typelist_release
// file acl.c line 681
signed int ci_acl_typelist_release(struct ci_acl_type_list *list)
{
  free((void *)list->acl_type_list);
  list->acl_type_list_size = 0;
  list->acl_type_list_num = 0;
  return 1;
}

// ci_acl_typelist_reset
// file acl.c line 689
signed int ci_acl_typelist_reset(struct ci_acl_type_list *list)
{
  list->acl_type_list_num = 0;
  return 1;
}

// ci_acl_typelist_search
// file acl.c line 671
const struct ci_acl_type * ci_acl_typelist_search(struct ci_acl_type_list *list, const char *name)
{
  signed int i = 0;
  for( ; !(i >= list->acl_type_list_num); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((list->acl_type_list + (signed long int)i)->name, name);
    if(return_value_strcmp$1 == 0)
      return (const struct ci_acl_type *)&list->acl_type_list[(signed long int)i];

  }
  return (const struct ci_acl_type *)(void *)0;
}

// ci_args_apply
// file ../include/cfg_param.h line 200
signed int ci_args_apply(signed int argc, char **argv, struct ci_options_entry *options)
{
  signed int i;
  struct ci_options_entry *entry;
  const char *act_args[2l];
  act_args[(signed long int)1] = (const char *)(void *)0;
  i = 1;
  if(!(i >= argc))
  {
    entry=search_options_table(argv[(signed long int)i], options);
    if(entry == ((struct ci_options_entry *)NULL))
      return 0;

    if(!(entry->parameter == ((const char *)NULL)))
    {
      i = i + 1;
      if(i >= argc)
        return 0;

      act_args[(signed long int)0] = argv[(signed long int)i];
      entry->action(entry->name, act_args, entry->data);
    }

    else
    {
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(entry->name, "$$");
      if(return_value_strcmp$1 == 0)
      {
        act_args[(signed long int)0] = argv[(signed long int)i];
        entry->action(entry->name, act_args, entry->data);
      }

      else
        entry->action(entry->name, (const char **)(void *)0, entry->data);
    }
    i = i + 1;
  }

  return 1;
}

// ci_args_usage
// file ../include/cfg_param.h line 199
void ci_args_usage(const char *progname, struct ci_options_entry *options)
{
  signed int i;
  printf("Usage : \n");
  printf("%s", progname);
  i = 0;
  for( ; !((options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
    if((signed int)*(options + (signed long int)i)->name == 36)
      printf(" [file1] [file2] ...");

    else
    {
      char *tmp_if_expr$1;
      if((options + (signed long int)i)->parameter == ((const char *)NULL))
        tmp_if_expr$1 = "";

      else
        tmp_if_expr$1 = (options + (signed long int)i)->parameter;
      printf(" [%s %s]", (options + (signed long int)i)->name, tmp_if_expr$1);
    }
  printf("\n\n");
  i = 0;
  for( ; !((options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
    if((signed int)*(options + (signed long int)i)->name == 36)
      printf(" [file1] [file2] ...\t: %s\n", (options + (signed long int)i)->msg);

    else
    {
      char *tmp_if_expr$2;
      if((options + (signed long int)i)->parameter == ((const char *)NULL))
        tmp_if_expr$2 = "\t";

      else
        tmp_if_expr$2 = (options + (signed long int)i)->parameter;
      printf("%s %s\t\t: %s\n", (options + (signed long int)i)->name, tmp_if_expr$2, (options + (signed long int)i)->msg);
    }
}

// ci_array_add
// file include/array.h line 118
const struct ci_array_item * ci_array_add(struct ci_array *array, const char *name, const void *value, unsigned long int size)
{
  struct ci_array_item *item;
  struct ci_mem_allocator *packer = array->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value_ci_pack_allocator_alloc_unaligned$1;
  return_value_ci_pack_allocator_alloc_unaligned$1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((struct ci_array_item *)0)[(signed long int)1]);
  item = (struct ci_array_item *)return_value_ci_pack_allocator_alloc_unaligned$1;
  if(!(item == ((struct ci_array_item *)NULL)))
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(name);
    void *return_value_ci_pack_allocator_alloc_from_rear$3;
    return_value_ci_pack_allocator_alloc_from_rear$3=ci_pack_allocator_alloc_from_rear(packer, (signed int)(return_value_strlen$2 + (unsigned long int)1));
    item->name = (char *)return_value_ci_pack_allocator_alloc_from_rear$3;
    item->value=ci_pack_allocator_alloc_from_rear(packer, (signed int)size);
  }

  _Bool tmp_if_expr$4;
  if(item == ((struct ci_array_item *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = !(item->name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = !(item->value != NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$5)
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item to array!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item to array!\n");

    }

    return (const struct ci_array_item *)(void *)0;
  }

  else
  {
    strcpy(item->name, name);
    memcpy(item->value, value, size);
    if(array->items == ((struct ci_array_item *)NULL))
      array->items = item;

    array->count = array->count + 1u;
    return item;
  }
}

// ci_array_destroy
// file include/array.h line 107
void ci_array_destroy(struct ci_array *array)
{
  void *buffer = (void *)array->mem;
  /* assertion buffer */
  assert(buffer != NULL);
  if(!(array->alloc == ((struct ci_mem_allocator *)NULL)))
    ci_mem_allocator_destroy(array->alloc);

  ci_buffer_free(buffer);
}

// ci_array_get_item
// file array.c line 144
const struct ci_array_item * ci_array_get_item(struct ci_array *array, signed int pos)
{
  if((unsigned int)pos >= array->count)
    return (const struct ci_array_item *)(void *)0;

  else
    return &array->items[(signed long int)pos];
}

// ci_array_iterate
// file array.c line 116
void ci_array_iterate(const struct ci_array *array, void *data, signed int (*fn)(void *, const char *, const void *))
{
  signed int i;
  signed int ret = 0;
  i = 0;
  if(ret == 0 && !((unsigned int)i >= array->count))
  {
    ret=fn(data, (array->items + (signed long int)i)->name, (array->items + (signed long int)i)->value);
    i = i + 1;
  }

}

// ci_array_new
// file include/array.h line 90
struct ci_array * ci_array_new(unsigned long int size)
{
  struct ci_array *array;
  struct ci_mem_allocator *packer;
  void *buffer;
  buffer=ci_buffer_alloc((signed int)size);
  if(buffer == NULL)
    return (struct ci_array *)(void *)0;

  else
  {
    packer=ci_create_pack_allocator_on_memblock((char *)buffer, size);
    if(packer == ((struct ci_mem_allocator *)NULL))
    {
      ci_buffer_free(buffer);
      return (struct ci_array *)(void *)0;
    }

    else
    {
      void *return_value_ci_pack_allocator_alloc$1;
      return_value_ci_pack_allocator_alloc$1=ci_pack_allocator_alloc(packer, sizeof(struct ci_array) /*40ul*/ );
      array = (struct ci_array *)return_value_ci_pack_allocator_alloc$1;
      if(array == ((struct ci_array *)NULL))
      {
        ci_buffer_free(buffer);
        ci_mem_allocator_destroy(packer);
        return (struct ci_array *)(void *)0;
      }

      else
      {
        array->max_size = size;
        array->count = (unsigned int)0;
        array->items = (struct ci_array_item *)(void *)0;
        array->mem = (char *)buffer;
        array->alloc = packer;
        return array;
      }
    }
  }
}

// ci_array_new2
// file array.c line 60
struct ci_array * ci_array_new2(unsigned long int items, unsigned long int item_size)
{
  unsigned long int array_size;
  unsigned long int return_value_ci_pack_allocator_required_size$1;
  return_value_ci_pack_allocator_required_size$1=ci_pack_allocator_required_size();
  array_size = return_value_ci_pack_allocator_required_size$1 + (sizeof(struct ci_array) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + items * ((item_size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_array_item) /*16ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  struct ci_array *return_value_ci_array_new$2;
  return_value_ci_array_new$2=ci_array_new(array_size);
  return return_value_ci_array_new$2;
}

// ci_array_pop
// file array.c line 125
const struct ci_array_item * ci_array_pop(struct ci_array *array)
{
  struct ci_array_item *item;
  if(array->count == 0u)
    return (const struct ci_array_item *)(void *)0;

  else
  {
    item = &array->items[(signed long int)(array->count - (unsigned int)1)];
    ci_pack_allocator_set_start_pos(array->alloc, (void *)item);
    array->count = array->count - 1u;
    if(array->count == 0u)
      ci_pack_allocator_set_end_pos(array->alloc, (void *)0);

    else
    {
      void *tmp_if_expr$1;
      if(!((void *)(array->items + (signed long int)(array->count + 4294967295u))->name >= (array->items + (signed long int)(array->count + 4294967295u))->value))
        tmp_if_expr$1 = (void *)(array->items + (signed long int)(array->count - (unsigned int)1))->name;

      else
        tmp_if_expr$1 = (void *)(array->items + (signed long int)(array->count - (unsigned int)1))->value;
      ci_pack_allocator_set_end_pos(array->alloc, tmp_if_expr$1);
    }
    return item;
  }
}

// ci_array_search
// file include/array.h line 135
const void * ci_array_search(struct ci_array *array, const char *name)
{
  signed int i = 0;
  for( ; !((unsigned int)i >= array->count); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((array->items + (signed long int)i)->name, name);
    if(return_value_strcmp$1 == 0)
      return (array->items + (signed long int)i)->value;

  }
  return (void *)0;
}

// ci_atol_ext
// file util.c line 78
signed long int ci_atol_ext(const char *str, const char **error)
{
  char *e;
  signed long int val;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  val=strtol(str, &e, 10);
  if(!(error == ((const char **)NULL)))
  {
    *error = (const char *)(void *)0;
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if((val == 0x7fffffffffffffffL || val == -9223372036854775808l) && *return_value___errno_location$3 == 34)
    {
      *error = atol_err_erange;
      goto __CPROVER_DUMP_L5;
    }

    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(val == 0l && !(*return_value___errno_location$2 == 0))
      *error = atol_err_conversion;

    else
      if(e == str)
        *error = atol_err_nonumber;


  __CPROVER_DUMP_L5:
    ;
    if(!(*error == ((const char *)NULL)))
      return (signed long int)0;

  }

  if(!(val == 0l))
  {
    _Bool tmp_if_expr$5;
    if((signed int)*e == 107)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)*e == 75 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      val = val * (signed long int)1024;

    else
    {
      _Bool tmp_if_expr$4;
      if((signed int)*e == 109)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)*e == 77 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        val = val * (signed long int)1024 * (signed long int)1024;

    }
  }

  return val;
}

// ci_base64_decode
// file decode.c line 54
signed int ci_base64_decode(const char *encoded, char *decoded, signed int len)
{
  signed int i;
  unsigned char *str;
  unsigned char *result;
  if(decoded == ((char *)NULL) || encoded == ((const char *)NULL) || len == 0)
    return 0;

  else
  {
    str = (unsigned char *)encoded;
    result = (unsigned char *)decoded;
    i = len;
    for( ; i >= 4; i = i - 3)
    {
      _Bool tmp_if_expr$1;
      if((signed int)base64_table[(signed long int)*str] >= 64)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)base64_table[(signed long int)str[(signed long int)1]] > 63 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$2;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)base64_table[(signed long int)str[(signed long int)2]] > 63 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)base64_table[(signed long int)str[(signed long int)3]] > 63 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        break;

      unsigned char *tmp_post$4 = result;
      result = result + 1l;
      *tmp_post$4 = (unsigned char)((signed int)base64_table[(signed long int)*str] << 2 | (signed int)base64_table[(signed long int)str[(signed long int)1]] >> 4);
      unsigned char *tmp_post$5 = result;
      result = result + 1l;
      *tmp_post$5 = (unsigned char)((signed int)base64_table[(signed long int)str[(signed long int)1]] << 4 | (signed int)base64_table[(signed long int)str[(signed long int)2]] >> 2);
      unsigned char *tmp_post$6 = result;
      result = result + 1l;
      *tmp_post$6 = (unsigned char)((signed int)base64_table[(signed long int)str[(signed long int)2]] << 6 | (signed int)base64_table[(signed long int)str[(signed long int)3]]);
      str = str + (signed long int)4;
    }
    *result = (unsigned char)0;
    return len - i;
  }
}

// ci_base64_decode_dup
// file decode.c line 88
char * ci_base64_decode_dup(const char *encoded)
{
  signed int len;
  char *result;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(encoded);
  len = (signed int)return_value_strlen$1;
  len = ((len + 3) / 4) * 3 + 1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)len * sizeof(char) /*1ul*/ );
  result = (char *)return_value_malloc$2;
  if(result == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    ci_base64_decode(encoded, result, len);
    return result;
  }
}

// ci_base64_encode
// file decode.c line 111
signed int ci_base64_encode(const unsigned char *data, unsigned long int len, char *out, unsigned long int outlen)
{
  signed int i;
  signed int k;
  const char *base64_set = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  i = 0;
  k = 0;
  for( ; !((unsigned long int)i >= len + 18446744073709551613ul) && !((unsigned long int)k >= outlen + 18446744073709551612ul); i = i + 3)
  {
    signed int tmp_post$1 = k;
    k = k + 1;
    out[(signed long int)tmp_post$1] = base64_set[(signed long int)((signed int)data[(signed long int)i] >> 2 & 0x3F)];
    signed int tmp_post$2 = k;
    k = k + 1;
    out[(signed long int)tmp_post$2] = base64_set[(signed long int)(((signed int)data[(signed long int)i] << 4 | (signed int)data[(signed long int)(i + 1)] >> 4) & 0x3F)];
    signed int tmp_post$3 = k;
    k = k + 1;
    out[(signed long int)tmp_post$3] = base64_set[(signed long int)(((signed int)data[(signed long int)(i + 1)] << 2 | (signed int)data[(signed long int)(i + 2)] >> 6) & 0x3F)];
    signed int tmp_post$4 = k;
    k = k + 1;
    out[(signed long int)tmp_post$4] = base64_set[(signed long int)((signed int)data[(signed long int)(i + 2)] & 0x3F)];
  }
  if(!((unsigned long int)i >= len) && !((unsigned long int)k >= outlen + 18446744073709551612ul))
  {
    signed int tmp_post$5 = k;
    k = k + 1;
    signed int tmp_if_expr$6;
    if(!((unsigned long int)i >= len))
      tmp_if_expr$6 = (signed int)data[(signed long int)i];

    else
      tmp_if_expr$6 = 0;
    out[(signed long int)tmp_post$5] = base64_set[(signed long int)(tmp_if_expr$6 >> 2 & 0x3F)];
    signed int tmp_post$7 = k;
    k = k + 1;
    signed int tmp_if_expr$8;
    if(!((unsigned long int)i >= len))
      tmp_if_expr$8 = (signed int)data[(signed long int)i];

    else
      tmp_if_expr$8 = 0;
    signed int tmp_if_expr$9;
    if(!((unsigned long int)(1 + i) >= len))
      tmp_if_expr$9 = (signed int)data[(signed long int)(i + 1)];

    else
      tmp_if_expr$9 = 0;
    out[(signed long int)tmp_post$7] = base64_set[(signed long int)((tmp_if_expr$8 << 4 | tmp_if_expr$9 >> 4) & 0x3F)];
    signed int tmp_post$10 = k;
    k = k + 1;
    signed int tmp_if_expr$11;
    if(!((unsigned long int)(1 + i) >= len))
      tmp_if_expr$11 = (signed int)data[(signed long int)(i + 1)];

    else
      tmp_if_expr$11 = 0;
    signed int tmp_if_expr$12;
    if(!((unsigned long int)(2 + i) >= len))
      tmp_if_expr$12 = (signed int)data[(signed long int)(i + 2)];

    else
      tmp_if_expr$12 = 0;
    out[(signed long int)tmp_post$10] = base64_set[(signed long int)((tmp_if_expr$11 << 2 | tmp_if_expr$12 >> 6) & 0x3F)];
    signed int tmp_post$13 = k;
    k = k + 1;
    signed int tmp_if_expr$14;
    if(!((unsigned long int)(2 + i) >= len))
      tmp_if_expr$14 = (signed int)data[(signed long int)(i + 2)];

    else
      tmp_if_expr$14 = 0;
    out[(signed long int)tmp_post$13] = base64_set[(signed long int)(tmp_if_expr$14 & 0x3F)];
  }

  out[(signed long int)k] = (char)0;
  return k;
}

// ci_belongs_to_group
// file filetype.c line 153
signed int ci_belongs_to_group(struct ci_magics_db *db, signed int type, signed int group)
{
  signed int i;
  if(!(db->types_num >= type))
    return 0;

  else
  {
    i = 0;
    for( ; (db->types + (signed long int)type)->groups[(signed long int)i] >= 0; i = i + 1)
    {
      if(i >= 64)
        break;

      if((db->types + (signed long int)type)->groups[(signed long int)i] == group)
        return 1;

    }
    return 0;
  }
}

// ci_buf_init
// file request_common.c line 45
void ci_buf_init(struct ci_buf *buf)
{
  buf->buf = (char *)(void *)0;
  buf->size = 0;
  buf->used = 0;
}

// ci_buf_mem_alloc
// file request_common.c line 56
signed int ci_buf_mem_alloc(struct ci_buf *buf, signed int size)
{
  void *return_value;
  return_value=__intl_malloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
  buf->buf = (char *)return_value;
  if(buf->buf == ((char *)NULL))
    return 0;

  else
  {
    buf->size = size;
    buf->used = 0;
    return size;
  }
}

// ci_buf_mem_free
// file request_common.c line 65
void ci_buf_mem_free(struct ci_buf *buf)
{
  __intl_free((void *)buf->buf);
  buf->buf = (char *)(void *)0;
  buf->size = 0;
  buf->used = 0;
}

// ci_buf_reset
// file request_common.c line 52
void ci_buf_reset(struct ci_buf *buf)
{
  buf->used = 0;
}

// ci_buf_reset_size
// file request_common.c line 83
signed int ci_buf_reset_size(struct ci_buf *buf, signed int req_size)
{
  if(!(req_size >= buf->size))
    return req_size;

  else
  {
    if(!(buf->buf == ((char *)NULL)))
      __intl_free((void *)buf->buf);

    signed int return_value_ci_buf_mem_alloc$1;
    return_value_ci_buf_mem_alloc$1=ci_buf_mem_alloc(buf, req_size);
    return return_value_ci_buf_mem_alloc$1;
  }
}

// ci_buf_write
// file request_common.c line 74
signed int ci_buf_write(struct ci_buf *buf, char *data, signed int len)
{
  if(!(buf->size + -buf->used >= len))
    return -1;

  else
  {
    memcpy((void *)(buf->buf + (signed long int)buf->used), (const void *)data, (unsigned long int)len);
    buf->used = buf->used + len;
    return len;
  }
}

// ci_buffer_alloc
// file include/mem.h line 66
void * ci_buffer_alloc(signed int block_size)
{
  signed int type;
  signed int size;
  struct mem_buffer_block *block = (struct mem_buffer_block *)(void *)0;
  size = (signed int)((unsigned long int)block_size + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  type = block_size - 1 >> 6;
  _Bool tmp_if_expr$1;
  if(!(type >= 16))
    tmp_if_expr$1 = short_buffers[(signed long int)type] != (struct ci_mem_allocator *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    void *return_value;
    return_value=short_buffers[(signed long int)type]->alloc(short_buffers[(signed long int)type], (unsigned long int)size);
    block = (struct mem_buffer_block *)return_value;
  }

  else
    if(!(type >= 512))
    {
      type = type >> 5;
      if(!(long_buffers[(signed long int)type] == ((struct ci_mem_allocator *)NULL)))
      {
        void *return_value_1;
        return_value_1=long_buffers[(signed long int)type]->alloc(long_buffers[(signed long int)type], (unsigned long int)size);
        block = (struct mem_buffer_block *)return_value_1;
      }

    }

  void *return_value_malloc$2;
  if(block == ((struct mem_buffer_block *)NULL))
  {
    return_value_malloc$2=malloc((unsigned long int)size);
    block = (struct mem_buffer_block *)return_value_malloc$2;
  }

  if(block == ((struct mem_buffer_block *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to allocate space for buffer of size:%d\n", block_size);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to allocate space for buffer of size:%d\n", block_size);

    }

    return (void *)0;
  }

  else
  {
    block->sig = (unsigned short int)0xAA55;
    block->ID = block_size;
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Geting buffer from pool %d:%d\n", block_size, type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Geting buffer from pool %d:%d\n", block_size, type);

    }

    return (void *)block->data.ptr;
  }
}

// ci_buffer_blocksize
// file mem.c line 204
unsigned long int ci_buffer_blocksize(const void *data)
{
  struct mem_buffer_block *block;
  signed int type;
  unsigned long int buffer_block_size = (unsigned long int)0;
  block = (struct mem_buffer_block *)(data - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  if(!((signed int)block->sig == 0xAA55))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_buffer_blocksize: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_buffer_blocksize: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

    }

    return (unsigned long int)0;
  }

  else
  {
    type = block->ID - 1 >> 6;
    _Bool tmp_if_expr$1;
    if(!(type >= 16))
      tmp_if_expr$1 = short_buffers[(signed long int)type] != (struct ci_mem_allocator *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      buffer_block_size = (unsigned long int)short_buffer_sizes[(signed long int)type];

    else
      if(!(type >= 512))
      {
        type = type >> 5;
        if(!(long_buffers[(signed long int)type] == ((struct ci_mem_allocator *)NULL)))
          buffer_block_size = (unsigned long int)long_buffer_sizes[(signed long int)type];

      }

    if(buffer_block_size == 0ul)
      buffer_block_size = (unsigned long int)block->ID;

    return buffer_block_size;
  }
}

// ci_buffer_free
// file ../include/mem.h line 68
void ci_buffer_free(void *data)
{
  signed int block_size;
  signed int type;
  struct mem_buffer_block *block;
  if(!(data == NULL))
  {
    block = (struct mem_buffer_block *)(data - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
    if(!((signed int)block->sig == 0xAA55))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_buffer_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_buffer_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

      }

    }

    else
    {
      block_size = block->ID;
      type = block_size - 1 >> 6;
      _Bool tmp_if_expr$1;
      if(!(type >= 16))
        tmp_if_expr$1 = short_buffers[(signed long int)type] != (struct ci_mem_allocator *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
      {
        short_buffers[(signed long int)type]->free(short_buffers[(signed long int)type], (void *)block);
        if(CI_DEBUG_LEVEL >= 8)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Store buffer to short pool %d:%d\n", block_size, type);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Store buffer to short pool %d:%d\n", block_size, type);

        }

      }

      else
        if(!(type >= 512))
        {
          type = type >> 5;
          if(!(long_buffers[(signed long int)type] == ((struct ci_mem_allocator *)NULL)))
            long_buffers[(signed long int)type]->free(long_buffers[(signed long int)type], (void *)block);

          else
            free((void *)block);
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Store buffer to long pool %d:%d\n", block_size, type);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Store buffer to long pool %d:%d\n", block_size, type);

          }

        }

        else
          free((void *)block);
    }
  }

}

// ci_buffer_realloc
// file include/mem.h line 67
void * ci_buffer_realloc(void *data, signed int block_size)
{
  signed int buffer_size = 0;
  struct mem_buffer_block *block;
  void *return_value_ci_buffer_alloc$1;
  if(data == NULL)
  {
    return_value_ci_buffer_alloc$1=ci_buffer_alloc(block_size);
    return return_value_ci_buffer_alloc$1;
  }

  block = (struct mem_buffer_block *)(data - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  if(!((signed int)block->sig == 0xAA55))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_buffer_realloc: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_buffer_realloc: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

    }

    return (void *)0;
  }

  else
  {
    unsigned long int return_value_ci_buffer_blocksize$2;
    return_value_ci_buffer_blocksize$2=ci_buffer_blocksize(data);
    buffer_size = (signed int)return_value_ci_buffer_blocksize$2;
    /* assertion buffer_size > 0 */
    assert(buffer_size > 0);
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Current block size for realloc: %d, requested block size: %d. The initial size: %d\n", buffer_size, block_size, block->ID);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Current block size for realloc: %d, requested block size: %d. The initial size: %d\n", buffer_size, block_size, block->ID);

    }

    if(!(buffer_size >= block_size))
    {
      if(CI_DEBUG_LEVEL >= 10)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "We are going to allocate a bigger block of size: %d\n", block_size);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("We are going to allocate a bigger block of size: %d\n", block_size);

      }

      data=ci_buffer_alloc(block_size);
      if(data == NULL)
        return (void *)0;

      if(CI_DEBUG_LEVEL >= 10)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Preserve data of size: %d\n", block->ID);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Preserve data of size: %d\n", block->ID);

      }

      memcpy(data, (const void *)block->data.ptr, (unsigned long int)block->ID);
      ci_buffer_free((void *)block->data.ptr);
    }

    else
      block->ID = block_size;
    return data;
  }
}

// ci_buffers_destroy
// file mem.c line 166
void ci_buffers_destroy()
{
  signed int i = 0;
  for( ; !(i >= 16); i = i + 1)
    if(!(short_buffers[(signed long int)i] == ((struct ci_mem_allocator *)NULL)))
      ci_mem_allocator_destroy(short_buffers[(signed long int)i]);

}

// ci_buffers_init
// file mem.c line 112
signed int ci_buffers_init()
{
  signed int i;
  struct ci_mem_allocator *buf64_pool;
  struct ci_mem_allocator *buf128_pool;
  struct ci_mem_allocator *buf256_pool;
  struct ci_mem_allocator *buf512_pool;
  struct ci_mem_allocator *buf1024_pool;
  struct ci_mem_allocator *buf2048_pool;
  struct ci_mem_allocator *buf4096_pool;
  struct ci_mem_allocator *buf8192_pool;
  struct ci_mem_allocator *buf16384_pool;
  struct ci_mem_allocator *buf32768_pool;
  buf64_pool=ci_create_pool_allocator((signed int)((unsigned long int)64 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf128_pool=ci_create_pool_allocator((signed int)((unsigned long int)128 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf256_pool=ci_create_pool_allocator((signed int)((unsigned long int)256 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf512_pool=ci_create_pool_allocator((signed int)((unsigned long int)512 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf1024_pool=ci_create_pool_allocator((signed int)((unsigned long int)1024 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf2048_pool=ci_create_pool_allocator((signed int)((unsigned long int)2048 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf4096_pool=ci_create_pool_allocator((signed int)((unsigned long int)4096 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf8192_pool=ci_create_pool_allocator((signed int)((unsigned long int)8192 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf16384_pool=ci_create_pool_allocator((signed int)((unsigned long int)16384 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf32768_pool=ci_create_pool_allocator((signed int)((unsigned long int)32768 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  short_buffers[(signed long int)0] = buf64_pool;
  short_buffers[(signed long int)1] = buf128_pool;
  short_buffers[(signed long int)3] = buf256_pool;
  short_buffers[(signed long int)2] = short_buffers[(signed long int)3];
  short_buffers[(signed long int)7] = buf512_pool;
  short_buffers[(signed long int)6] = short_buffers[(signed long int)7];
  short_buffers[(signed long int)5] = short_buffers[(signed long int)6];
  short_buffers[(signed long int)4] = short_buffers[(signed long int)5];
  i = 8;
  for( ; !(i >= 16); i = i + 1)
    short_buffers[(signed long int)i] = buf1024_pool;
  long_buffers[(signed long int)0] = buf2048_pool;
  long_buffers[(signed long int)1] = buf4096_pool;
  long_buffers[(signed long int)3] = buf8192_pool;
  long_buffers[(signed long int)2] = long_buffers[(signed long int)3];
  long_buffers[(signed long int)7] = buf16384_pool;
  long_buffers[(signed long int)6] = long_buffers[(signed long int)7];
  long_buffers[(signed long int)5] = long_buffers[(signed long int)6];
  long_buffers[(signed long int)4] = long_buffers[(signed long int)5];
  i = 8;
  for( ; !(i >= 16); i = i + 1)
    long_buffers[(signed long int)i] = buf32768_pool;
  return 1;
}

// ci_cache_build
// file ../include/cache.h line 88
struct ci_cache * ci_cache_build(const char *name, const char *cache_type, unsigned int cache_size, unsigned int max_object_size, signed int ttl, const struct ci_type_ops *key_ops)
{
  struct ci_cache *cache;
  const struct ci_cache_type *type;
  if(!(cache_size >= 1u))
    return (struct ci_cache *)(void *)0;

  else
  {
    type=ci_cache_type_get(cache_type);
    if(type == ((const struct ci_cache_type *)NULL))
    {
      type = &ci_local_cache;
      signed int return_value_strcasecmp$1;
      return_value_strcasecmp$1=strcasecmp(cache_type, ci_local_cache.name);
      if(!(return_value_strcasecmp$1 == 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "WARNING: Cache type '%s' not found. Creating a local cache\n", cache_type);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("WARNING: Cache type '%s' not found. Creating a local cache\n", cache_type);

        }

      }

    }

    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct ci_cache) /*80ul*/ );
    cache = (struct ci_cache *)return_value_malloc$2;
    if(cache == ((struct ci_cache *)NULL))
      return (struct ci_cache *)(void *)0;

    else
    {
      if(!(key_ops == ((const struct ci_type_ops *)NULL)))
        cache->key_ops = key_ops;

      else
        cache->key_ops = &ci_str_ops;
      cache->mem_size = cache_size;
      cache->max_object_size = max_object_size;
      cache->ttl = (signed long int)ttl;
      cache->init = type->init;
      cache->destroy = type->destroy;
      cache->search = type->search;
      cache->update = type->update;
      cache->_cache_type = type;
      signed int return_value;
      return_value=cache->init(cache, name);
      if(return_value == 0)
      {
        free((void *)cache);
        return (struct ci_cache *)(void *)0;
      }

      else
        return cache;
    }
  }
}

// ci_cache_destroy
// file ../include/cache.h line 124
void ci_cache_destroy(struct ci_cache *cache)
{
  cache->destroy(cache);
  free((void *)cache);
}

// ci_cache_read_vector_val
// file ../include/cache.h line 133
void * ci_cache_read_vector_val(const void *val, unsigned long int val_size, void *o)
{
  unsigned long int vector_size;
  unsigned long int item_size;
  signed int i;
  struct ci_vector *v;
  const void **data_indx;
  if(val == NULL)
    return (void *)0;

  else
  {
    data_indx = (const void **)(val + (signed long int)sizeof(unsigned long int) /*8ul*/ );
    vector_size = *((unsigned long int *)val);
    v=ci_vector_create(vector_size);
    item_size = (val_size - sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)data_indx[(signed long int)0];
    i = 0;
    for( ; !(data_indx[(signed long int)i] == NULL); i = i + 1)
    {
      ci_vector_add(v, (const void *)((const void *)data_indx + (signed long int)(unsigned long int)data_indx[(signed long int)i]), item_size);
      item_size = (unsigned long int)(data_indx[(signed long int)i] - data_indx[(signed long int)(i + 1)]);
    }
    return (void *)v;
  }
}

// ci_cache_search
// file ../include/cache.h line 107
const void * ci_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *))
{
  const void *return_value;
  return_value=cache->search(cache, key, val, data, dup_from_cache);
  return return_value;
}

// ci_cache_store_vector_size
// file ../include/cache.h line 131
unsigned long int ci_cache_store_vector_size(struct ci_vector *v)
{
  signed int vector_data_size;
  signed int vector_indx_size;
  void *vector_data_start;
  void *vector_data_end;
  if(v == ((struct ci_vector *)NULL))
    return (unsigned long int)0;

  else
  {
    vector_data_start = (void *)v->items[(signed long int)(v->count - 1)];
    vector_data_end = (void *)(v->mem + (signed long int)v->max_size);
    _Bool tmp_if_expr$1;
    if(!(vector_data_start >= vector_data_end))
      tmp_if_expr$1 = vector_data_start > (void *)v->mem ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    /* assertion vector_data_start < vector_data_end && vector_data_start > (void *)v->mem */
    assert(tmp_if_expr$1);
    vector_data_size = (signed int)(vector_data_end - vector_data_start);
    vector_indx_size = (signed int)((unsigned long int)(v->count + 1) * sizeof(void *) /*8ul*/ );
    return sizeof(unsigned long int) /*8ul*/  + (unsigned long int)vector_indx_size + (unsigned long int)vector_data_size;
  }
}

// ci_cache_store_vector_val
// file ../include/cache.h line 132
void * ci_cache_store_vector_val(void *buf, const void *val, unsigned long int buf_size)
{
  signed int vector_data_size;
  signed int vector_indx_size;
  signed int i;
  const void *vector_data_start;
  const void *vector_data_end;
  void *data;
  void **data_indx;
  struct ci_vector *v = (struct ci_vector *)val;
  if(buf == NULL || val == NULL)
    return (void *)0;

  else
  {
    vector_data_start = (void *)v->items[(signed long int)(v->count - 1)];
    vector_data_end = (const void *)(v->mem + (signed long int)v->max_size);
    _Bool tmp_if_expr$1;
    if(!(vector_data_start >= vector_data_end))
      tmp_if_expr$1 = vector_data_start > (void *)v->mem ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    /* assertion vector_data_start < vector_data_end && vector_data_start > (void *)v->mem */
    assert(tmp_if_expr$1);
    vector_data_size = (signed int)(vector_data_end - vector_data_start);
    vector_indx_size = (signed int)((unsigned long int)(v->count + 1) * sizeof(void *) /*8ul*/ );
    /* assertion buf_size >= sizeof(size_t) + vector_indx_size + vector_data_size */
    assert(buf_size >= sizeof(unsigned long int) /*8ul*/  + (unsigned long int)vector_indx_size + (unsigned long int)vector_data_size);
    data = buf;
    memcpy(data, (const void *)&v->max_size, sizeof(unsigned long int) /*8ul*/ );
    data_indx = (void **)(data + (signed long int)sizeof(unsigned long int) /*8ul*/ );
    memcpy((void *)data_indx + (signed long int)vector_indx_size, vector_data_start, (unsigned long int)vector_data_size);
    i = 0;
    for( ; !(v->items[(signed long int)i] == NULL); i = i + 1)
      data_indx[(signed long int)i] = (void *)((v->items[(signed long int)i] - vector_data_start) + (signed long int)vector_indx_size);
    data_indx[(signed long int)i] = (void *)0;
    return data;
  }
}

// ci_cache_type_get
// file cache.c line 42
static const struct ci_cache_type * ci_cache_type_get(const char *name)
{
  const void *return_value_ci_registry_get_item$1;
  return_value_ci_registry_get_item$1=ci_registry_get_item("c-icap::ci_cache_type", name);
  return (const struct ci_cache_type *)return_value_ci_registry_get_item$1;
}

// ci_cache_type_register
// file cache.c line 37
void ci_cache_type_register(struct ci_cache_type *type)
{
  ci_registry_add_item("c-icap::ci_cache_type", type->name, (const void *)type);
}

// ci_cache_update
// file ../include/cache.h line 118
signed int ci_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int))
{
  signed int return_value;
  return_value=cache->update(cache, key, val, val_size, copy_to_cache);
  return return_value;
}

// ci_cached_file_destroy
// file body.c line 423
void ci_cached_file_destroy(struct ci_cached_file *body)
{
  if(!(body == ((struct ci_cached_file *)NULL)))
  {
    if(!(body->buf == ((char *)NULL)))
      ci_buffer_free((void *)body->buf);

    if(body->fd >= 0)
    {
      do_close(body->fd);
      unlink(body->filename);
    }

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    ci_object_pool_free((void *)body);
  }

}

// ci_cached_file_new
// file body.c line 360
struct ci_cached_file * ci_cached_file_new(signed int size)
{
  struct ci_cached_file *body;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(CACHED_FILE_POOL);
  body = (struct ci_cached_file *)return_value_ci_object_pool_alloc$1;
  if(body == ((struct ci_cached_file *)NULL))
    return (struct ci_cached_file *)(void *)0;

  else
  {
    if(size == 0)
      size = CI_BODY_MAX_MEM;

    if(CI_BODY_MAX_MEM >= size && size >= 1)
    {
      void *return_value_ci_buffer_alloc$2;
      return_value_ci_buffer_alloc$2=ci_buffer_alloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
      body->buf = (char *)return_value_ci_buffer_alloc$2;
    }

    else
      body->buf = (char *)(void *)0;
    if(body->buf == ((char *)NULL))
    {
      body->bufsize = 0;
      body->fd=ci_mktemp_file(CI_TMPDIR, "CI_TMP_XXXXXX", body->filename);
      if(!(body->fd >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not open temporary filename in directory:%s\n", CI_TMPDIR);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not open temporary filename in directory:%s\n", CI_TMPDIR);

        }

        ci_object_pool_free((void *)body);
        return (struct ci_cached_file *)(void *)0;
      }

    }

    else
    {
      body->bufsize = size;
      body->fd = -1;
    }
    body->endpos = (signed long int)0;
    body->readpos = (signed long int)0;
    body->flags = 0;
    body->unlocked = (signed long int)0;
    body->attributes = (struct ci_array *)(void *)0;
    return body;
  }
}

// ci_cached_file_read
// file body.c line 520
signed int ci_cached_file_read(struct ci_cached_file *body, char *buf, signed int len)
{
  signed int remains;
  signed int bytes;
  if(body->readpos == body->endpos)
  {
    if((0x02 & body->flags) == 0)
      goto __CPROVER_DUMP_L1;

    return -2;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(len == 0)
      return 0;

    else
      if(body->fd >= 1)
      {
        _Bool tmp_if_expr$1;
        if(!((0x01 & body->flags) == 0))
          tmp_if_expr$1 = body->unlocked >= (signed long int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          remains = (signed int)(body->unlocked - body->readpos);

        else
          remains = len;
        bytes = remains > len ? len : remains;
        lseek64(body->fd, body->readpos, 0);
        bytes=do_read(body->fd, (void *)buf, (unsigned long int)bytes);
        if(bytes >= 1)
          body->readpos = body->readpos + (signed long int)bytes;

        return bytes;
      }

      else
      {
        _Bool tmp_if_expr$2;
        if(!((0x01 & body->flags) == 0))
          tmp_if_expr$2 = body->unlocked >= (signed long int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          remains = (signed int)(body->unlocked - body->readpos);

        else
          remains = (signed int)(body->endpos - body->readpos);
        bytes = len <= remains ? len : remains;
        if(bytes >= 1)
        {
          memcpy((void *)buf, (const void *)(body->buf + body->readpos), (unsigned long int)bytes);
          body->readpos = body->readpos + (signed long int)bytes;
        }

        else
        {
          bytes = 0;
          if(CI_DEBUG_LEVEL >= 10)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Read 0, %lld %lld\n", (signed long long int)body->readpos, (signed long long int)body->endpos);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Read 0, %lld %lld\n", (signed long long int)body->readpos, (signed long long int)body->endpos);

          }

        }
        return bytes;
      }
  }
}

// ci_cached_file_release
// file body.c line 442
void ci_cached_file_release(struct ci_cached_file *body)
{
  if(!(body == ((struct ci_cached_file *)NULL)))
  {
    if(!(body->buf == ((char *)NULL)))
      ci_buffer_free((void *)body->buf);

    if(body->fd >= 0)
      do_close(body->fd);

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    ci_object_pool_free((void *)body);
  }

}

// ci_cached_file_reset
// file body.c line 398
void ci_cached_file_reset(struct ci_cached_file *body, signed int new_size)
{
  if(body->fd >= 1)
  {
    do_close(body->fd);
    unlink(body->filename);
  }

  body->endpos = (signed long int)0;
  body->readpos = (signed long int)0;
  body->flags = 0;
  body->unlocked = (signed long int)0;
  body->fd = -1;
  if(!(body->attributes == ((struct ci_array *)NULL)))
    ci_array_destroy(body->attributes);

  body->attributes = (struct ci_array *)(void *)0;
  signed int return_value_resize_buffer$1;
  return_value_resize_buffer$1=resize_buffer(body, new_size);
}

// ci_cached_file_write
// file body.c line 461
signed int ci_cached_file_write(struct ci_cached_file *body, const char *buf, signed int len, signed int iseof)
{
  signed int remains;
  signed int ret;
  if(!(iseof == 0))
  {
    body->flags = body->flags | 0x02;
    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Buffer size=%d, Data size=%lld\n ", ((struct ci_cached_file *)body)->bufsize, (signed long long int)((struct ci_cached_file *)body)->endpos);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Buffer size=%d, Data size=%lld\n ", ((struct ci_cached_file *)body)->bufsize, (signed long long int)((struct ci_cached_file *)body)->endpos);

    }

  }

  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  signed int return_value_do_write$7;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  if(len == 0)
    return 0;

  else
    if(body->fd >= 1)
    {
      lseek64(body->fd, (signed long int)0, 2);
      ret=do_write(body->fd, (const void *)buf, (unsigned long int)len);
      if(!(ret >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location$1=__errno_location();
            __log_error((void *)0, "Cannot write to file!!! (errno=%d)\n", *return_value___errno_location$1);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location$2=__errno_location();
            printf("Cannot write to file!!! (errno=%d)\n", *return_value___errno_location$2);
          }

        }

      }

      body->endpos = body->endpos + (signed long int)len;
      return len;
    }

    else
    {
      remains = (signed int)((signed long int)body->bufsize - body->endpos);
      /* assertion remains >= 0 */
      assert(remains >= 0);
      if(!(remains >= len))
      {
        body->fd=ci_mktemp_file(CI_TMPDIR, "CI_TMP_XXXXXX", body->filename);
        if(!(body->fd >= 0))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "I cannot create the temporary file: %s!!!!!!\n", (const void *)body->filename);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("I cannot create the temporary file: %s!!!!!!\n", (const void *)body->filename);

          }

          return -1;
        }

        ret=do_write(body->fd, (const void *)body->buf, (unsigned long int)body->endpos);
        _Bool tmp_if_expr$8;
        if(ret >= 0)
        {
          return_value_do_write$7=do_write(body->fd, (const void *)buf, (unsigned long int)len);
          tmp_if_expr$8 = return_value_do_write$7 >= 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
        {
          body->endpos = body->endpos + (signed long int)len;
          return len;
        }

        else
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value___errno_location$3=__errno_location();
              return_value_strerror$4=strerror(*return_value___errno_location$3);
              __log_error((void *)0, "Cannot write to cachefile: %s\n", return_value_strerror$4);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value___errno_location$5=__errno_location();
              return_value_strerror$6=strerror(*return_value___errno_location$5);
              printf("Cannot write to cachefile: %s\n", return_value_strerror$6);
            }

          }

          return -1;
        }
      }

      if(len >= 1)
      {
        memcpy((void *)(body->buf + body->endpos), (const void *)buf, (unsigned long int)len);
        body->endpos = body->endpos + (signed long int)len;
      }

      return len;
    }
}

// ci_cfg_alloc_mem
// file cfg_lib.c line 44
void * ci_cfg_alloc_mem(signed int size)
{
  void *return_value;
  return_value=cfg_params_allocator->alloc(cfg_params_allocator, (unsigned long int)size);
  return return_value;
}

// ci_cfg_disable
// file cfg_lib.c line 192
signed int ci_cfg_disable(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    *((signed int *)setdata) = 0;
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Disabling parameter %s\n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Disabling parameter %s\n", directive);

    }

    return 1;
  }
}

// ci_cfg_enable
// file cfg_lib.c line 203
signed int ci_cfg_enable(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    *((signed int *)setdata) = 1;
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Enabling parameter %s\n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Enabling parameter %s\n", directive);

    }

    return 1;
  }
}

// ci_cfg_lib_init
// file ../include/cfg_param.h line 150
void ci_cfg_lib_init()
{
  cfg_params_allocator=ci_create_serial_allocator(65536);
}

// ci_cfg_lib_reset
// file cfg_lib.c line 39
void ci_cfg_lib_reset()
{
  cfg_params_allocator->reset(cfg_params_allocator);
}

// ci_cfg_onoff
// file cfg_lib.c line 169
signed int ci_cfg_onoff(const char *directive, const char **argv, void *setdata)
{
  signed int return_value_strcasecmp$2;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(argv == ((const char **)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive:%s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive:%s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int return_value_strcasecmp$3;
      return_value_strcasecmp$3=strcasecmp(argv[(signed long int)0], "on");
      if(return_value_strcasecmp$3 == 0)
        *((signed int *)setdata) = 1;

      else
      {
        return_value_strcasecmp$2=strcasecmp(argv[(signed long int)0], "off");
        if(return_value_strcasecmp$2 == 0)
          *((signed int *)setdata) = 0;

        else
          return 0;
      }
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=%d\n", directive, *((signed int *)setdata));

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=%d\n", directive, *((signed int *)setdata));

      }

      return 1;
    }
  }
}

// ci_cfg_set_int
// file ../include/cfg_param.h line 164
signed int ci_cfg_set_int(const char *directive, const char **argv, void *setdata)
{
  signed int val = 0;
  char *end;
  signed int *return_value___errno_location$4;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(argv == ((const char **)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive:%s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive:%s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 0;
      signed long long int return_value_strtoll$3;
      return_value_strtoll$3=strtoll(argv[(signed long int)0], &end, 10);
      val = (signed int)return_value_strtoll$3;
      if(val == 0)
      {
        return_value___errno_location$4=__errno_location();
        if(!(*return_value___errno_location$4 == 0))
          return 0;

      }

      *((signed int *)setdata) = val;
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=%d\n", directive, val);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=%d\n", directive, val);

      }

      return 1;
    }
  }
}

// ci_cfg_set_str
// file ../include/cfg_param.h line 158
signed int ci_cfg_set_str(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(argv == ((const char **)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      return 0;

    else
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(argv[(signed long int)0]);
      void *return_value_ci_cfg_alloc_mem$3;
      return_value_ci_cfg_alloc_mem$3=ci_cfg_alloc_mem((signed int)(return_value_strlen$2 + (unsigned long int)1));
      *((char **)setdata) = (char *)return_value_ci_cfg_alloc_mem$3;
      if(*((char **)setdata) == ((char *)NULL))
        return 0;

      else
      {
        strcpy(*((char **)setdata), argv[(signed long int)0]);
        if(CI_DEBUG_LEVEL >= 2)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

        }

        return 1;
      }
    }
  }
}

// ci_cfg_size_long
// file cfg_lib.c line 245
signed int ci_cfg_size_long(const char *directive, const char **argv, void *setdata)
{
  signed long int val = (signed long int)0;
  char *end;
  signed int *return_value___errno_location$3;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(argv == ((const char **)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive: %s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive: %s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 0;
      val=strtol(argv[(signed long int)0], &end, 10);
      _Bool tmp_if_expr$4;
      if(val == 0l)
      {
        return_value___errno_location$3=__errno_location();
        tmp_if_expr$4 = *return_value___errno_location$3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!(val >= 0l) || tmp_if_expr$4)
        return 0;

      else
      {
        _Bool tmp_if_expr$6;
        if((signed int)*end == 107)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)*end == 75 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          val = val * (signed long int)1024;

        else
        {
          _Bool tmp_if_expr$5;
          if((signed int)*end == 109)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = (signed int)*end == 77 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            val = val * (signed long int)1024 * (signed long int)1024;

        }
        if(val >= 1l)
          *((signed long int *)setdata) = val;

        if(CI_DEBUG_LEVEL >= 2)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Setting parameter :%s=%ld\n", directive, val);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Setting parameter :%s=%ld\n", directive, val);

        }

        return 1;
      }
    }
  }
}

// ci_cfg_size_off
// file cfg_lib.c line 213
signed int ci_cfg_size_off(const char *directive, const char **argv, void *setdata)
{
  signed long int val = (signed long int)0;
  char *end;
  signed int *return_value___errno_location$3;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(argv == ((const char **)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive:%s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive:%s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 0;
      val=strtoll(argv[(signed long int)0], &end, 10);
      _Bool tmp_if_expr$4;
      if(val == 0l)
      {
        return_value___errno_location$3=__errno_location();
        tmp_if_expr$4 = *return_value___errno_location$3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!(val >= 0l) || tmp_if_expr$4)
        return 0;

      else
      {
        _Bool tmp_if_expr$6;
        if((signed int)*end == 107)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)*end == 75 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          val = val * (signed long int)1024;

        else
        {
          _Bool tmp_if_expr$5;
          if((signed int)*end == 109)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = (signed int)*end == 77 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            val = val * (signed long int)1024 * (signed long int)1024;

        }
        if(val >= 1l)
          *((signed long int *)setdata) = val;

        if(CI_DEBUG_LEVEL >= 2)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Setting parameter :%s=%lld\n", directive, (signed long long int)val);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Setting parameter :%s=%lld\n", directive, (signed long long int)val);

        }

        return 1;
      }
    }
  }
}

// ci_client_connect_to
// file request_common.c line 984
struct ci_connection * ci_client_connect_to(char *servername, signed int port, signed int proto)
{
  struct ci_connection *connection;
  void *return_value;
  return_value=__intl_malloc((signed int)sizeof(struct ci_connection) /*88ul*/ );
  connection = (struct ci_connection *)return_value;
  char hostname[257l];
  unsigned int addrlen = (unsigned int)0;
  char errBuf[512l];
  signed int errNo;
  signed int *return_value___errno_location$1;
  char *return_value_ci_strerror$2;
  signed int *return_value___errno_location$3;
  char *return_value_ci_strerror$4;
  signed int *return_value___errno_location$6;
  signed int *return_value___errno_location$7;
  char *return_value_ci_strerror$8;
  signed int *return_value___errno_location$9;
  signed int *return_value___errno_location$10;
  char *return_value_ci_strerror$11;
  char *return_value_ci_strerror$13;
  char *return_value_ci_strerror$14;
  signed int *return_value___errno_location$16;
  char *return_value_ci_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_ci_strerror$19;
  if(connection == ((struct ci_connection *)NULL))
    return (struct ci_connection *)(void *)0;

  else
  {
    signed int return_value_ci_host_to_sockaddr_t$5;
    return_value_ci_host_to_sockaddr_t$5=ci_host_to_sockaddr_t(servername, &connection->srvaddr, proto);
    if(return_value_ci_host_to_sockaddr_t$5 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location$1=__errno_location();
          return_value_ci_strerror$2=ci_strerror(*return_value___errno_location$1, errBuf, sizeof(char [512l]) /*512ul*/ );
          __log_error((void *)0, "Error getting address info for host '%s': %s\n", servername, return_value_ci_strerror$2);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location$3=__errno_location();
          return_value_ci_strerror$4=ci_strerror(*return_value___errno_location$3, errBuf, sizeof(char [512l]) /*512ul*/ );
          printf("Error getting address info for host '%s': %s\n", servername, return_value_ci_strerror$4);
        }

      }

      close(connection->fd);
      __intl_free((void *)connection);
      return (struct ci_connection *)(void *)0;
    }

    else
    {
      ci_sockaddr_set_port(&connection->srvaddr, port);
      connection->fd=socket(connection->srvaddr.ci_sin_family, 1, 0);
      if(connection->fd == -1)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location$6=__errno_location();
            return_value___errno_location$7=__errno_location();
            return_value_ci_strerror$8=ci_strerror(*return_value___errno_location$7, errBuf, sizeof(char [512l]) /*512ul*/ );
            __log_error((void *)0, "Error opening socket :%d:%s....\n", *return_value___errno_location$6, return_value_ci_strerror$8);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location$9=__errno_location();
            return_value___errno_location$10=__errno_location();
            return_value_ci_strerror$11=ci_strerror(*return_value___errno_location$10, errBuf, sizeof(char [512l]) /*512ul*/ );
            printf("Error opening socket :%d:%s....\n", *return_value___errno_location$9, return_value_ci_strerror$11);
          }

        }

        __intl_free((void *)connection);
        return (struct ci_connection *)(void *)0;
      }

      else
      {
        addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        signed int return_value_connect$15;
        return_value_connect$15=connect(connection->fd, (struct sockaddr *)&connection->srvaddr.sockaddr, addrlen);
        if(!(return_value_connect$15 == 0))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          errNo = *return_value___errno_location$12;
          ci_sockaddr_t_to_host(&connection->srvaddr, hostname, 256);
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value_ci_strerror$13=ci_strerror(errNo, errBuf, sizeof(char [512l]) /*512ul*/ );
              __log_error((void *)0, "Error connecting to host  '%s': %s \n", (const void *)hostname, return_value_ci_strerror$13);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value_ci_strerror$14=ci_strerror(errNo, errBuf, sizeof(char [512l]) /*512ul*/ );
              printf("Error connecting to host  '%s': %s \n", (const void *)hostname, return_value_ci_strerror$14);
            }

          }

          close(connection->fd);
          __intl_free((void *)connection);
          return (struct ci_connection *)(void *)0;
        }

        addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        signed int return_value_getsockname$20;
        return_value_getsockname$20=getsockname(connection->fd, (struct sockaddr *)&connection->claddr.sockaddr, &addrlen);
        if(!(return_value_getsockname$20 == 0))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value___errno_location$16=__errno_location();
              return_value_ci_strerror$17=ci_strerror(*return_value___errno_location$16, errBuf, sizeof(char [512l]) /*512ul*/ );
              __log_error((void *)0, "Error getting client sockname: %s\n", return_value_ci_strerror$17);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value___errno_location$18=__errno_location();
              return_value_ci_strerror$19=ci_strerror(*return_value___errno_location$18, errBuf, sizeof(char [512l]) /*512ul*/ );
              printf("Error getting client sockname: %s\n", return_value_ci_strerror$19);
            }

          }

          close(connection->fd);
          __intl_free((void *)connection);
          return (struct ci_connection *)(void *)0;
        }

        else
        {
          ci_fill_sockaddr(&connection->claddr);
          ci_fill_sockaddr(&connection->srvaddr);
          ci_netio_init(connection->fd);
          return connection;
        }
      }
    }
  }
}

// ci_client_get_server_options
// file request_common.c line 962
signed int ci_client_get_server_options(struct ci_request *req, signed int timeout)
{
  signed int return_value_client_create_request$1;
  return_value_client_create_request$1=client_create_request(req, req->req_server, req->service, 0x01);
  signed int return_value_client_parse_icap_header$2;
  if(!(return_value_client_create_request$1 == 1))
    return -1;

  else
  {
    client_send_request_headers(req, 0, timeout);
    do
    {
      ci_wait_for_data(req->connection->fd, timeout, 0x1);
      signed int return_value_net_data_read$3;
      return_value_net_data_read$3=net_data_read(req);
      if(return_value_net_data_read$3 == -1)
        return -1;

      return_value_client_parse_icap_header$2=client_parse_icap_header(req, req->response_header);
    }
    while(return_value_client_parse_icap_header$2 == 2);
    ci_headers_unpack(req->response_header);
    get_request_options(req, req->response_header);
    return 1;
  }
}

// ci_client_http_headers_completed
// file request_common.c line 1422
signed int ci_client_http_headers_completed(struct ci_request *req)
{
  return (signed int)(req->status >= 2);
}

// ci_client_icapfilter
// file request_common.c line 1303
signed int ci_client_icapfilter(struct ci_request *req, signed int timeout, struct ci_headers_list *req_headers, struct ci_headers_list *resp_headers, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int))
{
  signed int i;
  signed int ret;
  signed int v1;
  signed int v2;
  signed int remains;
  signed int pre_eof = 0;
  signed int preview_status;
  char *buf;
  const char *val;
  signed int return_value_client_create_request$1;
  return_value_client_create_request$1=client_create_request(req, req->req_server, req->service, req->type);
  signed int return_value_client_parse_icap_header$3;
  if(!(return_value_client_create_request$1 == 1))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error making respmod request ....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error making respmod request ....\n");

    }

    return -1;
  }

  else
  {
    if(data_source == NULL)
      req->preview = -1;

    if(req->preview >= 1)
    {
      ci_buf_mem_alloc(&req->preview_data, req->preview);
      buf = req->preview_data.buf;
      remains = req->preview;
      if(pre_eof == 0 && !(remains == 0))
      {
        ret=source_read(data_source, buf, remains);
        if(!(ret >= 1))
          pre_eof = 1;

        else
          remains = remains - ret;
      }

      req->preview = req->preview - remains;
      req->preview_data.used = req->preview;
    }

    if(!(pre_eof == 0))
      req->eof_received = 1;

    signed int return_value_client_build_headers$2;
    return_value_client_build_headers$2=client_build_headers(req, (signed int)(req_headers != (struct ci_headers_list *)(void *)0), (signed int)(resp_headers != (struct ci_headers_list *)(void *)0), (signed int)(data_source != (void *)0));
    if(return_value_client_build_headers$2 == 0)
      return -1;

    else
    {
      if(!(req_headers == ((struct ci_headers_list *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Going to add %d request headers\n", req_headers->used);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Going to add %d request headers\n", req_headers->used);

        }

        i = 0;
        for( ; !(i >= req_headers->used); i = i + 1)
        {
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Add request header: %s\n", req_headers->headers[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Add request header: %s\n", req_headers->headers[(signed long int)i]);

          }

          ci_http_request_add_header(req, req_headers->headers[(signed long int)i]);
        }
      }

      if(!(resp_headers == ((struct ci_headers_list *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Going to add %d response headers\n", resp_headers->used);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Going to add %d response headers\n", resp_headers->used);

        }

        i = 0;
        for( ; !(i >= resp_headers->used); i = i + 1)
        {
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Add resp header: %s\n", resp_headers->headers[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Add resp header: %s\n", resp_headers->headers[(signed long int)i]);

          }

          ci_http_response_add_header(req, resp_headers->headers[(signed long int)i]);
        }
      }

      ret=client_send_request_headers(req, pre_eof, timeout);
      if(!(ret >= 0))
        return -1;

      else
      {
        i = 0;
        for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
          ci_request_release_entity(req, i);
        preview_status = 100;
        if(req->preview >= 0)
        {
          do
          {
            ci_wait_for_data(req->connection->fd, timeout, 0x1);
            signed int return_value_net_data_read$4;
            return_value_net_data_read$4=net_data_read(req);
            if(return_value_net_data_read$4 == -1)
              return -1;

            return_value_client_parse_icap_header$3=client_parse_icap_header(req, req->response_header);
          }
          while(return_value_client_parse_icap_header$3 == 2);
          sscanf(req->response_header->buf, "ICAP/%d.%d %d", &v1, &v2, &preview_status);
          if(CI_DEBUG_LEVEL >= 3)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Preview response was with status: %d \n", preview_status);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Preview response was with status: %d \n", preview_status);

          }

          if(preview_status == 204)
            ci_headers_unpack(req->response_header);

          else
            if(preview_status == 206 || preview_status == 200 && !(req->eof_received == 0))
            {
              ci_headers_unpack(req->response_header);
              val=ci_headers_search(req->response_header, "Encapsulated");
              if(val == ((const char *)NULL))
              {
                if(CI_DEBUG_LEVEL >= 1)
                {
                  if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                    __log_error((void *)0, "No encapsulated entities!\n");

                  if(!(CI_DEBUG_STDOUT == 0))
                    printf("No encapsulated entities!\n");

                }

                return -1;
              }

              process_encapsulated(req, val);
              if(req->entities[1l] == ((struct ci_encaps_entity *)NULL))
                req->status = 3;

              else
                req->status = 1;
            }

            else
              ci_headers_reset(req->response_header);
        }

        if(preview_status == 204 || preview_status == 206)
          return preview_status;

        else
        {
          ret=client_send_get_data(req, timeout, data_source, source_read, data_dest, dest_write);
          if(preview_status == 206 && ret == 1)
            return 206;

          else
            return ret;
        }
      }
    }
  }
}

// ci_client_request
// file request_common.c line 662
struct ci_request * ci_client_request(struct ci_connection *conn, char *server, char *service)
{
  struct ci_request *req;
  req=ci_request_alloc(conn);
  if(req == ((struct ci_request *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocation ci_request_t object(ci_client_request())\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocation ci_request_t object(ci_client_request())\n");

    }

    return (struct ci_request *)(void *)0;
  }

  else
  {
    strncpy(req->req_server, server, (unsigned long int)256);
    req->req_server[(signed long int)256] = (char)0;
    strncpy(req->service, service, (unsigned long int)63);
    req->service[(signed long int)63] = (char)0;
    return req;
  }
}

// ci_client_request_reuse
// file request_common.c line 679
void ci_client_request_reuse(struct ci_request *req)
{
  signed int i;
  req->packed = 0;
  req->args[(signed long int)0] = (char)0;
  req->type = -1;
  ci_buf_reset(&req->preview_data);
  req->hasbody = 0;
  req->responce_hasbody = 0;
  ci_headers_reset(req->request_header);
  ci_headers_reset(req->response_header);
  ci_headers_reset(req->xheaders);
  req->eof_received = 0;
  req->status = 0;
  req->pstrblock_read = (char *)(void *)0;
  req->pstrblock_read_len = 0;
  req->current_chunk_len = (unsigned int)0;
  req->chunk_bytes_read = (unsigned int)0;
  req->pstrblock_responce = (char *)(void *)0;
  req->remain_send_block_bytes = 0;
  req->write_to_module_pending = (unsigned int)0;
  req->data_locked = 1;
  req->allow204 = 0;
  req->allow206 = 0;
  req->i206_use_original_body = (signed long int)-1;
  req->bytes_in = (unsigned long int)0;
  req->bytes_out = (unsigned long int)0;
  req->http_bytes_in = (unsigned long int)0;
  req->http_bytes_out = (unsigned long int)0;
  req->body_bytes_in = (unsigned long int)0;
  req->body_bytes_out = (unsigned long int)0;
  i = 0;
  for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
    ci_request_release_entity(req, i);
}

// ci_connection_destroy
// file net_io.c line 191
void ci_connection_destroy(struct ci_connection *connection)
{
  if(!(connection == ((struct ci_connection *)NULL)))
  {
    if(connection->fd >= 0)
      close(connection->fd);

    free((void *)connection);
  }

}

// ci_copy_connection
// file net_io.c line 162
void ci_copy_connection(struct ci_connection *dest, struct ci_connection *src)
{
  dest->fd = src->fd;
  ci_copy_sockaddr(&dest->claddr, &src->claddr);
  ci_copy_sockaddr(&dest->srvaddr, &src->srvaddr);
}

// ci_copy_sockaddr
// file net_io.c line 68
void ci_copy_sockaddr(struct ci_sockaddr *dest, struct ci_sockaddr *src)
{
  memcpy((void *)dest, (const void *)src, sizeof(struct ci_sockaddr) /*40ul*/ );
  dest->ci_sin_addr = (void *)&dest->sockaddr.sin_addr;
}

// ci_create_os_allocator
// file mem.c line 424
struct ci_mem_allocator * ci_create_os_allocator()
{
  struct ci_mem_allocator *allocator;
  allocator=alloc_mem_allocator_struct();
  if(allocator == ((struct ci_mem_allocator *)NULL))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    allocator->alloc = os_allocator_alloc;
    allocator->free = os_allocator_free;
    allocator->reset = os_allocator_reset;
    allocator->destroy = os_allocator_destroy;
    allocator->data = (void *)0;
    allocator->name = (char *)(void *)0;
    allocator->type = 0;
    return allocator;
  }
}

// ci_create_pack_allocator
// file mem.c line 687
struct ci_mem_allocator * ci_create_pack_allocator(char *memblock, unsigned long int size)
{
  struct ci_mem_allocator *allocator;
  struct pack_allocator *pack_alloc;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(PACK_ALLOCATOR_POOL);
  pack_alloc = (struct pack_allocator *)return_value_ci_object_pool_alloc$1;
  if(pack_alloc == ((struct pack_allocator *)NULL))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    allocator=alloc_mem_allocator_struct();
    if(allocator == ((struct ci_mem_allocator *)NULL))
    {
      ci_object_pool_free((void *)pack_alloc);
      return (struct ci_mem_allocator *)(void *)0;
    }

    else
    {
      struct ci_mem_allocator *return_value_init_pack_allocator$2;
      return_value_init_pack_allocator$2=init_pack_allocator(allocator, pack_alloc, memblock, size, 2);
      return return_value_init_pack_allocator$2;
    }
  }
}

// ci_create_pack_allocator_on_memblock
// file mem.c line 704
struct ci_mem_allocator * ci_create_pack_allocator_on_memblock(char *memblock, unsigned long int size)
{
  struct ci_mem_allocator *allocator;
  if(!(size >= 97ul))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    struct pack_allocator *pack_alloc = (struct pack_allocator *)memblock;
    memblock = memblock + (signed long int)(sizeof(struct pack_allocator) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    size = size - (sizeof(struct pack_allocator) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    allocator = (struct ci_mem_allocator *)memblock;
    memblock = memblock + (signed long int)(sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    size = size - (sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    struct ci_mem_allocator *return_value_init_pack_allocator$1;
    return_value_init_pack_allocator$1=init_pack_allocator(allocator, pack_alloc, memblock, size, 0);
    return return_value_init_pack_allocator$1;
  }
}

// ci_create_pool_allocator
// file mem.c line 888
struct ci_mem_allocator * ci_create_pool_allocator(signed int items_size)
{
  struct pool_allocator *palloc;
  struct ci_mem_allocator *allocator;
  palloc=pool_allocator_build(items_size, 0);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_mem_allocator) /*56ul*/ );
  allocator = (struct ci_mem_allocator *)return_value_malloc$1;
  if(allocator == ((struct ci_mem_allocator *)NULL))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    allocator->alloc = pool_allocator_alloc;
    allocator->free = pool_allocator_free;
    allocator->reset = pool_allocator_reset;
    allocator->destroy = pool_allocator_destroy;
    allocator->data = (void *)palloc;
    allocator->name = (char *)(void *)0;
    allocator->type = 2;
    allocator->must_free = 1;
    return allocator;
  }
}

// ci_create_serial_allocator
// file include/mem.h line 48
struct ci_mem_allocator * ci_create_serial_allocator(signed int size)
{
  struct ci_mem_allocator *allocator;
  struct serial_allocator *sdata;
  sdata=serial_allocator_build(size);
  void *return_value_serial_allocation$1;
  return_value_serial_allocation$1=serial_allocation(sdata, sizeof(struct ci_mem_allocator) /*56ul*/ );
  allocator = (struct ci_mem_allocator *)return_value_serial_allocation$1;
  if(allocator == ((struct ci_mem_allocator *)NULL))
  {
    ci_buffer_free((void *)sdata);
    return (struct ci_mem_allocator *)(void *)0;
  }

  else
  {
    allocator->alloc = serial_allocator_alloc;
    allocator->free = serial_allocator_free;
    allocator->reset = serial_allocator_reset;
    allocator->destroy = serial_allocator_destroy;
    allocator->data = (void *)sdata;
    allocator->name = (char *)(void *)0;
    allocator->type = 1;
    allocator->must_free = 0;
    return allocator;
  }
}

// ci_dyn_array_add
// file array.c line 269
const struct ci_array_item * ci_dyn_array_add(struct ci_dyn_array *array, const char *name, const void *value, unsigned long int size)
{
  struct ci_array_item *item;
  struct ci_array_item **items_space;
  struct ci_mem_allocator *packer = array->alloc;
  signed int name_size;
  if(array->count == array->max_items)
  {
    void *return_value_ci_buffer_realloc$1;
    return_value_ci_buffer_realloc$1=ci_buffer_realloc((void *)array->items, (signed int)((unsigned long int)(array->max_items + 32) * sizeof(struct ci_array_item *) /*8ul*/ ));
    items_space = (struct ci_array_item **)return_value_ci_buffer_realloc$1;
    if(items_space == ((struct ci_array_item **)NULL))
      return (const struct ci_array_item *)(void *)0;

    array->items = items_space;
    array->max_items = array->max_items + 32;
  }

  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value;
  return_value=packer->alloc(packer, sizeof(struct ci_array_item) /*16ul*/ );
  item = (struct ci_array_item *)return_value;
  if(item == ((struct ci_array_item *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item %s to array!\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item %s to array!\n", name);

    }

    return (const struct ci_array_item *)(void *)0;
  }

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(name);
    name_size = (signed int)(return_value_strlen$2 + (unsigned long int)1);
    void *return_value_1;
    return_value_1=packer->alloc(packer, (unsigned long int)name_size);
    item->name = (char *)return_value_1;
    if(size >= 1ul)
      item->value=packer->alloc(packer, size);

    else
      item->value = (void *)0;
    _Bool tmp_if_expr$3;
    if(item->name == ((char *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (!(item->value != NULL) ? (size > (unsigned long int)0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not enough space to add the new item %s to array!\n", name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not enough space to add the new item %s to array!\n", name);

      }

      if(!(item->name == ((char *)NULL)))
        packer->free(packer, (void *)item->name);

      if(!(item->value == NULL))
        packer->free(packer, item->value);

      packer->free(packer, (void *)item);
      return (const struct ci_array_item *)(void *)0;
    }

    else
    {
      memcpy((void *)item->name, (const void *)name, (unsigned long int)name_size);
      if(size >= 1ul)
        memcpy(item->value, value, size);

      else
        item->value = (void *)value;
      signed int tmp_post$4 = array->count;
      array->count = array->count + 1;
      array->items[(signed long int)tmp_post$4] = item;
      return item;
    }
  }
}

// ci_dyn_array_destroy
// file array.c line 260
void ci_dyn_array_destroy(struct ci_dyn_array *array)
{
  if(!(array->items == ((struct ci_array_item **)NULL)))
    ci_buffer_free((void *)array->items);

  if(!(array->alloc == ((struct ci_mem_allocator *)NULL)))
    ci_mem_allocator_destroy(array->alloc);

}

// ci_dyn_array_iterate
// file array.c line 329
void ci_dyn_array_iterate(const struct ci_dyn_array *array, void *data, signed int (*fn)(void *, const char *, const void *))
{
  signed int i;
  signed int ret = 0;
  i = 0;
  if(ret == 0 && !(i >= array->count))
  {
    ret=fn(data, array->items[(signed long int)i]->name, array->items[(signed long int)i]->value);
    i = i + 1;
  }

}

// ci_dyn_array_new
// file array.c line 212
struct ci_dyn_array * ci_dyn_array_new(unsigned long int size)
{
  unsigned long int index_memory = size / (unsigned long int)4;
  unsigned long int items_memory = size - index_memory;
  unsigned long int items_count = index_memory / sizeof(struct ci_array_item *) /*8ul*/ ;
  unsigned long int item_size = items_memory / items_count;
  if(!(item_size >= sizeof(struct ci_array_item) /*16ul*/ ))
    item_size = sizeof(struct ci_array_item) /*16ul*/ ;

  struct ci_dyn_array *return_value_ci_dyn_array_new2$1;
  return_value_ci_dyn_array_new2$1=ci_dyn_array_new2(items_count, item_size);
  return return_value_ci_dyn_array_new2$1;
}

// ci_dyn_array_new2
// file array.c line 225
struct ci_dyn_array * ci_dyn_array_new2(unsigned long int items, unsigned long int item_size)
{
  struct ci_dyn_array *array;
  struct ci_mem_allocator *packer;
  unsigned long int array_size = (sizeof(struct ci_dyn_array) /*24ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + items * ((item_size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_array_item) /*16ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + ((unsigned long int)16 + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  packer=ci_create_serial_allocator((signed int)array_size);
  if(packer == ((struct ci_mem_allocator *)NULL))
    return (struct ci_dyn_array *)(void *)0;

  else
  {
    void *return_value;
    return_value=packer->alloc(packer, sizeof(struct ci_dyn_array) /*24ul*/ );
    array = (struct ci_dyn_array *)return_value;
    if(array == ((struct ci_dyn_array *)NULL))
    {
      ci_mem_allocator_destroy(packer);
      return (struct ci_dyn_array *)(void *)0;
    }

    else
    {
      if(!(items >= 32ul))
        items = (unsigned long int)32;

      array->max_items = (signed int)items;
      void *return_value_ci_buffer_alloc$1;
      return_value_ci_buffer_alloc$1=ci_buffer_alloc((signed int)(items * sizeof(struct ci_array_item *) /*8ul*/ ));
      array->items = (struct ci_array_item **)return_value_ci_buffer_alloc$1;
      array->count = 0;
      array->alloc = packer;
      return array;
    }
  }
}

// ci_dyn_array_search
// file array.c line 317
const void * ci_dyn_array_search(struct ci_dyn_array *array, const char *name)
{
  struct ci_array_item *item;
  signed int i = 0;
  signed int return_value_strcmp$1;
  for( ; !(i >= array->count); i = i + 1)
  {
    return_value_strcmp$1=strcmp(array->items[(signed long int)i]->name, name);
    if(return_value_strcmp$1 == 0)
      return array->items[(signed long int)i]->value;

  }
  return (void *)0;
}

// ci_extend_filetype
// file filetype.c line 661
signed int ci_extend_filetype(struct ci_magics_db *db, struct ci_request *req, const char *buf, signed int len, signed int *iscompressed)
{
  struct ci_headers_list *heads;
  if(req->type == 0x04)
    heads=ci_http_response_headers(req);

  else
    heads = (struct ci_headers_list *)(void *)0;
  signed int return_value_extend_object_type$1;
  return_value_extend_object_type$1=extend_object_type(db, heads, buf, len, iscompressed);
  return return_value_extend_object_type$1;
}

// ci_filetype
// file filetype.c line 541
signed int ci_filetype(struct ci_magics_db *db, const char *buf, signed int buflen)
{
  signed int ret;
  ret=check_magics(db, buf, buflen);
  if(ret >= 0)
    return ret;

  else
  {
    ret=check_ascii((unsigned char *)buf, buflen);
    if(ret >= 0)
      return ret;

    else
    {
      ret=check_unicode((unsigned char *)buf, buflen);
      if(ret >= 0)
        return 3;

      else
        return 5;
    }
  }
}

// ci_fill_ip_t
// file net_io.c line 75
void ci_fill_ip_t(struct ci_ip *ip_dest, struct ci_sockaddr *src)
{
  ip_dest->family = src->ci_sin_family;
  memcpy((void *)&ip_dest->address, src->ci_sin_addr, sizeof(struct in_addr) /*4ul*/ );
  ip_dest->netmask.s_addr=htonl(0xFFFFFFFF);
}

// ci_fill_sockaddr
// file include/net_io.h line 115
void ci_fill_sockaddr(struct ci_sockaddr *addr)
{
  addr->ci_sin_family = (signed int)addr->sockaddr.sin_family;
  addr->ci_sin_port = (signed int)addr->sockaddr.sin_port;
  addr->ci_sin_addr = (void *)&addr->sockaddr.sin_addr;
  addr->ci_inaddr_len = (signed int)sizeof(struct in_addr) /*4ul*/ ;
}

// ci_format_text
// file txt_format.c line 240
signed int ci_format_text(struct ci_request *req_data, const char *fmt, char *buffer, signed int len, struct ci_fmt_entry *user_table)
{
  const char *s;
  char *b;
  char *lb;
  struct ci_fmt_entry *fmte;
  signed int directive_len;
  signed int val_len;
  signed int remains;
  signed int left_align;
  signed int i;
  unsigned int width;
  unsigned int space = (unsigned int)0;
  char parameter[256l];
  lb = (char *)(void *)0;
  s = fmt;
  b = buffer;
  remains = len - 1;
  void *return_value_malloc$1;
  while(!(*s == 0))
  {
    if(!(remains >= 1))
      break;

    if((signed int)*s == 37)
    {
      fmte=check_tables(s, user_table, &directive_len, &width, &left_align, parameter);
      if(CI_DEBUG_LEVEL >= 7)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Width: %d, Parameter:%s\n", width, (const void *)parameter);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Width: %d, Parameter:%s\n", width, (const void *)parameter);

      }

      if(!(width == 0u))
      {
        width = (unsigned int)remains < width ? (unsigned int)remains : width;
        space = width;
      }

      else
        space = (unsigned int)remains;
      if(!(fmte == ((struct ci_fmt_entry *)NULL)))
      {
        if(!(width == 0u))
        {
          if(!(left_align == 0))
          {
            val_len=fmte->format(req_data, b, (signed int)space, parameter);
            if(!(val_len >= 1))
              val_len=fmt_none(req_data, b, (signed int)space, parameter);

            if(!(space >= (unsigned int)val_len))
              val_len = (signed int)space;

            b = b + (signed long int)val_len;
            i = 0;
            if(!((unsigned int)i >= width + -((unsigned int)val_len)))
            {
              b[(signed long int)i] = (char)32;
              i = i + 1;
            }

            b = b + (signed long int)(width - (unsigned int)val_len);
          }

          else
          {
            return_value_malloc$1=malloc((unsigned long int)(space + (unsigned int)1) * sizeof(char) /*1ul*/ );
            lb = (char *)return_value_malloc$1;
            if(!(lb == ((char *)NULL)))
            {
              val_len=fmte->format(req_data, lb, (signed int)space, parameter);
              if(!(val_len >= 1))
                val_len=fmt_none(req_data, lb, (signed int)space, parameter);

              if(!(space >= (unsigned int)val_len))
                val_len = (signed int)space;

              i = 0;
              if(!((unsigned int)i >= width + -((unsigned int)val_len)))
              {
                b[(signed long int)i] = (char)32;
                i = i + 1;
              }

              b = b + (signed long int)(width - (unsigned int)val_len);
              i = 0;
              if(!(i >= val_len))
              {
                b[(signed long int)i] = lb[(signed long int)i];
                i = i + 1;
              }

              b = b + (signed long int)val_len;
              free((void *)lb);
              lb = (char *)(void *)0;
            }

          }
          remains = remains - (signed int)width;
        }

        else
        {
          val_len=fmte->format(req_data, b, (signed int)space, parameter);
          if(!(val_len >= 1))
            val_len=fmt_none(req_data, b, (signed int)space, parameter);

          if(!(space >= (unsigned int)val_len))
            val_len = (signed int)space;

          b = b + (signed long int)val_len;
          remains = remains - val_len;
        }
        s = s + (signed long int)directive_len;
      }

      else
      {
        char *tmp_post$2 = b;
        b = b + 1l;
        const char *tmp_post$3 = s;
        s = s + 1l;
        *tmp_post$2 = *tmp_post$3;
        remains = remains - 1;
      }
    }

    else
    {
      char *tmp_post$4 = b;
      b = b + 1l;
      const char *tmp_post$5 = s;
      s = s + 1l;
      *tmp_post$4 = *tmp_post$5;
      remains = remains - 1;
    }
  }
  *b = (char)0;
  return len - remains;
}

// ci_get_data_group_id
// file filetype.c line 143
signed int ci_get_data_group_id(struct ci_magics_db *db, const char *group)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= db->groups_num); i = i + 1)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(group, (db->groups + (signed long int)i)->name);
    if(return_value_strcasecmp$1 == 0)
      return i;

  }
  return -1;
}

// ci_get_data_type_id
// file filetype.c line 133
signed int ci_get_data_type_id(struct ci_magics_db *db, const char *name)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= db->types_num); i = i + 1)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(name, (db->types + (signed long int)i)->name);
    if(return_value_strcasecmp$1 == 0)
      return i;

  }
  return -1;
}

// ci_hard_close
// file os/unix/net_io.c line 359
signed int ci_hard_close(signed int fd)
{
  close(fd);
  return 1;
}

// ci_hash_add
// file include/hash.h line 54
void * ci_hash_add(struct ci_hash_table *htable, const void *key, const void *val)
{
  struct ci_hash_entry *e;
  unsigned int hash;
  unsigned long int return_value;
  return_value=htable->ops->size(key);
  hash=ci_hash_compute((unsigned long int)htable->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= htable->hash_table_size */
  assert(hash <= htable->hash_table_size);
  void *return_value_1;
  return_value_1=htable->allocator->alloc(htable->allocator, sizeof(struct ci_hash_entry) /*32ul*/ );
  e = (struct ci_hash_entry *)return_value_1;
  if(e == ((struct ci_hash_entry *)NULL))
    return (void *)0;

  else
  {
    e->hnext = (struct ci_hash_entry *)(void *)0;
    e->key = key;
    e->val = val;
    e->hash = hash;
    e->hnext = htable->hash_table[(signed long int)hash];
    htable->hash_table[(signed long int)hash] = e;
    return (void *)e;
  }
}

// ci_hash_build
// file include/hash.h line 49
struct ci_hash_table * ci_hash_build(unsigned int hash_size, const struct ci_type_ops *ops, struct ci_mem_allocator *allocator)
{
  struct ci_hash_table *htable;
  unsigned int new_hash_size;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct ci_hash_table) /*32ul*/ );
  htable = (struct ci_hash_table *)return_value;
  if(htable == ((struct ci_hash_table *)NULL))
    return (struct ci_hash_table *)(void *)0;

  else
  {
    new_hash_size = (unsigned int)63;
    if(hash_size >= 64u)
    {
      if(!(new_hash_size >= 16777215u) && !(new_hash_size >= hash_size))
      {
        new_hash_size = new_hash_size + 1u;
        new_hash_size = (new_hash_size << 1) - (unsigned int)1;
      }

    }

    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Build hash table of size: %d, memallocated:%d\n", new_hash_size, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Build hash table of size: %d, memallocated:%d\n", new_hash_size, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );

    }

    void *return_value_1;
    return_value_1=allocator->alloc(allocator, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );
    htable->hash_table = (struct ci_hash_entry **)return_value_1;
    if(htable->hash_table == ((struct ci_hash_entry **)NULL))
    {
      allocator->free(allocator, (void *)htable);
      return (struct ci_hash_table *)(void *)0;
    }

    else
    {
      memset((void *)htable->hash_table, 0, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );
      htable->hash_table_size = new_hash_size;
      htable->ops = ops;
      htable->allocator = allocator;
      return htable;
    }
  }
}

// ci_hash_compute
// file include/hash.h line 48
unsigned int ci_hash_compute(unsigned long int hash_max_value, const void *key, signed int len)
{
  unsigned long int hash = (unsigned long int)5381;
  const unsigned char *s = (const unsigned char *)key;
  signed int i;
  if(!(len == 0))
  {
    i = 0;
    for( ; !(i >= len); s = s + 1l)
    {
      hash = (hash << 5) + hash + (unsigned long int)*s;
      i = i + 1;
    }
  }

  else
    for( ; !(*s == 0); s = s + 1l)
      hash = (hash << 5) + hash + (unsigned long int)*s;
  if(hash == 0ul)
    hash = hash + 1ul;

  hash = hash & hash_max_value;
  return (unsigned int)hash;
}

// ci_hash_destroy
// file include/hash.h line 52
void ci_hash_destroy(struct ci_hash_table *htable)
{
  signed int i;
  struct ci_hash_entry *e;
  struct ci_mem_allocator *allocator = htable->allocator;
  i = 0;
  for( ; htable->hash_table_size >= (unsigned int)i; i = i + 1)
    if(!(htable->hash_table[(signed long int)i] == ((struct ci_hash_entry *)NULL)))
    {
      e = htable->hash_table[(signed long int)i];
      htable->hash_table[(signed long int)i] = htable->hash_table[(signed long int)i]->hnext;
      allocator->free(allocator, (void *)e);
    }

  htable->allocator->free(allocator, (void *)htable->hash_table);
  allocator->free(allocator, (void *)htable);
}

// ci_hash_search
// file include/hash.h line 53
const void * ci_hash_search(struct ci_hash_table *htable, const void *key)
{
  struct ci_hash_entry *e;
  unsigned int hash;
  unsigned long int return_value;
  return_value=htable->ops->size(key);
  hash=ci_hash_compute((unsigned long int)htable->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= htable->hash_table_size */
  assert(hash <= htable->hash_table_size);
  e = htable->hash_table[(signed long int)hash];
  if(!(e == ((struct ci_hash_entry *)NULL)))
  {
    signed int return_value_1;
    return_value_1=htable->ops->compare(e->key, key);
    if(return_value_1 == 0)
      return e->val;

    e = e->hnext;
  }

  return (void *)0;
}

// ci_headers_add
// file header.c line 220
const char * ci_headers_add(struct ci_headers_list *h, const char *line)
{
  char *newhead;
  char **newspace;
  char *newbuf;
  signed int len;
  signed int linelen;
  signed int i = 0;
  unsigned long int return_value_strlen$4;
  if(!(h->packed == 0))
    return (const char *)(void *)0;

  else
  {
    if(h->used == h->size)
    {
      len = h->size + 64;
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)h->headers, (unsigned long int)len * sizeof(char *) /*8ul*/ );
      newspace = (char **)return_value_realloc$1;
      if(newspace == ((char **)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error:Error allocation memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error:Error allocation memory \n");

        }

        return (const char *)(void *)0;
      }

      h->headers = newspace;
      h->size = len;
    }

    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(line);
    linelen = (signed int)return_value_strlen$2;
    len = h->bufsize;
    for( ; !(len + -h->bufused >= 4 + linelen); len = len + 4096)
      ;
    if(!(h->bufsize >= len))
    {
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)h->buf, (unsigned long int)len * sizeof(char) /*1ul*/ );
      newbuf = (char *)return_value_realloc$3;
      if(newbuf == ((char *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error:Error allocation memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error:Error allocation memory \n");

        }

        return (const char *)(void *)0;
      }

      h->buf = newbuf;
      h->bufsize = len;
      h->headers[(signed long int)0] = h->buf;
      i = 1;
      for( ; !(i >= h->used); i = i + 1)
      {
        return_value_strlen$4=strlen(h->headers[(signed long int)(i - 1)]);
        h->headers[(signed long int)i] = h->headers[(signed long int)(i - 1)] + (signed long int)return_value_strlen$4 + (signed long int)2;
      }
    }

    newhead = h->buf + (signed long int)h->bufused;
    strcpy(newhead, line);
    h->bufused = h->bufused + linelen + 2;
    (newhead + (signed long int)linelen)[(signed long int)1] = (char)10;
    (newhead + (signed long int)linelen)[(signed long int)3] = (char)10;
    if(!(newhead == ((char *)NULL)))
    {
      signed int tmp_post$5 = h->used;
      h->used = h->used + 1;
      h->headers[(signed long int)tmp_post$5] = newhead;
    }

    return newhead;
  }
}

// ci_headers_addheaders
// file header.c line 269
signed int ci_headers_addheaders(struct ci_headers_list *h, const struct ci_headers_list *headers)
{
  signed int len;
  signed int i;
  char *newbuf;
  char **newspace;
  unsigned long int return_value_strlen$3;
  if(!(h->packed == 0))
    return 0;

  else
  {
    len = h->size;
    for( ; !(len + -h->used >= headers->used); len = len + 64)
      ;
    if(!(h->size >= len))
    {
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)h->headers, (unsigned long int)len * sizeof(char *) /*8ul*/ );
      newspace = (char **)return_value_realloc$1;
      if(newspace == ((char **)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error: Error allocating memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error: Error allocating memory \n");

        }

        return 0;
      }

      h->headers = newspace;
      h->size = len;
    }

    len = h->bufsize;
    for( ; !(len + -h->bufused >= 2 + headers->bufused); len = len + 4096)
      ;
    if(!(h->bufsize >= len))
    {
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)h->buf, (unsigned long int)len * sizeof(char) /*1ul*/ );
      newbuf = (char *)return_value_realloc$2;
      if(newbuf == ((char *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error: Error allocating memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error: Error allocating memory \n");

        }

        return 0;
      }

      h->buf = newbuf;
      h->bufsize = len;
    }

    memcpy((void *)(h->buf + (signed long int)h->bufused), (const void *)headers->buf, (unsigned long int)(headers->bufused + 2));
    h->bufused = h->bufused + headers->bufused;
    h->used = h->used + headers->used;
    h->headers[(signed long int)0] = h->buf;
    i = 1;
    for( ; !(i >= h->used); i = i + 1)
    {
      return_value_strlen$3=strlen(h->headers[(signed long int)(i - 1)]);
      h->headers[(signed long int)i] = h->headers[(signed long int)(i - 1)] + (signed long int)return_value_strlen$3 + (signed long int)2;
    }
    return 1;
  }
}

// ci_headers_copy_value
// file header.c line 343
const char * ci_headers_copy_value(struct ci_headers_list *h, const char *header, char *buf, unsigned long int len)
{
  const char *phead;
  signed int i;
  phead=ci_headers_search(h, header);
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(phead == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    if(!(h->packed == 0))
      for( ; !((signed int)*phead == 0); phead = phead + 1l)
      {
        if((signed int)*phead == 58)
          break;

        if((signed int)*phead == 13)
          break;

        if((signed int)*phead == 10)
          break;

      }

    else
      for( ; !((signed int)*phead == 0); phead = phead + 1l)
        if((signed int)*phead == 58)
          break;

    if(!((signed int)*phead == 58))
      return (const char *)(void *)0;

    else
    {
      phead = phead + 1l;
      do
      {
        return_value___ctype_b_loc$1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*phead]) == 0)
          break;

        if((signed int)*phead == 0)
          break;

        phead = phead + 1l;
      }
      while((_Bool)1);
      i = 0;
      do
      {
        if(!((unsigned long int)i >= len + 18446744073709551615ul))
          tmp_if_expr$2 = (signed int)*phead != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*phead != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (signed int)*phead != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        buf[(signed long int)i] = *phead;
        i = i + 1;
        phead = phead + 1l;
      }
      while((_Bool)1);
      buf[(signed long int)i] = (char)0;
      return buf;
    }
  }
}

// ci_headers_create
// file header.c line 156
struct ci_headers_list * ci_headers_create()
{
  struct ci_headers_list *h;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_headers_list) /*40ul*/ );
  h = (struct ci_headers_list *)return_value_malloc$1;
  void *return_value_malloc$3;
  if(h == ((struct ci_headers_list *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocation memory for ci_headers_list_t (header.c: ci_headers_create)\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocation memory for ci_headers_list_t (header.c: ci_headers_create)\n");

    }

    return (struct ci_headers_list *)(void *)0;
  }

  else
  {
    h->headers = (char **)(void *)0;
    h->buf = (char *)(void *)0;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)64 * sizeof(char *) /*8ul*/ );
    h->headers = (char **)return_value_malloc$2;
    _Bool tmp_if_expr$4;
    if(h->headers == ((char **)NULL))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_malloc$3=malloc((unsigned long int)4096 * sizeof(char) /*1ul*/ );
      h->buf = (char *)return_value_malloc$3;
      tmp_if_expr$4 = !(h->buf != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Server Error: Error allocation memory \n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Server Error: Error allocation memory \n");

      }

      if(!(h->headers == ((char **)NULL)))
        free((void *)h->headers);

      if(!(h->buf == ((char *)NULL)))
        free((void *)h->buf);

      free((void *)h);
      return (struct ci_headers_list *)(void *)0;
    }

    else
    {
      h->size = 64;
      h->used = 0;
      h->bufsize = 4096;
      h->bufused = 0;
      h->packed = 0;
      return h;
    }
  }
}

// ci_headers_destroy
// file header.c line 186
void ci_headers_destroy(struct ci_headers_list *h)
{
  free((void *)h->headers);
  free((void *)h->buf);
  free((void *)h);
}

// ci_headers_iterate
// file header.c line 424
signed int ci_headers_iterate(struct ci_headers_list *h, void *data, void (*fn)(void *, const char *, const char *))
{
  char header[256l];
  char value[8196l];
  char *s;
  signed int i;
  signed int j;
  i = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  if(!(i >= h->used))
  {
    s = h->headers[(signed long int)i];
    j = 0;
    do
    {
      if(!((unsigned long int)j >= 255ul))
        tmp_if_expr$1 = (signed int)*s != 58 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (signed int)*s != 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(!tmp_if_expr$5)
        break;

      header[(signed long int)j] = *s;
      s = s + 1l;
      j = j + 1;
    }
    while((_Bool)1);
    header[(signed long int)j] = (char)0;
    j = 0;
    if((signed int)*s == 58)
      s = s + 1l;

    else
    {
      header[(signed long int)0] = (char)0;
      s = h->headers[(signed long int)i];
    }
    for( ; (signed int)*s == 32; s = s + 1l)
      ;
    j = 0;
    do
    {
      if(!((unsigned long int)j >= 8195ul))
        tmp_if_expr$6 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
      {
        if((signed int)*s == 13)
          tmp_if_expr$7 = (signed int)s[(signed long int)1] == 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$7 = (_Bool)0;
        if(tmp_if_expr$7)
          tmp_if_expr$8 = (signed int)s[(signed long int)2] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = (signed int)s[(signed long int)2] != 32 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        if(tmp_if_expr$9)
          tmp_if_expr$12 = (_Bool)1;

        else
        {
          if((signed int)*s == 10)
            tmp_if_expr$10 = (signed int)s[(signed long int)1] != 9 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$10 = (_Bool)0;
          if(tmp_if_expr$10)
            tmp_if_expr$11 = (signed int)s[(signed long int)1] != 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$11 = (_Bool)0;
          tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr$13 = !tmp_if_expr$12 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$13 = (_Bool)0;
      if(!tmp_if_expr$13)
        break;

      value[(signed long int)j] = *s;
      s = s + 1l;
      j = j + 1;
    }
    while((_Bool)1);
    value[(signed long int)j] = (char)0;
    fn(data, header, value);
    i = i + 1;
  }

  return 1;
}

// ci_headers_pack
// file header.c line 451
void ci_headers_pack(struct ci_headers_list *h)
{
  signed int i = 0;
  signed int len = 0;
  i = 0;
  for( ; !(i >= h->used); i = i + 1)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(h->headers[(signed long int)i]);
    len = (signed int)return_value_strlen$1;
    if((signed int)h->headers[(signed long int)i][(signed long int)(1 + len)] == 10)
      h->headers[(signed long int)i][(signed long int)len] = (char)13;

    else
      h->headers[(signed long int)i][(signed long int)len] = (char)10;
  }
  if((signed int)h->buf[(signed long int)(1 + h->bufused)] == 10)
  {
    h->buf[(signed long int)h->bufused] = (char)13;
    h->bufused = h->bufused + 2;
  }

  else
  {
    h->buf[(signed long int)h->bufused] = (char)10;
    h->bufused = h->bufused + 1;
  }
  h->packed = 1;
}

// ci_headers_remove
// file header.c line 369
signed int ci_headers_remove(struct ci_headers_list *h, const char *header)
{
  char *phead;
  signed int i;
  signed int j;
  signed int header_len;
  signed int rest_len;
  if(!(h->packed == 0))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= h->used); i = i + 1)
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(header);
      signed int return_value_strncasecmp$3;
      return_value_strncasecmp$3=strncasecmp(h->headers[(signed long int)i], header, return_value_strlen$2);
      if(return_value_strncasecmp$3 == 0)
      {
        phead = h->headers[(signed long int)i];
        if(i == h->used + -1)
        {
          phead = h->headers[(signed long int)i];
          *phead = (char)13;
          phead[(signed long int)1] = (char)10;
          h->bufused = (signed int)(phead - h->buf);
          h->used = h->used - 1;
          return 1;
        }

        else
        {
          header_len = (signed int)(h->headers[(signed long int)(i + 1)] - h->headers[(signed long int)i]);
          rest_len = (signed int)(((signed long int)h->bufused - (h->headers[(signed long int)i] - h->buf)) - (signed long int)header_len);
          if(CI_DEBUG_LEVEL >= 5)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "remove_header : remain len %d\n", rest_len);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("remove_header : remain len %d\n", rest_len);

          }

          memmove((void *)phead, (const void *)h->headers[(signed long int)(i + 1)], (unsigned long int)rest_len);
          h->bufused = h->bufused - header_len;
          h->used = h->used - 1;
          j = i + 1;
          for( ; !(j >= h->used); j = j + 1)
          {
            unsigned long int return_value_strlen$1;
            return_value_strlen$1=strlen(h->headers[(signed long int)(j - 1)]);
            header_len = (signed int)return_value_strlen$1;
            h->headers[(signed long int)j] = h->headers[(signed long int)(j - 1)] + (signed long int)header_len + (signed long int)1;
            if((signed int)*h->headers[(signed long int)j] == 10)
              h->headers[(signed long int)j] = h->headers[(signed long int)j] + 1l;

          }
          return 1;
        }
      }

    }
    return 0;
  }
}

// ci_headers_replace
// file header.c line 414
const char * ci_headers_replace(struct ci_headers_list *h, const char *header, const char *newval)
{
  if(!(h->packed == 0))
    return (const char *)(void *)0;

  else
    return (const char *)(void *)0;
}

// ci_headers_reset
// file header.c line 213
void ci_headers_reset(struct ci_headers_list *h)
{
  h->packed = 0;
  h->used = 0;
  h->bufused = 0;
}

// ci_headers_search
// file header.c line 318
const char * ci_headers_search(struct ci_headers_list *h, const char *header)
{
  signed int i = 0;
  for( ; !(i >= h->used); i = i + 1)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(header);
    signed int return_value_strncasecmp$2;
    return_value_strncasecmp$2=strncasecmp(h->headers[(signed long int)i], header, return_value_strlen$1);
    if(return_value_strncasecmp$2 == 0)
      return h->headers[(signed long int)i];

  }
  return (const char *)(void *)0;
}

// ci_headers_setsize
// file header.c line 195
signed int ci_headers_setsize(struct ci_headers_list *h, signed int size)
{
  char *newbuf;
  signed int new_size;
  if(!(size >= h->bufsize))
    return 1;

  else
  {
    new_size = (size / 4096 + 1) * 4096;
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)h->buf, (unsigned long int)new_size * sizeof(char) /*1ul*/ );
    newbuf = (char *)return_value_realloc$1;
    if(newbuf == ((char *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Server Error:Error allocation memory \n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Server Error:Error allocation memory \n");

      }

      return 0;
    }

    else
    {
      h->buf = newbuf;
      h->bufsize = new_size;
      return 1;
    }
  }
}

// ci_headers_unpack
// file header.c line 478
signed int ci_headers_unpack(struct ci_headers_list *h)
{
  signed int len;
  signed int eoh;
  char **newspace;
  char *shead;
  char *ebuf;
  char *str;
  _Bool tmp_if_expr$1;
  if(!(h->bufused >= 2))
    return 4;

  else
  {
    ebuf = (h->buf + (signed long int)h->bufused) - (signed long int)2;
    if(!((signed int)*ebuf == 13))
    {
      if((signed int)*ebuf == 10)
        goto __CPROVER_DUMP_L4;

      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Parse error. The end chars are %c %c (%d %d) not the \\r \n", *ebuf, ebuf[(signed long int)1], (unsigned int)*ebuf, (unsigned int)ebuf[(signed long int)1]);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Parse error. The end chars are %c %c (%d %d) not the \\r \n", *ebuf, ebuf[(signed long int)1], (unsigned int)*ebuf, (unsigned int)ebuf[(signed long int)1]);

      }

      return 4;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      *ebuf = (char)0;
      shead = h->buf;
      h->headers[(signed long int)0] = h->buf;
      h->used = 1;
      str = h->buf;
      for( ; !(str >= ebuf); str = str + 1l)
      {
        eoh = 0;
        _Bool tmp_if_expr$5;
        if((signed int)*str == 13)
          tmp_if_expr$5 = (signed int)str[(signed long int)1] == 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
        {
          _Bool tmp_if_expr$2;
          if(str + 2l >= ebuf)
            tmp_if_expr$2 = (_Bool)1;

          else
          {
            if(!((signed int)str[2l] == 9))
              tmp_if_expr$1 = (signed int)str[(signed long int)2] != 32 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$1 = (_Bool)0;
            tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$2)
            eoh = 1;

        }

        else
        {
          _Bool tmp_if_expr$3;
          if((signed int)*str == 10)
            tmp_if_expr$3 = (signed int)str[(signed long int)1] != 9 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          _Bool tmp_if_expr$4;
          if(tmp_if_expr$3)
            tmp_if_expr$4 = (signed int)str[(signed long int)1] != 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
            eoh = 1;

          else
            if((signed int)*str == 0)
              *str = (char)32;

        }
        if(!(eoh == 0))
        {
          *str = (char)0;
          if(h->used >= h->size)
          {
            len = h->size + 64;
            void *return_value_realloc$6;
            return_value_realloc$6=realloc((void *)h->headers, (unsigned long int)len * sizeof(char *) /*8ul*/ );
            newspace = (char **)return_value_realloc$6;
            if(newspace == ((char **)NULL))
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Server Error: Error allocating memory \n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Server Error: Error allocating memory \n");

              }

              return 11;
            }

            h->headers = newspace;
            h->size = len;
          }

          str = str + 1l;
          if((signed int)*str == 10)
            str = str + 1l;

          h->headers[(signed long int)h->used] = str;
          h->used = h->used + 1;
        }

      }
      h->packed = 0;
      return 0;
    }
  }
}

// ci_headers_value
// file header.c line 328
const char * ci_headers_value(struct ci_headers_list *h, const char *header)
{
  const char *phead;
  phead=ci_headers_search(h, header);
  const unsigned short int **return_value___ctype_b_loc$1;
  if(phead == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    for( ; !((signed int)*phead == 0); phead = phead + 1l)
      if((signed int)*phead == 58)
        break;

    if(!((signed int)*phead == 58))
      return (const char *)(void *)0;

    else
    {
      phead = phead + 1l;
      do
      {
        return_value___ctype_b_loc$1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*phead]) == 0)
          break;

        if((signed int)*phead == 0)
          break;

        phead = phead + 1l;
      }
      while((_Bool)1);
      return phead;
    }
  }
}

// ci_host_to_sockaddr_t
// file include/net_io.h line 136
signed int ci_host_to_sockaddr_t(const char *servername, struct ci_sockaddr *addr, signed int proto)
{
  signed int ret = 0;
  struct addrinfo hints;
  struct addrinfo *res;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = proto;
  hints.ai_socktype = 1;
  hints.ai_protocol = 0;
  ret=getaddrinfo(servername, (const char *)(void *)0, &hints, &res);
  const char *return_value_gai_strerror$1;
  const char *return_value_gai_strerror$2;
  if(!(ret == 0))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value_gai_strerror$1=gai_strerror(ret);
        __log_error((void *)0, "Error geting addrinfo:%s\n", return_value_gai_strerror$1);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value_gai_strerror$2=gai_strerror(ret);
        printf("Error geting addrinfo:%s\n", return_value_gai_strerror$2);
      }

    }

    return 0;
  }

  else
  {
    memcpy((void *)&addr->sockaddr, (const void *)res->ai_addr, sizeof(struct sockaddr_in) /*16ul*/ );
    freeaddrinfo(res);
    ci_fill_sockaddr(addr);
    return 1;
  }
}

// ci_http_client_ip
// file simple_api.c line 301
const struct ci_ip * ci_http_client_ip(struct ci_request *req)
{
  const char *ip;
  if(req == ((struct ci_request *)NULL))
    return (const struct ci_ip *)(void *)0;

  else
    if(req->xclient_ip.family == -1)
      return (const struct ci_ip *)(void *)0;

    else
      if(!(req->xclient_ip.family == 0))
        return &req->xclient_ip;

      else
      {
        ip=ci_headers_value(req->request_header, "X-Client-IP");
        if(ip == ((const char *)NULL))
          return (const struct ci_ip *)(void *)0;

        else
        {
          signed int return_value_ci_inet_aton$1;
          return_value_ci_inet_aton$1=ci_inet_aton(2, ip, (void *)&req->xclient_ip.address);
          if(!(return_value_ci_inet_aton$1 == 0))
          {
            req->xclient_ip.family = 2;
            req->xclient_ip.netmask.s_addr=htonl(0xFFFFFFFF);
          }

          else
            req->xclient_ip.family = -1;
          if(req->xclient_ip.family == -1)
            return (const struct ci_ip *)(void *)0;

          else
            return &req->xclient_ip;
        }
      }
}

// ci_http_content_length
// file simple_api.c line 207
signed long int ci_http_content_length(struct ci_request *req)
{
  struct ci_headers_list *heads;
  const char *val;
  signed long int res = (signed long int)0;
  char *e;
  heads=ci_http_response_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
  {
    heads=ci_http_request_headers(req);
    if(!(heads == ((struct ci_headers_list *)NULL)))
      goto __CPROVER_DUMP_L1;

    return (signed long int)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    val=ci_headers_value(heads, "Content-Length");
    if(val == ((const char *)NULL))
      return (signed long int)-1;

    else
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 0;
      res=strtoll(val, &e, 10);
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(*return_value___errno_location$2 == 34)
      {
        if(!(res == 0x7fffffffffffffffLL) && !(res == -9223372036854775808ll))
          goto __CPROVER_DUMP_L5;

        if(CI_DEBUG_LEVEL >= 4)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Content-Length: overflow\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Content-Length: overflow\n");

        }

        return (signed long int)-2;
      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        if(val == e)
        {
          if(CI_DEBUG_LEVEL >= 4)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Content-Length: not valid value: '%s' \n", val);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Content-Length: not valid value: '%s' \n", val);

          }

          return (signed long int)-2;
        }

        else
          return res;
      }
    }
  }
}

// ci_http_request
// file simple_api.c line 234
const char * ci_http_request(struct ci_request *req)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
    if(heads->used == 0)
      return (const char *)(void *)0;

    else
      return heads->headers[(signed long int)0];
}

// ci_http_request_add_header
// file simple_api.c line 152
const char * ci_http_request_add_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return (const char *)(void *)0;

  else
  {
    heads=ci_http_request_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return (const char *)(void *)0;

    else
    {
      const char *return_value_ci_headers_add$1;
      return_value_ci_headers_add$1=ci_headers_add(heads, header);
      return return_value_ci_headers_add$1;
    }
  }
}

// ci_http_request_create
// file simple_api.c line 119
signed int ci_http_request_create(struct ci_request *req, signed int has_body)
{
  signed int i = 0;
  struct ci_encaps_entity **e_list = req->entities;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(!(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      ci_request_release_entity(req, i);

  i = 0;
  signed int tmp_post$1 = i;
  i = i + 1;
  req->entities[(signed long int)tmp_post$1]=ci_request_alloc_entity(req, 0, 0);
  if(!(has_body == 0))
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 2, 0);

  else
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 4, 0);
  return 1;
}

// ci_http_request_get_header
// file simple_api.c line 195
const char * ci_http_request_get_header(struct ci_request *req, const char *head_name)
{
  struct ci_headers_list *heads;
  const char *val;
  heads=ci_http_request_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
  {
    val=ci_headers_value(heads, head_name);
    if(val == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      return val;
  }
}

// ci_http_request_headers
// file simple_api.c line 52
struct ci_headers_list * ci_http_request_headers(struct ci_request *req)
{
  struct ci_encaps_entity **e_list = req->entities;
  if(!(*e_list == ((struct ci_encaps_entity *)NULL)))
  {
    if(!((*e_list)->type == 0))
      goto __CPROVER_DUMP_L1;

    return (struct ci_headers_list *)e_list[(signed long int)0]->entity;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(req->trash_entities[0l] == ((struct ci_encaps_entity *)NULL)))
    {
      if(req->trash_entities[0l]->entity == NULL)
        goto __CPROVER_DUMP_L2;

      if(((struct ci_headers_list *)req->trash_entities[0l]->entity)->used == 0)
        goto __CPROVER_DUMP_L2;

      return (struct ci_headers_list *)req->trash_entities[(signed long int)0]->entity;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return (struct ci_headers_list *)(void *)0;
    }
  }
}

// ci_http_request_remove_header
// file simple_api.c line 173
signed int ci_http_request_remove_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return 0;

  else
  {
    heads=ci_http_request_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return 0;

    else
    {
      signed int return_value_ci_headers_remove$1;
      return_value_ci_headers_remove$1=ci_headers_remove(heads, header);
      return return_value_ci_headers_remove$1;
    }
  }
}

// ci_http_request_reset_headers
// file simple_api.c line 79
signed int ci_http_request_reset_headers(struct ci_request *req)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return 0;

  else
  {
    ci_headers_reset(heads);
    return 1;
  }
}

// ci_http_request_url
// file simple_api.c line 257
signed int ci_http_request_url(struct ci_request *req, char *buf, signed int buf_size)
{
  struct ci_headers_list *heads;
  const char *str;
  const char *host;
  signed int i;
  signed int bytes;
  heads=ci_http_request_headers(req);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$10;
  const unsigned short int **return_value___ctype_b_loc$9;
  _Bool tmp_if_expr$11;
  if(heads == ((struct ci_headers_list *)NULL))
    return 0;

  else
    if(heads->used == 0)
      return 0;

    else
    {
      str = heads->headers[(signed long int)0];
      str=strchr(str, 32);
      if(str == ((const char *)NULL))
        return 0;

      else
      {
        for( ; (signed int)*str == 32; str = str + 1l)
          ;
        bytes = 0;
        if((signed int)*str == 47)
        {
          host=ci_headers_value(heads, "Host");
          if(!(host == ((const char *)NULL)))
          {
            i = 0;
            do
            {
              if(!(i >= buf_size + -1))
              {
                if((signed int)host[(signed long int)i] == 0)
                  tmp_if_expr$1 = (_Bool)1;

                else
                  tmp_if_expr$1 = (signed int)host[(signed long int)i] == 10 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$1)
                  tmp_if_expr$2 = (_Bool)1;

                else
                  tmp_if_expr$2 = (signed int)host[(signed long int)i] == 13 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$3 = !tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$3 = (_Bool)0;
              if(tmp_if_expr$3)
              {
                return_value___ctype_b_loc$4=__ctype_b_loc();
                tmp_if_expr$5 = !(((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)host[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$5 = (_Bool)0;
              if(!tmp_if_expr$5)
                break;

              buf[(signed long int)i] = host[(signed long int)i];
              i = i + 1;
            }
            while((_Bool)1);
            buf = buf + (signed long int)i;
            buf_size = buf_size - i;
            bytes = i;
          }

        }

        i = 0;
        do
        {
          if(!(i >= buf_size + -1))
          {
            if((signed int)str[(signed long int)i] == 0)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = (signed int)str[(signed long int)i] == 10 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$6)
              tmp_if_expr$7 = (_Bool)1;

            else
              tmp_if_expr$7 = (signed int)str[(signed long int)i] == 13 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$8 = !tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$8 = (_Bool)0;
          if(tmp_if_expr$8)
          {
            return_value___ctype_b_loc$9=__ctype_b_loc();
            tmp_if_expr$10 = !(((signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)str[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$10 = (_Bool)0;
          if(tmp_if_expr$10)
            tmp_if_expr$11 = (signed int)str[(signed long int)i] != 63 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$11 = (_Bool)0;
          if(!tmp_if_expr$11)
            break;

          buf[(signed long int)i] = str[(signed long int)i];
          i = i + 1;
        }
        while((_Bool)1);
        buf[(signed long int)i] = (char)0;
        bytes = bytes + i;
        return bytes;
      }
    }
}

// ci_http_response_add_header
// file simple_api.c line 141
const char * ci_http_response_add_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return (const char *)(void *)0;

  else
  {
    heads=ci_http_response_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return (const char *)(void *)0;

    else
    {
      const char *return_value_ci_headers_add$1;
      return_value_ci_headers_add$1=ci_headers_add(heads, header);
      return return_value_ci_headers_add$1;
    }
  }
}

// ci_http_response_create
// file simple_api.c line 96
signed int ci_http_response_create(struct ci_request *req, signed int has_reshdr, signed int has_body)
{
  signed int i = 0;
  struct ci_encaps_entity **e_list = req->entities;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(!(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      ci_request_release_entity(req, i);

  i = 0;
  if(!(has_reshdr == 0))
  {
    signed int tmp_post$1 = i;
    i = i + 1;
    req->entities[(signed long int)tmp_post$1]=ci_request_alloc_entity(req, 1, 0);
  }

  if(!(has_body == 0))
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 3, 0);

  else
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 4, 0);
  return 1;
}

// ci_http_response_get_header
// file simple_api.c line 184
const char * ci_http_response_get_header(struct ci_request *req, const char *head_name)
{
  struct ci_headers_list *heads;
  const char *val;
  heads=ci_http_response_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
  {
    val=ci_headers_value(heads, head_name);
    if(val == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      return val;
  }
}

// ci_http_response_headers
// file simple_api.c line 39
struct ci_headers_list * ci_http_response_headers(struct ci_request *req)
{
  signed int i;
  struct ci_encaps_entity **e_list = req->entities;
  i = 0;
  for( ; !(e_list[(signed long int)i] == ((struct ci_encaps_entity *)NULL)) && !(i >= 3); i = i + 1)
    if(e_list[(signed long int)i]->type == 1)
      return (struct ci_headers_list *)e_list[(signed long int)i]->entity;

  return (struct ci_headers_list *)(void *)0;
}

// ci_http_response_remove_header
// file simple_api.c line 162
signed int ci_http_response_remove_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return 0;

  else
  {
    heads=ci_http_response_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return 0;

    else
    {
      signed int return_value_ci_headers_remove$1;
      return_value_ci_headers_remove$1=ci_headers_remove(heads, header);
      return return_value_ci_headers_remove$1;
    }
  }
}

// ci_http_response_reset_headers
// file simple_api.c line 70
signed int ci_http_response_reset_headers(struct ci_request *req)
{
  struct ci_headers_list *heads;
  heads=ci_http_response_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return 0;

  else
  {
    ci_headers_reset(heads);
    return 1;
  }
}

// ci_icap_add_xheader
// file simple_api.c line 246
const char * ci_icap_add_xheader(struct ci_request *req, const char *header)
{
  const char *return_value_ci_headers_add$1;
  return_value_ci_headers_add$1=ci_headers_add(req->xheaders, header);
  return return_value_ci_headers_add$1;
}

// ci_icap_append_xheaders
// file simple_api.c line 251
signed int ci_icap_append_xheaders(struct ci_request *req, struct ci_headers_list *headers)
{
  signed int return_value_ci_headers_addheaders$1;
  return_value_ci_headers_addheaders$1=ci_headers_addheaders(req->xheaders, headers);
  return return_value_ci_headers_addheaders$1;
}

// ci_inet_aton
// file include/net_io.h line 119
signed int ci_inet_aton(signed int af, const char *cp, void *addr)
{
  signed int return_value_inet_aton$1;
  return_value_inet_aton$1=inet_aton(cp, (struct in_addr *)addr);
  return return_value_inet_aton$1;
}

// ci_inet_ntoa
// file include/net_io.h line 120
const char * ci_inet_ntoa(signed int af, const void *src, char *dst, signed int cnt)
{
  unsigned char *addr_bytes = (unsigned char *)src;
  snprintf(dst, (unsigned long int)cnt, "%d.%d.%d.%d", addr_bytes[(signed long int)0], addr_bytes[(signed long int)1], addr_bytes[(signed long int)2], addr_bytes[(signed long int)3]);
  dst[(signed long int)(cnt - 1)] = (char)0;
  return (const char *)dst;
}

// ci_internal_time
// file cache.c line 32
signed long int ci_internal_time()
{
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  return return_value_time$1;
}

// ci_linger_close
// file os/unix/net_io.c line 338
signed int ci_linger_close(signed int fd, signed int timeout)
{
  char buf[10l];
  signed int ret;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Waiting to close connection\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Waiting to close connection\n");

  }

  signed int return_value_shutdown$1;
  return_value_shutdown$1=shutdown(fd, 1);
  signed int return_value_ci_wait_for_data$2;
  if(!(return_value_shutdown$1 == 0))
  {
    close(fd);
    return 1;
  }

  else
  {
    do
    {
      return_value_ci_wait_for_data$2=ci_wait_for_data(fd, timeout, 0x1);
      if(return_value_ci_wait_for_data$2 == 0)
        break;

      ret=ci_read_nonblock(fd, (void *)buf, (unsigned long int)10);
      if(!(ret >= 1))
        break;

      if(CI_DEBUG_LEVEL >= 10)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "OK I linger %d bytes.....\n", ret);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("OK I linger %d bytes.....\n", ret);

      }

    }
    while((_Bool)1);
    close(fd);
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Connection closed ...\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Connection closed ...\n");

    }

    return 1;
  }
}

// ci_list_cmp_handler
// file array.c line 536
void ci_list_cmp_handler(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int))
{
  list->cmp_func = cmp_func;
}

// ci_list_copy_handler
// file array.c line 546
void ci_list_copy_handler(struct ci_list *list, signed int (*copy_func)(void *, const void *))
{
  list->copy_func = copy_func;
}

// ci_list_create
// file array.c line 507
struct ci_list * ci_list_create(unsigned long int init_size, unsigned long int obj_size)
{
  struct ci_list *list = (struct ci_list *)(void *)0;
  struct ci_mem_allocator *alloc = (struct ci_mem_allocator *)(void *)0;
  if(!(init_size >= 1024ul))
    init_size = (unsigned long int)1024;

  alloc=ci_create_serial_allocator((signed int)init_size);
  void *return_value;
  return_value=alloc->alloc(alloc, sizeof(struct ci_list) /*80ul*/ );
  list = (struct ci_list *)return_value;
  list->alloc = alloc;
  list->items = (struct ci_list_item *)(void *)0;
  list->last = (struct ci_list_item *)(void *)0;
  list->trash = (struct ci_list_item *)(void *)0;
  list->cursor = (struct ci_list_item *)(void *)0;
  list->obj_size = obj_size;
  list->cmp_func = (signed int (*)(const void *, const void *, unsigned long int))(void *)0;
  list->copy_func = (signed int (*)(void *, const void *))(void *)0;
  list->free_func = (void (*)(void *))(void *)0;
  return list;
}

// ci_list_destroy
// file array.c line 530
void ci_list_destroy(struct ci_list *list)
{
  struct ci_mem_allocator *alloc = list->alloc;
  ci_mem_allocator_destroy(alloc);
}

// ci_list_free_handler
// file array.c line 541
void ci_list_free_handler(struct ci_list *list, void (*free_func)(void *))
{
  list->free_func = free_func;
}

// ci_list_iterate
// file array.c line 551
void ci_list_iterate(struct ci_list *list, void *data, signed int (*fn)(void *, const void *))
{
  struct ci_list_item *it;
  list->cursor = list->items;
  if(!(list->cursor == ((struct ci_list_item *)NULL)))
  {
    it = list->cursor;
    list->cursor = list->cursor->next;
    signed int return_value;
    return_value=fn(data, it->item);
  }

}

// ci_list_pop
// file array.c line 617
void * ci_list_pop(struct ci_list *list, void *data)
{
  struct ci_list_item *it = list->items;
  if(list->items == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(list->last == list->items)
    {
      list->last = (struct ci_list_item *)(void *)0;
      list->items = (struct ci_list_item *)(void *)0;
      list->cursor = (struct ci_list_item *)(void *)0;
    }

    else
    {
      if(list->cursor == list->items)
        list->cursor = list->items->next;

      list->items = list->items->next;
    }
    it->next = list->trash;
    list->trash = it;
    if(!(list->obj_size == 0ul))
    {
      memcpy(data, it->item, list->obj_size);
      if(!(list->copy_func == ((signed int (*)(void *, const void *))NULL)))
        list->copy_func(data, it->item);

      if(!(list->free_func == ((void (*)(void *))NULL)))
        list->free_func(it->item);

      return data;
    }

    else
    {
      *((void **)data) = it->item;
      return *((void **)data);
    }
  }
}

// ci_list_pop_back
// file array.c line 647
void * ci_list_pop_back(struct ci_list *list, void *data)
{
  struct ci_list_item *tmp;
  struct ci_list_item *it = list->last;
  _Bool tmp_if_expr$1;
  if(list->items == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(list->last == list->items)
    {
      list->last = (struct ci_list_item *)(void *)0;
      list->items = (struct ci_list_item *)(void *)0;
      list->cursor = (struct ci_list_item *)(void *)0;
    }

    else
    {
      if(list->cursor == list->last)
        list->cursor = (struct ci_list_item *)(void *)0;

      tmp = list->items;
      do
      {
        if(!(tmp == ((struct ci_list_item *)NULL)))
          tmp_if_expr$1 = tmp->next != list->last ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        tmp = tmp->next;
      }
      while((_Bool)1);
      /* assertion tmp != ((void *)0) */
      assert(tmp != (struct ci_list_item *)(void *)0);
      list->last = tmp;
      list->last->next = (struct ci_list_item *)(void *)0;
    }
    it->next = list->trash;
    list->trash = it;
    if(!(list->obj_size == 0ul))
    {
      memcpy(data, it->item, list->obj_size);
      if(!(list->copy_func == ((signed int (*)(void *, const void *))NULL)))
        list->copy_func(data, it->item);

      if(!(list->free_func == ((void (*)(void *))NULL)))
        list->free_func(it->item);

      return data;
    }

    else
    {
      *((void **)data) = it->item;
      return *((void **)data);
    }
  }
}

// ci_list_push
// file array.c line 589
const void * ci_list_push(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  it=list_alloc_item(list, data);
  if(it == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(!(list->items == ((struct ci_list_item *)NULL)))
    {
      it->next = list->items;
      list->items = it;
    }

    else
    {
      list->last = it;
      list->items = list->last;
    }
    return it->item;
  }
}

// ci_list_push_back
// file array.c line 603
const void * ci_list_push_back(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  it=list_alloc_item(list, data);
  if(it == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(!(list->last == ((struct ci_list_item *)NULL)))
    {
      list->last->next = it;
      list->last = it;
    }

    else
    {
      list->last = it;
      list->items = list->last;
    }
    return it->item;
  }
}

// ci_list_remove
// file array.c line 690
signed int ci_list_remove(struct ci_list *list, const void *obj)
{
  struct ci_list_item *it;
  struct ci_list_item *prev;
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  if(!(list->cmp_func == ((signed int (*)(const void *, const void *, unsigned long int))NULL)))
    cmp_func = list->cmp_func;

  else
    if(!(list->obj_size == 0ul))
      cmp_func = default_cmp;

    else
      cmp_func = pointers_cmp;
  prev = (struct ci_list_item *)(void *)0;
  it = list->items;
  if(!(it == ((struct ci_list_item *)NULL)))
  {
    signed int return_value;
    return_value=cmp_func(it->item, obj, list->obj_size);
    if(return_value == 0)
    {
      if(!(prev == ((struct ci_list_item *)NULL)))
        prev->next = it->next;

      else
        list->items = it->next;
      if(list->cursor == it)
        list->cursor = list->cursor->next;

      it->next = list->trash;
      list->trash = it;
      if(!(list->free_func == ((void (*)(void *))NULL)))
      {
        if(!(list->obj_size == 0ul))
          list->free_func(it->item);

      }

      return 1;
    }

    prev = it;
    it = it->next;
  }

  return 0;
}

// ci_list_search
// file array.c line 723
const void * ci_list_search(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  if(!(list->cmp_func == ((signed int (*)(const void *, const void *, unsigned long int))NULL)))
    cmp_func = list->cmp_func;

  else
    if(!(list->obj_size == 0ul))
      cmp_func = default_cmp;

    else
      cmp_func = pointers_cmp;
  it = list->items;
  if(!(it == ((struct ci_list_item *)NULL)))
  {
    signed int return_value;
    return_value=cmp_func(it->item, data, list->obj_size);
    if(return_value == 0)
      return it->item;

    it = it->next;
  }

  return (void *)0;
}

// ci_list_search2
// file array.c line 742
const void * ci_list_search2(struct ci_list *list, const void *data, signed int (*cmp_func)(const void *, const void *, unsigned long int))
{
  struct ci_list_item *it = list->items;
  if(!(it == ((struct ci_list_item *)NULL)))
  {
    signed int return_value;
    return_value=cmp_func(it->item, data, list->obj_size);
    if(return_value == 0)
      return it->item;

    it = it->next;
  }

  return (void *)0;
}

// ci_list_sort
// file array.c line 752
void ci_list_sort(struct ci_list *list)
{
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  if(!(list->cmp_func == ((signed int (*)(const void *, const void *, unsigned long int))NULL)))
    cmp_func = list->cmp_func;

  else
    if(!(list->obj_size == 0ul))
      cmp_func = default_cmp;

    else
      cmp_func = pointers_cmp;
  ci_list_sort2(list, cmp_func);
}

// ci_list_sort2
// file array.c line 766
void ci_list_sort2(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int))
{
  struct ci_list_item *it;
  struct ci_list_item *sortedHead = (struct ci_list_item *)(void *)0;
  struct ci_list_item *sortedTail = (struct ci_list_item *)(void *)0;
  struct ci_list_item **currentSorted;
  struct ci_list_item *currentHead;
  _Bool tmp_if_expr$1;
  if(list->items == ((struct ci_list_item *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(list->items->next != ((struct ci_list_item *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value;
  if(!tmp_if_expr$1)
  {
    it = list->items;
    while(!(it == ((struct ci_list_item *)NULL)))
    {
      currentHead = it;
      it = it->next;
      currentSorted = &sortedHead;
      if(!(*currentSorted == ((struct ci_list_item *)NULL)))
      {
        return_value=cmp_func(currentHead->item, (*currentSorted)->item, list->obj_size);
        if(return_value >= 0)
          currentSorted = &(*currentSorted)->next;

      }

      currentHead->next = *currentSorted;
      *currentSorted = currentHead;
      if((*currentSorted)->next == ((struct ci_list_item *)NULL))
        sortedTail = *currentSorted;

    }
    list->items = sortedHead;
    list->last = sortedTail;
  }

}

// ci_local_cache_destroy
// file cache.c line 217
void ci_local_cache_destroy(struct ci_cache *cache)
{
  struct ci_cache_entry *e;
  struct ci_local_cache_data *cache_data = (struct ci_local_cache_data *)cache->cache_data;
  e = cache_data->first_queue_entry;
  if(!(e == ((struct ci_cache_entry *)NULL)))
  {
    cache_data->first_queue_entry = cache_data->first_queue_entry->qnext;
    if(!(e->key == NULL))
      cache->key_ops->free(e->key, cache_data->allocator);

    if(!(e->val == NULL))
    {
      if(e->val_size >= 1)
        cache_data->allocator->free(cache_data->allocator, e->val);

    }

    cache_data->allocator->free(cache_data->allocator, (void *)e);
    e = cache_data->first_queue_entry;
  }

  cache_data->allocator->free(cache_data->allocator, (void *)cache_data->hash_table);
  common_mutex_destroy(&cache_data->mtx);
  ci_mem_allocator_destroy(cache_data->allocator);
  free((void *)cache_data);
}

// ci_local_cache_init
// file cache.c line 135
signed int ci_local_cache_init(struct ci_cache *cache, const char *name)
{
  struct ci_local_cache_data *cache_data;
  signed int i;
  unsigned int new_hash_size;
  struct ci_mem_allocator *allocator;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_local_cache_data) /*128ul*/ );
  cache_data = (struct ci_local_cache_data *)return_value_malloc$1;
  if(cache_data == ((struct ci_local_cache_data *)NULL))
    return 0;

  else
  {
    cache->cache_data = (void *)cache_data;
    allocator=ci_create_os_allocator();
    if(allocator == ((struct ci_mem_allocator *)NULL))
    {
      free((void *)cache_data);
      return 0;
    }

    else
    {
      cache_data->allocator = allocator;
      void *return_value;
      return_value=allocator->alloc(allocator, sizeof(struct ci_cache_entry) /*56ul*/ );
      cache_data->first_queue_entry = (struct ci_cache_entry *)return_value;
      if(cache_data->first_queue_entry == ((struct ci_cache_entry *)NULL))
      {
        ci_mem_allocator_destroy(allocator);
        free((void *)cache_data);
        return 0;
      }

      else
      {
        cache_data->last_queue_entry = cache_data->first_queue_entry;
        cache_data->last_queue_entry->hnext = (struct ci_cache_entry *)(void *)0;
        cache_data->last_queue_entry->qnext = (struct ci_cache_entry *)(void *)0;
        cache_data->last_queue_entry->key = (void *)0;
        cache_data->last_queue_entry->val = (void *)0;
        cache_data->last_queue_entry->time = (signed long int)0;
        cache_data->last_queue_entry->hash = (unsigned int)0;
        unsigned int cache_items = (unsigned int)((unsigned long int)cache->mem_size / ((unsigned long int)cache->max_object_size + sizeof(struct ci_cache_entry) /*56ul*/ ));
        if(cache_items == 0u)
        {
          ci_mem_allocator_destroy(allocator);
          free((void *)cache_data);
          return 0;
        }

        else
        {
          i = 0;
          if(!((unsigned int)i >= cache_items + 4294967295u))
          {
            void *return_value_1;
            return_value_1=allocator->alloc(allocator, sizeof(struct ci_cache_entry) /*56ul*/ );
            cache_data->last_queue_entry->qnext = (struct ci_cache_entry *)return_value_1;
            if(cache_data->last_queue_entry->qnext == ((struct ci_cache_entry *)NULL))
            {
              ci_mem_allocator_destroy(allocator);
              return 0;
            }

            cache_data->last_queue_entry = cache_data->last_queue_entry->qnext;
            cache_data->last_queue_entry->hnext = (struct ci_cache_entry *)(void *)0;
            cache_data->last_queue_entry->qnext = (struct ci_cache_entry *)(void *)0;
            cache_data->last_queue_entry->key = (void *)0;
            cache_data->last_queue_entry->val = (void *)0;
            cache_data->last_queue_entry->time = (signed long int)0;
            cache_data->last_queue_entry->hash = (unsigned int)0;
            i = i + 1;
          }

          new_hash_size = (unsigned int)63;
          if(cache_items >= 64u)
          {
            if(!(new_hash_size >= 16777215u) && !(new_hash_size >= cache_items))
            {
              new_hash_size = new_hash_size + 1u;
              new_hash_size = (new_hash_size << 1) - (unsigned int)1;
            }

          }

          if(CI_DEBUG_LEVEL >= 7)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Hash size: %d\n", new_hash_size);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Hash size: %d\n", new_hash_size);

          }

          void *return_value_2;
          return_value_2=allocator->alloc(allocator, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_cache_entry *) /*8ul*/ );
          cache_data->hash_table = (struct ci_cache_entry **)return_value_2;
          if(cache_data->hash_table == ((struct ci_cache_entry **)NULL))
          {
            ci_mem_allocator_destroy(allocator);
            free((void *)cache);
            free((void *)cache_data);
            return 0;
          }

          else
          {
            memset((void *)cache_data->hash_table, 0, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_cache_entry *) /*8ul*/ );
            cache_data->hash_table_size = new_hash_size;
            common_mutex_init(&cache_data->mtx, 0);
            return 1;
          }
        }
      }
    }
  }
}

// ci_local_cache_search
// file cache.c line 238
const void * ci_local_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *))
{
  struct ci_cache_entry *e;
  struct ci_local_cache_data *cache_data;
  signed long int current_time;
  cache_data = (struct ci_local_cache_data *)cache->cache_data;
  unsigned int hash;
  unsigned long int return_value;
  return_value=cache->key_ops->size(key);
  hash=ci_hash_compute((unsigned long int)cache_data->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= cache_data->hash_table_size */
  assert(hash <= cache_data->hash_table_size);
  common_mutex_lock(&cache_data->mtx);
  e = cache_data->hash_table[(signed long int)hash];
  *val = (void *)0;
  if(!(e == ((struct ci_cache_entry *)NULL)))
  {
    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, " \t\t->>>>Val %s\n", (char *)e->val);

      if(!(CI_DEBUG_STDOUT == 0))
        printf(" \t\t->>>>Val %s\n", (char *)e->val);

    }

    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, " \t\t->>>>compare %s ~ %s\n", (char *)e->key, (char *)key);

      if(!(CI_DEBUG_STDOUT == 0))
        printf(" \t\t->>>>compare %s ~ %s\n", (char *)e->key, (char *)key);

    }

    signed int return_value_1;
    return_value_1=cache->key_ops->compare(e->key, key);
    if(return_value_1 == 0)
    {
      current_time=ci_internal_time();
      if(!(cache->ttl >= current_time + -e->time))
        key = (void *)0;

      else
        if(!(e->val_size == 0))
        {
          if(!(dup_from_cache == ((void * (*)(const void *, unsigned long int, void *))NULL)))
            *val=dup_from_cache(e->val, (unsigned long int)e->val_size, data);

          else
          {
            *val=ci_buffer_alloc(e->val_size);
            memcpy(*val, e->val, (unsigned long int)e->val_size);
          }
        }

      common_mutex_unlock(&cache_data->mtx);
      return key;
    }

    /* assertion e != e->hnext */
    assert(e != e->hnext);
    e = e->hnext;
  }

  common_mutex_unlock(&cache_data->mtx);
  return (void *)0;
}

// ci_local_cache_update
// file cache.c line 277
signed int ci_local_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int))
{
  struct ci_cache_entry *e;
  struct ci_cache_entry *tmp;
  signed int key_size;
  signed long int current_time;
  struct ci_local_cache_data *cache_data;
  unsigned int hash;
  cache_data = (struct ci_local_cache_data *)cache->cache_data;
  unsigned long int return_value;
  return_value=cache->key_ops->size(key);
  hash=ci_hash_compute((unsigned long int)cache_data->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= cache_data->hash_table_size */
  assert(hash <= cache_data->hash_table_size);
  if(CI_DEBUG_LEVEL >= 10)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Adding :%s:%p\n", (char *)key, (char *)val);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Adding :%s:%p\n", (char *)key, (char *)val);

  }

  current_time=ci_internal_time();
  common_mutex_lock(&cache_data->mtx);
  e = cache_data->first_queue_entry;
  if(!(current_time + -e->time >= cache->ttl))
  {
    if(CI_DEBUG_LEVEL >= 6)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_cache_update: not available slot (%d-%d %d).\n", (unsigned int)current_time, (unsigned int)e->time, (unsigned int)cache->ttl);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_cache_update: not available slot (%d-%d %d).\n", (unsigned int)current_time, (unsigned int)e->time, (unsigned int)cache->ttl);

    }

    common_mutex_unlock(&cache_data->mtx);
    return 0;
  }

  else
  {
    if(!(e->key == NULL))
    {
      cache->key_ops->free(e->key, cache_data->allocator);
      e->key = (void *)0;
    }

    if(!(e->val == NULL))
    {
      if(e->val_size >= 1)
      {
        cache_data->allocator->free(cache_data->allocator, e->val);
        e->val = (void *)0;
      }

    }

    /* assertion e->hash <= cache_data->hash_table_size */
    assert(e->hash <= cache_data->hash_table_size);
    tmp = cache_data->hash_table[(signed long int)e->hash];
    if(tmp == e)
      cache_data->hash_table[(signed long int)e->hash] = tmp->hnext;

    else
      if(!(tmp == ((struct ci_cache_entry *)NULL)))
      {
        if(!(tmp->hnext == ((struct ci_cache_entry *)NULL)))
        {
          if(!(e == tmp->hnext))
            tmp = tmp->hnext;

        }

        if(!(tmp->hnext == ((struct ci_cache_entry *)NULL)))
          tmp->hnext = tmp->hnext->hnext;

      }

    e->hnext = (struct ci_cache_entry *)(void *)0;
    e->time = (signed long int)0;
    e->hash = (unsigned int)0;
    unsigned long int return_value_1;
    return_value_1=cache->key_ops->size(key);
    key_size = (signed int)return_value_1;
    e->key=cache_data->allocator->alloc(cache_data->allocator, (unsigned long int)key_size);
    if(e->key == NULL)
    {
      common_mutex_unlock(&cache_data->mtx);
      if(CI_DEBUG_LEVEL >= 6)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_cache_update: failed to allocate memory for key.\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_cache_update: failed to allocate memory for key.\n");

      }

      return 0;
    }

    else
    {
      memcpy(e->key, key, (unsigned long int)key_size);
      if(val_size >= 1ul && !(val == NULL))
      {
        e->val=cache_data->allocator->alloc(cache_data->allocator, val_size);
        e->val_size = (signed int)val_size;
        if(!(e->val == NULL))
        {
          if(!(copy_to_cache == ((void * (*)(void *, const void *, unsigned long int))NULL)))
          {
            void *return_value_2;
            return_value_2=copy_to_cache(e->val, val, (unsigned long int)e->val_size);
            if(return_value_2 == NULL)
            {
              cache_data->allocator->free(cache_data->allocator, e->val);
              e->val = (void *)0;
            }

          }

          else
            memcpy(e->val, val, (unsigned long int)e->val_size);
        }

        if(e->val == NULL)
        {
          cache_data->allocator->free(cache_data->allocator, e->key);
          e->key = (void *)0;
          common_mutex_unlock(&cache_data->mtx);
          if(CI_DEBUG_LEVEL >= 6)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "ci_cache_update: failed to allocate memory for cache data.\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("ci_cache_update: failed to allocate memory for cache data.\n");

          }

          return 0;
        }

      }

      else
      {
        e->val = (void *)0;
        e->val_size = 0;
      }
      e->hash = hash;
      e->time = current_time;
      cache_data->first_queue_entry = cache_data->first_queue_entry->qnext;
      cache_data->last_queue_entry->qnext = e;
      cache_data->last_queue_entry = e;
      e->qnext = (struct ci_cache_entry *)(void *)0;
      if(!(cache_data->hash_table[(signed long int)hash] == ((struct ci_cache_entry *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 10)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "\t\t:::Found %s\n", (char *)cache_data->hash_table[(signed long int)hash]->val);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("\t\t:::Found %s\n", (char *)cache_data->hash_table[(signed long int)hash]->val);

        }

      }

      e->hnext = cache_data->hash_table[(signed long int)hash];
      cache_data->hash_table[(signed long int)hash] = e;
      common_mutex_unlock(&cache_data->mtx);
      return 1;
    }
  }
}

// ci_lookup_table_create
// file lookup_table.c line 144
struct ci_lookup_table * ci_lookup_table_create(const char *table)
{
  struct ci_mem_allocator *allocator;
  struct ci_lookup_table *lt;
  allocator=ci_create_os_allocator();
  if(allocator == ((struct ci_mem_allocator *)NULL))
    return (struct ci_lookup_table *)(void *)0;

  else
  {
    lt=ci_lookup_table_create_ext(table, &ci_str_ops, &ci_str_ops, allocator);
    if(lt == ((struct ci_lookup_table *)NULL))
      ci_mem_allocator_destroy(allocator);

    return lt;
  }
}

// ci_lookup_table_create_ext
// file lookup_table.c line 69
struct ci_lookup_table * ci_lookup_table_create_ext(const char *table, const struct ci_type_ops *key_ops, const struct ci_type_ops *val_ops, struct ci_mem_allocator *allocator)
{
  char *ttype;
  char *path;
  char *args;
  char *s;
  struct ci_lookup_table_type *lt_type;
  struct ci_lookup_table *lt;
  char *stable;
  stable=strdup(table);
  if(stable == ((char *)NULL))
    return (struct ci_lookup_table *)(void *)0;

  else
  {
    s=index(stable, 58);
    if(s == ((char *)NULL))
    {
      ttype = "file";
      path = stable;
      args = (char *)(void *)0;
    }

    else
    {
      ttype = stable;
      path = s + (signed long int)1;
      *s = (char)0;
      s=index(path, 123);
      if(!(s == ((char *)NULL)))
      {
        *s = (char)0;
        args = s + (signed long int)1;
        s=index(args, 125);
        if(!(s == ((char *)NULL)))
          *s = (char)0;

      }

      else
        args = (char *)(void *)0;
    }
    lt_type=ci_lookup_table_type_search(ttype);
    _Bool tmp_if_expr$1;
    if(lt_type == ((struct ci_lookup_table_type *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = !(lt_type->open != ((void * (*)(struct ci_lookup_table *))NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not lookuptable of type :%s!!!\n", ttype);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not lookuptable of type :%s!!!\n", ttype);

      }

      free((void *)stable);
      return (struct ci_lookup_table *)(void *)0;
    }

    else
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct ci_lookup_table) /*120ul*/ );
      lt = (struct ci_lookup_table *)return_value_malloc$2;
      if(lt == ((struct ci_lookup_table *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "memory allocation error!!");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("memory allocation error!!");

        }

        free((void *)stable);
        return (struct ci_lookup_table *)(void *)0;
      }

      else
      {
        lt->path=strdup(path);
        if(!(args == ((char *)NULL)))
          lt->args=strdup(args);

        else
          lt->args = (char *)(void *)0;
        free((void *)stable);
        lt->cols = -1;
        lt->key_ops = key_ops;
        lt->val_ops = val_ops;
        lt->type = lt_type->type;
        lt->open = lt_type->open;
        lt->close = lt_type->close;
        lt->search = lt_type->search;
        lt->get_row = lookup_table_get_row;
        lt->release_result = lt_type->release_result;
        lt->allocator = allocator;
        lt->_lt_type = lt_type;
        lt->data = (void *)0;
        return lt;
      }
    }
  }
}

// ci_lookup_table_destroy
// file lookup_table.c line 158
void ci_lookup_table_destroy(struct ci_lookup_table *lt)
{
  if(!(lt == ((struct ci_lookup_table *)NULL)))
  {
    lt->close(lt);
    free((void *)lt->path);
    if(!(lt->args == ((char *)NULL)))
      free((void *)lt->args);

    if(!(lt->allocator == ((struct ci_mem_allocator *)NULL)))
      ci_mem_allocator_destroy(lt->allocator);

    free((void *)lt);
  }

}

// ci_lookup_table_get_row
// file lookup_table.c line 228
const char * ci_lookup_table_get_row(struct ci_lookup_table *table, const char *key, const char **columns, char ***vals)
{
  _Bool tmp_if_expr$1;
  if(table->key_ops == &ci_str_ops)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = table->key_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = table->key_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!tmp_if_expr$2)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(table->val_ops == &ci_str_ops)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = table->val_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = table->val_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$5 = !tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s does not support search with string like keys!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s does not support search with string like keys!\n", table->type);

    }

    return (const char *)(void *)0;
  }

  else
  {
    const void *return_value_lookup_table_get_row$6;
    return_value_lookup_table_get_row$6=lookup_table_get_row(table, (const void *)key, columns, (void ***)vals);
    return (const char *)return_value_lookup_table_get_row$6;
  }
}

// ci_lookup_table_open
// file lookup_table.c line 172
void * ci_lookup_table_open(struct ci_lookup_table *table)
{
  _Bool tmp_if_expr$1;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(table->open != ((void * (*)(struct ci_lookup_table *))NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted (\"open\" method missing)!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted (\"open\" method missing)!\n", table->type);

    }

    return (void *)0;
  }

  else
  {
    void *return_value;
    return_value=table->open(table);
    return return_value;
  }
}

// ci_lookup_table_release_result
// file lookup_table.c line 196
void ci_lookup_table_release_result(struct ci_lookup_table *table, void **val)
{
  _Bool tmp_if_expr$1;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(table->release_result != ((void (*)(struct ci_lookup_table *, void **))NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted (\"release_result\" method missing)!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted (\"release_result\" method missing)!\n", table->type);

    }

  }

  else
    table->release_result(table, (void **)val);
}

// ci_lookup_table_search
// file lookup_table.c line 181
const char * ci_lookup_table_search(struct ci_lookup_table *table, const char *key, char ***vals)
{
  _Bool tmp_if_expr$1;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(table->search != ((void * (*)(struct ci_lookup_table *, void *, void ***))NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted (\"search\" method missing)!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted (\"search\" method missing)!\n", table->type);

    }

    return (const char *)(void *)0;
  }

  else
  {
    _Bool tmp_if_expr$2;
    if(table->key_ops == &ci_str_ops)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = table->key_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = table->key_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$6;
    if(!tmp_if_expr$3)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      if(table->val_ops == &ci_str_ops)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = table->val_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = table->val_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$6 = !tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "lookup_table of type  %s does not support search with string like keys!\n", table->type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("lookup_table of type  %s does not support search with string like keys!\n", table->type);

      }

      return (const char *)(void *)0;
    }

    else
    {
      void *return_value;
      return_value=table->search(table, (void *)key, (void ***)vals);
      return (const char *)return_value;
    }
  }
}

// ci_lookup_table_type_register
// file lookup_table.c line 36
struct ci_lookup_table_type * ci_lookup_table_type_register(struct ci_lookup_table_type *lt_type)
{
  if(lookup_tables_types_num >= 128)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "c-icap does not support more than 128 loookup table types");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("c-icap does not support more than 128 loookup table types");

    }

    return (struct ci_lookup_table_type *)(void *)0;
  }

  else
  {
    signed int tmp_post$1 = lookup_tables_types_num;
    lookup_tables_types_num = lookup_tables_types_num + 1;
    lookup_tables_types[(signed long int)tmp_post$1] = lt_type;
    return lt_type;
  }
}

// ci_lookup_table_type_search
// file lookup_table.c line 58
struct ci_lookup_table_type * ci_lookup_table_type_search(const char *type)
{
  signed int i = 0;
  for( ; !(i >= lookup_tables_types_num); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(type, lookup_tables_types[(signed long int)i]->type);
    if(return_value_strcmp$1 == 0)
      return lookup_tables_types[(signed long int)i];

  }
  return (struct ci_lookup_table_type *)(void *)0;
}

// ci_lookup_table_type_unregister
// file lookup_table.c line 46
void ci_lookup_table_type_unregister(struct ci_lookup_table_type *lt_type)
{
  signed int i = 0;
  for( ; !(lookup_tables_types[(signed long int)i] == lt_type) && !(i >= lookup_tables_types_num); i = i + 1)
    ;
  if(!(i >= lookup_tables_types_num))
  {
    lookup_tables_types_num = lookup_tables_types_num - 1;
    for( ; !(i >= lookup_tables_types_num); i = i + 1)
      lookup_tables_types[(signed long int)i] = lookup_tables_types[(signed long int)(i + 1)];
  }

}

// ci_magic_data_type
// file filetype.c line 711
signed int ci_magic_data_type(const char *buf, signed int len)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_ci_filetype$1;
    return_value_ci_filetype$1=ci_filetype(_MAGIC_DB, buf, len);
    return return_value_ci_filetype$1;
  }
}

// ci_magic_data_type_ext
// file filetype.c line 720
signed int ci_magic_data_type_ext(struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_extend_object_type$1;
    return_value_extend_object_type$1=extend_object_type(_MAGIC_DB, headers, buf, len, iscompressed);
    return return_value_extend_object_type$1;
  }
}

// ci_magic_db_free
// file filetype.c line 685
void ci_magic_db_free()
{
  if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
    ci_magics_db_release(_MAGIC_DB);

  _MAGIC_DB = (struct ci_magics_db *)(void *)0;
}

// ci_magic_db_load
// file filetype.c line 674
struct ci_magics_db * ci_magic_db_load(const char *filename)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
  {
    _MAGIC_DB=ci_magics_db_build(filename);
    return _MAGIC_DB;
  }

  else
  {
    signed int return_value_ci_magics_db_file_add$1;
    return_value_ci_magics_db_file_add$1=ci_magics_db_file_add(_MAGIC_DB, filename);
    if(!(return_value_ci_magics_db_file_add$1 == 0))
      return _MAGIC_DB;

    else
      return (struct ci_magics_db *)(void *)0;
  }
}

// ci_magic_group_check
// file filetype.c line 745
signed int ci_magic_group_check(signed int type, signed int group)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return 0;

  else
  {
    signed int return_value_ci_belongs_to_group$1;
    return_value_ci_belongs_to_group$1=ci_belongs_to_group(_MAGIC_DB, type, group);
    return return_value_ci_belongs_to_group$1;
  }
}

// ci_magic_group_id
// file filetype.c line 737
signed int ci_magic_group_id(const char *group)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_ci_get_data_group_id$1;
    return_value_ci_get_data_group_id$1=ci_get_data_group_id(_MAGIC_DB, group);
    return return_value_ci_get_data_group_id$1;
  }
}

// ci_magic_group_name
// file filetype.c line 783
char * ci_magic_group_name(signed int group)
{
  _Bool tmp_if_expr$2;
  signed int tmp_if_expr$1;
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL) || !(group >= 1))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$1 = _MAGIC_DB->groups_num;

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = group >= tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return (char *)(void *)0;

  else
  {
    _Bool tmp_if_expr$3;
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$3 = group < _MAGIC_DB->groups_num ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    char *tmp_if_expr$4;
    if(group >= 0 && tmp_if_expr$3)
      tmp_if_expr$4 = (_MAGIC_DB->groups + (signed long int)group)->name;

    else
      tmp_if_expr$4 = (char *)(void *)0;
    return tmp_if_expr$4;
  }
}

// ci_magic_groups_count
// file filetype.c line 760
signed int ci_magic_groups_count()
{
  signed int tmp_if_expr$1;
  if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
    tmp_if_expr$1 = _MAGIC_DB->groups_num;

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// ci_magic_req_data_type
// file filetype.c line 694
signed int ci_magic_req_data_type(struct ci_request *req, signed int *isencoded)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
    if(req->preview_data.used == 0)
      return -1;

    else
    {
      if(!(req->preview_data_type >= 0))
        req->preview_data_type=ci_extend_filetype(_MAGIC_DB, req, req->preview_data.buf, req->preview_data.used, isencoded);

      return req->preview_data_type;
    }
}

// ci_magic_type_descr
// file filetype.c line 774
char * ci_magic_type_descr(signed int type)
{
  _Bool tmp_if_expr$2;
  signed int tmp_if_expr$1;
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL) || !(type >= 1))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$1 = _MAGIC_DB->types_num;

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = type >= tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return (char *)(void *)0;

  else
  {
    _Bool tmp_if_expr$3;
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$3 = type < _MAGIC_DB->types_num ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    char *tmp_if_expr$4;
    if(type >= 0 && tmp_if_expr$3)
      tmp_if_expr$4 = (_MAGIC_DB->types + (signed long int)type)->descr;

    else
      tmp_if_expr$4 = (char *)(void *)0;
    return tmp_if_expr$4;
  }
}

// ci_magic_type_id
// file filetype.c line 729
signed int ci_magic_type_id(const char *name)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_ci_get_data_type_id$1;
    return_value_ci_get_data_type_id$1=ci_get_data_type_id(_MAGIC_DB, name);
    return return_value_ci_get_data_type_id$1;
  }
}

// ci_magic_type_name
// file filetype.c line 765
char * ci_magic_type_name(signed int type)
{
  _Bool tmp_if_expr$2;
  signed int tmp_if_expr$1;
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL) || !(type >= 1))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$1 = _MAGIC_DB->types_num;

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = type >= tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return (char *)(void *)0;

  else
  {
    char *tmp_if_expr$3;
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$3 = (_MAGIC_DB->types + (signed long int)type)->name;

    else
      tmp_if_expr$3 = (char *)(void *)0;
    return tmp_if_expr$3;
  }
}

// ci_magic_types_count
// file filetype.c line 754
signed int ci_magic_types_count()
{
  signed int tmp_if_expr$1;
  if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
    tmp_if_expr$1 = _MAGIC_DB->types_num;

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// ci_magics_db_build
// file filetype.c line 358
struct ci_magics_db * ci_magics_db_build(const char *filename)
{
  struct ci_magics_db *db;
  db=ci_magics_db_init();
  if(!(db == ((struct ci_magics_db *)NULL)))
    ci_magics_db_file_add(db, filename);

  return db;
}

// ci_magics_db_file_add
// file filetype.c line 302
signed int ci_magics_db_file_add(struct ci_magics_db *db, const char *filename)
{
  signed int type;
  signed int ret;
  signed int group;
  signed int i;
  signed int lineNum;
  signed int groups[65l];
  char line[32768l];
  struct ci_magic_record record;
  struct _IO_FILE *f;
  f=fopen64(filename, "r");
  char *return_value_fgets$1;
  if(f == ((struct _IO_FILE *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error opening magic file: %s\n", filename);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error opening magic file: %s\n", filename);

    }

    return 0;
  }

  else
  {
    lineNum = 0;
    ret = 0;
    do
    {
      return_value_fgets$1=fgets(line, 32768, f);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      lineNum = lineNum + 1;
      ret=parse_record(line, &record);
      if(!(ret == 0))
      {
        if(!(ret >= 0))
          break;

        type=ci_get_data_type_id(db, record.type);
        if(!(type >= 0))
        {
          i = 0;
          for( ; !(record.groups[(signed long int)i] == ((char *)NULL)); i = i + 1)
          {
            if(i >= 64)
              break;

            group=ci_get_data_group_id(db, record.groups[(signed long int)i]);
            if(!(group >= 0))
              group=groups_add(db, record.groups[(signed long int)i], "");

            groups[(signed long int)i] = group;
          }
          groups[(signed long int)i] = -1;
          type=types_add(db, record.type, record.descr, groups);
          if(!(type >= 0))
          {
            ret = -2;
            break;
          }

        }

        magics_add(db, record.offset, record.magic, record.len, (signed int)(unsigned int)type);
        free_records_group(&record);
      }

    }
    while((_Bool)1);
    fclose(f);
    if(!(ret >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error reading magic file (%d), line number: %d\nBuggy line: %s\n", ret, lineNum, (const void *)line);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error reading magic file (%d), line number: %d\nBuggy line: %s\n", ret, lineNum, (const void *)line);

      }

      return 0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "In database: magic: %d, types: %d, groups: %d\n", db->magics_num, db->types_num, db->groups_num);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("In database: magic: %d, types: %d, groups: %d\n", db->magics_num, db->types_num, db->groups_num);

      }

      return 1;
    }
  }
}

// ci_magics_db_init
// file filetype.c line 267
struct ci_magics_db * ci_magics_db_init()
{
  struct ci_magics_db *db;
  signed int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_magics_db) /*48ul*/ );
  db = (struct ci_magics_db *)return_value_malloc$1;
  if(db == ((struct ci_magics_db *)NULL))
    return (struct ci_magics_db *)(void *)0;

  else
  {
    types_init(db);
    groups_init(db);
    magics_init(db);
    i = 0;
    for( ; !((signed int)predefined_types[(signed long int)i].name[0l] == 0); i = i + 1)
      types_add(db, predefined_types[(signed long int)i].name, predefined_types[(signed long int)i].descr, predefined_types[(signed long int)i].groups);
    i = 0;
    for( ; !((signed int)predefined_groups[(signed long int)i].name[0l] == 0); i = i + 1)
      groups_add(db, predefined_groups[(signed long int)i].name, predefined_groups[(signed long int)i].descr);
    return db;
  }
}

// ci_magics_db_release
// file filetype.c line 294
void ci_magics_db_release(struct ci_magics_db *db)
{
  free((void *)db->types);
  free((void *)db->groups);
  free((void *)db->magics);
  free((void *)db);
}

// ci_mem_allocator_destroy
// file mem.c line 62
void ci_mem_allocator_destroy(struct ci_mem_allocator *allocator)
{
  allocator->destroy(allocator);
  if(allocator->must_free == 1)
    free((void *)allocator);

  else
    if(allocator->must_free == 2)
      ci_object_pool_free((void *)allocator);

}

// ci_membuf_attr_add
// file body.c line 244
signed int ci_membuf_attr_add(struct ci_membuf *body, const char *attr, const void *val, unsigned long int val_size)
{
  if(body->attributes == ((struct ci_array *)NULL))
    body->attributes=ci_array_new((unsigned long int)1024);

  const struct ci_array_item *return_value_ci_array_add$1;
  if(!(body->attributes == ((struct ci_array *)NULL)))
  {
    return_value_ci_array_add$1=ci_array_add(body->attributes, attr, val, val_size);
    return (signed int)(return_value_ci_array_add$1 != (const struct ci_array_item *)(void *)0);
  }

  return 0;
}

// ci_membuf_attr_get
// file body.c line 256
const void * ci_membuf_attr_get(struct ci_membuf *body, const char *attr)
{
  const void *return_value_ci_array_search$1;
  if(!(body->attributes == ((struct ci_array *)NULL)))
  {
    return_value_ci_array_search$1=ci_array_search(body->attributes, attr);
    return return_value_ci_array_search$1;
  }

  return (void *)0;
}

// ci_membuf_free
// file body.c line 147
void ci_membuf_free(struct ci_membuf *b)
{
  if(!(b == ((struct ci_membuf *)NULL)))
  {
    if(!(b->buf == ((char *)NULL)))
    {
      if((16u & b->flags) == 0u)
        ci_buffer_free((void *)b->buf);

    }

    if(!(b->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(b->attributes);

    ci_object_pool_free((void *)b);
  }

}

// ci_membuf_from_content
// file body.c line 108
struct ci_membuf * ci_membuf_from_content(char *buf, unsigned long int buf_size, unsigned long int content_size, unsigned int flags)
{
  struct ci_membuf *b;
  if(buf == ((char *)NULL) || !(buf_size >= 1ul) || !(buf_size >= content_size))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_membuf_from_content: Wrong arguments: %p, of size=%u and content size=%u\n", buf, (unsigned int)buf_size, (unsigned int)content_size);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_membuf_from_content: Wrong arguments: %p, of size=%u and content size=%u\n", buf, (unsigned int)buf_size, (unsigned int)content_size);

    }

    return (struct ci_membuf *)(void *)0;
  }

  else
    if(!((15u & flags) == flags))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_membuf_from_content: Wrong flags: %u\n", flags);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_membuf_from_content: Wrong flags: %u\n", flags);

      }

      return (struct ci_membuf *)(void *)0;
    }

    else
    {
      if(!((1u & flags) == 0u))
      {
        if((signed int)buf[-1l + (signed long int)content_size] == 0)
          content_size = content_size - 1ul;

        else
        {
          _Bool tmp_if_expr$1;
          if(content_size >= buf_size)
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = (signed int)buf[(signed long int)content_size] != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "ci_membuf_from_content: content is not NULL terminated!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("ci_membuf_from_content: content is not NULL terminated!\n");

            }

            return (struct ci_membuf *)(void *)0;
          }

        }
      }

      void *return_value_ci_object_pool_alloc$2;
      return_value_ci_object_pool_alloc$2=ci_object_pool_alloc(MEMBUF_POOL);
      b = (struct ci_membuf *)return_value_ci_object_pool_alloc$2;
      if(b == ((struct ci_membuf *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "ci_membuf_from_content: memory allocation failed\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("ci_membuf_from_content: memory allocation failed\n");

        }

        return (struct ci_membuf *)(void *)0;
      }

      else
      {
        b->flags = (unsigned int)0x10 | flags;
        b->endpos = (signed int)content_size;
        b->readpos = 0;
        b->buf = buf;
        b->bufsize = (signed int)buf_size;
        b->unlocked = -1;
        b->attributes = (struct ci_array *)(void *)0;
        return b;
      }
    }
}

// ci_membuf_new
// file body.c line 82
struct ci_membuf * ci_membuf_new()
{
  struct ci_membuf *return_value_ci_membuf_new_sized$1;
  return_value_ci_membuf_new_sized$1=ci_membuf_new_sized(8192);
  return return_value_ci_membuf_new_sized$1;
}

// ci_membuf_new_sized
// file body.c line 87
struct ci_membuf * ci_membuf_new_sized(signed int size)
{
  struct ci_membuf *b;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(MEMBUF_POOL);
  b = (struct ci_membuf *)return_value_ci_object_pool_alloc$1;
  if(b == ((struct ci_membuf *)NULL))
    return (struct ci_membuf *)(void *)0;

  else
  {
    b->endpos = 0;
    b->readpos = 0;
    b->flags = (unsigned int)0;
    void *return_value_ci_buffer_alloc$2;
    return_value_ci_buffer_alloc$2=ci_buffer_alloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
    b->buf = (char *)return_value_ci_buffer_alloc$2;
    if(b->buf == ((char *)NULL))
    {
      ci_object_pool_free((void *)b);
      return (struct ci_membuf *)(void *)0;
    }

    else
    {
      b->bufsize = size;
      b->unlocked = -1;
      b->attributes = (struct ci_array *)(void *)0;
      return b;
    }
  }
}

// ci_membuf_read
// file body.c line 225
signed int ci_membuf_read(struct ci_membuf *b, char *data, signed int len)
{
  signed int remains;
  signed int copybytes;
  if(b->unlocked >= 0)
    remains = b->unlocked - b->readpos;

  else
    remains = b->endpos - b->readpos;
  if(remains == 0)
  {
    if((2u & b->flags) == 0u)
      goto __CPROVER_DUMP_L3;

    return -2;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    copybytes = len <= remains ? len : remains;
    if(!(copybytes == 0))
    {
      memcpy((void *)data, (const void *)(b->buf + (signed long int)b->readpos), (unsigned long int)copybytes);
      b->readpos = b->readpos + copybytes;
    }

    return copybytes;
  }
}

// ci_membuf_set_flag
// file body.c line 158
unsigned int ci_membuf_set_flag(struct ci_membuf *body, unsigned int flag)
{
  if((5u & flag) == 0u)
    return (unsigned int)0;

  else
  {
    body->flags = body->flags | flag;
    return body->flags;
  }
}

// ci_membuf_truncate
// file body.c line 263
signed int ci_membuf_truncate(struct ci_membuf *body, signed int new_size)
{
  if(!(body->endpos >= new_size))
    return 0;

  else
  {
    body->endpos = new_size;
    if(!((1u & body->flags) == 0u))
      body->buf[(signed long int)body->endpos] = (char)0;

    if(!(body->endpos >= body->readpos))
      body->readpos = body->endpos;

    if(!(body->endpos >= body->unlocked))
      body->unlocked = body->endpos;

    return 1;
  }
}

// ci_membuf_write
// file body.c line 167
signed int ci_membuf_write(struct ci_membuf *b, const char *data, signed int len, signed int iseof)
{
  signed int remains;
  signed int newsize;
  char *newbuf;
  signed int terminate = (signed int)(b->flags & (unsigned int)0x01);
  _Bool tmp_if_expr$1;
  if(!((4u & b->flags) == 0u))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (b->flags & (unsigned int)0x08) != 0u ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_membuf_write: can not write: buffer is read-only!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_membuf_write: can not write: buffer is read-only!\n");

    }

    return 0;
  }

  else
    if(!((2u & b->flags) == 0u))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Cannot write to membuf: the eof flag is set!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Cannot write to membuf: the eof flag is set!\n");

      }

      return 0;
    }

    else
    {
      if(!(iseof == 0))
        b->flags = b->flags | (unsigned int)0x02;

      remains = (b->bufsize - b->endpos) - (terminate != 0 ? 1 : 0);
      /* assertion remains >= -1 */
      assert(remains >= -1);
      while(!(remains >= len))
      {
        newsize = b->bufsize + 4096;
        void *return_value_ci_buffer_realloc$2;
        return_value_ci_buffer_realloc$2=ci_buffer_realloc((void *)b->buf, newsize);
        newbuf = (char *)return_value_ci_buffer_realloc$2;
        if(newbuf == ((char *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "ci_membuf_write: Failed to grow membuf for new data!\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("ci_membuf_write: Failed to grow membuf for new data!\n");

          }

          if(remains >= 0)
          {
            if(!(remains == 0))
              memcpy((void *)(b->buf + (signed long int)b->endpos), (const void *)data, (unsigned long int)remains);

            if(!(terminate == 0))
            {
              b->endpos = b->bufsize - 1;
              b->buf[(signed long int)b->endpos] = (char)0;
            }

            else
              b->endpos = b->bufsize;
          }

          else
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "ci_membuf_write: Failed to NULL terminate membuf!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("ci_membuf_write: Failed to NULL terminate membuf!\n");

            }

          return remains;
        }

        b->buf = newbuf;
        b->bufsize = newsize;
        remains = (b->bufsize - b->endpos) - (terminate != 0 ? 1 : 0);
      }
      if(!(len == 0))
      {
        memcpy((void *)(b->buf + (signed long int)b->endpos), (const void *)data, (unsigned long int)len);
        b->endpos = b->endpos + len;
      }

      if(!(terminate == 0))
        b->buf[(signed long int)b->endpos] = (char)0;

      return len;
    }
}

// ci_mktemp_file
// file include/util.h line 34
signed int ci_mktemp_file(char *dir, char *template, char *filename)
{
  snprintf(filename, (unsigned long int)4096, "%s%s", dir, template);
  filename[(signed long int)(4096 - 1)] = (char)0;
  signed int return_value_mkstemp64$1;
  return_value_mkstemp64$1=mkstemp64(filename);
  return return_value_mkstemp64$1;
}

// ci_module_load
// file ../include/dlib.h line 40
void * ci_module_load(const char *module_file, const char *default_path)
{
  char path[4096l];
  void *handle;
  signed int len;
  if(!((signed int)*module_file == 47))
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(default_path);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(module_file);
    len = (signed int)(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)1);
    if(len >= 4096)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Path name len of %s+%s is greater than MAXPATH:%d, not loading\n", default_path, module_file, 4096);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Path name len of %s+%s is greater than MAXPATH:%d, not loading\n", default_path, module_file, 4096);

      }

      return (void *)0;
    }

    strcpy(path, default_path);
    strcat(path, "/");
    strcat(path, module_file);
  }

  else
    strncpy(path, module_file, (unsigned long int)(4096 - 1));
  path[(signed long int)(4096 - 1)] = (char)0;
  handle=dlopen(path, 0x00002 | 0x00100);
  if(handle == NULL)
  {
    char *error_str;
    error_str=dlerror();
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error loading module %s:%s\n", module_file, error_str);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error loading module %s:%s\n", module_file, error_str);

    }

    return (void *)0;
  }

  return handle;
}

// ci_module_sym
// file ../include/dlib.h line 41
void * ci_module_sym(void *handle, const char *symbol)
{
  void *return_value_dlsym$1;
  return_value_dlsym$1=dlsym(handle, symbol);
  return return_value_dlsym$1;
}

// ci_module_unload
// file os/unix/dlib.c line 65
signed int ci_module_unload(void *handle, const char *name)
{
  signed int ret;
  ret=dlclose(handle);
  if(ret == 1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error unloading module:%s\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error unloading module:%s\n", name);

    }

    return 0;
  }

  else
    return 1;
}

// ci_netio_init
// file include/net_io.h line 149
signed int ci_netio_init(signed int fd)
{
  fcntl(fd, 4, 04000);
  return 1;
}

// ci_object_pool_alloc
// file include/mem.h line 73
void * ci_object_pool_alloc(signed int id)
{
  struct mem_buffer_block *block = (struct mem_buffer_block *)(void *)0;
  _Bool tmp_if_expr$1;
  if(id >= object_pools_used || !(id >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(object_pools[(signed long int)id] != ((struct ci_mem_allocator *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Invalid object pool %d. This is a BUG!\n", id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Invalid object pool %d. This is a BUG!\n", id);

    }

    return (void *)0;
  }

  else
  {
    void *return_value;
    return_value=object_pools[(signed long int)id]->alloc(object_pools[(signed long int)id], (unsigned long int)1);
    block = (struct mem_buffer_block *)return_value;
    if(block == ((struct mem_buffer_block *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Failed to allocate object from pool %d\n", id);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Failed to allocate object from pool %d\n", id);

      }

      return (void *)0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Allocating from objects pool object %d\n", id);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Allocating from objects pool object %d\n", id);

      }

      block->sig = (unsigned short int)0x55AA;
      block->ID = id;
      return (void *)block->data.ptr;
    }
  }
}

// ci_object_pool_free
// file include/mem.h line 74
void ci_object_pool_free(void *ptr)
{
  struct mem_buffer_block *block = (struct mem_buffer_block *)(ptr - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  if(!((signed int)block->sig == 0x55AA))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_object_pool_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", ptr);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_object_pool_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", ptr);

    }

  }

  else
  {
    _Bool tmp_if_expr$1;
    if(!(object_pools_used >= block->ID))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = block->ID < 0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = !(object_pools[(signed long int)block->ID] != ((struct ci_mem_allocator *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_object_pool_free: ERROR, %p is pointing to corrupted mem? This is a bug!!!!\n", ptr);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_object_pool_free: ERROR, %p is pointing to corrupted mem? This is a bug!!!!\n", ptr);

      }

    }

    else
    {
      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Storing to objects pool object %d\n", block->ID);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Storing to objects pool object %d\n", block->ID);

      }

      object_pools[(signed long int)block->ID]->free(object_pools[(signed long int)block->ID], (void *)block);
    }
  }
}

// ci_object_pool_register
// file include/mem.h line 71
signed int ci_object_pool_register(const char *name, signed int size)
{
  signed int ID;
  signed int i;
  ID = -1;
  if(object_pools == ((struct ci_mem_allocator **)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)128 * sizeof(struct ci_mem_allocator *) /*8ul*/ );
    object_pools = (struct ci_mem_allocator **)return_value_malloc$1;
    object_pools_size = 128;
    ID = 0;
  }

  else
  {
    i = 0;
    for( ; !(i >= object_pools_used); i = i + 1)
      if(object_pools[(signed long int)i] == ((struct ci_mem_allocator *)NULL))
      {
        ID = i;
        break;
      }

    if(ID == -1)
    {
      if(object_pools_size == object_pools_used)
      {
        object_pools_size = object_pools_size + 128;
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)object_pools, (unsigned long int)object_pools_size * sizeof(struct ci_mem_allocator *) /*8ul*/ );
        object_pools = (struct ci_mem_allocator **)return_value_realloc$2;
      }

      ID = object_pools_used;
    }

  }
  if(object_pools == ((struct ci_mem_allocator **)NULL))
    return -1;

  else
  {
    object_pools[(signed long int)ID]=ci_create_pool_allocator((signed int)((unsigned long int)size + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
    object_pools_used = object_pools_used + 1;
    return ID;
  }
}

// ci_object_pool_unregister
// file include/mem.h line 72
void ci_object_pool_unregister(signed int id)
{
  if(!(id >= object_pools_used) && id >= 0)
  {
    if(!(object_pools[(signed long int)id] == ((struct ci_mem_allocator *)NULL)))
    {
      ci_mem_allocator_destroy(object_pools[(signed long int)id]);
      object_pools[(signed long int)id] = (struct ci_mem_allocator *)(void *)0;
    }

  }

}

// ci_object_pools_destroy
// file mem.c line 310
void ci_object_pools_destroy()
{
  signed int i = 0;
  for( ; !(i >= object_pools_used); i = i + 1)
    if(!(object_pools[(signed long int)i] == ((struct ci_mem_allocator *)NULL)))
      ci_mem_allocator_destroy(object_pools[(signed long int)i]);

}

// ci_object_pools_init
// file mem.c line 305
signed int ci_object_pools_init()
{
  return 1;
}

// ci_pack_allocator_alloc
// file mem.c line 604
void * ci_pack_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  size = size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1);
  void *return_value_ci_pack_allocator_alloc_unaligned$1;
  return_value_ci_pack_allocator_alloc_unaligned$1=ci_pack_allocator_alloc_unaligned(allocator, size);
  return return_value_ci_pack_allocator_alloc_unaligned$1;
}

// ci_pack_allocator_alloc_from_rear
// file mem.c line 610
void * ci_pack_allocator_alloc_from_rear(struct ci_mem_allocator *allocator, signed int size)
{
  signed int max_size;
  void *mem;
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  if(pack_alloc == ((struct pack_allocator *)NULL))
    return (void *)0;

  else
  {
    size = (signed int)((unsigned long int)size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    max_size = (signed int)(pack_alloc->endpos - pack_alloc->curpos);
    if(!(max_size >= size))
      return (void *)0;

    else
    {
      pack_alloc->endpos = pack_alloc->endpos - (signed long int)size;
      mem = pack_alloc->endpos;
      return mem;
    }
  }
}

// ci_pack_allocator_alloc_unaligned
// file mem.c line 582
void * ci_pack_allocator_alloc_unaligned(struct ci_mem_allocator *allocator, unsigned long int size)
{
  signed int max_size;
  void *mem;
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  if(pack_alloc == ((struct pack_allocator *)NULL))
    return (void *)0;

  else
  {
    max_size = (signed int)(pack_alloc->endpos - pack_alloc->curpos);
    if(!((unsigned long int)max_size >= size))
      return (void *)0;

    else
    {
      mem = pack_alloc->curpos;
      pack_alloc->curpos = pack_alloc->curpos + (signed long int)size;
      return mem;
    }
  }
}

// ci_pack_allocator_data_size
// file mem.c line 722
signed int ci_pack_allocator_data_size(struct ci_mem_allocator *allocator)
{
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  struct pack_allocator *pack_alloc = (struct pack_allocator *)allocator->data;
  return (signed int)((signed long int)(signed int)(pack_alloc->curpos - pack_alloc->memchunk) + (pack_alloc->end - pack_alloc->endpos));
}

// ci_pack_allocator_destroy
// file mem.c line 647
void ci_pack_allocator_destroy(struct ci_mem_allocator *allocator)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  if(!(pack_alloc->must_free == 0))
  {
    ci_object_pool_free(allocator->data);
    allocator->data = (void *)0;
  }

}

// ci_pack_allocator_free
// file mem.c line 633
void ci_pack_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  ;
}

// ci_pack_allocator_required_size
// file mem.c line 730
unsigned long int ci_pack_allocator_required_size()
{
  return (sizeof(struct pack_allocator) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
}

// ci_pack_allocator_reset
// file mem.c line 638
void ci_pack_allocator_reset(struct ci_mem_allocator *allocator)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  pack_alloc->curpos = pack_alloc->memchunk;
  pack_alloc->endpos = pack_alloc->end;
}

// ci_pack_allocator_set_end_pos
// file mem.c line 746
void ci_pack_allocator_set_end_pos(struct ci_mem_allocator *allocator, void *p)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  /* assertion p <= pack_alloc->end */
  assert(p <= pack_alloc->end);
  if(p == NULL)
    pack_alloc->endpos = pack_alloc->end;

  else
    pack_alloc->endpos = p;
}

// ci_pack_allocator_set_start_pos
// file mem.c line 737
void ci_pack_allocator_set_start_pos(struct ci_mem_allocator *allocator, void *p)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  /* assertion p >= pack_alloc->memchunk */
  assert(p >= pack_alloc->memchunk);
  pack_alloc->curpos = p;
}

// ci_parse_key_value_list
// file util.c line 163
struct ci_dyn_array * ci_parse_key_value_list(const char *str, char sep)
{
  char *s;
  char *e;
  char *k;
  char *v;
  struct ci_dyn_array *args_array;
  s=strdup(str);
  unsigned long int return_value_strlen$1;
  if(s == ((char *)NULL))
    return (struct ci_dyn_array *)(void *)0;

  else
  {
    args_array=ci_dyn_array_new((unsigned long int)1024);
    k = s;
    while(!(k == ((char *)NULL)))
    {
      e=strchr(k, (signed int)sep);
      if(!(e == ((char *)NULL)))
      {
        *e = (char)0;
        e = e + 1l;
      }

      v=strchr(k, 61);
      if(!(v == ((char *)NULL)))
      {
        *v = (char)0;
        v = v + 1l;
      }

      k=ci_str_trim2(k);
      if(!(v == ((char *)NULL)))
        v=ci_str_trim2(v);

      if(!(*k == 0))
      {
        unsigned long int tmp_if_expr$2;
        if(!(v == ((char *)NULL)))
        {
          return_value_strlen$1=strlen(v);
          tmp_if_expr$2 = return_value_strlen$1 + (unsigned long int)1;
        }

        else
          tmp_if_expr$2 = (unsigned long int)1;
        ci_dyn_array_add(args_array, k, (const void *)(v != ((char *)NULL) ? v : ""), tmp_if_expr$2);
      }

      _Bool tmp_if_expr$3;
      if(!(e == ((char *)NULL)))
        tmp_if_expr$3 = *e != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      k = tmp_if_expr$3 ? e : (char *)(void *)0;
    }
    return args_array;
  }
}

// ci_proc_mutex_default_scheme
// file os/unix/proc_mutex.c line 254
const struct ci_proc_mutex_scheme * ci_proc_mutex_default_scheme()
{
  return default_mutex_scheme;
}

// ci_proc_mutex_destroy
// file os/unix/proc_mutex.c line 292
signed int ci_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  signed int return_value;
  if(!(mutex->scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    return_value=mutex->scheme->proc_mutex_destroy(mutex);
    return return_value;
  }

  return 0;
}

// ci_proc_mutex_init
// file os/unix/proc_mutex.c line 283
signed int ci_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  if(!(default_mutex_scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    mutex->scheme = default_mutex_scheme;
    signed int return_value;
    return_value=default_mutex_scheme->proc_mutex_init(mutex, name);
    return return_value;
  }

  return 0;
}

// ci_proc_mutex_lock
// file os/unix/proc_mutex.c line 299
signed int ci_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  signed int return_value;
  if(!(mutex->scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    return_value=mutex->scheme->proc_mutex_lock(mutex);
    return return_value;
  }

  return 0;
}

// ci_proc_mutex_set_scheme
// file os/unix/proc_mutex.c line 259
signed int ci_proc_mutex_set_scheme(const char *scheme)
{
  signed int return_value_strcasecmp$3;
  return_value_strcasecmp$3=strcasecmp(scheme, "sysv");
  signed int return_value_strcasecmp$2;
  signed int return_value_strcasecmp$1;
  if(return_value_strcasecmp$3 == 0)
    default_mutex_scheme = &sysv_mutex_scheme;

  else
  {
    return_value_strcasecmp$2=strcasecmp(scheme, "posix");
    if(return_value_strcasecmp$2 == 0)
      default_mutex_scheme = &posix_mutex_scheme;

    else
    {
      return_value_strcasecmp$1=strcasecmp(scheme, "file");
      if(return_value_strcasecmp$1 == 0)
        default_mutex_scheme = &file_mutex_scheme;

      else
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Unknown interprocess locking scheme: '%s'", scheme);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Unknown interprocess locking scheme: '%s'", scheme);

        }

        return 0;
      }
    }
  }
  return 1;
}

// ci_proc_mutex_unlock
// file os/unix/proc_mutex.c line 306
signed int ci_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  signed int return_value;
  if(!(mutex->scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    return_value=mutex->scheme->proc_mutex_unlock(mutex);
    return return_value;
  }

  return 0;
}

// ci_ptr_array_add
// file array.c line 165
const struct ci_array_item * ci_ptr_array_add(struct ci_array *ptr_array, const char *name, void *value)
{
  struct ci_array_item *item;
  struct ci_mem_allocator *packer = ptr_array->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value_ci_pack_allocator_alloc_unaligned$1;
  return_value_ci_pack_allocator_alloc_unaligned$1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((struct ci_array_item *)0)[(signed long int)1]);
  item = (struct ci_array_item *)return_value_ci_pack_allocator_alloc_unaligned$1;
  unsigned long int return_value_strlen$2;
  void *return_value_ci_pack_allocator_alloc_from_rear$3;
  if(!(item == ((struct ci_array_item *)NULL)))
  {
    return_value_strlen$2=strlen(name);
    return_value_ci_pack_allocator_alloc_from_rear$3=ci_pack_allocator_alloc_from_rear(packer, (signed int)(return_value_strlen$2 + (unsigned long int)1));
    item->name = (char *)return_value_ci_pack_allocator_alloc_from_rear$3;
  }

  _Bool tmp_if_expr$4;
  if(item == ((struct ci_array_item *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = !(item->name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item to array!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item to array!\n");

    }

    return (const struct ci_array_item *)(void *)0;
  }

  else
  {
    strcpy(item->name, name);
    item->value = value;
    if(ptr_array->items == ((struct ci_array_item *)NULL))
      ptr_array->items = item;

    ptr_array->count = ptr_array->count + 1u;
    return item;
  }
}

// ci_ptr_array_new2
// file array.c line 151
struct ci_array * ci_ptr_array_new2(unsigned long int items)
{
  unsigned long int array_size;
  unsigned long int return_value_ci_pack_allocator_required_size$1;
  return_value_ci_pack_allocator_required_size$1=ci_pack_allocator_required_size();
  array_size = return_value_ci_pack_allocator_required_size$1 + (sizeof(struct ci_array) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + items * ((sizeof(void *) /*8ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_array_item) /*16ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  struct ci_array *return_value_ci_array_new$2;
  return_value_ci_array_new$2=ci_array_new(array_size);
  return return_value_ci_array_new$2;
}

// ci_ptr_array_pop
// file array.c line 189
const struct ci_array_item * ci_ptr_array_pop(struct ci_array *ptr_array)
{
  struct ci_array_item *item;
  if(ptr_array->count == 0u)
    return (const struct ci_array_item *)(void *)0;

  else
  {
    item = &ptr_array->items[(signed long int)(ptr_array->count - (unsigned int)1)];
    ci_pack_allocator_set_start_pos(ptr_array->alloc, (void *)item);
    ptr_array->count = ptr_array->count - 1u;
    return item;
  }
}

// ci_ptr_array_pop_value
// file array.c line 200
void * ci_ptr_array_pop_value(struct ci_array *ptr_array, char *name, unsigned long int name_size)
{
  const struct ci_array_item *item;
  item=ci_ptr_array_pop(ptr_array);
  if(item == ((const struct ci_array_item *)NULL))
    return (void *)0;

  else
  {
    strncpy(name, item->name, name_size);
    name[(signed long int)(name_size - (unsigned long int)1)] = (char)0;
    return item->value;
  }
}

// ci_ptr_array_search
// file array.c line 160
void * ci_ptr_array_search(struct ci_array *array, const char *name)
{
  const void *return_value_ci_array_search$1;
  return_value_ci_array_search$1=ci_array_search(array, name);
  return (void *)return_value_ci_array_search$1;
}

// ci_ptr_dyn_array_add
// file array.c line 336
const struct ci_array_item * ci_ptr_dyn_array_add(struct ci_dyn_array *array, const char *name, void *value)
{
  const struct ci_array_item *return_value_ci_dyn_array_add$1;
  return_value_ci_dyn_array_add$1=ci_dyn_array_add(array, name, value, (unsigned long int)0);
  return return_value_ci_dyn_array_add$1;
}

// ci_ptr_vector_add
// file array.c line 479
void * ci_ptr_vector_add(struct ci_vector *vector, void *value)
{
  void **indx;
  struct ci_mem_allocator *packer = vector->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  if(value == NULL)
    return (void *)0;

  else
  {
    void *return_value_ci_pack_allocator_alloc_unaligned$1;
    return_value_ci_pack_allocator_alloc_unaligned$1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((void **)0)[(signed long int)1]);
    indx = (void **)return_value_ci_pack_allocator_alloc_unaligned$1;
    if(indx == ((void **)NULL))
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not enough space to add the new item to ptr_vector!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not enough space to add the new item to ptr_vector!\n");

      }

      return (void *)0;
    }

    else
    {
      *vector->last = value;
      vector->last = indx;
      *vector->last = (void *)0;
      vector->count = vector->count + 1;
      return value;
    }
  }
}

// ci_read
// file os/unix/net_io.c line 253
signed int ci_read(signed int fd, void *buf, unsigned long int count, signed int timeout)
{
  signed int bytes = 0;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    signed long int return_value_read$3;
    return_value_read$3=read(fd, buf, count);
    bytes = (signed int)return_value_read$3;
    if(bytes == -1)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  signed int *return_value___errno_location$8;
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  if(bytes == -1)
  {
    return_value___errno_location$8=__errno_location();
    if(*return_value___errno_location$8 == 11)
    {
      signed int return_value_ci_wait_for_data$4;
      return_value_ci_wait_for_data$4=ci_wait_for_data(fd, timeout, 0x1);
      if(return_value_ci_wait_for_data$4 == 0)
        return bytes;

      do
      {
        signed long int return_value_read$7;
        return_value_read$7=read(fd, buf, count);
        bytes = (signed int)return_value_read$7;
        if(bytes == -1)
        {
          return_value___errno_location$5=__errno_location();
          tmp_if_expr$6 = *return_value___errno_location$5 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
      }
      while(tmp_if_expr$6);
    }

  }

  if(bytes == 0)
    return -1;

  else
    return bytes;
}

// ci_read_nonblock
// file include/net_io.h line 152
signed int ci_read_nonblock(signed int fd, void *buf, unsigned long int count)
{
  signed int bytes = 0;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    signed long int return_value_read$3;
    return_value_read$3=read(fd, buf, count);
    bytes = (signed int)return_value_read$3;
    if(bytes == -1)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  signed int *return_value___errno_location$4;
  if(!(bytes >= 0))
  {
    return_value___errno_location$4=__errno_location();
    if(*return_value___errno_location$4 == 11)
      return 0;

  }

  return bytes;
}

// ci_regex_apply
// file include/ci_regex.h line 46
signed int ci_regex_apply(void * const regex, const char *str, signed int len, signed int recurs, struct ci_list *matches, const void *user_data)
{
  signed int count = 0;
  signed int i;
  struct ci_regex_replace_part parts;
  unsigned long int return_value_strlen$1;
  _Bool tmp_if_expr$3;
  if(str == ((const char *)NULL))
    return 0;

  else
  {
    signed int ovector[30l];
    signed int rc;
    signed int offset = 0;
    signed int str_length;
    unsigned long int tmp_if_expr$2;
    if(len >= 0)
      tmp_if_expr$2 = (unsigned long int)len;

    else
    {
      return_value_strlen$1=strlen(str);
      tmp_if_expr$2 = return_value_strlen$1;
    }
    str_length = (signed int)tmp_if_expr$2;
    do
    {
      memset((void *)ovector, 0, sizeof(signed int [30l]) /*120ul*/ );
      rc=pcre_exec((const struct real_pcre *)regex, (const struct pcre_extra *)(void *)0, str, str_length, offset, 0, ovector, 30);
      if(rc >= 0)
      {
        if(!(ovector[0l] == ovector[1l]))
        {
          count = count + 1;
          if(CI_DEBUG_LEVEL >= 9)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)0], ovector[(signed long int)1], ovector[(signed long int)1] - ovector[(signed long int)0], str + (signed long int)ovector[(signed long int)0]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)0], ovector[(signed long int)1], ovector[(signed long int)1] - ovector[(signed long int)0], str + (signed long int)ovector[(signed long int)0]);

          }

          offset = ovector[(signed long int)1];
          if(!(matches == ((struct ci_list *)NULL)))
          {
            parts.user_data = user_data;
            memset((void *)parts.matches, 0, sizeof(struct ci_regex_match [10l]) /*160ul*/ );
            i = 0;
            do
            {
              if(!(i >= 10))
                tmp_if_expr$3 = ovector[(signed long int)(2 * i + 1)] > ovector[(signed long int)(2 * i)] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              if(!tmp_if_expr$3)
                break;

              if(CI_DEBUG_LEVEL >= 9)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "\t sub-match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)(2 * i)], ovector[(signed long int)(2 * i + 1)], ovector[(signed long int)(2 * i + 1)] - ovector[(signed long int)(2 * i)], str + (signed long int)ovector[(signed long int)(2 * i)]);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("\t sub-match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)(2 * i)], ovector[(signed long int)(2 * i + 1)], ovector[(signed long int)(2 * i + 1)] - ovector[(signed long int)(2 * i)], str + (signed long int)ovector[(signed long int)(2 * i)]);

              }

              parts.matches[(signed long int)i].s = (unsigned long int)ovector[(signed long int)(2 * i)];
              parts.matches[(signed long int)i].e = (unsigned long int)ovector[(signed long int)(2 * i + 1)];
              i = i + 1;
            }
            while((_Bool)1);
            ci_list_push_back(matches, (void *)&parts);
          }

        }

      }

    }
    while(rc >= 0 && !(recurs == 0) && !(offset >= str_length));
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_regex_apply matches count: %d\n", count);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_regex_apply matches count: %d\n", count);

    }

    return count;
  }
}

// ci_regex_build
// file include/ci_regex.h line 44
void * ci_regex_build(const char *regex_str, signed int regex_flags)
{
  struct real_pcre *re;
  const char *error;
  signed int erroffset;
  re=pcre_compile(regex_str, regex_flags, &error, &erroffset, (const unsigned char *)(void *)0);
  if(re == ((struct real_pcre *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "PCRE compilation failed at offset %d: %s\n", erroffset, error);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("PCRE compilation failed at offset %d: %s\n", erroffset, error);

    }

    return (void *)0;
  }

  else
    return (void *)re;
}

// ci_regex_free
// file include/ci_regex.h line 45
void ci_regex_free(void *regex)
{
  pcre_free((void *)(struct real_pcre *)regex);
}

// ci_regex_parse
// file include/ci_regex.h line 43
char * ci_regex_parse(const char *str, signed int *flags, signed int *recursive)
{
  signed int slen;
  const char *e;
  char *s;
  if(!((signed int)*str == 47))
    return (char *)(void *)0;

  else
  {
    str = str + 1l;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    slen = (signed int)return_value_strlen$1;
    e = str + (signed long int)slen;
    for( ; !((signed int)*e == 47); e = e - 1l)
      if(e == str)
        break;

    if(!((signed int)*e == 47))
      return (char *)(void *)0;

    else
    {
      slen = (signed int)(e - str);
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)(slen + 1) * sizeof(char) /*1ul*/ );
      s = (char *)return_value_malloc$2;
      strncpy(s, str, (unsigned long int)slen);
      s[(signed long int)slen] = (char)0;
      *flags = 0;
      *flags = *flags | 0x00400000;
      *flags = *flags | 0x00500000;
      for( ; !((signed int)*e == 0); e = e + 1l)
        if((signed int)*e == 105)
          *flags = *flags | 0x00000001;

        else
          if((signed int)*e == 109)
            *flags = *flags | 0x00000002;

          else
            if((signed int)*e == 115)
              *flags = *flags | 0x00000004;

            else
              if((signed int)*e == 120)
                *flags = *flags | 0x00000008;

              else
                if((signed int)*e == 65)
                  *flags = *flags | 0x00000010;

                else
                  if((signed int)*e == 68)
                    *flags = *flags | 0x00000020;

                  else
                    if((signed int)*e == 85)
                      *flags = *flags | 0x00000200;

                    else
                      if((signed int)*e == 88)
                        *flags = *flags | 0x00000040;

                      else
                        if((signed int)*e == 68)
                          *flags = *flags | 0x00000020;

                        else
                          if((signed int)*e == 117)
                            *flags = *flags | 0x00000800;

                          else
                            if((signed int)*e == 103)
                              *recursive = 1;

      return s;
    }
  }
}

// ci_registry_add_item
// file include/registry.h line 34
signed int ci_registry_add_item(const char *name, const char *label, const void *obj)
{
  struct ci_dyn_array *registry = (struct ci_dyn_array *)(void *)0;
  _Bool tmp_if_expr$4;
  void *return_value_ci_ptr_array_search$3;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_ci_ptr_array_search$3=ci_ptr_array_search(REGISTRIES, name);
    registry = (struct ci_dyn_array *)return_value_ci_ptr_array_search$3;
    tmp_if_expr$4 = registry == (struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
  {
    if(CI_DEBUG_LEVEL >= 3)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry '%s' does not exist create it\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry '%s' does not exist create it\n", name);

    }

    signed int return_value_ci_registry_create$1;
    return_value_ci_registry_create$1=ci_registry_create(name);
    if(!(return_value_ci_registry_create$1 >= 0))
      return 0;

    void *return_value_ci_ptr_array_search$2;
    return_value_ci_ptr_array_search$2=ci_ptr_array_search(REGISTRIES, name);
    registry = (struct ci_dyn_array *)return_value_ci_ptr_array_search$2;
  }

  const struct ci_array_item *return_value_ci_ptr_dyn_array_add$5;
  return_value_ci_ptr_dyn_array_add$5=ci_ptr_dyn_array_add(registry, label, (void *)obj);
  if(!(return_value_ci_ptr_dyn_array_add$5 == ((const struct ci_array_item *)NULL)))
  {
    REG_ITEMS_COUNT = REG_ITEMS_COUNT + 1;
    return REG_ITEMS_COUNT;
  }

  else
    return 0;
}

// ci_registry_clean
// file registry.c line 49
void ci_registry_clean()
{
  struct ci_dyn_array *registry = (struct ci_dyn_array *)(void *)0;
  char buf[1024l];
  void *return_value_ci_ptr_array_pop_value$1;
  if(!(REGISTRIES == ((struct ci_array *)NULL)))
  {
    do
    {
      return_value_ci_ptr_array_pop_value$1=ci_ptr_array_pop_value(REGISTRIES, buf, sizeof(char [1024l]) /*1024ul*/ );
      registry = (struct ci_dyn_array *)return_value_ci_ptr_array_pop_value$1;
      if(registry == ((struct ci_dyn_array *)NULL))
        break;

      if(CI_DEBUG_LEVEL >= 4)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Registry %s removed\n", (const void *)buf);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Registry %s removed\n", (const void *)buf);

      }

      ci_dyn_array_destroy(registry);
    }
    while((_Bool)1);
    ci_array_destroy(REGISTRIES);
    REGISTRIES = (struct ci_array *)(void *)0;
  }

}

// ci_registry_create
// file registry.c line 29
signed int ci_registry_create(const char *name)
{
  void *return_value_ci_ptr_array_search$1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    REGISTRIES=ci_ptr_array_new2((unsigned long int)1024);

  else
  {
    return_value_ci_ptr_array_search$1=ci_ptr_array_search(REGISTRIES, name);
    if(!(return_value_ci_ptr_array_search$1 == NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Registry '%s' already exist!\n", name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Registry '%s' already exist!\n", name);

      }

      return -1;
    }

  }
  struct ci_dyn_array *registry;
  registry=ci_dyn_array_new((unsigned long int)1024);
  ci_ptr_array_add(REGISTRIES, name, (void *)registry);
  if(CI_DEBUG_LEVEL >= 4)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Registry '%s' added and is ready to store new registry entries\n", name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Registry '%s' added and is ready to store new registry entries\n", name);

  }

  return (signed int)(REGISTRIES->count - (unsigned int)1);
}

// ci_registry_get_id
// file registry.c line 119
signed int ci_registry_get_id(const char *name)
{
  struct check_reg_data rdata;
  rdata.name = name;
  rdata.found = 0;
  rdata.count = 0;
  if(!(REGISTRIES == ((struct ci_array *)NULL)))
    ci_array_iterate(REGISTRIES, (void *)&rdata, check_reg);

  if(!(rdata.found == 0))
    return rdata.count - 1;

  else
    return -1;
}

// ci_registry_get_item
// file include/registry.h line 35
const void * ci_registry_get_item(const char *name, const char *label)
{
  struct ci_dyn_array *registry = (struct ci_dyn_array *)(void *)0;
  _Bool tmp_if_expr$2;
  void *return_value_ci_ptr_array_search$1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_ci_ptr_array_search$1=ci_ptr_array_search(REGISTRIES, name);
    registry = (struct ci_dyn_array *)return_value_ci_ptr_array_search$1;
    tmp_if_expr$2 = registry == (struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry '%s' does not exist!\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry '%s' does not exist!\n", name);

    }

    return (void *)0;
  }

  else
  {
    const void *return_value_ci_dyn_array_search$3;
    return_value_ci_dyn_array_search$3=ci_dyn_array_search(registry, label);
    return return_value_ci_dyn_array_search$3;
  }
}

// ci_registry_id_get_item
// file registry.c line 147
const void * ci_registry_id_get_item(signed int reg_id, const char *label)
{
  const struct ci_dyn_array *registry = (const struct ci_dyn_array *)(void *)0;
  const struct ci_array_item *ai;
  _Bool tmp_if_expr$1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    ai=ci_array_get_item(REGISTRIES, reg_id);
    tmp_if_expr$1 = ai == (const struct ci_array_item *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    registry = (const struct ci_dyn_array *)ai->value;
    tmp_if_expr$2 = registry == (const struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry with id='%d' does not exist!\n", reg_id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry with id='%d' does not exist!\n", reg_id);

    }

    return NULL;
  }

  else
  {
    const void *return_value_ci_dyn_array_search$3;
    return_value_ci_dyn_array_search$3=ci_dyn_array_search(registry, label);
    return return_value_ci_dyn_array_search$3;
  }
}

// ci_registry_id_iterate
// file registry.c line 135
signed int ci_registry_id_iterate(signed int reg_id, void *data, signed int (*fn)(void *, const char *, const void *))
{
  const struct ci_dyn_array *registry = (const struct ci_dyn_array *)(void *)0;
  const struct ci_array_item *ai;
  _Bool tmp_if_expr$1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    ai=ci_array_get_item(REGISTRIES, reg_id);
    tmp_if_expr$1 = ai == (const struct ci_array_item *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    registry = (const struct ci_dyn_array *)ai->value;
    tmp_if_expr$2 = registry == (const struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry with id='%d' does not exist!\n", reg_id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry with id='%d' does not exist!\n", reg_id);

    }

    return 0;
  }

  else
  {
    ci_dyn_array_iterate(registry, data, fn);
    return 1;
  }
}

// ci_registry_iterate
// file registry.c line 65
signed int ci_registry_iterate(const char *name, void *data, signed int (*fn)(void *, const char *, const void *))
{
  const struct ci_dyn_array *registry = (const struct ci_dyn_array *)(void *)0;
  _Bool tmp_if_expr$2;
  void *return_value_ci_ptr_array_search$1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_ci_ptr_array_search$1=ci_ptr_array_search(REGISTRIES, name);
    registry = (const struct ci_dyn_array *)return_value_ci_ptr_array_search$1;
    tmp_if_expr$2 = registry == (const struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry '%s' does not exist!\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry '%s' does not exist!\n", name);

    }

    return 0;
  }

  else
  {
    ci_dyn_array_iterate(registry, data, fn);
    return 1;
  }
}

// ci_request_206_origin_body
// file request_common.c line 436
signed int ci_request_206_origin_body(struct ci_request *req, unsigned long int offset)
{
  if(req == ((struct ci_request *)NULL))
    return 0;

  else
    if(req->allow206 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Request does not support allow206 responses! Can not set use-original-body extension\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Request does not support allow206 responses! Can not set use-original-body extension\n");

      }

      return 0;
    }

    else
    {
      req->i206_use_original_body = (signed long int)offset;
      return 1;
    }
}

// ci_request_alloc
// file request_common.c line 231
struct ci_request * ci_request_alloc(struct ci_connection *connection)
{
  struct ci_request *req;
  signed int i;
  void *return_value;
  return_value=__intl_malloc((signed int)sizeof(struct ci_request) /*9392ul*/ );
  req = (struct ci_request *)return_value;
  if(req == ((struct ci_request *)NULL))
    return (struct ci_request *)(void *)0;

  else
  {
    req->connection = connection;
    req->packed = 0;
    req->user[(signed long int)0] = (char)0;
    req->access_type = 0;
    req->service[(signed long int)0] = (char)0;
    req->req_server[(signed long int)0] = (char)0;
    req->current_service_mod = (struct ci_service_module *)(void *)0;
    req->service_data = (void *)0;
    req->args[(signed long int)0] = (char)0;
    req->type = -1;
    req->preview = -1;
    ci_buf_init(&req->preview_data);
    req->keepalive = 1;
    req->allow204 = 0;
    req->allow206 = 0;
    req->hasbody = 0;
    req->responce_hasbody = 0;
    req->eof_received = 0;
    req->request_header=ci_headers_create();
    req->response_header=ci_headers_create();
    req->xheaders=ci_headers_create();
    req->status = 0;
    req->return_code = -1;
    req->pstrblock_read = (char *)(void *)0;
    req->pstrblock_read_len = 0;
    req->current_chunk_len = (unsigned int)0;
    req->chunk_bytes_read = (unsigned int)0;
    req->write_to_module_pending = (unsigned int)0;
    req->pstrblock_responce = (char *)(void *)0;
    req->remain_send_block_bytes = 0;
    req->data_locked = 1;
    req->i206_use_original_body = (signed long int)-1;
    req->preview_data_type = -1;
    req->auth_required = 0;
    req->log_str = (char *)(void *)0;
    req->attributes = (struct ci_array *)(void *)0;
    memset((void *)&req->xclient_ip, 0, sizeof(struct ci_ip) /*12ul*/ );
    req->bytes_in = (unsigned long int)0;
    req->bytes_out = (unsigned long int)0;
    req->request_bytes_in = (unsigned long int)0;
    req->http_bytes_in = (unsigned long int)0;
    req->http_bytes_out = (unsigned long int)0;
    req->body_bytes_in = (unsigned long int)0;
    req->body_bytes_out = (unsigned long int)0;
    i = 0;
    if(!(i >= 5))
    {
      req->entities[(signed long int)i] = (struct ci_encaps_entity *)(void *)0;
      i = i + 1;
    }

    i = 0;
    if(!(i >= 7))
    {
      req->trash_entities[(signed long int)i] = (struct ci_encaps_entity *)(void *)0;
      i = i + 1;
    }

    return req;
  }
}

// ci_request_alloc_entity
// file include/request.h line 174
struct ci_encaps_entity * ci_request_alloc_entity(struct ci_request *req, signed int type, signed int val)
{
  struct ci_encaps_entity *e = (struct ci_encaps_entity *)(void *)0;
  if(type >= 6 || !(type >= 0))
    return (struct ci_encaps_entity *)(void *)0;

  else
    if(!(req->trash_entities[(signed long int)type] == ((struct ci_encaps_entity *)NULL)))
    {
      e = req->trash_entities[(signed long int)type];
      req->trash_entities[(signed long int)type] = (struct ci_encaps_entity *)(void *)0;
      e->type = type;
      e->start = val;
      _Bool tmp_if_expr$1;
      if(e->type == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = e->type == 1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        if(!(e->entity == NULL))
          ci_headers_reset((struct ci_headers_list *)e->entity);

      }

      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Get entity from trash....\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Get entity from trash....\n");

      }

      return e;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Allocate a new entity of type %d\n", type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Allocate a new entity of type %d\n", type);

      }

      struct ci_encaps_entity *return_value_mk_encaps_entity$2;
      return_value_mk_encaps_entity$2=mk_encaps_entity(type, val);
      return return_value_mk_encaps_entity$2;
    }
}

// ci_request_destroy
// file request_common.c line 378
void ci_request_destroy(struct ci_request *req)
{
  signed int i;
  if(!(req->connection == ((struct ci_connection *)NULL)))
    __intl_free((void *)req->connection);

  ci_buf_mem_free(&req->preview_data);
  ci_headers_destroy(req->request_header);
  ci_headers_destroy(req->response_header);
  ci_headers_destroy(req->xheaders);
  i = 0;
  for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
    destroy_encaps_entity(req->entities[(signed long int)i]);
  i = 0;
  for( ; !(i >= 7); i = i + 1)
    if(!(req->trash_entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      destroy_encaps_entity(req->trash_entities[(signed long int)i]);

  if(!(req->log_str == ((char *)NULL)))
    __intl_free((void *)req->log_str);

  if(!(req->attributes == ((struct ci_array *)NULL)))
    ci_array_destroy(req->attributes);

  __intl_free((void *)req);
}

// ci_request_pack
// file request_common.c line 152
void ci_request_pack(struct ci_request *req)
{
  ci_request_t_pack(req, 1);
}

// ci_request_release_entity
// file include/request.h line 175
signed int ci_request_release_entity(struct ci_request *req, signed int pos)
{
  signed int type = 0;
  if(req->entities[(signed long int)pos] == ((struct ci_encaps_entity *)NULL))
    return 0;

  else
  {
    type = req->entities[(signed long int)pos]->type;
    if(type >= 6 || !(type >= 0))
    {
      destroy_encaps_entity(req->entities[(signed long int)pos]);
      req->entities[(signed long int)pos] = (struct ci_encaps_entity *)(void *)0;
      return 0;
    }

    else
    {
      if(!(req->trash_entities[(signed long int)type] == ((struct ci_encaps_entity *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 3)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "ERROR!!!!! There is an entity of type %d to trash..... ", type);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("ERROR!!!!! There is an entity of type %d to trash..... ", type);

        }

        destroy_encaps_entity(req->trash_entities[(signed long int)type]);
      }

      req->trash_entities[(signed long int)type] = req->entities[(signed long int)pos];
      req->entities[(signed long int)pos] = (struct ci_encaps_entity *)(void *)0;
      return 1;
    }
  }
}

// ci_request_reset
// file request_common.c line 308
void ci_request_reset(struct ci_request *req)
{
  signed int i;
  req->packed = 0;
  req->user[(signed long int)0] = (char)0;
  req->service[(signed long int)0] = (char)0;
  req->current_service_mod = (struct ci_service_module *)(void *)0;
  req->service_data = (void *)0;
  req->args[(signed long int)0] = (char)0;
  req->type = -1;
  req->preview = -1;
  ci_buf_reset(&req->preview_data);
  req->keepalive = 1;
  req->allow204 = 0;
  req->allow206 = 0;
  req->hasbody = 0;
  req->responce_hasbody = 0;
  ci_headers_reset(req->request_header);
  ci_headers_reset(req->response_header);
  ci_headers_reset(req->xheaders);
  req->eof_received = 0;
  req->status = 0;
  req->return_code = -1;
  req->pstrblock_read = (char *)(void *)0;
  req->pstrblock_read_len = 0;
  req->current_chunk_len = (unsigned int)0;
  req->chunk_bytes_read = (unsigned int)0;
  req->pstrblock_responce = (char *)(void *)0;
  req->remain_send_block_bytes = 0;
  req->write_to_module_pending = (unsigned int)0;
  req->data_locked = 1;
  req->i206_use_original_body = (signed long int)-1;
  req->preview_data_type = -1;
  req->auth_required = 0;
  if(!(req->log_str == ((char *)NULL)))
    __intl_free((void *)req->log_str);

  req->log_str = (char *)(void *)0;
  if(!(req->attributes == ((struct ci_array *)NULL)))
    ci_array_destroy(req->attributes);

  req->attributes = (struct ci_array *)(void *)0;
  memset((void *)&req->xclient_ip, 0, sizeof(struct ci_ip) /*12ul*/ );
  req->bytes_in = (unsigned long int)0;
  req->bytes_out = (unsigned long int)0;
  req->request_bytes_in = (unsigned long int)0;
  req->http_bytes_in = (unsigned long int)0;
  req->http_bytes_out = (unsigned long int)0;
  req->body_bytes_in = (unsigned long int)0;
  req->body_bytes_out = (unsigned long int)0;
  i = 0;
  for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
    ci_request_release_entity(req, i);
  if(!(req->trash_entities[0l] == ((struct ci_encaps_entity *)NULL)))
  {
    if(!(req->trash_entities[0l]->entity == NULL))
      ci_headers_reset((struct ci_headers_list *)req->trash_entities[(signed long int)0]->entity);

  }

  if(!(req->trash_entities[1l] == ((struct ci_encaps_entity *)NULL)))
  {
    if(!(req->trash_entities[1l]->entity == NULL))
      ci_headers_reset((struct ci_headers_list *)req->trash_entities[(signed long int)1]->entity);

  }

}

// ci_request_set_log_str
// file request_common.c line 405
char * ci_request_set_log_str(struct ci_request *req, char *logstr)
{
  signed int size;
  if(!(req->log_str == ((char *)NULL)))
    __intl_free((void *)req->log_str);

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(logstr);
  size = (signed int)(return_value_strlen$1 + (unsigned long int)1);
  void *return_value;
  return_value=__intl_malloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
  req->log_str = (char *)return_value;
  if(req->log_str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    strcpy(req->log_str, logstr);
    return req->log_str;
  }
}

// ci_request_set_str_attribute
// file request_common.c line 419
signed int ci_request_set_str_attribute(struct ci_request *req, const char *name, const char *value)
{
  if(req->attributes == ((struct ci_array *)NULL))
  {
    req->attributes=ci_array_new((unsigned long int)4096);
    if(!(req->attributes == ((struct ci_array *)NULL)))
      goto __CPROVER_DUMP_L3;

    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocating request attributes array!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocating request attributes array!\n");

    }

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(value);
    const struct ci_array_item *return_value_ci_array_add$2;
    return_value_ci_array_add$2=ci_array_add(req->attributes, name, (const void *)value, return_value_strlen$1 + (unsigned long int)1);
    if(return_value_ci_array_add$2 == ((const struct ci_array_item *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not enough space to add attribute %s:%s for service %s\n", name, value, (const void *)req->service);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not enough space to add attribute %s:%s for service %s\n", name, value, (const void *)req->service);

      }

      return 0;
    }

    else
      return 1;
  }
}

// ci_request_t_pack
// file request_common.c line 92
void ci_request_t_pack(struct ci_request *req, signed int is_request)
{
  struct ci_encaps_entity **elist;
  struct ci_encaps_entity *e;
  char buf[256l];
  req->packed = 1;
  if(!(is_request == 0))
  {
    if(req->preview >= 0)
    {
      sprintf(buf, "Preview: %d", req->preview);
      ci_headers_add(req->request_header, buf);
    }

  }

  elist = req->entities;
  if(!(*elist == ((struct ci_encaps_entity *)NULL)))
    elist[(signed long int)0]->start = 0;

  if(!(elist[1l] == ((struct ci_encaps_entity *)NULL)))
    elist[(signed long int)1]->start=sizeofencaps(elist[(signed long int)0]);

  if(!(elist[2l] == ((struct ci_encaps_entity *)NULL)))
  {
    signed int return_value_sizeofencaps$1;
    return_value_sizeofencaps$1=sizeofencaps(elist[(signed long int)1]);
    elist[(signed long int)2]->start = return_value_sizeofencaps$1 + elist[(signed long int)1]->start;
  }

  if(*elist == ((struct ci_encaps_entity *)NULL))
    sprintf(buf, "Encapsulated: null-body=0");

  else
    if(!(elist[2l] == ((struct ci_encaps_entity *)NULL)))
    {
      _Bool tmp_if_expr$2;
      if(!((*elist)->type >= 6))
        tmp_if_expr$2 = elist[(signed long int)0]->type >= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      const char *tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = ci_encaps_entities[(signed long int)elist[(signed long int)0]->type];

      else
        tmp_if_expr$3 = "UNKNOWN";
      _Bool tmp_if_expr$4;
      if(!(elist[1l]->type >= 6))
        tmp_if_expr$4 = elist[(signed long int)1]->type >= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      const char *tmp_if_expr$5;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = ci_encaps_entities[(signed long int)elist[(signed long int)1]->type];

      else
        tmp_if_expr$5 = "UNKNOWN";
      _Bool tmp_if_expr$6;
      if(!(elist[2l]->type >= 6))
        tmp_if_expr$6 = elist[(signed long int)2]->type >= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      const char *tmp_if_expr$7;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = ci_encaps_entities[(signed long int)elist[(signed long int)2]->type];

      else
        tmp_if_expr$7 = "UNKNOWN";
      sprintf(buf, "Encapsulated: %s=%d, %s=%d, %s=%d", tmp_if_expr$3, elist[(signed long int)0]->start, tmp_if_expr$5, elist[(signed long int)1]->start, tmp_if_expr$7, elist[(signed long int)2]->start);
    }

    else
      if(!(elist[1l] == ((struct ci_encaps_entity *)NULL)))
      {
        _Bool tmp_if_expr$8;
        if(!((*elist)->type >= 6))
          tmp_if_expr$8 = elist[(signed long int)0]->type >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        const char *tmp_if_expr$9;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = ci_encaps_entities[(signed long int)elist[(signed long int)0]->type];

        else
          tmp_if_expr$9 = "UNKNOWN";
        _Bool tmp_if_expr$10;
        if(!(elist[1l]->type >= 6))
          tmp_if_expr$10 = elist[(signed long int)1]->type >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$10 = (_Bool)0;
        const char *tmp_if_expr$11;
        if(tmp_if_expr$10)
          tmp_if_expr$11 = ci_encaps_entities[(signed long int)elist[(signed long int)1]->type];

        else
          tmp_if_expr$11 = "UNKNOWN";
        sprintf(buf, "Encapsulated: %s=%d, %s=%d", tmp_if_expr$9, elist[(signed long int)0]->start, tmp_if_expr$11, elist[(signed long int)1]->start);
      }

      else
      {
        _Bool tmp_if_expr$12;
        if(!((*elist)->type >= 6))
          tmp_if_expr$12 = elist[(signed long int)0]->type >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$12 = (_Bool)0;
        const char *tmp_if_expr$13;
        if(tmp_if_expr$12)
          tmp_if_expr$13 = ci_encaps_entities[(signed long int)elist[(signed long int)0]->type];

        else
          tmp_if_expr$13 = "UNKNOWN";
        sprintf(buf, "Encapsulated: %s=%d", tmp_if_expr$13, elist[(signed long int)0]->start);
      }
  if(!(is_request == 0))
    ci_headers_add(req->request_header, buf);

  else
    ci_headers_add(req->response_header, buf);
  struct ci_encaps_entity **tmp_post$14;
  do
  {
    tmp_post$14 = elist;
    elist = elist + 1l;
    e = *tmp_post$14;
    if(e == ((struct ci_encaps_entity *)NULL))
      break;

    _Bool tmp_if_expr$15;
    if(e->type == 0)
      tmp_if_expr$15 = (_Bool)1;

    else
      tmp_if_expr$15 = e->type == 1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$15)
      ci_headers_pack((struct ci_headers_list *)e->entity);

  }
  while((_Bool)1);
  if(!(is_request == 0))
    ci_headers_pack(req->request_header);

  else
    ci_headers_pack(req->response_header);
}

// ci_response_pack
// file request_common.c line 156
void ci_response_pack(struct ci_request *req)
{
  ci_request_t_pack(req, 0);
}

// ci_ring_buf_consume
// file body.c line 931
void ci_ring_buf_consume(struct ci_ring_buf *buf, signed int len)
{
  if(len >= 1)
  {
    buf->read_pos = buf->read_pos + (signed long int)len;
    if(!(buf->end_buf >= buf->read_pos))
      buf->read_pos = buf->buf;

    if(!(buf->full == 0))
      buf->full = 0;

  }

}

// ci_ring_buf_destroy
// file body.c line 882
void ci_ring_buf_destroy(struct ci_ring_buf *buf)
{
  ci_buffer_free((void *)buf->buf);
  ci_object_pool_free((void *)buf);
}

// ci_ring_buf_is_empty
// file body.c line 888
signed int ci_ring_buf_is_empty(struct ci_ring_buf *buf)
{
  _Bool tmp_if_expr$1;
  if(buf->read_pos == buf->write_pos)
    tmp_if_expr$1 = buf->full == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return (signed int)tmp_if_expr$1;
}

// ci_ring_buf_new
// file body.c line 863
struct ci_ring_buf * ci_ring_buf_new(signed int size)
{
  struct ci_ring_buf *buf;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(RING_BUF_POOL);
  buf = (struct ci_ring_buf *)return_value_ci_object_pool_alloc$1;
  if(buf == ((struct ci_ring_buf *)NULL))
    return (struct ci_ring_buf *)(void *)0;

  else
  {
    void *return_value_ci_buffer_alloc$2;
    return_value_ci_buffer_alloc$2=ci_buffer_alloc(size);
    buf->buf = (char *)return_value_ci_buffer_alloc$2;
    if(buf->buf == ((char *)NULL))
    {
      ci_object_pool_free((void *)buf);
      return (struct ci_ring_buf *)(void *)0;
    }

    else
    {
      buf->end_buf = (buf->buf + (signed long int)size) - (signed long int)1;
      buf->read_pos = buf->buf;
      buf->write_pos = buf->buf;
      buf->full = 0;
      return buf;
    }
  }
}

// ci_ring_buf_produce
// file body.c line 942
void ci_ring_buf_produce(struct ci_ring_buf *buf, signed int len)
{
  if(len >= 1)
  {
    buf->write_pos = buf->write_pos + (signed long int)len;
    if(!(buf->end_buf >= buf->write_pos))
      buf->write_pos = buf->buf;

    if(buf->write_pos == buf->read_pos)
      buf->full = 1;

  }

}

// ci_ring_buf_read
// file body.c line 975
signed int ci_ring_buf_read(struct ci_ring_buf *buf, char *data, signed int size)
{
  char *rb;
  signed int rb_len;
  signed int ret;
  signed int data_read = 0;
  do
  {
    ret=ci_ring_buf_read_block(buf, &rb, &rb_len);
    if(!(rb_len == 0))
    {
      rb_len = size > rb_len ? rb_len : size;
      memcpy((void *)data, (const void *)rb, (unsigned long int)rb_len);
      ci_ring_buf_consume(buf, rb_len);
      size = size - rb_len;
      data = data + (signed long int)rb_len;
      data_read = data_read + rb_len;
    }

  }
  while(size >= 1 && !(ret == 0));
  return data_read;
}

// ci_ring_buf_read_block
// file body.c line 912
signed int ci_ring_buf_read_block(struct ci_ring_buf *buf, char **rb, signed int *len)
{
  _Bool tmp_if_expr$1;
  if(buf->read_pos == buf->write_pos)
    tmp_if_expr$1 = buf->full == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    *rb = buf->read_pos;
    *len = 0;
    return 0;
  }

  else
    if(buf->read_pos >= buf->write_pos)
    {
      *rb = buf->read_pos;
      *len = (signed int)((buf->end_buf - buf->read_pos) + (signed long int)1);
      return buf->read_pos != buf->buf ? 1 : 0;
    }

    else
    {
      *rb = buf->read_pos;
      *len = (signed int)(buf->write_pos - buf->read_pos);
      return 0;
    }
}

// ci_ring_buf_write
// file body.c line 955
signed int ci_ring_buf_write(struct ci_ring_buf *buf, const char *data, signed int size)
{
  char *wb;
  signed int wb_len;
  signed int ret;
  signed int written = 0;
  do
  {
    ret=ci_ring_buf_write_block(buf, &wb, &wb_len);
    if(!(wb_len == 0))
    {
      wb_len = size > wb_len ? wb_len : size;
      memcpy((void *)wb, (const void *)data, (unsigned long int)wb_len);
      ci_ring_buf_produce(buf, wb_len);
      size = size - wb_len;
      data = data + (signed long int)wb_len;
      written = written + wb_len;
    }

  }
  while(size >= 1 && !(ret == 0));
  return written;
}

// ci_ring_buf_write_block
// file body.c line 893
signed int ci_ring_buf_write_block(struct ci_ring_buf *buf, char **wb, signed int *len)
{
  _Bool tmp_if_expr$1;
  if(buf->read_pos == buf->write_pos)
    tmp_if_expr$1 = buf->full == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    *wb = buf->write_pos;
    *len = (signed int)((buf->end_buf - buf->write_pos) + (signed long int)1);
    return 0;
  }

  else
    if(buf->read_pos >= buf->write_pos)
    {
      *wb = buf->write_pos;
      *len = (signed int)(buf->read_pos - buf->write_pos);
      return 0;
    }

    else
    {
      *wb = buf->write_pos;
      *len = (signed int)((buf->end_buf - buf->write_pos) + (signed long int)1);
      return 1;
    }
}

// ci_service_add_xincludes
// file service_lib.c line 125
void ci_service_add_xincludes(struct ci_service_xdata *srv_xdata, char **xincludes)
{
  signed int len;
  signed int i;
  len = 0;
  i = 0;
  if(!(xincludes == ((char **)NULL)))
  {
    pthread_rwlock_wrlock(&srv_xdata->lock);
    while(511 + -len + -2 >= 1)
    {
      if(xincludes[(signed long int)i] == ((char *)NULL))
        break;

      if(!(len == 0))
      {
        strcat(srv_xdata->xincludes, ", ");
        len = len + 2;
      }

      strncat(srv_xdata->xincludes, xincludes[(signed long int)i], (unsigned long int)(511 - len));
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(xincludes[(signed long int)i]);
      len = len + (signed int)return_value_strlen$1;
      i = i + 1;
    }
    pthread_rwlock_unlock(&srv_xdata->lock);
  }

}

// ci_service_add_xopts
// file service_lib.c line 118
void ci_service_add_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->xopts = srv_xdata->xopts | xopts;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_data_read_lock
// file service_lib.c line 25
void ci_service_data_read_lock(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_rdlock(&srv_xdata->lock);
}

// ci_service_data_read_unlock
// file service_lib.c line 30
void ci_service_data_read_unlock(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_enable_204
// file service_lib.c line 82
void ci_service_enable_204(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->allow_204 = 1;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_enable_206
// file service_lib.c line 89
void ci_service_enable_206(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  if(srv_xdata->disable_206 == 0)
    srv_xdata->allow_206 = 1;

  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_istag
// file service_lib.c line 35
void ci_service_set_istag(struct ci_service_xdata *srv_xdata, const char *istag)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strncpy(srv_xdata->ISTag + (signed long int)13, istag, (unsigned long int)(39 - 13));
  srv_xdata->ISTag[(signed long int)39] = (char)0;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_max_connections
// file service_lib.c line 97
void ci_service_set_max_connections(struct ci_service_xdata *srv_xdata, signed int max_connections)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->max_connections = max_connections;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_options_ttl
// file service_lib.c line 104
void ci_service_set_options_ttl(struct ci_service_xdata *srv_xdata, signed int ttl)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->options_ttl = ttl;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_preview
// file service_lib.c line 75
void ci_service_set_preview(struct ci_service_xdata *srv_xdata, signed int preview)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->preview_size = preview;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_transfer_complete
// file service_lib.c line 64
void ci_service_set_transfer_complete(struct ci_service_xdata *srv_xdata, const char *complete)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strcpy(srv_xdata->TransferComplete, "Transfer-Complete: ");
  strncat(srv_xdata->TransferComplete, complete, (unsigned long int)1023 - sizeof(char [20l]) /*20ul*/ );
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_transfer_ignore
// file service_lib.c line 54
void ci_service_set_transfer_ignore(struct ci_service_xdata *srv_xdata, const char *ignore)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strcpy(srv_xdata->TransferIgnore, "Transfer-Ignore: ");
  strncat(srv_xdata->TransferIgnore, ignore, (unsigned long int)1023 - sizeof(char [18l]) /*18ul*/ );
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_transfer_preview
// file service_lib.c line 44
void ci_service_set_transfer_preview(struct ci_service_xdata *srv_xdata, const char *preview)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strcpy(srv_xdata->TransferPreview, "Transfer-Preview: ");
  strncat(srv_xdata->TransferPreview, preview, (unsigned long int)1023 - sizeof(char [19l]) /*19ul*/ );
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_xopts
// file service_lib.c line 111
void ci_service_set_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->xopts = xopts;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_shared_mem_attach
// file os/unix/shared_mem.c line 262
void * ci_shared_mem_attach(struct ci_shared_mem_id *id)
{
  _Bool tmp_if_expr$1;
  if(!(id == ((struct ci_shared_mem_id *)NULL)))
    tmp_if_expr$1 = id->scheme != ((const struct ci_shared_mem_scheme *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  /* assertion id && id->scheme */
  assert(tmp_if_expr$1);
  void *return_value;
  return_value=id->scheme->shared_mem_attach(id);
  return return_value;
}

// ci_shared_mem_create
// file os/unix/shared_mem.c line 252
void * ci_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  if(default_scheme == ((const struct ci_shared_mem_scheme *)NULL))
    return (void *)0;

  else
  {
    id->scheme = default_scheme;
    void *return_value;
    return_value=default_scheme->shared_mem_create(id, name, size);
    return return_value;
  }
}

// ci_shared_mem_destroy
// file os/unix/shared_mem.c line 276
signed int ci_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  _Bool tmp_if_expr$1;
  if(!(id == ((struct ci_shared_mem_id *)NULL)))
    tmp_if_expr$1 = id->scheme != ((const struct ci_shared_mem_scheme *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  /* assertion id && id->scheme */
  assert(tmp_if_expr$1);
  signed int return_value;
  return_value=id->scheme->shared_mem_destroy(id);
  return return_value;
}

// ci_shared_mem_detach
// file os/unix/shared_mem.c line 269
signed int ci_shared_mem_detach(struct ci_shared_mem_id *id)
{
  _Bool tmp_if_expr$1;
  if(!(id == ((struct ci_shared_mem_id *)NULL)))
    tmp_if_expr$1 = id->scheme != ((const struct ci_shared_mem_scheme *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  /* assertion id && id->scheme */
  assert(tmp_if_expr$1);
  signed int return_value;
  return_value=id->scheme->shared_mem_detach(id);
  return return_value;
}

// ci_shared_mem_set_scheme
// file os/unix/shared_mem.c line 227
signed int ci_shared_mem_set_scheme(const char *name)
{
  signed int return_value_strcasecmp$3;
  return_value_strcasecmp$3=strcasecmp(name, "posix");
  signed int return_value_strcasecmp$2;
  signed int return_value_strcasecmp$1;
  if(return_value_strcasecmp$3 == 0)
    default_scheme = &posix_scheme;

  else
  {
    return_value_strcasecmp$2=strcasecmp(name, "mmap");
    if(return_value_strcasecmp$2 == 0)
      default_scheme = &mmap_scheme;

    else
    {
      return_value_strcasecmp$1=strcasecmp(name, "sysv");
      if(return_value_strcasecmp$1 == 0)
        default_scheme = &sysv_scheme;

      else
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Shared mem scheme '%s' does not supported by c-icap\n", name);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Shared mem scheme '%s' does not supported by c-icap\n", name);

        }

        return 0;
      }
    }
  }
  return 1;
}

// ci_simple_file_destroy
// file body.c line 643
void ci_simple_file_destroy(struct ci_simple_file *body)
{
  if(!(body == ((struct ci_simple_file *)NULL)))
  {
    if(body->fd >= 0)
    {
      do_close(body->fd);
      unlink(body->filename);
    }

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    if(!(body->mmap_addr == ((char *)NULL)))
      munmap((void *)body->mmap_addr, (unsigned long int)body->mmap_size);

    ci_object_pool_free((void *)body);
  }

}

// ci_simple_file_named_new
// file body.c line 601
struct ci_simple_file * ci_simple_file_named_new(char *dir, char *filename, signed long int maxsize)
{
  struct ci_simple_file *body;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(SIMPLE_FILE_POOL);
  body = (struct ci_simple_file *)return_value_ci_object_pool_alloc$1;
  if(body == ((struct ci_simple_file *)NULL))
    return (struct ci_simple_file *)(void *)0;

  else
  {
    if(!(filename == ((char *)NULL)))
    {
      snprintf(body->filename, (unsigned long int)4096, "%s/%s", dir, filename);
      body->fd=do_open(body->filename, 0100 | 02 | 0200);
      if(!(body->fd >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not open temporary filename: %s\n", (const void *)body->filename);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not open temporary filename: %s\n", (const void *)body->filename);

        }

        ci_object_pool_free((void *)body);
        return (struct ci_simple_file *)(void *)0;
      }

    }

    else
    {
      body->fd=ci_mktemp_file(dir, "CI_TMP_XXXXXX", body->filename);
      if(!(body->fd >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not open temporary filename in directory: %s\n", dir);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not open temporary filename in directory: %s\n", dir);

        }

        ci_object_pool_free((void *)body);
        return (struct ci_simple_file *)(void *)0;
      }

    }
    body->endpos = (signed long int)0;
    body->readpos = (signed long int)0;
    body->flags = (unsigned int)0;
    body->unlocked = (signed long int)0;
    body->max_store_size = maxsize > (signed long int)0 ? maxsize : (signed long int)0;
    body->bytes_in = (signed long int)0;
    body->bytes_out = (signed long int)0;
    body->attributes = (struct ci_array *)(void *)0;
    body->mmap_addr = (char *)(void *)0;
    body->mmap_size = (signed long int)0;
    return body;
  }
}

// ci_simple_file_new
// file body.c line 571
struct ci_simple_file * ci_simple_file_new(signed long int maxsize)
{
  struct ci_simple_file *body;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(SIMPLE_FILE_POOL);
  body = (struct ci_simple_file *)return_value_ci_object_pool_alloc$1;
  if(body == ((struct ci_simple_file *)NULL))
    return (struct ci_simple_file *)(void *)0;

  else
  {
    body->fd=ci_mktemp_file(CI_TMPDIR, "CI_TMP_XXXXXX", body->filename);
    if(!(body->fd >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_simple_file_new: Can not open temporary filename in directory:%s\n", CI_TMPDIR);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_simple_file_new: Can not open temporary filename in directory:%s\n", CI_TMPDIR);

      }

      ci_object_pool_free((void *)body);
      return (struct ci_simple_file *)(void *)0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_simple_file_new: Use temporary filename: %s\n", (const void *)body->filename);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_simple_file_new: Use temporary filename: %s\n", (const void *)body->filename);

      }

      body->endpos = (signed long int)0;
      body->readpos = (signed long int)0;
      body->flags = (unsigned int)0;
      body->unlocked = (signed long int)0;
      body->max_store_size = maxsize > (signed long int)0 ? maxsize : (signed long int)0;
      body->bytes_in = (signed long int)0;
      body->bytes_out = (signed long int)0;
      body->attributes = (struct ci_array *)(void *)0;
      return body;
    }
  }
}

// ci_simple_file_read
// file body.c line 750
signed int ci_simple_file_read(struct ci_simple_file *body, char *buf, signed int len)
{
  signed int remains;
  signed int bytes;
  if(!(len >= 1))
    return 0;

  else
    if(body->readpos == body->endpos)
    {
      if(!((2u & body->flags) == 0u))
      {
        if(CI_DEBUG_LEVEL >= 9)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Has EOF and no data to read, send EOF\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Has EOF and no data to read, send EOF\n");

        }

        return -2;
      }

      return 0;
    }

    else
    {
      if(!(body->max_store_size == 0l))
      {
        if(body->readpos == body->max_store_size)
          body->readpos = (signed long int)0;

      }

      _Bool tmp_if_expr$1;
      if(!((1u & body->flags) == 0u))
        tmp_if_expr$1 = body->unlocked >= (signed long int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        remains = (signed int)(body->unlocked - body->readpos);

      else
        if(!(body->readpos >= body->endpos))
          remains = (signed int)(body->endpos - body->readpos);

        else
          if(!(body->max_store_size == 0l))
            remains = (signed int)(body->max_store_size - body->readpos);

          else
          {
            if(CI_DEBUG_LEVEL >= 9)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error? anyway send EOF\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error? anyway send EOF\n");

            }

            return -2;
          }
      bytes = remains > len ? len : remains;
      lseek64(body->fd, body->readpos, 0);
      bytes=do_read(body->fd, (void *)buf, (unsigned long int)bytes);
      if(bytes >= 1)
      {
        body->readpos = body->readpos + (signed long int)bytes;
        body->bytes_out = body->bytes_out + (signed long int)bytes;
      }

      return bytes;
    }
}

// ci_simple_file_release
// file body.c line 665
void ci_simple_file_release(struct ci_simple_file *body)
{
  if(!(body == ((struct ci_simple_file *)NULL)))
  {
    if(body->fd >= 0)
      do_close(body->fd);

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    if(!(body->mmap_addr == ((char *)NULL)))
      munmap((void *)body->mmap_addr, (unsigned long int)body->mmap_size);

    ci_object_pool_free((void *)body);
  }

}

// ci_simple_file_to_const_string
// file body.c line 824
const char * ci_simple_file_to_const_string(struct ci_simple_file *body)
{
  signed long int map_size;
  char *addr = (char *)(void *)0;
  if((2u & body->flags) == 0u)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "mmap to file: '%s' failed, the eof flag is not set!\n", (const void *)body->filename);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("mmap to file: '%s' failed, the eof flag is not set!\n", (const void *)body->filename);

    }

    return (const char *)(void *)0;
  }

  else
  {
    map_size = body->endpos + (signed long int)1;
    if(body->mmap_addr == ((char *)NULL))
    {
      void *return_value_mmap64$1;
      return_value_mmap64$1=mmap64((void *)0, (unsigned long int)map_size, 0x1 | 0x2, 0x02, body->fd, (signed long int)0);
      addr = (char *)return_value_mmap64$1;
      if(addr == ((char *)NULL))
        return ((const char *)NULL);

      addr[map_size - (signed long int)1] = (char)0;
      body->mmap_addr = addr;
      body->mmap_size = map_size;
    }

    return body->mmap_addr;
  }
}

// ci_simple_file_to_membuf
// file body.c line 848
struct ci_membuf * ci_simple_file_to_membuf(struct ci_simple_file *body, unsigned int flags)
{
  /* assertion ((0x08 | 0x04 | 0x01) & flags) ==flags */
  assert(((unsigned int)(0x08 | 0x04 | 0x01) & flags) == flags);
  /* assertion flags & 0x08 */
  assert((flags & (unsigned int)0x08) != 0u);
  void *addr;
  const char *return_value_ci_simple_file_to_const_string$1;
  return_value_ci_simple_file_to_const_string$1=ci_simple_file_to_const_string(body);
  addr = (void *)return_value_ci_simple_file_to_const_string$1;
  if(addr == NULL)
    return (struct ci_membuf *)(void *)0;

  else
  {
    struct ci_membuf *return_value_ci_membuf_from_content$2;
    return_value_ci_membuf_from_content$2=ci_membuf_from_content(body->mmap_addr, (unsigned long int)body->mmap_size, (unsigned long int)body->endpos, (unsigned int)(0x08 | 0x04 | 0x01 | 0x02));
    return return_value_ci_membuf_from_content$2;
  }
}

// ci_simple_file_truncate
// file body.c line 797
signed int ci_simple_file_truncate(struct ci_simple_file *body, signed long int new_size)
{
  if(!(body->endpos >= new_size))
    return 0;

  else
  {
    if(new_size == 0l)
    {
      new_size=lseek64(body->fd, (signed long int)0, 2);
      if(!(body->endpos >= new_size))
        return 0;

    }

    else
    {
      signed int return_value_ftruncate64$1;
      return_value_ftruncate64$1=ftruncate64(body->fd, new_size);
      if(!(return_value_ftruncate64$1 == 0))
        return 0;

    }
    body->endpos = new_size;
    if(!(new_size >= body->readpos))
      body->readpos = new_size;

    if(!(new_size >= body->unlocked))
      body->unlocked = new_size;

    return 1;
  }
}

// ci_simple_file_write
// file body.c line 686
signed int ci_simple_file_write(struct ci_simple_file *body, const char *buf, signed int len, signed int iseof)
{
  signed int ret;
  signed int wsize = 0;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!((2u & body->flags) == 0u))
  {
    if(len >= 1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Cannot write to file: '%s', the eof flag is set!\n", (const void *)body->filename);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Cannot write to file: '%s', the eof flag is set!\n", (const void *)body->filename);

      }

    }

    return 0;
  }

  else
    if(!(len >= 1))
    {
      if(!(iseof == 0))
        body->flags = body->flags | (unsigned int)0x02;

      return 0;
    }

    else
    {
      if(!(body->endpos >= body->readpos))
      {
        signed long int tmp_if_expr$1;
        if(!((signed long int)len >= body->readpos + -body->endpos + -1l))
          tmp_if_expr$1 = (signed long int)len;

        else
          tmp_if_expr$1 = (body->readpos - body->endpos) - (signed long int)1;
        wsize = (signed int)tmp_if_expr$1;
      }

      else
      {
        _Bool tmp_if_expr$5;
        if(!(body->max_store_size == 0l))
          tmp_if_expr$5 = body->endpos >= body->max_store_size ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
        {
          _Bool tmp_if_expr$3;
          if(!(body->readpos == 0l))
            tmp_if_expr$3 = (body->flags & (unsigned int)0x01) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
          {
            body->endpos = (signed long int)0;
            if((4u & body->flags) == 0u)
            {
              body->flags = body->flags | (unsigned int)0x04;
              if(CI_DEBUG_LEVEL >= 9)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Entering Ring mode!\n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Entering Ring mode!\n");

              }

            }

            signed long int tmp_if_expr$2;
            if(!((signed long int)len >= body->readpos + -body->endpos + -1l))
              tmp_if_expr$2 = (signed long int)len;

            else
              tmp_if_expr$2 = (body->readpos - body->endpos) - (signed long int)1;
            wsize = (signed int)tmp_if_expr$2;
          }

          else
          {
            if(!((1u & body->flags) == 0u))
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "File locked and no space on file for writing data, (Is this a bug?)!\n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("File locked and no space on file for writing data, (Is this a bug?)!\n");

              }

            }

            return 0;
          }
        }

        else
          if(!(body->max_store_size == 0l))
          {
            signed long int tmp_if_expr$4;
            if(!((signed long int)len >= body->max_store_size + -body->endpos))
              tmp_if_expr$4 = (signed long int)len;

            else
              tmp_if_expr$4 = body->max_store_size - body->endpos;
            wsize = (signed int)tmp_if_expr$4;
          }

          else
            wsize = len;
      }
      lseek64(body->fd, body->endpos, 0);
      ret=do_write(body->fd, (const void *)buf, (unsigned long int)wsize);
      if(!(ret >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location$6=__errno_location();
            return_value_strerror$7=strerror(*return_value___errno_location$6);
            __log_error((void *)0, "Cannot write to file: %s\n", return_value_strerror$7);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location$8=__errno_location();
            return_value_strerror$9=strerror(*return_value___errno_location$8);
            printf("Cannot write to file: %s\n", return_value_strerror$9);
          }

        }

      }

      else
      {
        body->endpos = body->endpos + (signed long int)ret;
        body->bytes_in = body->bytes_in + (signed long int)ret;
      }
      if(ret == len && !(iseof == 0))
      {
        body->flags = body->flags | (unsigned int)0x02;
        if(CI_DEBUG_LEVEL >= 9)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Body data size=%lld\n ", (signed long long int)body->endpos);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Body data size=%lld\n ", (signed long long int)body->endpos);

        }

      }

      return ret;
    }
}

// ci_sockaddr_set_port
// file include/net_io.h line 131
void ci_sockaddr_set_port(struct ci_sockaddr *addr, signed int port)
{
  addr->sockaddr.sin_port=htons((unsigned short int)port);
  addr->ci_sin_port = (signed int)addr->sockaddr.sin_port;
}

// ci_sockaddr_t_to_host
// file include/net_io.h line 135
const char * ci_sockaddr_t_to_host(struct ci_sockaddr *addr, char *hname, signed int maxhostlen)
{
  getnameinfo((struct sockaddr *)&addr->sockaddr, (unsigned int)(addr->ci_sin_family == 10 ? sizeof(struct sockaddr_in6) /*28ul*/  : sizeof(struct sockaddr_in) /*16ul*/ ), hname, (unsigned int)(maxhostlen - 1), (char *)(void *)0, (unsigned int)0, 0);
  return (const char *)hname;
}

// ci_sockaddr_t_to_ip
// file include/net_io.h line 123
const char * ci_sockaddr_t_to_ip(struct ci_sockaddr *addr, char *ip, signed int maxlen)
{
  const char *return_value_ci_inet_ntoa$1;
  return_value_ci_inet_ntoa$1=ci_inet_ntoa(addr->ci_sin_family, addr->ci_sin_addr, ip, maxlen);
  return return_value_ci_inet_ntoa$1;
}

// ci_stat_area_construct
// file stats.c line 198
struct stat_area * ci_stat_area_construct(void *mem_block, signed int size, void (*release_mem)(void *))
{
  struct stat_area *area = (struct stat_area *)(void *)0;
  signed int return_value_ci_stat_memblock_size$1;
  return_value_ci_stat_memblock_size$1=ci_stat_memblock_size();
  if(!(size >= return_value_ci_stat_memblock_size$1))
    return (struct stat_area *)(void *)0;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct stat_area) /*56ul*/ );
    area = (struct stat_area *)return_value_malloc$2;
    if(area == ((struct stat_area *)NULL))
      return (struct stat_area *)(void *)0;

    else
    {
      /* assertion ((struct stat_memblock *)mem_block)->sig == 0xFAFA */
      assert(((struct stat_memblock *)mem_block)->sig == (unsigned int)0xFAFA);
      ci_thread_mutex_init(&area->mtx);
      area->mem_block = (struct stat_memblock *)mem_block;
      area->release_mem = release_mem;
      area->mem_block->counters64 = (unsigned long int *)(mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
      area->mem_block->counterskbs = (struct kbs *)(mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)STAT_INT64.entries_num * sizeof(unsigned long int) /*8ul*/ ));
      area->mem_block->counters64_size = STAT_INT64.entries_num;
      area->mem_block->counterskbs_size = STAT_KBS.entries_num;
      ci_stat_area_reset(area);
      return area;
    }
  }
}

// ci_stat_area_destroy
// file stats.c line 236
void ci_stat_area_destroy(struct stat_area *area)
{
  ci_thread_mutex_destroy(&area->mtx);
  if(!(area->release_mem == ((void (*)(void *))NULL)))
    area->release_mem((void *)area->mem_block);

  free((void *)area);
}

// ci_stat_area_kbs_inc
// file stats.c line 257
void ci_stat_area_kbs_inc(struct stat_area *area, signed int ID, signed int count)
{
  if(!(area->mem_block == ((struct stat_memblock *)NULL)))
  {
    _Bool tmp_if_expr$1;
    if(!(ID >= 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ID >= area->mem_block->counterskbs_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      pthread_mutex_lock(&area->mtx);
      (area->mem_block->counterskbs + (signed long int)ID)->bytes = (area->mem_block->counterskbs + (signed long int)ID)->bytes + (unsigned int)count;
      (area->mem_block->counterskbs + (signed long int)ID)->kb = (area->mem_block->counterskbs + (signed long int)ID)->kb + (unsigned long int)((area->mem_block->counterskbs + (signed long int)ID)->bytes >> 10);
      (area->mem_block->counterskbs + (signed long int)ID)->bytes = (area->mem_block->counterskbs + (signed long int)ID)->bytes & (unsigned int)0x3FF;
      pthread_mutex_unlock(&area->mtx);
    }

  }

}

// ci_stat_area_merge
// file stats.c line 322
void ci_stat_area_merge(struct stat_area *dest, struct stat_area *src)
{
  _Bool tmp_if_expr$1;
  if(dest->mem_block == ((struct stat_memblock *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(src->mem_block != ((struct stat_memblock *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
    ci_stat_memblock_merge(dest->mem_block, src->mem_block);

}

// ci_stat_area_reset
// file stats.c line 221
void ci_stat_area_reset(struct stat_area *area)
{
  signed int i;
  pthread_mutex_lock(&area->mtx);
  i = 0;
  for( ; !(i >= area->mem_block->counters64_size); i = i + 1)
    area->mem_block->counters64[(signed long int)i] = (unsigned long int)0;
  i = 0;
  for( ; !(i >= area->mem_block->counterskbs_size); i = i + 1)
  {
    (area->mem_block->counterskbs + (signed long int)i)->kb = (unsigned long int)0;
    (area->mem_block->counterskbs + (signed long int)i)->bytes = (unsigned int)0;
  }
  pthread_mutex_unlock(&area->mtx);
}

// ci_stat_area_uint64_inc
// file stats.c line 245
void ci_stat_area_uint64_inc(struct stat_area *area, signed int ID, signed int count)
{
  if(!(area->mem_block == ((struct stat_memblock *)NULL)))
  {
    _Bool tmp_if_expr$1;
    if(!(ID >= 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ID >= area->mem_block->counters64_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      pthread_mutex_lock(&area->mtx);
      area->mem_block->counters64[(signed long int)ID] = area->mem_block->counters64[(signed long int)ID] + (unsigned long int)count;
      pthread_mutex_unlock(&area->mtx);
    }

  }

}

// ci_stat_attach_mem
// file stats.c line 152
void ci_stat_attach_mem(void *mem_block, signed int size, void (*release_mem)(void *))
{
  if(STATS == ((struct stat_area *)NULL))
    STATS=ci_stat_area_construct(mem_block, size, release_mem);

}

// ci_stat_entry_register
// file stats.c line 129
signed int ci_stat_entry_register(char *label, signed int type, char *group)
{
  signed int gid;
  gid=stat_group_add(group);
  if(!(gid >= 0))
    return -1;

  else
  {
    if(type == 0)
    {
      signed int return_value_stat_entry_add$1;
      return_value_stat_entry_add$1=stat_entry_add(&STAT_INT64, label, type, gid);
      return return_value_stat_entry_add$1;
    }

    else
      if(type == 1)
      {
        signed int return_value_stat_entry_add$2;
        return_value_stat_entry_add$2=stat_entry_add(&STAT_KBS, label, type, gid);
        return return_value_stat_entry_add$2;
      }

    return -1;
  }
}

// ci_stat_entry_release_lists
// file stats.c line 146
void ci_stat_entry_release_lists()
{
  stat_entry_release_list(&STAT_INT64);
  stat_entry_release_list(&STAT_KBS);
}

// ci_stat_kbs_inc
// file stats.c line 179
void ci_stat_kbs_inc(signed int ID, signed int count)
{
  if(!(STATS->mem_block == ((struct stat_memblock *)NULL)))
  {
    _Bool tmp_if_expr$1;
    if(!(ID >= 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ID >= STATS->mem_block->counterskbs_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      pthread_mutex_lock(&STATS->mtx);
      (STATS->mem_block->counterskbs + (signed long int)ID)->bytes = (STATS->mem_block->counterskbs + (signed long int)ID)->bytes + (unsigned int)count;
      (STATS->mem_block->counterskbs + (signed long int)ID)->kb = (STATS->mem_block->counterskbs + (signed long int)ID)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)ID)->bytes >> 10);
      (STATS->mem_block->counterskbs + (signed long int)ID)->bytes = (STATS->mem_block->counterskbs + (signed long int)ID)->bytes & (unsigned int)0x3FF;
      pthread_mutex_unlock(&STATS->mtx);
    }

  }

}

// ci_stat_memblock_merge
// file stats.c line 303
void ci_stat_memblock_merge(struct stat_memblock *dest_block, struct stat_memblock *mem_block)
{
  signed int i;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(!(dest_block == ((struct stat_memblock *)NULL)) && !(mem_block == ((struct stat_memblock *)NULL)))
  {
    i = 0;
    do
    {
      if(!(i >= dest_block->counters64_size))
        tmp_if_expr$1 = i < mem_block->counters64_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      dest_block->counters64[(signed long int)i] = dest_block->counters64[(signed long int)i] + mem_block->counters64[(signed long int)i];
      i = i + 1;
    }
    while((_Bool)1);
    i = 0;
    do
    {
      if(!(i >= dest_block->counterskbs_size))
        tmp_if_expr$2 = i < mem_block->counterskbs_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      (dest_block->counterskbs + (signed long int)i)->kb = (dest_block->counterskbs + (signed long int)i)->kb + (mem_block->counterskbs + (signed long int)i)->kb;
      (dest_block->counterskbs + (signed long int)i)->bytes = (dest_block->counterskbs + (signed long int)i)->bytes + (mem_block->counterskbs + (signed long int)i)->bytes;
      (dest_block->counterskbs + (signed long int)i)->kb = (dest_block->counterskbs + (signed long int)i)->kb + (unsigned long int)((dest_block->counterskbs + (signed long int)i)->bytes >> 10);
      (dest_block->counterskbs + (signed long int)i)->bytes = (dest_block->counterskbs + (signed long int)i)->bytes & (unsigned int)0x3FF;
      i = i + 1;
    }
    while((_Bool)1);
  }

}

// ci_stat_memblock_reset
// file stats.c line 292
void ci_stat_memblock_reset(struct stat_memblock *block)
{
  signed int i = 0;
  for( ; !(i >= block->counters64_size); i = i + 1)
    block->counters64[(signed long int)i] = (unsigned long int)0;
  i = 0;
  for( ; !(i >= block->counterskbs_size); i = i + 1)
  {
    (block->counterskbs + (signed long int)i)->kb = (unsigned long int)0;
    (block->counterskbs + (signed long int)i)->bytes = (unsigned int)0;
  }
}

// ci_stat_memblock_size
// file stats.c line 33
signed int ci_stat_memblock_size(void)
{
  return (signed int)((sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (unsigned long int)STAT_INT64.entries_num * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)STAT_KBS.entries_num * sizeof(struct kbs) /*16ul*/ );
}

// ci_stat_release
// file stats.c line 160
void ci_stat_release()
{
  if(!(STATS == ((struct stat_area *)NULL)))
  {
    ci_stat_area_destroy(STATS);
    STATS = (struct stat_area *)(void *)0;
  }

}

// ci_stat_uint64_inc
// file stats.c line 168
void ci_stat_uint64_inc(signed int ID, signed int count)
{
  _Bool tmp_if_expr$1;
  if(STATS == ((struct stat_area *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(STATS->mem_block != ((struct stat_memblock *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    _Bool tmp_if_expr$2;
    if(!(ID >= 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = ID >= STATS->mem_block->counters64_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$2)
    {
      pthread_mutex_lock(&STATS->mtx);
      STATS->mem_block->counters64[(signed long int)ID] = STATS->mem_block->counters64[(signed long int)ID] + (unsigned long int)count;
      pthread_mutex_unlock(&STATS->mtx);
    }

  }

}

// ci_str_trim
// file util.c line 108
void ci_str_trim(char *str)
{
  char *s;
  char *e;
  const unsigned short int **return_value___ctype_b_loc$1;
  const unsigned short int **return_value___ctype_b_loc$3;
  if(!(str == ((char *)NULL)))
  {
    s = str;
    e = (char *)(void *)0;
    do
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*s]) == 0)
        break;

      e = s;
      for( ; !((signed int)*e == 0); e = e + 1l)
        *e = e[(signed long int)1];
    }
    while((_Bool)1);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(str);
    e = str + (signed long int)return_value_strlen$2;
    e = e - 1l;
    do
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*e]) == 0)
        break;

      if(!(e >= str))
        break;

      *e = (char)0;
      e = e - 1l;
    }
    while((_Bool)1);
  }

}

// ci_str_trim2
// file util.c line 131
char * ci_str_trim2(char *s)
{
  char *e;
  const unsigned short int **return_value___ctype_b_loc$1;
  const unsigned short int **return_value___ctype_b_loc$3;
  if(s == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(s);
    e = s + (signed long int)return_value_strlen$2;
    e = e - 1l;
    do
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*e]) == 0)
        break;

      if(!(e >= s))
        break;

      *e = (char)0;
      e = e - 1l;
    }
    while((_Bool)1);
    return s;
  }
}

// ci_str_vector_iterate
// file array.c line 461
void ci_str_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const char *))
{
  ci_vector_iterate(vector, data, (signed int (*)(void *, const void *))fn);
}

// ci_str_vector_search
// file include/array.h line 549
const char * ci_str_vector_search(struct ci_vector *vector, const char *item)
{
  signed int i = 0;
  for( ; !(vector->items[(signed long int)i] == NULL); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)vector->items[(signed long int)i], item);
    if(return_value_strcmp$1 == 0)
      return (const char *)vector->items[(signed long int)i];

  }
  return (const char *)(void *)0;
}

// ci_strcasestr
// file util.c line 43
const char * ci_strcasestr(const char *str, const char *find)
{
  const char *s;
  const char *c;
  const char *f;
  s = str;
  for( ; !((signed int)*s == 0); s = s + 1l)
  {
    f = find;
    c = s;
    for( ; (_Bool)1; c = c + 1l)
    {
      if((signed int)*f == 0)
        return s;

      if((signed int)*c == 0)
        return (const char *)(void *)0;

      signed int return_value_tolower$1;
      return_value_tolower$1=tolower((signed int)*c);
      signed int return_value_tolower$2;
      return_value_tolower$2=tolower((signed int)*f);
      if(!(return_value_tolower$1 == return_value_tolower$2))
        break;

      f = f + 1l;
    }
  }
  return (const char *)(void *)0;
}

// ci_strerror
// file include/util.h line 57
char * ci_strerror(signed int error, char *buf, unsigned long int buflen)
{
  char *return_value_strerror_r$1;
  return_value_strerror_r$1=strerror_r(error, buf, buflen);
  return return_value_strerror_r$1;
}

// ci_strncasestr
// file util.c line 59
const char * ci_strncasestr(const char *s, const char *find, unsigned long int slen)
{
  unsigned long int len;
  len=strlen(find);
  signed int return_value_strncasecmp$1;
  if(len == 0ul)
    return (const char *)(void *)0;

  else
  {
    while(slen >= len)
    {
      signed int return_value_tolower$2;
      return_value_tolower$2=tolower((signed int)*s);
      signed int return_value_tolower$3;
      return_value_tolower$3=tolower((signed int)*find);
      if(return_value_tolower$2 == return_value_tolower$3)
      {
        return_value_strncasecmp$1=strncasecmp(s, find, len);
        if(return_value_strncasecmp$1 == 0)
          return s;

      }

      s = s + 1l;
      slen = slen - 1ul;
    }
    return (const char *)(void *)0;
  }
}

// ci_strnstr
// file include/util.h line 44
const char * ci_strnstr(const char *s, const char *find, unsigned long int slen)
{
  unsigned long int len;
  len=strlen(find);
  signed int return_value_strncmp$1;
  if(len == 0ul)
    return (const char *)(void *)0;

  else
  {
    while(slen >= len)
    {
      if(*s == *find)
      {
        return_value_strncmp$1=strncmp(s, find, len);
        if(return_value_strncmp$1 == 0)
          return s;

      }

      s = s + 1l;
      slen = slen - 1ul;
    }
    return (const char *)(void *)0;
  }
}

// ci_strtime
// file os/unix/utilfunc.c line 51
void ci_strtime(char *buf)
{
  struct tm br_tm;
  signed long int tm;
  time(&tm);
  struct tm *return_value_localtime_r$1;
  return_value_localtime_r$1=localtime_r(&tm, &br_tm);
  asctime_r(return_value_localtime_r$1, buf);
  buf[(signed long int)(64 - 1)] = (char)0;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(buf);
  buf[(signed long int)(return_value_strlen$2 - (unsigned long int)1)] = (char)0;
}

// ci_strtime_rfc822
// file os/unix/utilfunc.c line 61
void ci_strtime_rfc822(char *buf)
{
  struct tm br_tm;
  signed long int tm;
  time(&tm);
  gmtime_r(&tm, &br_tm);
  snprintf(buf, (unsigned long int)64, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", days[(signed long int)br_tm.tm_wday], br_tm.tm_mday, months[(signed long int)br_tm.tm_mon], br_tm.tm_year + 1900, br_tm.tm_hour, br_tm.tm_min, br_tm.tm_sec);
  buf[(signed long int)(64 - 1)] = (char)0;
}

// ci_thread_cond_destroy
// file os/unix/threads.c line 196
signed int ci_thread_cond_destroy(union anonymous$6 *pcond)
{
  signed int return_value_pthread_cond_destroy$1;
  return_value_pthread_cond_destroy$1=pthread_cond_destroy(pcond);
  return return_value_pthread_cond_destroy$1;
}

// ci_thread_cond_init
// file os/unix/threads.c line 191
signed int ci_thread_cond_init(union anonymous$6 *pcond)
{
  signed int return_value_pthread_cond_init$1;
  return_value_pthread_cond_init$1=pthread_cond_init(pcond, (const union anonymous$4 *)(void *)0);
  return return_value_pthread_cond_init$1;
}

// ci_thread_create
// file os/unix/threads.c line 201
signed int ci_thread_create(unsigned long int *pthread_id, void * (*pfunc)(void *), void *parg)
{
  signed int return_value_pthread_create$1;
  return_value_pthread_create$1=pthread_create(pthread_id, (const union pthread_attr_t *)(void *)0, pfunc, parg);
  return return_value_pthread_create$1;
}

// ci_thread_join
// file os/unix/threads.c line 206
signed int ci_thread_join(unsigned long int thread_id)
{
  signed int return_value_pthread_join$1;
  return_value_pthread_join$1=pthread_join(thread_id, (void **)(void *)0);
  return return_value_pthread_join$1;
}

// ci_thread_mutex_destroy
// file include/ci_threads.h line 40
signed int ci_thread_mutex_destroy(union anonymous$8 *pmutex)
{
  del_mutex((void *)pmutex);
  signed int return_value_pthread_mutex_destroy$1;
  return_value_pthread_mutex_destroy$1=pthread_mutex_destroy(pmutex);
  return return_value_pthread_mutex_destroy$1;
}

// ci_thread_mutex_init
// file include/ci_threads.h line 39
signed int ci_thread_mutex_init(union anonymous$8 *pmutex)
{
  signed int ret;
  ret=pthread_mutex_init(pmutex, (const union anonymous$4 *)(void *)0);
  if(!(ret == 0))
    return ret;

  else
  {
    add_mutex((void *)pmutex, 0);
    return ret;
  }
}

// ci_thread_rwlock_destroy
// file os/unix/threads.c line 154
signed int ci_thread_rwlock_destroy(union anonymous$10 *rwlock)
{
  del_mutex((void *)rwlock);
  signed int return_value_pthread_rwlock_destroy$1;
  return_value_pthread_rwlock_destroy$1=pthread_rwlock_destroy(rwlock);
  return return_value_pthread_rwlock_destroy$1;
}

// ci_thread_rwlock_init
// file os/unix/threads.c line 144
signed int ci_thread_rwlock_init(union anonymous$10 *rwlock)
{
  signed int ret;
  ret=pthread_rwlock_init(rwlock, (const union anonymous$7 *)(void *)0);
  if(!(ret == 0))
    return ret;

  else
  {
    add_mutex((void *)rwlock, 1);
    return ret;
  }
}

// ci_txt_template_build_content
// file txtTemplate.c line 396
struct ci_membuf * ci_txt_template_build_content(const struct ci_request *req, const char *SERVICE_NAME, const char *TEMPLATE_NAME, struct ci_fmt_entry *user_table)
{
  struct ci_membuf *content;
  char templpath[4096l];
  struct anonymous$20 *template = (struct anonymous$20 *)(void *)0;
  content=ci_membuf_new_sized(TEMPLATE_MEMBUF_SIZE);
  unsigned long int return_value_strlen$1;
  if(content == ((struct ci_membuf *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to allocate buffer to load template!");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to allocate buffer to load template!");

    }

    return (struct ci_membuf *)(void *)0;
  }

  else
  {
    template=templateLoadText(req, SERVICE_NAME, TEMPLATE_NAME);
    if(!(template == ((struct anonymous$20 *)NULL)))
    {
      content->endpos=ci_format_text((struct ci_request *)req, template->data->buf, content->buf, content->bufsize, user_table);
      ci_membuf_write(content, "\0", 1, 1);
      if(!(template->LANGUAGE == ((char *)NULL)))
      {
        return_value_strlen$1=strlen(template->LANGUAGE);
        ci_membuf_attr_add(content, "lang", (const void *)template->LANGUAGE, return_value_strlen$1 + (unsigned long int)1);
      }

      template_release(template);
    }

    else
    {
      makeTemplatePathFileName(templpath, 4096, SERVICE_NAME, TEMPLATE_NAME, TEMPLATE_DEF_LANG);
      content->endpos=snprintf(content->buf, (unsigned long int)content->bufsize, "ERROR: Unable to find specified template: %s\n", (const void *)templpath);
      if(!(content->bufsize >= content->endpos))
        content->endpos = content->bufsize;

      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(TEMPLATE_DEF_LANG);
      ci_membuf_attr_add(content, "lang", (const void *)TEMPLATE_DEF_LANG, return_value_strlen$2 + (unsigned long int)1);
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ERROR: Unable to find specified template: %s\n", (const void *)templpath);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ERROR: Unable to find specified template: %s\n", (const void *)templpath);

      }

    }
    return content;
  }
}

// ci_txt_template_close
// file txtTemplate.c line 192
void ci_txt_template_close(void)
{
  signed int i;
  if(!(templates == ((struct anonymous$20 *)NULL)))
  {
    i = 0;
    for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
      templateFree(&templates[(signed long int)i]);
    free((void *)templates);
    templates = (struct anonymous$20 *)(void *)0;
    ci_thread_mutex_destroy(&templates_mutex);
  }

}

// ci_txt_template_init
// file txtTemplate.c line 77
signed int ci_txt_template_init(void)
{
  signed int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)TEMPLATE_CACHE_SIZE * sizeof(struct anonymous$20) /*72ul*/ );
  templates = (struct anonymous$20 *)return_value_malloc$1;
  if(templates == ((struct anonymous$20 *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Unable to allocate memory in in inittxtTemplate for template storage!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Unable to allocate memory in in inittxtTemplate for template storage!\n");

    }

    return -1;
  }

  else
  {
    i = 0;
    for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    {
      (templates + (signed long int)i)->data = (struct ci_membuf *)(void *)0;
      (templates + (signed long int)i)->loaded = (signed long int)0;
      (templates + (signed long int)i)->locked = 0;
      (templates + (signed long int)i)->must_free = 0;
      (templates + (signed long int)i)->non_cached = 0;
    }
    txtTemplateInited = 1;
    ci_thread_mutex_init(&templates_mutex);
    return 1;
  }
}

// ci_txt_template_reset
// file txtTemplate.c line 181
void ci_txt_template_reset(void)
{
  signed int i = 0;
  pthread_mutex_lock(&templates_mutex);
  i = 0;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    templateFree(&templates[(signed long int)i]);
  pthread_mutex_unlock(&templates_mutex);
}

// ci_txt_template_set_default_lang
// file txtTemplate.c line 104
void ci_txt_template_set_default_lang(const char *lang)
{
  TEMPLATE_DEF_LANG = lang;
}

// ci_txt_template_set_dir
// file txtTemplate.c line 99
void ci_txt_template_set_dir(const char *dir)
{
  TEMPLATE_DIR = dir;
}

// ci_uncompress_preview
// file decode.c line 313
signed int ci_uncompress_preview(signed int compress_method, const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len)
{
  signed int return_value_zlib_inflate$1;
  return_value_zlib_inflate$1=zlib_inflate(buf, len, unzipped_buf, unzipped_buf_len);
  return return_value_zlib_inflate$1;
  return -1;
}

// ci_usleep
// file os/unix/utilfunc.c line 85
signed int ci_usleep(unsigned long int usec)
{
  struct timespec us;
  struct timespec ur;
  us.tv_sec = (signed long int)0;
  us.tv_nsec = (signed long int)(usec * (unsigned long int)1000);
  nanosleep(&us, &ur);
  return 0;
}

// ci_vector_add
// file ../include/array.h line 480
void * ci_vector_add(struct ci_vector *vector, const void *value, unsigned long int size)
{
  void *item;
  void **indx;
  struct ci_mem_allocator *packer = vector->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value_ci_pack_allocator_alloc_unaligned$1;
  return_value_ci_pack_allocator_alloc_unaligned$1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((void **)0)[(signed long int)1]);
  indx = (void **)return_value_ci_pack_allocator_alloc_unaligned$1;
  item=ci_pack_allocator_alloc_from_rear(packer, (signed int)size);
  if(item == NULL || indx == ((void **)NULL))
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item to vector!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item to vector!\n");

    }

    return (void *)0;
  }

  else
  {
    memcpy(item, value, size);
    *vector->last = item;
    vector->last = indx;
    *vector->last = (void *)0;
    vector->count = vector->count + 1;
    return item;
  }
}

// ci_vector_cast_from_voidvoid
// file array.c line 386
struct ci_vector * ci_vector_cast_from_voidvoid(const void **p)
{
  const void *buf;
  struct ci_vector *v = (struct ci_vector *)((void *)p - (signed long int)(sizeof(struct ci_vector) /*48ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  unsigned long int return_value_ci_pack_allocator_required_size$1;
  return_value_ci_pack_allocator_required_size$1=ci_pack_allocator_required_size();
  buf = (void *)v - (signed long int)return_value_ci_pack_allocator_required_size$1;
  /* assertion v->mem == buf */
  assert(v->mem == (char *)buf);
  unsigned long int return_value_ci_buffer_blocksize$2;
  return_value_ci_buffer_blocksize$2=ci_buffer_blocksize(buf);
  /* assertion ci_buffer_blocksize(buf) != 0 */
  assert(return_value_ci_buffer_blocksize$2 != (unsigned long int)0);
  return v;
}

// ci_vector_cast_to_voidvoid
// file array.c line 381
const void ** ci_vector_cast_to_voidvoid(struct ci_vector *vector)
{
  return (const void **)vector->items;
}

// ci_vector_create
// file ../include/array.h line 463
struct ci_vector * ci_vector_create(unsigned long int max_size)
{
  struct ci_vector *vector;
  struct ci_mem_allocator *packer;
  void *buffer;
  void **indx;
  buffer=ci_buffer_alloc((signed int)max_size);
  if(buffer == NULL)
    return (struct ci_vector *)(void *)0;

  else
  {
    packer=ci_create_pack_allocator_on_memblock((char *)buffer, max_size);
    if(packer == ((struct ci_mem_allocator *)NULL))
    {
      ci_buffer_free(buffer);
      return (struct ci_vector *)(void *)0;
    }

    else
    {
      void *return_value_ci_pack_allocator_alloc$1;
      return_value_ci_pack_allocator_alloc$1=ci_pack_allocator_alloc(packer, sizeof(struct ci_vector) /*48ul*/ );
      vector = (struct ci_vector *)return_value_ci_pack_allocator_alloc$1;
      void *return_value_ci_pack_allocator_alloc_unaligned$2;
      return_value_ci_pack_allocator_alloc_unaligned$2=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((void **)0)[(signed long int)1]);
      indx = (void **)return_value_ci_pack_allocator_alloc_unaligned$2;
      if(indx == ((void **)NULL) || vector == ((struct ci_vector *)NULL))
      {
        ci_buffer_free(buffer);
        ci_mem_allocator_destroy(packer);
        return (struct ci_vector *)(void *)0;
      }

      else
      {
        *indx = (void *)0;
        vector->max_size = max_size;
        vector->mem = (char *)buffer;
        vector->items = indx;
        vector->last = indx;
        vector->count = 0;
        vector->alloc = packer;
        return vector;
      }
    }
  }
}

// ci_vector_destroy
// file ../include/array.h line 470
void ci_vector_destroy(struct ci_vector *vector)
{
  void *buffer = (void *)vector->mem;
  /* assertion buffer */
  assert(buffer != NULL);
  if(!(vector->alloc == ((struct ci_mem_allocator *)NULL)))
    ci_mem_allocator_destroy(vector->alloc);

  ci_buffer_free(buffer);
}

// ci_vector_iterate
// file array.c line 452
void ci_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const void *))
{
  signed int i;
  signed int ret = 0;
  i = 0;
  if(ret == 0 && !(vector->items[(signed long int)i] == NULL))
  {
    ret=fn(data, vector->items[(signed long int)i]);
    i = i + 1;
  }

}

// ci_vector_pop
// file array.c line 427
void * ci_vector_pop(struct ci_vector *vector)
{
  void *p;
  if(vector->count == 0)
    return (void *)0;

  else
  {
    ci_pack_allocator_set_start_pos(vector->alloc, (void *)vector->last);
    vector->count = vector->count - 1;
    vector->last = &vector->items[(signed long int)vector->count];
    if(vector->count == 0)
      ci_pack_allocator_set_end_pos(vector->alloc, (void *)0);

    else
      ci_pack_allocator_set_end_pos(vector->alloc, vector->items[(signed long int)(vector->count - 1)]);
    p = *vector->last;
    *vector->last = (void *)0;
    return p;
  }
}

// ci_wait_for_data
// file include/net_io.h line 144
signed int ci_wait_for_data(signed int fd, signed int secs, signed int what_wait)
{
  struct anonymous rfds;
  struct anonymous wfds;
  struct anonymous *preadfds;
  struct anonymous *pwritefds;
  struct timeval tv;
  signed int ret = 0;
  if(secs >= 0)
  {
    tv.tv_sec = (signed long int)secs;
    tv.tv_usec = (signed long int)0;
  }

  preadfds = (struct anonymous *)(void *)0;
  pwritefds = (struct anonymous *)(void *)0;
  if(!((0x1 & what_wait) == 0))
  {
    do
    {
      signed int __d0;
      signed int ci_wait_for_data$$1$$2$$1$$__d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(ci_wait_for_data$$1$$2$$1$$__d1) : "a"(0), "0"(sizeof(struct anonymous) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&rfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    preadfds = &rfds;
  }

  if(!((0x2 & what_wait) == 0))
  {
    do
    {
      signed int ci_wait_for_data$$1$$3$$1$$__d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(ci_wait_for_data$$1$$3$$1$$__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wfds)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&wfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    pwritefds = &wfds;
  }

  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  ret=select(fd + 1, preadfds, pwritefds, (struct anonymous *)(void *)0, secs >= 0 ? &tv : (struct timeval *)(void *)0);
  signed int *return_value___errno_location$4;
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$3;
  if(ret >= 1)
  {
    ret = 0;
    if(!(preadfds == ((struct anonymous *)NULL)))
    {
      if(!((preadfds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
        ret = 0x1;

    }

    if(!(pwritefds == ((struct anonymous *)NULL)))
    {
      if(!((pwritefds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
        ret = ret | 0x2;

    }

    return ret;
  }

  else
  {
    if(!(ret >= 0))
    {
      return_value___errno_location$4=__errno_location();
      if(!(*return_value___errno_location$4 == 4))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location$2=__errno_location();
            __log_error((void *)0, "Fatal error while waiting for new data (errno=%d....\n", *return_value___errno_location$2);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location$3=__errno_location();
            printf("Fatal error while waiting for new data (errno=%d....\n", *return_value___errno_location$3);
          }

        }

        return -1;
      }

    }

    return 0;
  }
}

// ci_write
// file include/net_io.h line 151
signed int ci_write(signed int fd, const void *buf, unsigned long int count, signed int timeout)
{
  signed int bytes = 0;
  signed int remains = (signed int)count;
  char *b = (char *)buf;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$8;
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  while(remains >= 1)
  {
    do
    {
      signed long int return_value_write$3;
      return_value_write$3=write(fd, (const void *)b, (unsigned long int)remains);
      bytes = (signed int)return_value_write$3;
      if(bytes == -1)
      {
        return_value___errno_location$1=__errno_location();
        tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
    }
    while(tmp_if_expr$2);
    if(bytes == -1)
    {
      return_value___errno_location$8=__errno_location();
      if(*return_value___errno_location$8 == 11)
      {
        signed int return_value_ci_wait_for_data$4;
        return_value_ci_wait_for_data$4=ci_wait_for_data(fd, timeout, 0x2);
        if(return_value_ci_wait_for_data$4 == 0)
          return bytes;

        do
        {
          signed long int return_value_write$7;
          return_value_write$7=write(fd, (const void *)b, (unsigned long int)remains);
          bytes = (signed int)return_value_write$7;
          if(bytes == -1)
          {
            return_value___errno_location$5=__errno_location();
            tmp_if_expr$6 = *return_value___errno_location$5 == 4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$6 = (_Bool)0;
        }
        while(tmp_if_expr$6);
      }

    }

    if(!(bytes >= 0))
      return bytes;

    b = b + (signed long int)bytes;
    remains = remains - bytes;
  }
  return (signed int)count;
}

// ci_write_nonblock
// file include/net_io.h line 153
signed int ci_write_nonblock(signed int fd, const void *buf, unsigned long int count)
{
  signed int bytes = 0;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    signed long int return_value_write$3;
    return_value_write$3=write(fd, buf, count);
    bytes = (signed int)return_value_write$3;
    if(bytes == -1)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  signed int *return_value___errno_location$4;
  if(!(bytes >= 0))
  {
    return_value___errno_location$4=__errno_location();
    if(*return_value___errno_location$4 == 11)
      return 0;

  }

  return bytes;
}

// ci_writen
// file request_common.c line 801
static signed int ci_writen(signed int fd, char *buf, signed int len, signed int timeout)
{
  signed int ret = 0;
  signed int remains = len;
  for( ; !(remains == 0); remains = remains - ret)
  {
    ret=ci_write(fd, (const void *)buf, (unsigned long int)remains, timeout);
    if(!(ret >= 0))
      return ret;

    buf = buf + (signed long int)ret;
  }
  return len;
}

// client_build_headers
// file request_common.c line 1281
static signed int client_build_headers(struct ci_request *req, signed int has_reqhdr, signed int has_reshdr, signed int has_body)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(!(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      ci_request_release_entity(req, i);

  i = 0;
  if(!(has_reqhdr == 0))
  {
    signed int tmp_post$1 = i;
    i = i + 1;
    req->entities[(signed long int)tmp_post$1]=ci_request_alloc_entity(req, 0, 0);
  }

  if(!(has_reshdr == 0))
  {
    signed int tmp_post$2 = i;
    i = i + 1;
    req->entities[(signed long int)tmp_post$2]=ci_request_alloc_entity(req, 1, 0);
  }

  if(!(has_body == 0))
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, req->type == 0x04 ? 3 : 2, 0);

  else
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 4, 0);
  return 1;
}

// client_create_request
// file request_common.c line 724
static signed int client_create_request(struct ci_request *req, char *servername, char *service, signed int reqtype)
{
  char buf[256l];
  if(!(reqtype == 0x01) && !(reqtype == 0x02) && !(reqtype == 0x04))
    return -1;

  else
  {
    req->type = reqtype;
    const char *tmp_if_expr$1;
    if(reqtype >= 0x01 && !(reqtype >= 5))
      tmp_if_expr$1 = ci_methods[(signed long int)reqtype];

    else
      tmp_if_expr$1 = "UNKNOWN";
    snprintf(buf, (unsigned long int)255, "%s icap://%s/%s ICAP/1.0", tmp_if_expr$1, servername, service);
    buf[(signed long int)255] = (char)0;
    ci_headers_add(req->request_header, buf);
    snprintf(buf, (unsigned long int)255, "Host: %s", servername);
    buf[(signed long int)255] = (char)0;
    ci_headers_add(req->request_header, buf);
    ci_headers_add(req->request_header, "User-Agent: C-ICAP-Client-Library/0.01");
    _Bool tmp_if_expr$2;
    if(!(req->allow204 == 0))
      tmp_if_expr$2 = req->allow206 != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      ci_headers_add(req->request_header, "Allow: 204, 206");

    else
      if(!(req->allow204 == 0))
        ci_headers_add(req->request_header, "Allow: 204");

    if(!(req->allow206 == 0))
      ci_headers_add(req->request_header, "Allow: 206");

    if(!(req->xheaders->used == 0))
      ci_headers_addheaders(req->request_header, req->xheaders);

    return 1;
  }
}

// client_parse_encaps_header
// file request_common.c line 921
static signed int client_parse_encaps_header(struct ci_request *req, struct ci_headers_list *h, signed int size)
{
  signed int remains;
  signed int readed = 0;
  char *buf_end = (char *)(void *)0;
  remains = size - h->bufused;
  if(!(remains >= 0))
    return -1;

  else
    if(remains == 0)
      return 1;

    else
    {
      if(req->pstrblock_read_len >= 1)
      {
        signed int tmp_if_expr$1;
        if(!(req->pstrblock_read_len >= remains))
          tmp_if_expr$1 = req->pstrblock_read_len;

        else
          tmp_if_expr$1 = remains;
        readed = tmp_if_expr$1;
        memcpy((void *)(h->buf + (signed long int)h->bufused), (const void *)req->pstrblock_read, (unsigned long int)readed);
        h->bufused = h->bufused + readed;
        req->pstrblock_read = req->pstrblock_read + (signed long int)readed;
        req->pstrblock_read_len = req->pstrblock_read_len - readed;
      }

      if(!(h->bufused >= size))
        return 2;

      else
      {
        buf_end = h->buf + (signed long int)h->bufused;
        signed int return_value_strncmp$2;
        return_value_strncmp$2=strncmp(buf_end - (signed long int)4, "\r\n\r\n", (unsigned long int)4);
        if(return_value_strncmp$2 == 0)
        {
          h->bufused = h->bufused - 2;
          return 1;
        }

        else
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error parsing encapsulated headers,no \\r\\n\\r\\n at the end of headers:%s!\n", buf_end);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error parsing encapsulated headers,no \\r\\n\\r\\n at the end of headers:%s!\n", buf_end);

          }

          return -1;
        }
      }
    }
}

// client_parse_icap_header
// file request_common.c line 891
static signed int client_parse_icap_header(struct ci_request *req, struct ci_headers_list *h)
{
  signed int readed = 0;
  signed int eoh = 0;
  char *buf;
  char *end;
  if(!(req->pstrblock_read_len >= 4))
    return 2;

  else
  {
    end=strstr(req->pstrblock_read, "\r\n\r\n");
    if(!(end == ((char *)NULL)))
    {
      readed = (signed int)((end - req->pstrblock_read) + (signed long int)4);
      eoh = 1;
    }

    else
      readed = req->pstrblock_read_len - 3;
    signed int return_value_check_realloc$1;
    return_value_check_realloc$1=check_realloc(&h->buf, &h->bufsize, h->bufused, readed);
    if(!(return_value_check_realloc$1 == 1))
      return -1;

    else
    {
      buf = h->buf + (signed long int)h->bufused;
      memcpy((void *)buf, (const void *)req->pstrblock_read, (unsigned long int)readed);
      h->bufused = h->bufused + readed;
      req->pstrblock_read = req->pstrblock_read + (signed long int)readed;
      req->pstrblock_read_len = req->pstrblock_read_len - readed;
      if(eoh == 0)
        return 2;

      else
      {
        h->bufused = h->bufused - 2;
        return 1;
      }
    }
  }
}

// client_parse_incoming_data
// file request_common.c line 1082
static signed int client_parse_incoming_data(struct ci_request *req, void *data_dest, signed int (*dest_write)(void *, char *, signed int))
{
  signed int ret;
  signed int v1;
  signed int v2;
  signed int status;
  signed int bytes;
  signed int size;
  char *buf;
  const char *val;
  struct ci_headers_list *resp_heads;
  if(req->status == 0)
  {
    ret=client_parse_icap_header(req, req->response_header);
    if(!(ret == 1))
      return ret;

    sscanf(req->response_header->buf, "ICAP/%d.%d %d", &v1, &v2, &status);
    if(CI_DEBUG_LEVEL >= 3)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Response was with status:%d \n", status);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Response was with status:%d \n", status);

    }

    ci_headers_unpack(req->response_header);
    if(!(req->allow204 == 0))
    {
      if(status == 204)
      {
        req->status = 4;
        return 204;
      }

    }

    val=ci_headers_search(req->response_header, "Encapsulated");
    if(val == ((const char *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "No encapsulated entities!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("No encapsulated entities!\n");

      }

      return -1;
    }

    process_encapsulated(req, val);
    if(req->entities[0l] == ((struct ci_encaps_entity *)NULL))
      return -1;

    if(req->entities[1l] == ((struct ci_encaps_entity *)NULL))
    {
      req->status = 3;
      if(req->pstrblock_read_len == 0)
        return 2;

    }

    else
    {
      req->status = 1;
      size = req->entities[(signed long int)1]->start - req->entities[(signed long int)0]->start;
      resp_heads = (struct ci_headers_list *)req->entities[(signed long int)0]->entity;
      signed int return_value_ci_headers_setsize$1;
      return_value_ci_headers_setsize$1=ci_headers_setsize(resp_heads, size);
      if(return_value_ci_headers_setsize$1 == 0)
        return -1;

    }
  }

  if(req->status == 1)
  {
    size = req->entities[(signed long int)1]->start - req->entities[(signed long int)0]->start;
    resp_heads = (struct ci_headers_list *)req->entities[(signed long int)0]->entity;
    ret=client_parse_encaps_header(req, resp_heads, size);
    if(!(ret == 1))
      return ret;

    ci_headers_unpack(resp_heads);
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "OK reading headers, going to read body\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("OK reading headers, going to read body\n");

    }

    req->current_chunk_len = (unsigned int)0;
    req->chunk_bytes_read = (unsigned int)0;
    req->write_to_module_pending = (unsigned int)0;
    if(req->entities[1l]->type == 4)
    {
      req->status = 4;
      return 1;
    }

    req->status = 3;
    if(!(req->pstrblock_read_len == 0))
      goto __CPROVER_DUMP_L17;

    return 2;
  }

  else
  {

  __CPROVER_DUMP_L17:
    ;
    if(req->status == 3)
    {
      do
      {
        ret=parse_chunk_data(req, &buf);
        if(ret == -1)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error parsing chunks, current chunk len: %d, read: %d, readlen: %d, str: %s\n", req->current_chunk_len, req->chunk_bytes_read, req->pstrblock_read_len, req->pstrblock_read);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error parsing chunks, current chunk len: %d, read: %d, readlen: %d, str: %s\n", req->current_chunk_len, req->chunk_bytes_read, req->pstrblock_read_len, req->pstrblock_read);

          }

          return -1;
        }

        if(req->write_to_module_pending >= 1u)
        {
          bytes=dest_write(data_dest, buf, (signed int)req->write_to_module_pending);
          if(!(bytes >= 0))
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error writing to output file!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error writing to output file!\n");

            }

            return -1;
          }

          req->write_to_module_pending = req->write_to_module_pending - (unsigned int)bytes;
        }

        if(ret == -2)
        {
          req->status = 4;
          return 1;
        }

      }
      while(!(ret == 2));
      return 2;
    }

    else
      return 1;
  }
}

// client_prepere_body_chunk
// file request_common.c line 1052
static signed int client_prepere_body_chunk(struct ci_request *req, void *data, signed int (*readdata)(void *, char *, signed int))
{
  signed int chunksize;
  signed int def_bytes;
  char *wbuf = (char *)(void *)0;
  char tmpbuf[30l];
  wbuf = req->wbuf + (signed long int)30;
  chunksize=readdata(data, wbuf, 4064);
  if(!(chunksize >= 1))
  {
    req->remain_send_block_bytes = 0;
    return chunksize;
  }

  else
  {
    wbuf = wbuf + (signed long int)chunksize;
    char *tmp_post$1 = wbuf;
    wbuf = wbuf + 1l;
    *tmp_post$1 = (char)13;
    *wbuf = (char)10;
    def_bytes=snprintf(tmpbuf, (unsigned long int)30, "%x\r\n", chunksize);
    wbuf = (req->wbuf + (signed long int)30) - (signed long int)def_bytes;
    memcpy((void *)wbuf, (const void *)tmpbuf, (unsigned long int)def_bytes);
    req->pstrblock_responce = wbuf;
    req->remain_send_block_bytes = def_bytes + chunksize + 2;
    return req->remain_send_block_bytes;
  }
}

// client_send_get_data
// file request_common.c line 1200
static signed int client_send_get_data(struct ci_request *req, signed int timeout, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int))
{
  signed int io_ret;
  signed int read_status;
  signed int bytes;
  signed int io_action;
  signed int return_value_client_prepere_body_chunk$1;
  if(!(req->pstrblock_read_len == 0))
  {
    read_status=client_parse_incoming_data(req, data_dest, dest_write);
    if(read_status == -1)
      return -1;

    if(read_status == 204)
      return 204;

    if(!(req->status == 4))
      goto __CPROVER_DUMP_L3;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(data_source == NULL)
      req->eof_received = 1;

    if(req->eof_received == 0)
      io_action = 0x3;

    else
      io_action = 0x1;
    while(!(io_action == 0))
    {
      io_ret=ci_wait_for_data(req->connection->fd, timeout, io_action);
      if(io_ret == 0)
        break;

      if(!(io_ret >= 0))
        return -1;

      if(!((0x2 & io_ret) == 0))
      {
        if(req->remain_send_block_bytes == 0)
        {
          if(!(data_source == NULL))
          {
            return_value_client_prepere_body_chunk$1=client_prepere_body_chunk(req, data_source, source_read);
            if(!(return_value_client_prepere_body_chunk$1 >= 1))
            {
              req->eof_received = 1;
              req->pstrblock_responce = (char *)eof_str;
              req->remain_send_block_bytes = 5;
            }

          }

        }

        bytes=ci_write_nonblock(req->connection->fd, (const void *)req->pstrblock_responce, (unsigned long int)req->remain_send_block_bytes);
        if(!(bytes >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)bytes;
        req->pstrblock_responce = req->pstrblock_responce + (signed long int)bytes;
        req->remain_send_block_bytes = req->remain_send_block_bytes - bytes;
      }

      _Bool tmp_if_expr$2;
      if(!(req->eof_received == 0))
        tmp_if_expr$2 = req->remain_send_block_bytes == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        io_action = 0;

      else
        io_action = 0x2;
      if(!((0x1 & io_ret) == 0))
      {
        signed int return_value_net_data_read$3;
        return_value_net_data_read$3=net_data_read(req);
        if(return_value_net_data_read$3 == -1)
          return -1;

        read_status=client_parse_incoming_data(req, data_dest, dest_write);
        if(read_status == -1)
          return -1;

        if(read_status == 204)
          return 204;

      }

      if(!(req->status == 4))
        io_action = io_action | 0x1;

    }
    return 1;
  }
}

// client_send_request_headers
// file request_common.c line 816
static signed int client_send_request_headers(struct ci_request *req, signed int has_eof, signed int timeout)
{
  struct ci_encaps_entity **elist;
  struct ci_encaps_entity *e;
  struct ci_headers_list *headers;
  signed int bytes;
  ci_request_pack(req);
  signed int return_value_ci_writen$1;
  return_value_ci_writen$1=ci_writen(req->connection->fd, req->request_header->buf, req->request_header->bufused, timeout);
  struct ci_encaps_entity **tmp_post$2;
  if(!(return_value_ci_writen$1 >= 0))
    return -1;

  else
  {
    req->bytes_out = req->bytes_out + (unsigned long int)req->request_header->bufused;
    elist = req->entities;
    do
    {
      tmp_post$2 = elist;
      elist = elist + 1l;
      e = *tmp_post$2;
      if(e == ((struct ci_encaps_entity *)NULL))
        break;

      _Bool tmp_if_expr$4;
      if(e->type == 0)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = e->type == 1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        headers = (struct ci_headers_list *)e->entity;
        signed int return_value_ci_writen$3;
        return_value_ci_writen$3=ci_writen(req->connection->fd, headers->buf, headers->bufused, timeout);
        if(!(return_value_ci_writen$3 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)headers->bufused;
      }

    }
    while((_Bool)1);
    _Bool tmp_if_expr$10;
    if(req->preview >= 1)
      tmp_if_expr$10 = req->preview_data.used > 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
    {
      bytes=sprintf(req->wbuf, "%x\r\n", req->preview);
      signed int return_value_ci_writen$5;
      return_value_ci_writen$5=ci_writen(req->connection->fd, req->wbuf, bytes, timeout);
      if(!(return_value_ci_writen$5 >= 0))
        return -1;

      req->bytes_out = req->bytes_out + (unsigned long int)bytes;
      signed int return_value_ci_writen$6;
      return_value_ci_writen$6=ci_writen(req->connection->fd, req->preview_data.buf, req->preview, timeout);
      if(!(return_value_ci_writen$6 >= 0))
        return -1;

      req->bytes_out = req->bytes_out + (unsigned long int)req->preview;
      if(!(has_eof == 0))
      {
        signed int return_value_ci_writen$7;
        return_value_ci_writen$7=ci_writen(req->connection->fd, "\r\n0; ieof\r\n\r\n", 13, timeout);
        if(!(return_value_ci_writen$7 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)13;
        req->eof_received = 1;
      }

      else
      {
        signed int return_value_ci_writen$8;
        return_value_ci_writen$8=ci_writen(req->connection->fd, "\r\n0\r\n\r\n", 7, timeout);
        if(!(return_value_ci_writen$8 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)7;
      }
    }

    else
      if(req->preview == 0)
      {
        signed int return_value_ci_writen$9;
        return_value_ci_writen$9=ci_writen(req->connection->fd, "0\r\n\r\n", 5, timeout);
        if(!(return_value_ci_writen$9 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)5;
      }

    return 1;
  }
}

// common_mutex_destroy
// file cache.c line 114
signed int common_mutex_destroy(struct common_mutex *mtx)
{
  if(!(mtx->isproc == 0))
    return 0;

  else
  {
    signed int return_value_ci_thread_mutex_destroy$1;
    return_value_ci_thread_mutex_destroy$1=ci_thread_mutex_destroy(&mtx->mtx.thread_mutex);
    return return_value_ci_thread_mutex_destroy$1;
  }
}

// common_mutex_init
// file cache.c line 105
signed int common_mutex_init(struct common_mutex *mtx, signed int proc_mtx)
{
  if(!(proc_mtx == 0))
    return 0;

  else
  {
    mtx->isproc = 0;
    signed int return_value_ci_thread_mutex_init$1;
    return_value_ci_thread_mutex_init$1=ci_thread_mutex_init(&mtx->mtx.thread_mutex);
    return return_value_ci_thread_mutex_init$1;
  }
}

// common_mutex_lock
// file cache.c line 121
signed int common_mutex_lock(struct common_mutex *mtx)
{
  if(!(mtx->isproc == 0))
    return 0;

  else
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&mtx->mtx.thread_mutex);
    return return_value_pthread_mutex_lock$1;
  }
}

// common_mutex_unlock
// file cache.c line 128
signed int common_mutex_unlock(struct common_mutex *mtx)
{
  if(!(mtx->isproc == 0))
    return 0;

  else
  {
    signed int return_value_pthread_mutex_unlock$1;
    return_value_pthread_mutex_unlock$1=pthread_mutex_unlock(&mtx->mtx.thread_mutex);
    return return_value_pthread_mutex_unlock$1;
  }
}

// datatype_cmp
// file types_ops.c line 330
signed int datatype_cmp(const void *key1, const void *key2)
{
  unsigned int type = *((unsigned int *)key1);
  if(key2 == NULL)
    return -1;

  else
    if((0xFFFF0000 & type) == 0u)
      return (signed int)(*((unsigned int *)key1) - *((unsigned int *)key2));

    else
    {
      type = type >> 16;
      signed int return_value_ci_magic_group_check$1;
      return_value_ci_magic_group_check$1=ci_magic_group_check((signed int)*((unsigned int *)key2), (signed int)type);
      if(!(return_value_ci_magic_group_check$1 == 0))
        return 0;

      else
        return 1;
    }
}

// datatype_dup
// file types_ops.c line 311
void * datatype_dup(const char *str, struct ci_mem_allocator *allocator)
{
  signed int type;
  unsigned int *val;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(unsigned int) /*4ul*/ );
  val = (unsigned int *)return_value;
  type=ci_magic_type_id(str);
  if(type >= 0)
    *val = (unsigned int)type;

  else
  {
    type=ci_magic_group_id(str);
    if(type >= 0)
    {
      *val = (unsigned int)type;
      *val = *val << 16;
    }

    else
    {
      allocator->free(allocator, (void *)val);
      val = (unsigned int *)(void *)0;
    }
  }
  return (void *)val;
}

// datatype_equal
// file types_ops.c line 348
signed int datatype_equal(const void *key1, const void *key2)
{
  unsigned int type = *((unsigned int *)key1);
  if(key2 == NULL)
    return 0;

  else
    if((0xFFFF0000 & type) == 0u)
      return (signed int)(*((unsigned int *)key1) == *((unsigned int *)key2));

    else
    {
      type = type >> 16;
      signed int return_value_ci_magic_group_check$1;
      return_value_ci_magic_group_check$1=ci_magic_group_check((signed int)*((unsigned int *)key2), (signed int)type);
      if(!(return_value_ci_magic_group_check$1 == 0))
        return 1;

      else
        return 0;
    }
}

// datatype_free
// file types_ops.c line 371
void datatype_free(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// datatype_len
// file types_ops.c line 366
unsigned long int datatype_len(const void *key)
{
  return sizeof(unsigned int) /*4ul*/ ;
}

// default_cmp
// file array.c line 680
static signed int default_cmp(const void *obj1, const void *obj2, unsigned long int size)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp(obj1, obj2, size);
  return return_value_memcmp$1;
}

// del_mutex
// file os/unix/threads.c line 105
static void del_mutex(void *pmutex)
{
  struct mutex_itm *m;
  struct mutex_itm *p = (struct mutex_itm *)(void *)0;
  pthread_mutex_lock(&mutexes_lock);
  m = mutexes;
  for( ; !(m == ((struct mutex_itm *)NULL)); m = m->next)
  {
    if(m->mtx.mutex == (union anonymous$8 *)pmutex)
    {
      if(p == ((struct mutex_itm *)NULL))
        mutexes = mutexes->next;

      else
        p->next = m->next;
      free((void *)m);
      pthread_mutex_unlock(&mutexes_lock);
      goto __CPROVER_DUMP_L6;
    }

    p = m;
  }
  pthread_mutex_unlock(&mutexes_lock);

__CPROVER_DUMP_L6:
  ;
}

// destroy_encaps_entity
// file header.c line 563
void destroy_encaps_entity(struct ci_encaps_entity *e)
{
  _Bool tmp_if_expr$1;
  if(e->type == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = e->type == 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    ci_headers_destroy((struct ci_headers_list *)e->entity);

  else
    free(e->entity);
  free((void *)e);
}

// do_close
// file body.c line 318
void do_close(signed int fd)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  signed int return_value_close$2;
  signed int *return_value___errno_location$3;
  do
  {
    return_value_close$2=close(fd);
    if(return_value_close$2 >= 0)
      break;

    return_value___errno_location$3=__errno_location();
    if(!(*return_value___errno_location$3 == 4))
      break;

  }
  while((_Bool)1);
}

// do_open
// file body.c line 308
signed int do_open(const char *pathname, signed int flags)
{
  signed int fd;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    fd=open64(pathname, flags, 0400 | 0200 | 0400 >> 3 | (0400 >> 3) >> 3);
    if(!(fd >= 0))
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
  }
  while(tmp_if_expr$3);
  return fd;
}

// do_read
// file body.c line 292
signed int do_read(signed int fd, void *buf, unsigned long int count)
{
  signed int bytes;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    signed long int return_value_read$4;
    return_value_read$4=read(fd, buf, count);
    bytes = (signed int)return_value_read$4;
    if(!(bytes >= 0))
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
  }
  while(tmp_if_expr$3);
  return bytes;
}

// do_write
// file body.c line 282
signed int do_write(signed int fd, const void *buf, unsigned long int count)
{
  signed int bytes;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    signed long int return_value_write$4;
    return_value_write$4=write(fd, buf, count);
    bytes = (signed int)return_value_write$4;
    if(!(bytes >= 0))
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
  }
  while(tmp_if_expr$3);
  return bytes;
}

// extend_object_type
// file filetype.c line 559
signed int extend_object_type(struct ci_magics_db *db, struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed)
{
  signed int file_type;
  signed int unzip_error = 0;
  signed int unzipped_buf_len = 0;
  char *unzipped_buf = (char *)(void *)0;
  const char *checkbuf = buf;
  const char *content_type = (const char *)(void *)0;
  const char *content_encoding = (const char *)(void *)0;
  *iscompressed = 0;
  char *return_value_strcasestr$2;
  char *return_value_strcasestr$1;
  char *return_value_strcasestr$14;
  char *return_value_strcasestr$16;
  if(!(len >= 1))
    return 5;

  else
  {
    if(!(headers == ((struct ci_headers_list *)NULL)))
    {
      content_encoding=ci_headers_value(headers, "Content-Encoding");
      if(!(content_encoding == ((const char *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 8)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Content-Encoding :%s\n", content_encoding);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Content-Encoding :%s\n", content_encoding);

        }

        char *return_value_strcasestr$3;
        return_value_strcasestr$3=strcasestr(content_encoding, "gzip");
        if(!(return_value_strcasestr$3 == ((char *)NULL)))
          *iscompressed = 1;

        else
        {
          return_value_strcasestr$2=strcasestr(content_encoding, "deflate");
          if(!(return_value_strcasestr$2 == ((char *)NULL)))
            *iscompressed = 2;

          else
          {
            return_value_strcasestr$1=strcasestr(content_encoding, "bzip2");
            if(!(return_value_strcasestr$1 == ((char *)NULL)))
              *iscompressed = 3;

            else
              *iscompressed = 4;
          }
        }
        _Bool tmp_if_expr$6;
        if(*iscompressed == 1)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = *iscompressed == 2 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
        {
          void *return_value_ci_buffer_alloc$4;
          return_value_ci_buffer_alloc$4=ci_buffer_alloc(len);
          unzipped_buf = (char *)return_value_ci_buffer_alloc$4;
          unzipped_buf_len = len;
          signed int return_value_ci_uncompress_preview$5;
          return_value_ci_uncompress_preview$5=ci_uncompress_preview(*iscompressed, buf, len, unzipped_buf, &unzipped_buf_len);
          if(!(return_value_ci_uncompress_preview$5 == -1))
          {
            checkbuf = unzipped_buf;
            len = unzipped_buf_len;
          }

          else
          {
            if(CI_DEBUG_LEVEL >= 3)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error uncompressing encoded object\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error uncompressing encoded object\n");

            }

            ci_buffer_free((void *)unzipped_buf);
            unzipped_buf = (char *)(void *)0;
            unzip_error = 1;
          }
        }

      }

    }

    file_type=ci_filetype(db, checkbuf, len);
    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        char *tmp_if_expr$7;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$7 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr$7 = (char *)(void *)0;
        _Bool tmp_if_expr$8;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$8 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        char *tmp_if_expr$9;
        if(file_type >= 0 && tmp_if_expr$8)
          tmp_if_expr$9 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr$9 = (char *)(void *)0;
        __log_error((void *)0, "File type returned :%s,%s\n", tmp_if_expr$7, tmp_if_expr$9);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        char *tmp_if_expr$10;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$10 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr$10 = (char *)(void *)0;
        _Bool tmp_if_expr$11;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$11 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$11 = (_Bool)0;
        char *tmp_if_expr$12;
        if(file_type >= 0 && tmp_if_expr$11)
          tmp_if_expr$12 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr$12 = (char *)(void *)0;
        printf("File type returned :%s,%s\n", tmp_if_expr$10, tmp_if_expr$12);
      }

    }

    signed int return_value_ci_belongs_to_group$18;
    return_value_ci_belongs_to_group$18=ci_belongs_to_group(db, file_type, 0);
    if(!(return_value_ci_belongs_to_group$18 == 0))
    {
      if(!(headers == ((struct ci_headers_list *)NULL)))
      {
        content_type=ci_headers_value(headers, "Content-Type");
        if(!(content_type == ((const char *)NULL)))
        {
          char *return_value_strcasestr$13;
          return_value_strcasestr$13=strcasestr(content_type, "text/html");
          _Bool tmp_if_expr$15;
          if(!(return_value_strcasestr$13 == ((char *)NULL)))
            tmp_if_expr$15 = (_Bool)1;

          else
          {
            return_value_strcasestr$14=strcasestr(content_type, "text/css");
            tmp_if_expr$15 = return_value_strcasestr$14 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          }
          _Bool tmp_if_expr$17;
          if(tmp_if_expr$15)
            tmp_if_expr$17 = (_Bool)1;

          else
          {
            return_value_strcasestr$16=strcasestr(content_type, "text/javascript");
            tmp_if_expr$17 = return_value_strcasestr$16 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$17)
            file_type = 4;

        }

      }

    }

    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        char *tmp_if_expr$19;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$19 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr$19 = (char *)(void *)0;
        _Bool tmp_if_expr$20;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$20 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$20 = (_Bool)0;
        char *tmp_if_expr$21;
        if(file_type >= 0 && tmp_if_expr$20)
          tmp_if_expr$21 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr$21 = (char *)(void *)0;
        __log_error((void *)0, "The file type now is :%s,%s\n", tmp_if_expr$19, tmp_if_expr$21);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        char *tmp_if_expr$22;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$22 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr$22 = (char *)(void *)0;
        _Bool tmp_if_expr$23;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$23 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$23 = (_Bool)0;
        char *tmp_if_expr$24;
        if(file_type >= 0 && tmp_if_expr$23)
          tmp_if_expr$24 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr$24 = (char *)(void *)0;
        printf("The file type now is :%s,%s\n", tmp_if_expr$22, tmp_if_expr$24);
      }

    }

    if(!(unzipped_buf == ((char *)NULL)))
      ci_buffer_free((void *)unzipped_buf);

    return file_type;
  }
}

// file_proc_mutex_destroy
// file os/unix/proc_mutex.c line 195
static signed int file_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  close(mutex->$anon0.file.fd);
  signed int return_value_unlink$1;
  return_value_unlink$1=unlink(mutex->name);
  if(!(return_value_unlink$1 == 0))
    return 0;

  else
    return 1;
}

// file_proc_mutex_init
// file os/unix/proc_mutex.c line 185
static signed int file_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  strcpy(mutex->name, "/tmp/icap_lock");
  snprintf(mutex->name, (unsigned long int)64, "%s_%s.XXXXXX", (const void *)"/tmp/icap_lock", name);
  mutex->$anon0.file.fd=mkstemp64(mutex->name);
  if(!(mutex->$anon0.file.fd >= 0))
    return 0;

  else
    return 1;
}

// file_proc_mutex_lock
// file os/unix/proc_mutex.c line 203
static signed int file_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  struct flock fl;
  fl.l_type = (signed short int)1;
  fl.l_whence = (signed short int)0;
  fl.l_start = (signed long int)0;
  fl.l_len = (signed long int)0;
  signed int return_value_fcntl$1;
  return_value_fcntl$1=fcntl(mutex->$anon0.file.fd, 7, &fl);
  if(!(return_value_fcntl$1 >= 0))
    return 0;

  else
    return 1;
}

// file_proc_mutex_print_info
// file os/unix/proc_mutex.c line 228
static signed int file_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "file:%s", (const void *)mutex->name);
  return return_value_snprintf$1;
}

// file_proc_mutex_unlock
// file os/unix/proc_mutex.c line 216
static signed int file_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  struct flock fl;
  fl.l_type = (signed short int)2;
  fl.l_whence = (signed short int)0;
  fl.l_start = (signed long int)0;
  fl.l_len = (signed long int)0;
  signed int return_value_fcntl$1;
  return_value_fcntl$1=fcntl(mutex->$anon0.file.fd, 6, &fl);
  if(!(return_value_fcntl$1 >= 0))
    return 0;

  else
    return 1;
}

// file_table_close
// file lookup_file_table.c line 264
void file_table_close(struct ci_lookup_table *table)
{
  signed int i;
  void **vals = (void **)(void *)0;
  struct text_table_entry *tmp;
  struct ci_mem_allocator *allocator = table->allocator;
  struct text_table *text_table = (struct text_table *)table->data;
  if(text_table == ((struct text_table *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Closing a non open file lookup table?(%s)\n", table->path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Closing a non open file lookup table?(%s)\n", table->path);

    }

  }

  else
  {
    if(!(text_table->entries == ((struct text_table_entry *)NULL)))
    {
      tmp = text_table->entries;
      text_table->entries = text_table->entries->next;
      if(!(tmp->vals == ((void **)NULL)))
      {
        vals = (void **)tmp->vals;
        i = 0;
        if(!(vals[(signed long int)i] == NULL))
        {
          table->val_ops->free(vals[(signed long int)i], allocator);
          i = i + 1;
        }

        allocator->free(allocator, (void *)tmp->vals);
      }

      table->key_ops->free(tmp->key, allocator);
      allocator->free(allocator, (void *)tmp);
    }

    allocator->free(allocator, (void *)text_table);
    table->data = (void *)0;
  }
}

// file_table_open
// file lookup_file_table.c line 247
void * file_table_open(struct ci_lookup_table *table)
{
  struct ci_mem_allocator *allocator = table->allocator;
  struct text_table *text_table;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct text_table) /*24ul*/ );
  text_table = (struct text_table *)return_value;
  if(text_table == ((struct text_table *)NULL))
    return (void *)0;

  else
  {
    text_table->entries = (struct text_table_entry *)(void *)0;
    table->data = (void *)text_table;
    signed int return_value_load_text_table$1;
    return_value_load_text_table$1=load_text_table(table->path, table);
    if(return_value_load_text_table$1 == 0)
    {
      table->data = (void *)0;
      return table->data;
    }

    else
    {
      text_table->hash_table = (struct ci_hash_table *)(void *)0;
      return (void *)text_table;
    }
  }
}

// file_table_release_result
// file lookup_file_table.c line 316
void file_table_release_result(struct ci_lookup_table *table_data, void **val)
{
  ;
}

// file_table_search
// file lookup_file_table.c line 294
void * file_table_search(struct ci_lookup_table *table, void *key, void ***vals)
{
  struct text_table_entry *e;
  struct text_table *text_table = (struct text_table *)table->data;
  if(text_table == ((struct text_table *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Search a non open lookup table?(%s)\n", table->path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Search a non open lookup table?(%s)\n", table->path);

    }

    return (void *)0;
  }

  else
  {
    e = text_table->entries;
    *vals = (void **)(void *)0;
    if(!(e == ((struct text_table_entry *)NULL)))
    {
      signed int return_value;
      return_value=table->key_ops->compare((void *)e->key, key);
      if(return_value == 0)
      {
        *vals = (void **)e->vals;
        return (void *)e->key;
      }

      e = e->next;
    }

    return (void *)0;
  }
}

// fmt_gmttime
// file txt_format.c line 399
signed int fmt_gmttime(struct ci_request *req, char *buf, signed int len, const char *param)
{
  struct tm tm;
  signed long int t;
  const char *tfmt = "%d/%b/%Y:%H:%M:%S";
  if(len == 0)
    return 0;

  else
  {
    if(!(param == ((const char *)NULL)))
    {
      if(!((signed int)*param == 0))
        tfmt = param;

    }

    t=time(&t);
    gmtime_r(&t, &tm);
    unsigned long int return_value_strftime$1;
    return_value_strftime$1=strftime(buf, (unsigned long int)len, tfmt, &tm);
    return (signed int)return_value_strftime$1;
  }
}

// fmt_http_req_head_o
// file txt_format.c line 474
signed int fmt_http_req_head_o(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(param == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      s=ci_http_request(req);

    else
      s=ci_http_request_get_header(req, param);
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_http_req_url_o
// file txt_format.c line 466
signed int fmt_http_req_url_o(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(len == 0)
    return 0;

  else
  {
    signed int return_value_ci_http_request_url$1;
    return_value_ci_http_request_url$1=ci_http_request_url(req, buf, len);
    return return_value_ci_http_request_url$1;
  }
}

// fmt_http_res_head_o
// file txt_format.c line 497
signed int fmt_http_res_head_o(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  struct ci_headers_list *http_resp_headers;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(param == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      http_resp_headers=ci_http_response_headers(req);
      if(!(http_resp_headers == ((struct ci_headers_list *)NULL)))
      {
        if(!(http_resp_headers->used == 0))
          s = http_resp_headers->headers[(signed long int)0];

      }

    }

    else
      s=ci_http_response_get_header(req, param);
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_httpclientip
// file txt_format.c line 429
signed int fmt_httpclientip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s;
  signed int i;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(len == 0)
    return 0;

  else
  {
    s=ci_headers_value(req->request_header, "X-Client-IP");
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$1 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(!tmp_if_expr$3)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_httpserverip
// file txt_format.c line 448
signed int fmt_httpserverip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s;
  signed int i;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(len == 0)
    return 0;

  else
  {
    s=ci_headers_value(req->request_header, "X-Server-IP");
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$1 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(!tmp_if_expr$3)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_icap_req_head
// file txt_format.c line 525
signed int fmt_icap_req_head(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(param == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(!(req->request_header == ((struct ci_headers_list *)NULL)))
      {
        if(!(req->request_header->used == 0))
          s = req->request_header->headers[(signed long int)0];

      }

    }

    else
      s=ci_headers_value(req->request_header, param);
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_icap_res_head
// file txt_format.c line 549
signed int fmt_icap_res_head(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(param == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(!(req->response_header == ((struct ci_headers_list *)NULL)))
      {
        if(!(req->response_header->used == 0))
          s = req->response_header->headers[(signed long int)0];

      }

    }

    else
    {
      s=ci_headers_value(req->response_header, param);
      if(s == ((const char *)NULL))
      {
        if(!(req->xheaders == ((struct ci_headers_list *)NULL)))
          s=ci_headers_value(req->xheaders, param);

      }

    }
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_icapmethod
// file txt_format.c line 338
signed int fmt_icapmethod(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  const char *s;
  _Bool tmp_if_expr$1;
  if(!(req->type >= 5))
    tmp_if_expr$1 = req->type >= 0x01 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  const char *tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ci_methods[(signed long int)req->type];

  else
    tmp_if_expr$2 = "UNKNOWN";
  s = tmp_if_expr$2;
  i = 0;
  _Bool tmp_if_expr$3;
  do
  {
    if(!(i >= len))
      tmp_if_expr$3 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  return i;
}

// fmt_icapstatus
// file txt_format.c line 416
signed int fmt_icapstatus(struct ci_request *req, char *buf, signed int len, const char *param)
{
  _Bool tmp_if_expr$1;
  if(req->return_code >= 0)
    tmp_if_expr$1 = req->return_code < 16 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  signed int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ci_error_codes[(signed long int)req->return_code].code;

  else
    tmp_if_expr$2 = 1000;
  signed int return_value_snprintf$3;
  return_value_snprintf$3=snprintf(buf, (unsigned long int)len, "%d", tmp_if_expr$2);
  return return_value_snprintf$3;
}

// fmt_localip
// file txt_format.c line 327
signed int fmt_localip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(!(len >= 16))
    return 0;

  else
  {
    const char *return_value_ci_sockaddr_t_to_ip$1;
    return_value_ci_sockaddr_t_to_ip$1=ci_sockaddr_t_to_ip(&req->connection->srvaddr, buf, 16);
    if(return_value_ci_sockaddr_t_to_ip$1 == ((const char *)NULL))
      strcpy(buf, "-");

    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    return (signed int)return_value_strlen$2;
  }
}

// fmt_localtime
// file txt_format.c line 382
signed int fmt_localtime(struct ci_request *req, char *buf, signed int len, const char *param)
{
  struct tm tm;
  signed long int t;
  const char *tfmt = "%d/%b/%Y:%H:%M:%S %z";
  if(len == 0)
    return 0;

  else
  {
    if(!(param == ((const char *)NULL)))
    {
      if(!((signed int)*param == 0))
        tfmt = param;

    }

    t=time(&t);
    localtime_r(&t, &tm);
    unsigned long int return_value_strftime$1;
    return_value_strftime$1=strftime(buf, (unsigned long int)len, tfmt, &tm);
    return (signed int)return_value_strftime$1;
  }
}

// fmt_logstr
// file txt_format.c line 645
signed int fmt_logstr(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  const char *s;
  _Bool tmp_if_expr$1;
  if(req->log_str == ((char *)NULL))
    return 0;

  else
  {
    s = req->log_str;
    i = 0;
    do
    {
      if(!(i >= len))
        tmp_if_expr$1 = *s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      buf[(signed long int)i] = *s;
      i = i + 1;
      s = s + 1l;
    }
    while((_Bool)1);
    return i;
  }
}

// fmt_none
// file txt_format.c line 142
signed int fmt_none(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(len == 0)
    return 0;

  else
  {
    *buf = (char)45;
    return 1;
  }
}

// fmt_percent
// file txt_format.c line 151
signed int fmt_percent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(len == 0)
    return 0;

  else
  {
    *buf = (char)37;
    return 1;
  }
}

// fmt_remoteip
// file txt_format.c line 316
signed int fmt_remoteip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(!(len >= 16))
    return 0;

  else
  {
    const char *return_value_ci_sockaddr_t_to_ip$1;
    return_value_ci_sockaddr_t_to_ip$1=ci_sockaddr_t_to_ip(&req->connection->claddr, buf, 16);
    if(return_value_ci_sockaddr_t_to_ip$1 == ((const char *)NULL))
      strcpy(buf, "-");

    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    return (signed int)return_value_strlen$2;
  }
}

// fmt_req_attribute
// file txt_format.c line 659
signed int fmt_req_attribute(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  const char *s;
  _Bool tmp_if_expr$2;
  if(req->attributes == ((struct ci_array *)NULL))
    return 0;

  else
  {
    const void *return_value_ci_array_search$1;
    return_value_ci_array_search$1=ci_array_search(req->attributes, param);
    s = (const char *)return_value_ci_array_search$1;
    if(s == ((const char *)NULL))
      return 0;

    else
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = *s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }
  }
}

// fmt_req_body_bytes_rcv
// file txt_format.c line 593
signed int fmt_req_body_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->body_bytes_in);
  return return_value_snprintf$1;
}

// fmt_req_body_bytes_sent
// file txt_format.c line 597
signed int fmt_req_body_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->body_bytes_out);
  return return_value_snprintf$1;
}

// fmt_req_bytes_rcv
// file txt_format.c line 577
signed int fmt_req_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->bytes_in);
  return return_value_snprintf$1;
}

// fmt_req_bytes_sent
// file txt_format.c line 581
signed int fmt_req_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->bytes_out);
  return return_value_snprintf$1;
}

// fmt_req_http_bytes_rcv
// file txt_format.c line 585
signed int fmt_req_http_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->http_bytes_in);
  return return_value_snprintf$1;
}

// fmt_req_http_bytes_sent
// file txt_format.c line 589
signed int fmt_req_http_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->http_bytes_out);
  return return_value_snprintf$1;
}

// fmt_req_preview_hex
// file txt_format.c line 601
signed int fmt_req_preview_hex(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  signed int num;
  signed int n;
  signed int bytes;
  _Bool tmp_if_expr$2;
  if(len == 0)
    return 0;

  else
    if(!(req->preview_data.used >= 1))
    {
      *buf = (char)45;
      return 1;
    }

    else
    {
      if(!(param == ((const char *)NULL)))
      {
        signed long int return_value_strtol$1;
        return_value_strtol$1=strtol(param, (char ** restrict )(void *)0, 10);
        num = (signed int)return_value_strtol$1;
      }

      else
        num = 5;
      n = 0;
      i = 0;
      do
      {
        if(!(i >= num))
          tmp_if_expr$2 = i < req->preview_data.used ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!(len >= 1) || !tmp_if_expr$2)
          break;

        _Bool tmp_if_expr$4;
        if((signed int)req->preview_data.buf[(signed long int)i] >= 32)
          tmp_if_expr$4 = (signed int)req->preview_data.buf[(signed long int)i] <= 126 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
        {
          signed int tmp_post$3 = n;
          n = n + 1;
          buf[(signed long int)tmp_post$3] = req->preview_data.buf[(signed long int)i];
          len = len - 1;
        }

        else
        {
          bytes=snprintf(buf + (signed long int)n, (unsigned long int)len, "\\x%X", 0xFF & (signed int)buf[(signed long int)i]);
          if(!(len >= bytes))
            bytes = len;

          n = n + bytes;
          len = len - bytes;
        }
        i = i + 1;
      }
      while((_Bool)1);
      return n;
    }
}

// fmt_req_preview_len
// file txt_format.c line 633
signed int fmt_req_preview_len(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  if(len == 0)
    return 0;

  else
  {
    if(req->preview >= 0)
    {
      return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%d", req->preview_data.used);
      return return_value_snprintf$1;
    }

    *buf = (char)45;
    return 1;
  }
}

// fmt_request
// file txt_format.c line 365
signed int fmt_request(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  char *s = req->service;
  i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= len))
      tmp_if_expr$1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr$2;
  if(!((signed int)req->args[0l] == 0))
  {
    if(!(i >= len))
    {
      buf[(signed long int)i] = (char)63;
      s = req->args;
      i = i + 1;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = *s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
    }

  }

  return i;
}

// fmt_seconds
// file txt_format.c line 422
signed int fmt_seconds(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed long int tm;
  time(&tm);
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%ld", tm);
  return return_value_snprintf$1;
}

// fmt_service
// file txt_format.c line 347
signed int fmt_service(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  char *s = req->service;
  i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= len))
      tmp_if_expr$1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  return i;
}

// fmt_username
// file txt_format.c line 356
signed int fmt_username(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  char *s = req->user;
  i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= len))
      tmp_if_expr$1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  return i;
}

// free_a_buffer
// file decode.c line 203
static void free_a_buffer(void *op, void *ptr)
{
  ci_buffer_free(ptr);
}

// free_cmp_uint64_data
// file acl.c line 997
void free_cmp_uint64_data(struct ci_request *req, void *param)
{
  ci_buffer_free(param);
}

// free_data_type
// file acl.c line 976
void free_data_type(struct ci_request *req, void *param)
{
  free(param);
}

// free_http_req_header
// file acl.c line 938
void free_http_req_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  release_header_value(heads, (char *)param);
}

// free_http_resp_header
// file acl.c line 952
void free_http_resp_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_response_headers(req);
  release_header_value(heads, (char *)param);
}

// free_icap_header
// file acl.c line 911
void free_icap_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads = req->request_header;
  release_header_value(heads, (char *)param);
}

// free_icap_response_header
// file acl.c line 925
void free_icap_response_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads = req->response_header;
  release_header_value(heads, (char *)param);
}

// free_records_group
// file filetype.c line 167
void free_records_group(struct ci_magic_record *record)
{
  signed int i = 0;
  for( ; !(record->groups[(signed long int)i] == ((char *)NULL)); i = i + 1)
  {
    free((void *)record->groups[(signed long int)i]);
    record->groups[(signed long int)i] = (char *)(void *)0;
  }
}

// free_time_data
// file acl.c line 394
void free_time_data(struct ci_request *req, void *param)
{
  if(CI_DEBUG_LEVEL >= 5)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "free_time_data(req=%p, param=%p)", req, param);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("free_time_data(req=%p, param=%p)", req, param);

  }

  ci_buffer_free(param);
}

// get_client_ip
// file acl.c line 60
void * get_client_ip(struct ci_request *req, char *param)
{
  return (void *)&req->connection->claddr;
}

// get_content_length
// file acl.c line 980
void * get_content_length(struct ci_request *req, char *param)
{
  struct acl_cmp_uint64_data *clen_p;
  void *return_value_ci_buffer_alloc$1;
  return_value_ci_buffer_alloc$1=ci_buffer_alloc((signed int)sizeof(struct acl_cmp_uint64_data) /*16ul*/ );
  clen_p = (struct acl_cmp_uint64_data *)return_value_ci_buffer_alloc$1;
  signed long int clen;
  clen=ci_http_content_length(req);
  if(!(clen >= 0l))
    return (void *)0;

  else
  {
    clen_p->data = (unsigned long int)clen;
    if((signed int)*param == 61)
      clen_p->operator = 0;

    else
      if((signed int)*param == 62)
        clen_p->operator = 1;

      else
        if((signed int)*param == 60)
          clen_p->operator = 2;

    return (void *)clen_p;
  }
}

// get_data_type
// file acl.c line 961
void * get_data_type(struct ci_request *req, char *param)
{
  signed int type;
  signed int isenc;
  signed int *ret_type;
  type=ci_magic_req_data_type(req, &isenc);
  if(!(type >= 0))
    return (void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(unsigned int) /*4ul*/ );
    ret_type = (signed int *)return_value_malloc$1;
    if(ret_type == ((signed int *)NULL))
      return (void *)0;

    else
    {
      *ret_type = type;
      return (void *)ret_type;
    }
  }
}

// get_encaps_type
// file header.c line 573
signed int get_encaps_type(const char *buf, signed int *val, char **endpoint)
{
  signed int return_value_strncmp$2;
  return_value_strncmp$2=strncmp(buf, "req-hdr", (unsigned long int)7);
  if(return_value_strncmp$2 == 0)
  {
    signed long int return_value_strtol$1;
    return_value_strtol$1=strtol(buf + (signed long int)8, endpoint, 10);
    *val = (signed int)return_value_strtol$1;
    return 0;
  }

  signed int return_value_strncmp$4;
  return_value_strncmp$4=strncmp(buf, "res-hdr", (unsigned long int)7);
  if(return_value_strncmp$4 == 0)
  {
    signed long int return_value_strtol$3;
    return_value_strtol$3=strtol(buf + (signed long int)8, endpoint, 10);
    *val = (signed int)return_value_strtol$3;
    return 1;
  }

  signed int return_value_strncmp$6;
  return_value_strncmp$6=strncmp(buf, "req-body", (unsigned long int)8);
  if(return_value_strncmp$6 == 0)
  {
    signed long int return_value_strtol$5;
    return_value_strtol$5=strtol(buf + (signed long int)9, endpoint, 10);
    *val = (signed int)return_value_strtol$5;
    return 2;
  }

  signed int return_value_strncmp$8;
  return_value_strncmp$8=strncmp(buf, "res-body", (unsigned long int)8);
  if(return_value_strncmp$8 == 0)
  {
    signed long int return_value_strtol$7;
    return_value_strtol$7=strtol(buf + (signed long int)9, endpoint, 10);
    *val = (signed int)return_value_strtol$7;
    return 3;
  }

  signed int return_value_strncmp$10;
  return_value_strncmp$10=strncmp(buf, "null-body", (unsigned long int)9);
  if(return_value_strncmp$10 == 0)
  {
    signed long int return_value_strtol$9;
    return_value_strtol$9=strtol(buf + (signed long int)10, endpoint, 10);
    *val = (signed int)return_value_strtol$9;
    return 4;
  }

  return -1;
}

// get_header
// file acl.c line 872
const char * get_header(struct ci_headers_list *headers, char *head)
{
  const char *val;
  char *buf;
  signed int i;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(head == ((char *)NULL) || headers == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
  {
    val=ci_headers_value(headers, head);
    if(val == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      if(headers->packed == 0)
        return val;

      else
      {
        void *return_value_ci_buffer_alloc$1;
        return_value_ci_buffer_alloc$1=ci_buffer_alloc(8192);
        buf = (char *)return_value_ci_buffer_alloc$1;
        if(buf == ((char *)NULL))
          return (const char *)(void *)0;

        else
        {
          i = 0;
          do
          {
            if(!(i >= 8191))
              tmp_if_expr$2 = (signed int)*val != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$2 = (_Bool)0;
            if(tmp_if_expr$2)
              tmp_if_expr$3 = (signed int)*val != 13 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$3 = (_Bool)0;
            if(tmp_if_expr$3)
              tmp_if_expr$4 = (signed int)*val != 10 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            if(!tmp_if_expr$4)
              break;

            buf[(signed long int)i] = *val;
            i = i + 1;
            val = val + 1l;
          }
          while((_Bool)1);
          buf[(signed long int)8191] = (char)0;
          return buf;
        }
      }
  }
}

// get_http_client_ip
// file acl.c line 68
void * get_http_client_ip(struct ci_request *req, char *param)
{
  const struct ci_ip *return_value_ci_http_client_ip$1;
  return_value_ci_http_client_ip$1=ci_http_client_ip(req);
  return (void *)return_value_ci_http_client_ip$1;
}

// get_http_req_header
// file acl.c line 932
void * get_http_req_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  const char *return_value_get_header$1;
  return_value_get_header$1=get_header(heads, param);
  return (void *)return_value_get_header$1;
}

// get_http_resp_header
// file acl.c line 945
void * get_http_resp_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_response_headers(req);
  const char *return_value_get_header$1;
  return_value_get_header$1=get_header(heads, param);
  return (void *)return_value_get_header$1;
}

// get_icap_header
// file acl.c line 904
void * get_icap_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads = req->request_header;
  const char *return_value_get_header$1;
  return_value_get_header$1=get_header(heads, param);
  return (void *)return_value_get_header$1;
}

// get_icap_response_header
// file acl.c line 918
void * get_icap_response_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads = req->response_header;
  const char *return_value_get_header$1;
  return_value_get_header$1=get_header(heads, param);
  return (void *)return_value_get_header$1;
}

// get_port
// file acl.c line 56
void * get_port(struct ci_request *req, char *param)
{
  return (void *)&req->connection->srvaddr.ci_sin_port;
}

// get_reqtype
// file acl.c line 52
void * get_reqtype(struct ci_request *req, char *param)
{
  _Bool tmp_if_expr$1;
  if(!(req->type >= 5))
    tmp_if_expr$1 = req->type >= 0x01 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  const char *tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ci_methods[(signed long int)req->type];

  else
    tmp_if_expr$2 = "UNKNOWN";
  return (void *)tmp_if_expr$2;
}

// get_request_options
// file request_common.c line 757
static signed int get_request_options(struct ci_request *req, struct ci_headers_list *h)
{
  const char *pstr;
  pstr=ci_headers_value(h, "Preview");
  if(!(pstr == ((const char *)NULL)))
  {
    signed long int return_value_strtol$1;
    return_value_strtol$1=strtol(pstr, (char ** restrict )(void *)0, 10);
    req->preview = (signed int)return_value_strtol$1;
  }

  else
    req->preview = -1;
  req->allow204 = 0;
  pstr=ci_headers_value(h, "Allow");
  if(!(pstr == ((const char *)NULL)))
  {
    signed long int return_value_strtol$2;
    return_value_strtol$2=strtol(pstr, (char ** restrict )(void *)0, 10);
    if(return_value_strtol$2 == 204l)
      req->allow204 = 1;

  }

  pstr=ci_headers_value(h, "Connection");
  signed int return_value_strncmp$3;
  if(!(pstr == ((const char *)NULL)))
  {
    return_value_strncmp$3=strncmp(pstr, "close", (unsigned long int)5);
    if(return_value_strncmp$3 == 0)
      req->keepalive = 0;

  }

  pstr=ci_headers_value(h, "Transfer-Preview");
  pstr=ci_headers_value(h, "Transfer-Ignore");
  pstr=ci_headers_value(h, "Transfer-Complete");
  return 1;
}

// get_service
// file acl.c line 48
void * get_service(struct ci_request *req, char *param)
{
  return (void *)req->service;
}

// get_srv_ip
// file acl.c line 64
void * get_srv_ip(struct ci_request *req, char *param)
{
  return (void *)&req->connection->srvaddr;
}

// get_time_data
// file acl.c line 401
void * get_time_data(struct ci_request *req, char *param)
{
  struct acl_time_data *tmd_req;
  void *return_value_ci_buffer_alloc$1;
  return_value_ci_buffer_alloc$1=ci_buffer_alloc((signed int)sizeof(struct acl_time_data) /*12ul*/ );
  tmd_req = (struct acl_time_data *)return_value_ci_buffer_alloc$1;
  struct tm br_tm;
  signed long int tm;
  time(&tm);
  localtime_r(&tm, &br_tm);
  tmd_req->days = (unsigned int)0;
  tmd_req->days = tmd_req->days | (unsigned int)(1 << br_tm.tm_wday);
  tmd_req->start_time = (unsigned int)(br_tm.tm_hour * 60 + br_tm.tm_min);
  tmd_req->end_time = (unsigned int)0;
  return (void *)tmd_req;
}

// get_user
// file acl.c line 44
void * get_user(struct ci_request *req, char *param)
{
  return (void *)req->user;
}

// groups_add
// file filetype.c line 104
signed int groups_add(struct ci_magics_db *db, const char *name, const char *descr)
{
  struct ci_data_group *newdata;
  signed int indx;
  if(db->groups_num >= db->groups_size)
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)db->groups, (unsigned long int)(db->groups_size + 15) * sizeof(struct ci_data_group) /*67ul*/ );
    newdata = (struct ci_data_group *)return_value_realloc$1;
    if(newdata == ((struct ci_data_group *)NULL))
      return -1;

    db->groups_size = db->groups_size + 15;
    db->groups = newdata;
  }

  indx = db->groups_num;
  db->groups_num = db->groups_num + 1;
  strcpy((db->groups + (signed long int)indx)->name, name);
  strcpy((db->groups + (signed long int)indx)->descr, descr);
  return indx;
}

// groups_init
// file filetype.c line 82
signed int groups_init(struct ci_magics_db *db)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)15 * sizeof(struct ci_data_group) /*67ul*/ );
  db->groups = (struct ci_data_group *)return_value_malloc$1;
  if(db->groups == ((struct ci_data_group *)NULL))
    return 0;

  else
  {
    db->groups_num = 0;
    db->groups_size = 15;
    return 1;
  }
}

// hash_table_close
// file lookup_file_table.c line 365
void hash_table_close(struct ci_lookup_table *table)
{
  struct text_table *text_table = (struct text_table *)table->data;
  if(!(text_table == ((struct text_table *)NULL)))
  {
    if(!(text_table->hash_table == ((struct ci_hash_table *)NULL)))
    {
      ci_hash_destroy(text_table->hash_table);
      text_table->hash_table = (struct ci_hash_table *)(void *)0;
    }

  }

  file_table_close(table);
}

// hash_table_open
// file lookup_file_table.c line 339
void * hash_table_open(struct ci_lookup_table *table)
{
  struct text_table_entry *e;
  struct text_table *text_table;
  void *return_value_file_table_open$1;
  return_value_file_table_open$1=file_table_open(table);
  text_table = (struct text_table *)return_value_file_table_open$1;
  if(text_table == ((struct text_table *)NULL))
    return (void *)0;

  else
  {
    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Will build a hash for %d rows of data\n", text_table->rows);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Will build a hash for %d rows of data\n", text_table->rows);

    }

    text_table->hash_table=ci_hash_build((unsigned int)text_table->rows, table->key_ops, table->allocator);
    if(text_table->hash_table == ((struct ci_hash_table *)NULL))
    {
      file_table_close(table);
      return (void *)0;
    }

    else
    {
      e = text_table->entries;
      for( ; !(e == ((struct text_table_entry *)NULL)); e = e->next)
        ci_hash_add(text_table->hash_table, e->key, (const void *)e);
      return (void *)text_table;
    }
  }
}

// hash_table_release_result
// file lookup_file_table.c line 396
void hash_table_release_result(struct ci_lookup_table *table_data, void **val)
{
  ;
}

// hash_table_search
// file lookup_file_table.c line 377
void * hash_table_search(struct ci_lookup_table *table, void *key, void ***vals)
{
  struct text_table_entry *e;
  struct text_table *text_table = (struct text_table *)table->data;
  if(text_table == ((struct text_table *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Search a non open hash lookup table?(%s)\n", table->path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Search a non open hash lookup table?(%s)\n", table->path);

    }

    return (void *)0;
  }

  else
  {
    *vals = (void **)(void *)0;
    const void *return_value_ci_hash_search$1;
    return_value_ci_hash_search$1=ci_hash_search(text_table->hash_table, key);
    e = (struct text_table_entry *)return_value_ci_hash_search$1;
    if(e == ((struct text_table_entry *)NULL))
      return (void *)0;

    else
    {
      *vals = (void **)e->vals;
      return (void *)e->key;
    }
  }
}

// icap_init_server
// file os/unix/net_io.c line 87
signed int icap_init_server(char *address, signed int port, signed int *protocol_family, signed int secs_to_linger)
{
  signed int fd;
  struct sockaddr_in addr;
  fd=socket(2, 1, 0);
  signed int return_value_inet_pton$1;
  if(fd == -1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error opening socket ....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error opening socket ....\n");

    }

    return -1;
  }

  else
  {
    icap_socket_opts(fd, secs_to_linger);
    memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    addr.sin_family = (unsigned short int)2;
    addr.sin_port=htons((unsigned short int)port);
    if(address == ((char *)NULL))
      addr.sin_addr.s_addr = (unsigned int)0x00000000;

    else
    {
      return_value_inet_pton$1=inet_pton(2, address, (void *)&addr.sin_addr.s_addr);
      if(!(return_value_inet_pton$1 == 1))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error converting ipv4 address to the network byte order \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error converting ipv4 address to the network byte order \n");

        }

        close(fd);
        return -1;
      }

    }
    signed int return_value_bind$2;
    return_value_bind$2=bind(fd, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_bind$2 == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error binding  \n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error binding  \n");

      }

      return -1;
    }

    else
    {
      signed int return_value_listen$3;
      return_value_listen$3=listen(fd, 512);
      if(!(return_value_listen$3 == 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error listening .....\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error listening .....\n");

        }

        return -1;
      }

      else
      {
        *protocol_family = 2;
        return fd;
      }
    }
  }
}

// icap_socket_opts
// file os/unix/net_io.c line 135
signed int icap_socket_opts(signed int fd, signed int secs_to_linger)
{
  struct linger li;
  signed int value = 1;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(fd, 1, 2, (const void *)&value, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(return_value_setsockopt$1 == -1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "setsockopt: unable to set SO_REUSEADDR\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("setsockopt: unable to set SO_REUSEADDR\n");

    }

  }

  value = 1;
  signed int return_value_setsockopt$2;
  return_value_setsockopt$2=setsockopt(fd, 6, 1, (const void *)&value, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(return_value_setsockopt$2 == -1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "setsockopt: unable to set TCP_NODELAY\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("setsockopt: unable to set TCP_NODELAY\n");

    }

  }

  li.l_onoff = 1;
  li.l_linger = secs_to_linger;
  signed int return_value_setsockopt$3;
  return_value_setsockopt$3=setsockopt(fd, 1, 13, (const void *)(char *)&li, (unsigned int)sizeof(struct linger) /*8ul*/ );
  if(!(return_value_setsockopt$3 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "setsockopt: unable to set SO_LINGER \n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("setsockopt: unable to set SO_LINGER \n");

    }

  }

  return 1;
}

// init_body_system
// file body.c line 49
signed int init_body_system()
{
  MEMBUF_POOL=ci_object_pool_register("ci_membuf_t", (signed int)sizeof(struct ci_membuf) /*40ul*/ );
  if(!(MEMBUF_POOL >= 0))
    return -1;

  else
  {
    CACHED_FILE_POOL=ci_object_pool_register("ci_cached_file_t", (signed int)sizeof(struct ci_cached_file) /*4152ul*/ );
    if(!(CACHED_FILE_POOL >= 0))
      return -1;

    else
    {
      SIMPLE_FILE_POOL=ci_object_pool_register("ci_simple_file_t", (signed int)sizeof(struct ci_simple_file) /*4184ul*/ );
      if(!(SIMPLE_FILE_POOL >= 0))
        return -1;

      else
      {
        RING_BUF_POOL=ci_object_pool_register("ci_ring_buf_t", (signed int)sizeof(struct ci_ring_buf) /*40ul*/ );
        if(!(RING_BUF_POOL >= 0))
          return -1;

        else
          return 1;
      }
    }
  }
}

// init_child_mutexes
// file os/unix/threads.c line 46
static void init_child_mutexes()
{
  struct mutex_itm *m;
  pthread_mutex_init(&mutexes_lock, (const union anonymous$4 *)(void *)0);
  m = mutexes;
  for( ; !(m == ((struct mutex_itm *)NULL)); m = m->next)
    switch(m->type)
    {
      case 0:
      {
        pthread_mutex_init(m->mtx.mutex, (const union anonymous$4 *)(void *)0);
        break;
      }
      case 1:
        pthread_rwlock_init(m->mtx.rwlock, (const union anonymous$7 *)(void *)0);
    }
}

// init_internal_lookup_tables
// file lookup_table.c line 241
void init_internal_lookup_tables()
{
  ci_lookup_table_type_register(&file_table_type);
  ci_lookup_table_type_register(&hash_table_type);
  ci_lookup_table_type_register(&regex_table_type);
}

// init_pack_allocator
// file mem.c line 661
struct ci_mem_allocator * init_pack_allocator(struct ci_mem_allocator *allocator, struct pack_allocator *pack_alloc, char *memblock, unsigned long int size, signed int free)
{
  unsigned long int tmp_if_expr$1;
  if(!(size == (7 + size & 18446744073709551608)))
    tmp_if_expr$1 = (size - (unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d) + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1);

  else
    tmp_if_expr$1 = size;
  size = tmp_if_expr$1;
  pack_alloc->memchunk = (void *)memblock;
  pack_alloc->curpos = pack_alloc->memchunk;
  pack_alloc->end = pack_alloc->memchunk + (signed long int)size;
  pack_alloc->endpos = pack_alloc->end;
  pack_alloc->must_free = free;
  allocator->alloc = ci_pack_allocator_alloc;
  allocator->free = ci_pack_allocator_free;
  allocator->reset = ci_pack_allocator_reset;
  allocator->destroy = ci_pack_allocator_destroy;
  allocator->data = (void *)pack_alloc;
  allocator->name = (char *)(void *)0;
  allocator->type = 3;
  allocator->must_free = free;
  return allocator;
}

// int32_cmp
// file types_ops.c line 125
signed int int32_cmp(const void *key1, const void *key2)
{
  signed int k1;
  signed int k2;
  k1 = *((signed int *)key1);
  k2 = *((signed int *)key2);
  if(!(k1 >= k2))
    return -1;

  else
    if(!(k2 >= k1))
      return 1;

    else
      return 0;
}

// int32_dup
// file types_ops.c line 107
void * int32_dup(const char *str, struct ci_mem_allocator *allocator)
{
  signed int *i;
  char *e = (char *)(void *)0;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(signed int) /*4ul*/ );
  i = (signed int *)return_value;
  if(!(i == ((signed int *)NULL)))
  {
    signed long int return_value_strtol$1;
    return_value_strtol$1=strtol(str, &e, 10);
    *i = (signed int)return_value_strtol$1;
    _Bool tmp_if_expr$4;
    if((signed int)*e == 75)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)*e == 107 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      *i = *i * 1000;

    else
    {
      _Bool tmp_if_expr$3;
      if((signed int)*e == 77)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*e == 109 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        *i = *i * 1000000;

      else
      {
        _Bool tmp_if_expr$2;
        if((signed int)*e == 71)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)*e == 103 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          *i = *i * 1000000000;

      }
    }
  }

  return (void *)i;
}

// int32_equal
// file types_ops.c line 138
signed int int32_equal(const void *key1, const void *key2)
{
  signed int k1;
  signed int k2;
  k1 = *((signed int *)key1);
  k2 = *((signed int *)key2);
  return (signed int)(k1 == k2);
}

// int32_free
// file types_ops.c line 151
void int32_free(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// int32_len
// file types_ops.c line 146
unsigned long int int32_len(const void *key)
{
  return (unsigned long int)4;
}

// ip_cmp
// file types_ops.c line 520
signed int ip_cmp(const void *ref_key, const void *key_check)
{
  return 0;
}

// ip_dup
// file types_ops.c line 448
void * ip_dup(const char *value, struct ci_mem_allocator *allocator)
{
  signed int socket_family;
  signed int len;
  struct ci_ip *ip;
  char str_addr[17l];
  char str_netmask[17l];
  char *pstr;
  struct in_addr address;
  struct in_addr netmask;
  address.s_addr = (unsigned int)0;
  netmask.s_addr = (unsigned int)0;
  socket_family = 2;
  pstr=strchr(value, 47);
  if(!(pstr == ((char *)NULL)))
  {
    len = (signed int)(pstr - value);
    if(len >= 16)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid ip address (len>%d): %s\n", 16, value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid ip address (len>%d): %s\n", 16, value);

      }

      return (void *)0;
    }

    strncpy(str_addr, value, (unsigned long int)len);
    str_addr[(signed long int)len] = (char)0;
    signed int return_value_ci_inet_aton$1;
    return_value_ci_inet_aton$1=ci_inet_aton(socket_family, str_addr, (void *)&address);
    if(return_value_ci_inet_aton$1 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid ip address in network %s definition\n", value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid ip address in network %s definition\n", value);

      }

      return (void *)0;
    }

    strncpy(str_netmask, pstr + (signed long int)1, (unsigned long int)16);
    str_netmask[(signed long int)16] = (char)0;
    signed int return_value_ci_inet_aton$2;
    return_value_ci_inet_aton$2=ci_inet_aton(socket_family, str_netmask, (void *)&netmask);
    if(return_value_ci_inet_aton$2 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid netmask in network %s definition\n", value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid netmask in network %s definition\n", value);

      }

      return (void *)0;
    }

  }

  else
  {
    signed int return_value_ci_inet_aton$3;
    return_value_ci_inet_aton$3=ci_inet_aton(socket_family, value, (void *)&address);
    if(return_value_ci_inet_aton$3 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid ip address: %s\n", value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid ip address: %s\n", value);

      }

      return (void *)0;
    }

    netmask.s_addr=htonl(0xFFFFFFFF);
  }
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct ci_ip) /*12ul*/ );
  ip = (struct ci_ip *)return_value;
  ip->family = socket_family;
  ip->address = address;
  ip->netmask = netmask;
  return (void *)ip;
}

// ip_equal
// file types_ops.c line 525
signed int ip_equal(const void *ref_key, const void *key_check)
{
  const struct ci_ip *ip_ref = (const struct ci_ip *)ref_key;
  const struct ci_ip *ip_check = (const struct ci_ip *)key_check;
  char buf[128l];
  char buf1[128l];
  char buf2[128l];
  const char *return_value_ci_inet_ntoa$1;
  const char *return_value_ci_inet_ntoa$2;
  const char *return_value_ci_inet_ntoa$3;
  const char *return_value_ci_inet_ntoa$4;
  const char *return_value_ci_inet_ntoa$5;
  const char *return_value_ci_inet_ntoa$6;
  if(ip_check == ((const struct ci_ip *)NULL))
    return 0;

  else
  {
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value_ci_inet_ntoa$1=ci_inet_ntoa(ip_check->family, (const void *)&ip_check->address, buf, 128);
        return_value_ci_inet_ntoa$2=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa$3=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        __log_error((void *)0, "going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa$1, return_value_ci_inet_ntoa$2, return_value_ci_inet_ntoa$3);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value_ci_inet_ntoa$4=ci_inet_ntoa(ip_check->family, (const void *)&ip_check->address, buf, 128);
        return_value_ci_inet_ntoa$5=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa$6=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        printf("going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa$4, return_value_ci_inet_ntoa$5, return_value_ci_inet_ntoa$6);
      }

    }

    return (signed int)((ip_ref->address.s_addr & ip_ref->netmask.s_addr) == (ip_check->address.s_addr & ip_ref->netmask.s_addr));
  }
}

// ip_free
// file types_ops.c line 511
void ip_free(void *data, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, data);
}

// ip_len
// file types_ops.c line 515
unsigned long int ip_len(const void *key)
{
  return sizeof(struct ci_ip) /*12ul*/ ;
}

// ip_sockaddr_cmp
// file types_ops.c line 556
signed int ip_sockaddr_cmp(const void *ref_key, const void *key_check)
{
  return 1;
}

// ip_sockaddr_equal
// file types_ops.c line 561
signed int ip_sockaddr_equal(const void *ref_key, const void *key_check)
{
  const struct ci_ip *ip_ref = (const struct ci_ip *)ref_key;
  const struct ci_sockaddr *ip_check = (const struct ci_sockaddr *)key_check;
  char buf[128l];
  char buf1[128l];
  char buf2[128l];
  const char *return_value_ci_inet_ntoa$1;
  const char *return_value_ci_inet_ntoa$2;
  const char *return_value_ci_inet_ntoa$3;
  const char *return_value_ci_inet_ntoa$4;
  const char *return_value_ci_inet_ntoa$5;
  const char *return_value_ci_inet_ntoa$6;
  if(ip_check == ((const struct ci_sockaddr *)NULL))
    return 0;

  else
  {
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value_ci_inet_ntoa$1=ci_inet_ntoa(ip_check->ci_sin_family, ip_check->ci_sin_addr, buf, 128);
        return_value_ci_inet_ntoa$2=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa$3=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        __log_error((void *)0, "going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa$1, return_value_ci_inet_ntoa$2, return_value_ci_inet_ntoa$3);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value_ci_inet_ntoa$4=ci_inet_ntoa(ip_check->ci_sin_family, ip_check->ci_sin_addr, buf, 128);
        return_value_ci_inet_ntoa$5=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa$6=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        printf("going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa$4, return_value_ci_inet_ntoa$5, return_value_ci_inet_ntoa$6);
      }

    }

    return (signed int)((ip_ref->address.s_addr & ip_ref->netmask.s_addr) == (((struct in_addr *)ip_check->ci_sin_addr)->s_addr & ip_ref->netmask.s_addr));
  }
}

// isUTF8
// file filetype.c line 439
signed int isUTF8(unsigned char *c, signed int size)
{
  signed int i;
  signed int r_size = 0;
  unsigned int ucs_c = (unsigned int)0;
  if((signed int)text_chars[(signed long int)(signed int)*c] == 1)
    return 1;

  else
  {
    if((0xE0 & (signed int)*c) == 0xC0)
    {
      ucs_c = (unsigned int)((signed int)*c & 0x1F);
      r_size = 2;
    }

    else
      if((0xF0 & (signed int)*c) == 0xE0)
      {
        ucs_c = (unsigned int)((signed int)*c & 0x0F);
        r_size = 3;
      }

      else
        if((0xF8 & (signed int)*c) == 0xF0)
        {
          ucs_c = (unsigned int)((signed int)*c & 0x07);
          r_size = 4;
        }

        else
          if((0xFC & (signed int)*c) == 0xF8)
          {
            ucs_c = (unsigned int)((signed int)*c & 0x03);
            r_size = 5;
          }

          else
            if((0xFE & (signed int)*c) == 0xFC)
            {
              ucs_c = (unsigned int)((signed int)*c & 0x01);
              r_size = 6;
            }

    if(r_size == 0)
      return 0;

    else
    {
      i = 1;
      for( ; !(i >= r_size) && !(i >= size); i = i + 1)
      {
        if(!((0xC0 & (signed int)c[(signed long int)i]) == 0x80))
          return 0;

        ucs_c = ucs_c << 6 | (unsigned int)((signed int)c[(signed long int)i] & 0x3F);
      }
      if(!(i >= r_size))
        return -1;

      else
        if(utf_boundaries[(signed long int)r_size] >= ucs_c)
          return 0;

        else
          if(ucs_c == 65534u || ucs_c == 65535u || ucs_c >= 55296u && !(ucs_c >= 57344u))
            return 0;

          else
            return r_size;
    }
  }
}

// list_alloc_item
// file array.c line 562
static struct ci_list_item * list_alloc_item(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  if(!(list->trash == ((struct ci_list_item *)NULL)))
  {
    it = list->trash;
    list->trash = list->trash->next;
  }

  else
  {
    void *return_value;
    return_value=list->alloc->alloc(list->alloc, sizeof(struct ci_list_item) /*16ul*/ );
    it = (struct ci_list_item *)return_value;
    if(it == ((struct ci_list_item *)NULL))
      return (struct ci_list_item *)(void *)0;

    if(!(list->obj_size == 0ul))
    {
      it->item=list->alloc->alloc(list->alloc, list->obj_size);
      if(it->item == NULL)
        return (struct ci_list_item *)(void *)0;

    }

  }
  it->next = (struct ci_list_item *)(void *)0;
  if(!(list->obj_size == 0ul))
  {
    memcpy(it->item, data, list->obj_size);
    if(!(list->copy_func == ((signed int (*)(void *, const void *))NULL)))
      list->copy_func(it->item, data);

  }

  else
    it->item = data;
  return it;
}

// load_module
// file test_cache.c line 16
signed int load_module(const char *directive, const char **argv, void *setdata)
{
  void *lib;
  struct common_module *module;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    lib=ci_module_load(argv[(signed long int)0], "./");
    if(lib == NULL)
    {
      printf("Error opening module :%s\n", argv[(signed long int)0]);
      return 0;
    }

    else
    {
      void *return_value_ci_module_sym$2;
      return_value_ci_module_sym$2=ci_module_sym(lib, "module");
      module = (struct common_module *)return_value_ci_module_sym$2;
      if(module == ((struct common_module *)NULL))
      {
        printf("Error opening module %s: can not find symbol module\n", argv[(signed long int)0]);
        return 0;
      }

      else
      {
        if(!(module->init_module == ((signed int (*)(struct ci_server_conf *))NULL)))
          module->init_module((struct ci_server_conf *)(void *)0);

        if(!(module->post_init_module == ((signed int (*)(struct ci_server_conf *))NULL)))
          module->post_init_module((struct ci_server_conf *)(void *)0);

        return 1;
      }
    }
  }
}

// load_text_table
// file lookup_file_table.c line 205
signed int load_text_table(char *filename, struct ci_lookup_table *table)
{
  struct _IO_FILE *f;
  struct text_table_entry *e;
  struct text_table_entry *l = (struct text_table_entry *)(void *)0;
  signed int rows;
  signed int ret;
  struct text_table *text_table = (struct text_table *)table->data;
  f=fopen64(filename, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error opening file: %s\n", filename);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error opening file: %s\n", filename);

    }

    return 0;
  }

  else
  {
    rows = 0;
    if(!(text_table->entries == ((struct text_table_entry *)NULL)))
    {
      l = text_table->entries;
      for( ; !(l->next == ((struct text_table_entry *)NULL)); l = l->next)
        ;
    }

    do
    {
      ret=read_row(f, table->cols, &e, table);
      if(!(ret >= 1))
        break;

      if(!(e == ((struct text_table_entry *)NULL)))
      {
        e->next = (struct text_table_entry *)(void *)0;
        if(text_table->entries == ((struct text_table_entry *)NULL))
        {
          text_table->entries = e;
          l = e;
        }

        else
        {
          l->next = e;
          l = e;
        }
      }

      rows = rows + 1;
    }
    while((_Bool)1);
    fclose(f);
    if(ret == -1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error loading file table %s: parse error on line %d\n", filename, rows + 1);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error loading file table %s: parse error on line %d\n", filename, rows + 1);

      }

      file_table_close(table);
      return 0;
    }

    else
    {
      text_table->rows = rows;
      return 1;
    }
  }
}

// log_errors
// file test_cache.c line 46
void log_errors(void *unused, const char *format, ...)
{
  void **ap = (void **)&format;
  vfprintf(stderr, format, ap);
  ap = ((void **)NULL);
}

// lookup_table_get_row
// file lookup_table.c line 205
static const void * lookup_table_get_row(struct ci_lookup_table *table, const void *key, const char **columns, void ***vals)
{
  signed int i;
  _Bool tmp_if_expr$2;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted!\n", table->type);

    }

    return (void *)0;
  }

  else
  {
    _Bool tmp_if_expr$1;
    if(table->col_names == ((struct ci_vector *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = table->_lt_type->get_row != ((const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "lookup_table :%s does not support lookup on named columns\n", table->type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("lookup_table :%s does not support lookup on named columns\n", table->type);

      }

      return (void *)0;
    }

    else
    {
      i = 0;
      do
      {
        if(!(i >= 1024))
          tmp_if_expr$2 = columns[(signed long int)i] != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        const char *return_value_ci_str_vector_search$3;
        return_value_ci_str_vector_search$3=ci_str_vector_search(table->col_names, columns[(signed long int)i]);
        if(return_value_ci_str_vector_search$3 == ((const char *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "lookup_table :%s does not has column %s\n", table->type, columns[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("lookup_table :%s does not has column %s\n", table->type, columns[(signed long int)i]);

          }

          return (void *)0;
        }

        i = i + 1;
      }
      while((_Bool)1);
      const void *return_value;
      return_value=table->_lt_type->get_row(table, key, columns, vals);
      return return_value;
    }
  }
}

// magics_add
// file filetype.c line 116
signed int magics_add(struct ci_magics_db *db, signed int offset, unsigned char *magic, unsigned long int len, signed int type)
{
  struct ci_magic *newdata;
  signed int indx;
  if(db->magics_num >= db->magics_size)
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)db->magics, (unsigned long int)(db->magics_size + 50) * sizeof(struct ci_magic) /*72ul*/ );
    newdata = (struct ci_magic *)return_value_realloc$1;
    if(newdata == ((struct ci_magic *)NULL))
      return -1;

    db->magics_size = db->magics_size + 50;
    db->magics = newdata;
  }

  indx = db->magics_num;
  db->magics_num = db->magics_num + 1;
  (db->magics + (signed long int)indx)->type = (unsigned int)type;
  (db->magics + (signed long int)indx)->offset = offset;
  (db->magics + (signed long int)indx)->len = len;
  memcpy((void *)(db->magics + (signed long int)indx)->magic, (const void *)magic, len);
  return indx;
}

// magics_init
// file filetype.c line 83
signed int magics_init(struct ci_magics_db *db)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)50 * sizeof(struct ci_magic) /*72ul*/ );
  db->magics = (struct ci_magic *)return_value_malloc$1;
  if(db->magics == ((struct ci_magic *)NULL))
    return 0;

  else
  {
    db->magics_num = 0;
    db->magics_size = 50;
    return 1;
  }
}

// main
// file test_cache.c line 66
signed int main(signed int argc, char **argv)
{
  signed int i;
  struct ci_cache *cache;
  char *s;
  const char *str;
  unsigned long int v_size;
  ci_cfg_lib_init();
  mem_init();
  __log_error = (void (*)(void *, const char *, ...))log_errors;
  signed int return_value_ci_args_apply$1;
  return_value_ci_args_apply$1=ci_args_apply(argc, argv, options);
  if(return_value_ci_args_apply$1 == 0)
  {
    ci_args_usage(argv[(signed long int)0], options);
    exit(-1);
  }

  if(CACHE_TYPE == ((char *)NULL))
    CACHE_TYPE = "local";

  cache=ci_cache_build("test1", CACHE_TYPE, (unsigned int)65536, (unsigned int)2048, 0, &ci_str_ops);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen("A test1 val");
  ci_cache_update(cache, (const void *)"test1", (const void *)"A test1 val", return_value_strlen$2 + (unsigned long int)1, (void * (*)(void *, const void *, unsigned long int))(void *)0);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen("A test2 val");
  ci_cache_update(cache, (const void *)"test2", (const void *)"A test2 val", return_value_strlen$3 + (unsigned long int)1, (void * (*)(void *, const void *, unsigned long int))(void *)0);
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen("A test 3 val");
  ci_cache_update(cache, (const void *)"test3", (const void *)"A test 3 val", return_value_strlen$4 + (unsigned long int)1, (void * (*)(void *, const void *, unsigned long int))(void *)0);
  unsigned long int return_value_strlen$5;
  return_value_strlen$5=strlen("A test 4 val");
  ci_cache_update(cache, (const void *)"test4", (const void *)"A test 4 val", return_value_strlen$5 + (unsigned long int)1, (void * (*)(void *, const void *, unsigned long int))(void *)0);
  const void *return_value_ci_cache_search$6;
  return_value_ci_cache_search$6=ci_cache_search(cache, (const void *)"test2", (void **)&s, (void *)0, (void * (*)(const void *, unsigned long int, void *))(void *)0);
  if(!(return_value_ci_cache_search$6 == NULL))
  {
    printf("Found : %s\n", s);
    ci_buffer_free((void *)s);
  }

  const void *return_value_ci_cache_search$7;
  return_value_ci_cache_search$7=ci_cache_search(cache, (const void *)"test21", (void **)&s, (void *)0, (void * (*)(const void *, unsigned long int, void *))(void *)0);
  if(!(return_value_ci_cache_search$7 == NULL))
  {
    printf("Found : %s (correct is NULL!)\n", s);
    ci_buffer_free((void *)s);
  }

  const void *return_value_ci_cache_search$8;
  return_value_ci_cache_search$8=ci_cache_search(cache, (const void *)"test1", (void **)&s, (void *)0, (void * (*)(const void *, unsigned long int, void *))(void *)0);
  if(!(return_value_ci_cache_search$8 == NULL))
  {
    printf("Found : %s\n", s);
    ci_buffer_free((void *)s);
  }

  const void *return_value_ci_cache_search$9;
  return_value_ci_cache_search$9=ci_cache_search(cache, (const void *)"test4", (void **)&s, (void *)0, (void * (*)(const void *, unsigned long int, void *))(void *)0);
  if(!(return_value_ci_cache_search$9 == NULL))
  {
    printf("Found : %s\n", s);
    ci_buffer_free((void *)s);
  }

  ci_cache_destroy(cache);
  cache=ci_cache_build("test2", CACHE_TYPE, (unsigned int)65536, (unsigned int)2048, 0, &ci_str_ops);
  struct ci_vector *vect_str;
  vect_str=ci_vector_create((unsigned long int)4096);
  unsigned long int return_value_strlen$10;
  return_value_strlen$10=strlen("1_val1");
  void *return_value_ci_vector_add$11;
  return_value_ci_vector_add$11=ci_vector_add(vect_str, (const void *)"1_val1", return_value_strlen$10 + (unsigned long int)1);
  str = (const char *)return_value_ci_vector_add$11;
  printf("Found 1_val1: %s\n", str);
  unsigned long int return_value_strlen$12;
  return_value_strlen$12=strlen("1_val2");
  void *return_value_ci_vector_add$13;
  return_value_ci_vector_add$13=ci_vector_add(vect_str, (const void *)"1_val2", return_value_strlen$12 + (unsigned long int)1);
  str = (const char *)return_value_ci_vector_add$13;
  printf("Found 1_val2: %s\n", str);
  v_size=ci_cache_store_vector_size(vect_str);
  ci_cache_update(cache, (const void *)"vect1", (const void *)vect_str, v_size, ci_cache_store_vector_val);
  ci_vector_destroy(vect_str);
  vect_str=ci_vector_create((unsigned long int)4096);
  unsigned long int return_value_strlen$14;
  return_value_strlen$14=strlen("2_val1");
  void *return_value_ci_vector_add$15;
  return_value_ci_vector_add$15=ci_vector_add(vect_str, (const void *)"2_val1", return_value_strlen$14 + (unsigned long int)1);
  str = (const char *)return_value_ci_vector_add$15;
  unsigned long int return_value_strlen$16;
  return_value_strlen$16=strlen("2_val2");
  void *return_value_ci_vector_add$17;
  return_value_ci_vector_add$17=ci_vector_add(vect_str, (const void *)"2_val2", return_value_strlen$16 + (unsigned long int)1);
  str = (const char *)return_value_ci_vector_add$17;
  unsigned long int return_value_strlen$18;
  return_value_strlen$18=strlen("2_val3");
  void *return_value_ci_vector_add$19;
  return_value_ci_vector_add$19=ci_vector_add(vect_str, (const void *)"2_val3", return_value_strlen$18 + (unsigned long int)1);
  str = (const char *)return_value_ci_vector_add$19;
  v_size=ci_cache_store_vector_size(vect_str);
  ci_cache_update(cache, (const void *)"vect2", (const void *)vect_str, v_size, ci_cache_store_vector_val);
  ci_vector_destroy(vect_str);
  const void *return_value_ci_cache_search$21;
  return_value_ci_cache_search$21=ci_cache_search(cache, (const void *)"vect1", (void **)&vect_str, (void *)0, ci_cache_read_vector_val);
  _Bool tmp_if_expr$20;
  if(!(return_value_ci_cache_search$21 == NULL))
  {
    i = 0;
    do
    {
      if(!(vect_str == ((struct ci_vector *)NULL)))
        tmp_if_expr$20 = vect_str->items[(signed long int)i] != (void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$20 = (_Bool)0;
      if(!tmp_if_expr$20)
        break;

      printf("Vector item %d:%s \n", i, (char *)vect_str->items[(signed long int)i]);
      i = i + 1;
    }
    while((_Bool)1);
    ci_vector_destroy(vect_str);
  }

  const void *return_value_ci_cache_search$23;
  return_value_ci_cache_search$23=ci_cache_search(cache, (const void *)"vect2", (void **)&vect_str, (void *)0, ci_cache_read_vector_val);
  _Bool tmp_if_expr$22;
  if(!(return_value_ci_cache_search$23 == NULL))
  {
    i = 0;
    do
    {
      if(!(vect_str == ((struct ci_vector *)NULL)))
        tmp_if_expr$22 = vect_str->items[(signed long int)i] != (void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$22 = (_Bool)0;
      if(!tmp_if_expr$22)
        break;

      printf("Vector item %d:%s \n", i, (char *)vect_str->items[(signed long int)i]);
      i = i + 1;
    }
    while((_Bool)1);
    ci_vector_destroy(vect_str);
  }

  ci_cache_destroy(cache);
  cache=ci_cache_build("test3", CACHE_TYPE, (unsigned int)65536, (unsigned int)2048, 0, (const struct ci_type_ops *)(void *)0);
  ci_cache_update(cache, (const void *)"nulkey1", (void *)0, (unsigned long int)0, (void * (*)(void *, const void *, unsigned long int))(void *)0);
  ci_cache_update(cache, (const void *)"nulkey2", (void *)0, (unsigned long int)0, (void * (*)(void *, const void *, unsigned long int))(void *)0);
  const void *return_value_ci_cache_search$24;
  return_value_ci_cache_search$24=ci_cache_search(cache, (const void *)"nulkey1", (void **)&s, (void *)0, (void * (*)(const void *, unsigned long int, void *))(void *)0);
  if(!(return_value_ci_cache_search$24 == NULL))
  {
    printf("Found : %s\n", s);
    ci_buffer_free((void *)s);
  }

  const void *return_value_ci_cache_search$25;
  return_value_ci_cache_search$25=ci_cache_search(cache, (const void *)"nulkey2", (void **)&s, (void *)0, (void * (*)(const void *, unsigned long int, void *))(void *)0);
  if(!(return_value_ci_cache_search$25 == NULL))
  {
    printf("Found : %s\n", s);
    ci_buffer_free((void *)s);
  }

  ci_cache_destroy(cache);
  return 0;
}

// makeTemplatePathFileName
// file txtTemplate.c line 70
static void makeTemplatePathFileName(char *path, signed int path_len, const char *service_name, const char *page_name, const char *lang)
{
  snprintf(path, (unsigned long int)path_len, "%s/%s/%s/%s", TEMPLATE_DIR, service_name, lang, page_name);
  path[(signed long int)(path_len - 1)] = (char)0;
}

// mem_init
// file test_cache.c line 65
signed int mem_init()
{
  signed int ret = -1;
  ret=ci_buffers_init();
  default_allocator=ci_create_os_allocator();
  if(default_allocator == ((struct ci_mem_allocator *)NULL) && ret == -1)
    ret = 0;

  MEM_ALLOCATOR_POOL=ci_object_pool_register("ci_mem_allocator_t", (signed int)sizeof(struct ci_mem_allocator) /*56ul*/ );
  /* assertion MEM_ALLOCATOR_POOL >=0 */
  assert(MEM_ALLOCATOR_POOL >= 0);
  unsigned long int return_value_sizeof_pack_allocator$1;
  return_value_sizeof_pack_allocator$1=sizeof_pack_allocator();
  PACK_ALLOCATOR_POOL=ci_object_pool_register("pack_allocator_t", (signed int)return_value_sizeof_pack_allocator$1);
  /* assertion PACK_ALLOCATOR_POOL >=0 */
  assert(PACK_ALLOCATOR_POOL >= 0);
  return ret;
}

// mem_reset
// file mem.c line 58
void mem_reset()
{
  ;
}

// mk_encaps_entity
// file header.c line 547
struct ci_encaps_entity * mk_encaps_entity(signed int type, signed int val)
{
  struct ci_encaps_entity *h;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_encaps_entity) /*16ul*/ );
  h = (struct ci_encaps_entity *)return_value_malloc$1;
  struct ci_headers_list *return_value_ci_headers_create$2;
  if(h == ((struct ci_encaps_entity *)NULL))
    return (struct ci_encaps_entity *)(void *)0;

  else
  {
    h->start = val;
    h->type = type;
    if(type == 0 || type == 1)
    {
      return_value_ci_headers_create$2=ci_headers_create();
      h->entity = (void *)return_value_ci_headers_create$2;
    }

    else
      h->entity = (void *)0;
    return h;
  }
}

// mmap_shared_mem_attach
// file os/unix/shared_mem.c line 118
void * mmap_shared_mem_attach(struct ci_shared_mem_id *id)
{
  return (void *)id->mem;
}

// mmap_shared_mem_create
// file os/unix/shared_mem.c line 103
void * mmap_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  id->mem=mmap64(NULL, (unsigned long int)size, 0x1 | 0x2, 0x01 | 0x20, -1, (signed long int)0);
  if(id->mem == (void *)-1)
    return (void *)0;

  else
  {
    id->size = (unsigned long int)size;
    snprintf(id->name, (unsigned long int)64, "%s", name);
    return id->mem;
  }
}

// mmap_shared_mem_destroy
// file os/unix/shared_mem.c line 131
signed int mmap_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  munmap(id->mem, id->size);
  return 1;
}

// mmap_shared_mem_detach
// file os/unix/shared_mem.c line 124
signed int mmap_shared_mem_detach(struct ci_shared_mem_id *id)
{
  return 1;
}

// mmap_shared_mem_print_info
// file os/unix/shared_mem.c line 137
signed int mmap_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "mmap:%s/%p %ld kbs", (const void *)id->name, id->mem, (signed long int)(id->size / (unsigned long int)1024));
  return return_value_snprintf$1;
}

// net_data_read
// file request_common.c line 627
signed int net_data_read(struct ci_request *req)
{
  signed int bytes;
  if(!(req->pstrblock_read == req->rbuf))
  {
    if(!(req->pstrblock_read_len == 0))
      memmove((void *)req->rbuf, (const void *)req->pstrblock_read, (unsigned long int)req->pstrblock_read_len);

    req->pstrblock_read = req->rbuf;
  }

  bytes = 4096 - req->pstrblock_read_len;
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  if(!(bytes >= 1))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to read data! Is this a bug (%d %d)?????\n", req->pstrblock_read_len, 4096);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to read data! Is this a bug (%d %d)?????\n", req->pstrblock_read_len, 4096);

    }

    return -1;
  }

  else
  {
    bytes=ci_read_nonblock(req->connection->fd, (void *)(req->rbuf + (signed long int)req->pstrblock_read_len), (unsigned long int)bytes);
    if(!(bytes >= 1))
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location$1=__errno_location();
          __log_error((void *)0, "Error reading data (read return=%d, errno=%d) \n", bytes, *return_value___errno_location$1);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location$2=__errno_location();
          printf("Error reading data (read return=%d, errno=%d) \n", bytes, *return_value___errno_location$2);
        }

      }

      return -1;
    }

    else
    {
      req->pstrblock_read_len = req->pstrblock_read_len + bytes;
      req->bytes_in = req->bytes_in + (unsigned long int)bytes;
      return 1;
    }
  }
}

// os_allocator_alloc
// file mem.c line 404
static void * os_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(size);
  return return_value_malloc$1;
}

// os_allocator_destroy
// file mem.c line 419
static void os_allocator_destroy(struct ci_mem_allocator *allocator)
{
  ;
}

// os_allocator_free
// file mem.c line 409
static void os_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  free(p);
}

// os_allocator_reset
// file mem.c line 414
static void os_allocator_reset(struct ci_mem_allocator *allocator)
{
  ;
}

// parse_chunk_data
// file request_common.c line 492
signed int parse_chunk_data(struct ci_request *req, char **wdata)
{
  char *end;
  const char *eofChunk;
  signed int chunkLen;
  signed int remains;
  signed int tmp;
  signed int read_status = 0;
  *wdata = (char *)(void *)0;
  signed int return_value_strncmp$4;
  signed int return_value_strncmp$3;
  if(!(req->write_to_module_pending == 0u))
    return -1;

  else
  {
    while((_Bool)1)
    {
      if(req->current_chunk_len == req->chunk_bytes_read)
        read_status = 1;

      else
        read_status = 2;
      if(read_status == 1)
      {
        eofChunk=ci_strnstr(req->pstrblock_read, "\r\n", (unsigned long int)req->pstrblock_read_len);
        if(eofChunk == ((const char *)NULL))
        {
          if(req->pstrblock_read_len >= 4096)
            return -1;

          return 2;
        }

        eofChunk = eofChunk + (signed long int)2;
        chunkLen = (signed int)(eofChunk - req->pstrblock_read);
        req->request_bytes_in = req->request_bytes_in + (unsigned long int)(eofChunk - req->pstrblock_read);
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        *return_value___errno_location$1 = 0;
        signed long int return_value_strtol$2;
        return_value_strtol$2=strtol(req->pstrblock_read, &end, 16);
        tmp = (signed int)return_value_strtol$2;
        if(tmp == 0)
        {
          if(req->pstrblock_read == end)
          {
            if(CI_DEBUG_LEVEL >= 5)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Parse error:count=%d,start=%c\n", tmp, req->pstrblock_read[(signed long int)0]);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Parse error:count=%d,start=%c\n", tmp, req->pstrblock_read[(signed long int)0]);

            }

            return -1;
          }

        }

        req->current_chunk_len = (unsigned int)tmp;
        req->chunk_bytes_read = (unsigned int)0;
        for( ; (_Bool)1; end = end + 1l)
          if(!((signed int)*end == 32))
          {
            if(!((signed int)*end == 9))
              goto __CPROVER_DUMP_L11;

          }


      __CPROVER_DUMP_L11:
        ;
        if(req->current_chunk_len == 0u)
        {
          remains = req->pstrblock_read_len - chunkLen;
          if(!(remains >= 2))
            return 2;

          if(!((signed int)*eofChunk == 13))
          {
            if(!((signed int)eofChunk[1l] == 10))
              return -1;

          }

          eofChunk = eofChunk + (signed long int)2;
          chunkLen = chunkLen + 2;
          req->request_bytes_in = req->request_bytes_in + (unsigned long int)2;
          if((signed int)*end == 59)
          {
            end = end + 1l;
            for( ; (_Bool)1; end = end + 1l)
              if(!((signed int)*end == 32))
              {
                if(!((signed int)*end == 9))
                  goto __CPROVER_DUMP_L16;

              }


          __CPROVER_DUMP_L16:
            ;
            remains = (signed int)((signed long int)req->pstrblock_read_len - (end - req->pstrblock_read));
            _Bool tmp_if_expr$5;
            if(remains >= 18)
            {
              return_value_strncmp$4=strncmp(end, "use-original-body=", (unsigned long int)18);
              tmp_if_expr$5 = return_value_strncmp$4 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$5 = (_Bool)0;
            if(tmp_if_expr$5)
              req->i206_use_original_body=strtol(end + (signed long int)18, &end, 10);

            else
              if(remains >= 4)
              {
                return_value_strncmp$3=strncmp(end, "ieof", (unsigned long int)4);
                if(!(return_value_strncmp$3 == 0))
                  return -1;

              }

            for( ; !((signed int)*end == 13); end = end + 1l)
              ;
            req->eof_received = 1;
          }

        }

        else
        {
          read_status = 2;
          req->current_chunk_len = req->current_chunk_len + (unsigned int)2;
        }
        _Bool tmp_if_expr$6;
        if(!((signed int)*end == 13))
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)end[(signed long int)1] != 10 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          return -1;

        req->pstrblock_read_len = req->pstrblock_read_len - chunkLen;
        req->pstrblock_read = req->pstrblock_read + (signed long int)chunkLen;
      }

      if(req->current_chunk_len == 0u)
        return -2;

      if(!(req->write_to_module_pending == 0u))
        return 1;

      if(read_status == 2)
      {
        if(!(req->pstrblock_read_len >= 1))
          return 2;

        *wdata = req->pstrblock_read;
        remains = (signed int)(req->current_chunk_len - req->chunk_bytes_read);
        if(req->pstrblock_read_len >= remains)
        {
          if(remains >= 3)
          {
            req->write_to_module_pending = (unsigned int)(remains - 2);
            req->http_bytes_in = req->http_bytes_in + (unsigned long int)req->write_to_module_pending;
            req->body_bytes_in = req->body_bytes_in + (unsigned long int)req->write_to_module_pending;
          }

          else
            req->write_to_module_pending = (unsigned int)0;
          req->chunk_bytes_read = req->chunk_bytes_read + (unsigned int)remains;
          req->pstrblock_read = req->pstrblock_read + (signed long int)remains;
          req->pstrblock_read_len = req->pstrblock_read_len - remains;
          req->request_bytes_in = req->request_bytes_in + (unsigned long int)remains;
        }

        else
        {
          tmp = remains - req->pstrblock_read_len;
          if(!(tmp >= 2))
            req->write_to_module_pending = (unsigned int)(req->pstrblock_read_len - tmp);

          else
            req->write_to_module_pending = (unsigned int)req->pstrblock_read_len;
          req->http_bytes_in = req->http_bytes_in + (unsigned long int)req->write_to_module_pending;
          req->body_bytes_in = req->body_bytes_in + (unsigned long int)req->write_to_module_pending;
          req->request_bytes_in = req->request_bytes_in + (unsigned long int)req->pstrblock_read_len;
          req->chunk_bytes_read = req->chunk_bytes_read + (unsigned int)req->pstrblock_read_len;
          req->pstrblock_read = req->pstrblock_read + (signed long int)req->pstrblock_read_len;
          req->pstrblock_read_len = req->pstrblock_read_len - req->pstrblock_read_len;
        }
      }

      if(req->pstrblock_read_len == 0)
        return 2;

    }
    return 1;
  }
}

// parse_directive
// file txt_format.c line 160
unsigned int parse_directive(const char *var, unsigned int *width, signed int *left_align, char *parameter)
{
  const char *s1;
  signed int i = 0;
  char *e;
  s1 = var + (signed long int)1;
  parameter[(signed long int)0] = (char)0;
  if((signed int)*s1 == 45)
  {
    *left_align = 1;
    s1 = s1 + 1l;
  }

  else
    *left_align = 0;
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(s1, &e, 10);
  *width = (unsigned int)return_value_strtol$1;
  if(e == s1)
    *width = (unsigned int)0;

  else
    s1 = e;
  if((signed int)*s1 == 123)
  {
    s1 = s1 + 1l;
    i = 0;
    for( ; !(*s1 == 0); s1 = s1 + 1l)
    {
      if((signed int)*s1 == 125)
        break;

      if(i >= 256)
        break;

      parameter[(signed long int)i] = *s1;
      i = i + 1;
    }
    if(!((signed int)*s1 == 125))
      return (unsigned int)0;

    parameter[(signed long int)i] = (char)0;
    s1 = s1 + 1l;
  }

  return (unsigned int)(s1 - var);
}

// parse_record
// file filetype.c line 179
static signed int parse_record(char *line, struct ci_magic_record *record)
{
  char *s;
  char *end;
  char num[4l];
  signed int len;
  signed int c;
  signed int i;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(line);
  len = (signed int)return_value_strlen$1;
  signed int *return_value___errno_location$4;
  if(!(len >= 4))
    return 0;

  else
    if((signed int)*line == 35)
      return 0;

    else
    {
      len = len - 1;
      line[(signed long int)len] = (char)0;
      s = line;
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 0;
      signed long int return_value_strtol$3;
      return_value_strtol$3=strtol(s, &end, 10);
      record->offset = (signed int)return_value_strtol$3;
      _Bool tmp_if_expr$5;
      if(!((signed int)*end == 58))
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value___errno_location$4=__errno_location();
        tmp_if_expr$5 = *return_value___errno_location$4 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        return 0;

      else
      {
        s = end + (signed long int)1;
        i = 0;
        end = line + (signed long int)len;
        while(!((signed int)*s == 58))
        {
          if(s >= end)
            break;

          if(i >= 50)
            break;

          if((signed int)*s == 92)
          {
            s = s + 1l;
            if((signed int)*s == 120)
            {
              s = s + 1l;
              char *tmp_post$6 = s;
              s = s + 1l;
              num[(signed long int)0] = *tmp_post$6;
              char *tmp_post$7 = s;
              s = s + 1l;
              num[(signed long int)1] = *tmp_post$7;
              num[(signed long int)2] = (char)0;
              signed long int return_value_strtol$8;
              return_value_strtol$8=strtol(num, (char ** restrict )(void *)0, 16);
              c = (signed int)return_value_strtol$8;
            }

            else
            {
              char *tmp_post$9 = s;
              s = s + 1l;
              num[(signed long int)0] = *tmp_post$9;
              char *tmp_post$10 = s;
              s = s + 1l;
              num[(signed long int)1] = *tmp_post$10;
              char *tmp_post$11 = s;
              s = s + 1l;
              num[(signed long int)2] = *tmp_post$11;
              num[(signed long int)3] = (char)0;
              signed long int return_value_strtol$12;
              return_value_strtol$12=strtol(num, (char ** restrict )(void *)0, 8);
              c = (signed int)return_value_strtol$12;
            }
            if(c >= 257 || !(c >= 0))
              return -2;

            signed int tmp_post$13 = i;
            i = i + 1;
            record->magic[(signed long int)tmp_post$13] = (unsigned char)c;
          }

          else
          {
            signed int tmp_post$14 = i;
            i = i + 1;
            record->magic[(signed long int)tmp_post$14] = (unsigned char)*s;
            s = s + 1l;
          }
        }
        record->len = (unsigned long int)i;
        _Bool tmp_if_expr$15;
        if(s >= end)
          tmp_if_expr$15 = (_Bool)1;

        else
          tmp_if_expr$15 = (signed int)*s != 58 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$15)
          return -2;

        else
        {
          s = s + 1l;
          end=strchr(s, 58);
          if(end == ((char *)NULL))
            return -2;

          else
          {
            *end = (char)0;
            strncpy(record->type, s, (unsigned long int)15);
            record->type[(signed long int)15] = (char)0;
            s = end + (signed long int)1;
            end=strchr(s, 58);
            if(end == ((char *)NULL))
              return -2;

            else
            {
              *end = (char)0;
              strncpy(record->descr, s, (unsigned long int)50);
              record->descr[(signed long int)50] = (char)0;
              s = end + (signed long int)1;
              i = 0;
              do
              {
                end=strchr(s, 58);
                if(end == ((char *)NULL))
                  break;

                *end = (char)0;
                void *return_value_malloc$16;
                return_value_malloc$16=malloc((unsigned long int)(15 + 1));
                record->groups[(signed long int)i] = (char *)return_value_malloc$16;
                strncpy(record->groups[(signed long int)i], s, (unsigned long int)15);
                record->groups[(signed long int)i][(signed long int)15] = (char)0;
                i = i + 1;
                if(i >= 64)
                  break;

                s = end + (signed long int)1;
              }
              while((_Bool)1);
              void *return_value_malloc$17;
              return_value_malloc$17=malloc((unsigned long int)(15 + 1));
              record->groups[(signed long int)i] = (char *)return_value_malloc$17;
              strncpy(record->groups[(signed long int)i], s, (unsigned long int)15);
              record->groups[(signed long int)i][(signed long int)15] = (char)0;
              i = i + 1;
              record->groups[(signed long int)i] = (char *)(void *)0;
              return 1;
            }
          }
        }
      }
    }
}

// pointers_cmp
// file array.c line 685
static signed int pointers_cmp(const void *obj1, const void *obj2, unsigned long int size)
{
  return obj1 == obj2 ? 0 : (obj1 > obj2 ? 1 : -1);
}

// pool_allocator_alloc
// file mem.c line 796
static void * pool_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  struct mem_block_item *mem_item;
  void *data = (void *)0;
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  if(!((unsigned long int)palloc->items_size >= size))
    return (void *)0;

  else
  {
    pthread_mutex_lock(&palloc->mutex);
    if(!(palloc->free == ((struct mem_block_item *)NULL)))
    {
      mem_item = palloc->free;
      palloc->free = palloc->free->next;
      data = mem_item->data;
      mem_item->data = (void *)0;
      palloc->hits_count = palloc->hits_count + 1;
    }

    else
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct mem_block_item) /*16ul*/ );
      mem_item = (struct mem_block_item *)return_value_malloc$1;
      mem_item->data = (void *)0;
      data=malloc((unsigned long int)palloc->items_size);
      palloc->alloc_count = palloc->alloc_count + 1;
    }
    mem_item->next = palloc->allocated;
    palloc->allocated = mem_item;
    pthread_mutex_unlock(&palloc->mutex);
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "pool hits:%d allocations: %d\n", palloc->hits_count, palloc->alloc_count);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("pool hits:%d allocations: %d\n", palloc->hits_count, palloc->alloc_count);

    }

    return data;
  }
}

// pool_allocator_build
// file mem.c line 775
static struct pool_allocator * pool_allocator_build(signed int items_size, signed int strict)
{
  struct pool_allocator *palloc;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct pool_allocator) /*72ul*/ );
  palloc = (struct pool_allocator *)return_value_malloc$1;
  if(palloc == ((struct pool_allocator *)NULL))
    return (struct pool_allocator *)(void *)0;

  else
  {
    palloc->items_size = items_size;
    palloc->strict = strict;
    palloc->free = (struct mem_block_item *)(void *)0;
    palloc->allocated = (struct mem_block_item *)(void *)0;
    palloc->alloc_count = 0;
    palloc->hits_count = 0;
    ci_thread_mutex_init(&palloc->mutex);
    return palloc;
  }
}

// pool_allocator_destroy
// file mem.c line 880
static void pool_allocator_destroy(struct ci_mem_allocator *allocator)
{
  pool_allocator_reset(allocator);
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  ci_thread_mutex_destroy(&palloc->mutex);
  free((void *)palloc);
}

// pool_allocator_free
// file mem.c line 829
static void pool_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  struct mem_block_item *mem_item;
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  pthread_mutex_lock(&palloc->mutex);
  if(palloc->allocated == ((struct mem_block_item *)NULL))
    free(p);

  else
  {
    mem_item = palloc->allocated;
    palloc->allocated = palloc->allocated->next;
    mem_item->data = p;
    mem_item->next = palloc->free;
    palloc->free = mem_item;
  }
  pthread_mutex_unlock(&palloc->mutex);
}

// pool_allocator_reset
// file mem.c line 850
static void pool_allocator_reset(struct ci_mem_allocator *allocator)
{
  struct mem_block_item *mem_item;
  struct mem_block_item *cur;
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  pthread_mutex_lock(&palloc->mutex);
  if(!(palloc->allocated == ((struct mem_block_item *)NULL)))
  {
    mem_item = palloc->allocated;
    while(!(mem_item == ((struct mem_block_item *)NULL)))
    {
      cur = mem_item;
      mem_item = mem_item->next;
      free((void *)cur);
    }
  }

  palloc->allocated = (struct mem_block_item *)(void *)0;
  if(!(palloc->free == ((struct mem_block_item *)NULL)))
  {
    mem_item = palloc->free;
    while(!(mem_item == ((struct mem_block_item *)NULL)))
    {
      cur = mem_item;
      mem_item = mem_item->next;
      free(cur->data);
      free((void *)cur);
    }
  }

  palloc->free = (struct mem_block_item *)(void *)0;
  pthread_mutex_unlock(&palloc->mutex);
}

// posix_proc_mutex_destroy
// file os/unix/proc_mutex.c line 139
static signed int posix_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  signed int return_value_sem_unlink$1;
  return_value_sem_unlink$1=sem_unlink(mutex->name);
  if(!(return_value_sem_unlink$1 >= 0))
    return 0;

  else
    return 1;
}

// posix_proc_mutex_init
// file os/unix/proc_mutex.c line 118
static signed int posix_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  signed int i = 0;
  mutex->$anon0.posix.sem = (union anonymous$1 *)0;
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    snprintf(mutex->name, (unsigned long int)64, "%s%s.%d", (const void *)"/c-icap-sem.", name, i);
    mutex->$anon0.posix.sem=sem_open(mutex->name, 0100 | 0200, 0400 | 0200 | 0400 >> 3, 1);
    if(!(mutex->$anon0.posix.sem == ((union anonymous$1 *)NULL)))
      return 1;

    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(!(*return_value___errno_location$2 == 17))
      break;

  }
  signed int *return_value___errno_location$5;
  return_value___errno_location$5=__errno_location();
  signed int *return_value___errno_location$3;
  signed int *return_value___errno_location$4;
  if(*return_value___errno_location$5 == 17)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocation posix proc mutex, to many c-icap mutexes are open!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocation posix proc mutex, to many c-icap mutexes are open!\n");

    }

  }

  else
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value___errno_location$3=__errno_location();
        __log_error((void *)0, "Error allocation posix proc mutex, errno: %d\n", *return_value___errno_location$3);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value___errno_location$4=__errno_location();
        printf("Error allocation posix proc mutex, errno: %d\n", *return_value___errno_location$4);
      }

    }

  return 0;
}

// posix_proc_mutex_lock
// file os/unix/proc_mutex.c line 147
static signed int posix_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  signed int return_value_sem_wait$1;
  return_value_sem_wait$1=sem_wait(mutex->$anon0.posix.sem);
  if(!(return_value_sem_wait$1 == 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to get lock of posix mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to get lock of posix mutex\n");

    }

    return 0;
  }

  else
    return 1;
}

// posix_proc_mutex_print_info
// file os/unix/proc_mutex.c line 165
static signed int posix_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "posix:%s", (const void *)mutex->name);
  return return_value_snprintf$1;
}

// posix_proc_mutex_unlock
// file os/unix/proc_mutex.c line 156
static signed int posix_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  signed int return_value_sem_post$1;
  return_value_sem_post$1=sem_post(mutex->$anon0.posix.sem);
  if(!(return_value_sem_post$1 == 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to unlock of posix mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to unlock of posix mutex\n");

    }

    return 0;
  }

  else
    return 1;
}

// posix_shared_mem_attach
// file os/unix/shared_mem.c line 179
void * posix_shared_mem_attach(struct ci_shared_mem_id *id)
{
  return id->mem;
}

// posix_shared_mem_create
// file os/unix/shared_mem.c line 157
void * posix_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  signed int i;
  id->size = (unsigned long int)size;
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    snprintf(id->name, (unsigned long int)64, "%s-%s.%d", (const void *)"/c-icap-shared", name, i);
    id->$anon0.posix.fd=shm_open(id->name, 02 | 0100 | 0200, (unsigned int)(0400 | 0200));
    ftruncate64(id->$anon0.posix.fd, (signed long int)id->size);
    if(id->$anon0.posix.fd >= 0)
    {
      id->mem=mmap64((void *)0, (unsigned long int)size, 0x1 | 0x2, 0x01, id->$anon0.posix.fd, (signed long int)0);
      if(id->mem == (void *)-1)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Posix mem: Failed to created shared memory!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Posix mem: Failed to created shared memory!\n");

        }

        return (void *)0;
      }

      return id->mem;
    }

  }
  return (void *)0;
}

// posix_shared_mem_destroy
// file os/unix/shared_mem.c line 192
signed int posix_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  munmap(id->mem, id->size);
  close(id->$anon0.posix.fd);
  id->mem = (void *)0;
  shm_unlink(id->name);
  return 1;
}

// posix_shared_mem_detach
// file os/unix/shared_mem.c line 184
signed int posix_shared_mem_detach(struct ci_shared_mem_id *id)
{
  munmap(id->mem, id->size);
  id->mem = (void *)0;
  return 1;
}

// posix_shared_mem_print_info
// file os/unix/shared_mem.c line 201
signed int posix_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "posix:%s %ld kbs", (const void *)id->name, (signed long int)(id->size / (unsigned long int)1024));
  return return_value_snprintf$1;
}

// process_encapsulated
// file request_common.c line 456
signed int process_encapsulated(struct ci_request *req, const char *buf)
{
  const char *start;
  const char *pos;
  char *end;
  signed int type = 0;
  signed int num = 0;
  signed int val = 0;
  signed int hasbody = 1;
  start = buf + (signed long int)13;
  pos = start;
  end = (char *)start;
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$2;
  do
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*pos]) == 0))
      tmp_if_expr$2 = (signed int)*pos != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    pos = pos + 1l;
  }
  while((_Bool)1);
  const unsigned short int **return_value___ctype_b_loc$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  while(!((signed int)*pos == 0))
  {
    type=get_encaps_type(pos, &val, &end);
    if(!(type >= 0))
      return 4;

    if(num >= 6)
      break;

    if(type == 4)
      hasbody = 0;

    signed int tmp_post$3 = num;
    num = num + 1;
    req->entities[(signed long int)tmp_post$3]=ci_request_alloc_entity(req, type, val);
    /* assertion start != end */
    assert(start != end);
    pos = end;
    do
    {
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*pos]) == 0))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)*pos == 44 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (signed int)*pos != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(!tmp_if_expr$6)
        break;

      pos = pos + 1l;
    }
    while((_Bool)1);
  }
  req->hasbody = hasbody;
  return 0;
}

// read_row
// file lookup_file_table.c line 102
signed int read_row(struct _IO_FILE *f, signed int cols, struct text_table_entry **e, struct ci_lookup_table *table)
{
  char line[65536l];
  char *s;
  char *val;
  char *end;
  signed int row_cols;
  signed int line_len;
  signed int i;
  struct ci_mem_allocator *allocator = table->allocator;
  const struct ci_type_ops *key_ops = table->key_ops;
  const struct ci_type_ops *val_ops = table->val_ops;
  *e = (struct text_table_entry *)(void *)0;
  char *return_value_fgets$1;
  return_value_fgets$1=fgets(line, 65535, f);
  unsigned long int return_value_strlen$3;
  if(return_value_fgets$1 == ((char *)NULL))
    return 0;

  else
  {
    line[(signed long int)65535] = (char)0;
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(line);
    line_len = (signed int)return_value_strlen$2;
    if(line_len >= 65536)
    {
      line[(signed long int)64] = (char)0;
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Too long line: %s...", (const void *)line);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Too long line: %s...", (const void *)line);

      }

      return 0;
    }

    else
    {
      if((signed int)line[(signed long int)(line_len + -1)] == 10)
        line[(signed long int)(line_len - 1)] = (char)0;

      s = line;
      for( ; (_Bool)1; s = s + 1l)
        if(!((signed int)*s == 32))
        {
          if(!((signed int)*s == 9))
            goto __CPROVER_DUMP_L8;

        }


    __CPROVER_DUMP_L8:
      ;
      if((signed int)*s == 35)
        return 1;

      else
        if((signed int)*s == 0)
          return 1;

        else
        {
          if(!(cols >= 0))
          {
            s=index(line, 58);
            if(s == ((char *)NULL))
              row_cols = 1;

            else
            {
              row_cols = 2;
              do
              {
                s=index(s, 44);
                if(s == ((char *)NULL))
                  break;

                row_cols = row_cols + 1;
                s = s + 1l;
              }
              while((_Bool)1);
            }
          }

          else
            row_cols = cols;
          *e=alloc_text_table_entry(row_cols - 1, allocator);
          if(*e == ((struct text_table_entry *)NULL))
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error allocating memory for table entry:%s\n", (const void *)line);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error allocating memory for table entry:%s\n", (const void *)line);

            }

            return 0;
          }

          else
          {
            s = line;
            for( ; (_Bool)1; s = s + 1l)
              if(!((signed int)*s == 32))
              {
                if(!((signed int)*s == 9))
                  goto __CPROVER_DUMP_L21;

              }


          __CPROVER_DUMP_L21:
            ;
            val = s;
            end = (char *)(void *)0;
            if(row_cols >= 2)
              end=index(s, 58);

            if(end == ((char *)NULL))
            {
              return_value_strlen$3=strlen(s);
              end = s + (signed long int)return_value_strlen$3;
            }

            s = end + (signed long int)1;
            end = end - 1l;
            for( ; (_Bool)1; end = end - 1l)
              if(!((signed int)*end == 32))
              {
                if(!((signed int)*end == 9))
                  goto __CPROVER_DUMP_L26;

              }


          __CPROVER_DUMP_L26:
            ;
            end[(signed long int)1] = (char)0;
            (*e)->key=key_ops->dup(val, allocator);
            if((*e)->key == NULL)
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Error reading key in line:%s\n", (const void *)line);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Error reading key in line:%s\n", (const void *)line);

              }

              release_text_table_entry(*e, table);
              *e = (struct text_table_entry *)(void *)0;
              return -1;
            }

            else
            {
              if(row_cols >= 2)
              {
                /* assertion (*e)->vals */
                assert((*e)->vals != ((void **)NULL));
                i = 0;
                if(!((signed int)*s == 0))
                {
                  if(i >= row_cols)
                  {
                    if(CI_DEBUG_LEVEL >= 1)
                    {
                      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                        __log_error((void *)0, "Error in read_row of file lookup table!(line:%s)\n", (const void *)line);

                      if(!(CI_DEBUG_STDOUT == 0))
                        printf("Error in read_row of file lookup table!(line:%s)\n", (const void *)line);

                    }

                    release_text_table_entry(*e, table);
                    *e = (struct text_table_entry *)(void *)0;
                    return -1;
                  }

                  if((signed int)*s == 32)
                    s = s + 1l;

                  val = s;
                  end = s;
                  if(!((signed int)*end == 44))
                  {
                    if(!((signed int)*end == 0))
                      end = end + 1l;

                  }

                  if((signed int)*end == 0)
                    s = end;

                  else
                    s = end + (signed long int)1;
                  end = end - 1l;
                  if((signed int)*end == 32)
                    end = end - 1l;

                  end[(signed long int)1] = (char)0;
                  (*e)->vals[(signed long int)i]=val_ops->dup(val, allocator);
                  i = i + 1;
                }

                (*e)->vals[(signed long int)i] = (void *)0;
              }

              return 1;
            }
          }
        }
    }
  }
}

// regex_cmp
// file types_ops.c line 271
signed int regex_cmp(const void *key1, const void *key2)
{
  struct ci_acl_regex *reg = (struct ci_acl_regex *)key1;
  if(key2 == NULL)
    return -1;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen((const char *)key2);
    signed int return_value_ci_regex_apply$2;
    return_value_ci_regex_apply$2=ci_regex_apply(reg->preg, (const char *)key2, (signed int)return_value_strlen$1, 0, (struct ci_list *)(void *)0, (void *)0);
    return return_value_ci_regex_apply$2 == 0 ? 1 : 0;
  }
}

// regex_dup
// file types_ops.c line 238
void * regex_dup(const char *str, struct ci_mem_allocator *allocator)
{
  struct ci_acl_regex *reg;
  char *newstr;
  signed int flags;
  signed int recursive;
  newstr=ci_regex_parse(str, &flags, &recursive);
  if(newstr == ((char *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Parse error, while parsing regex: '%s')!\n", str);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Parse error, while parsing regex: '%s')!\n", str);

    }

    return (void *)0;
  }

  else
  {
    void *return_value;
    return_value=allocator->alloc(allocator, sizeof(struct ci_acl_regex) /*24ul*/ );
    reg = (struct ci_acl_regex *)return_value;
    if(reg == ((struct ci_acl_regex *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error allocating memory for regex_dup (1)!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error allocating memory for regex_dup (1)!\n");

      }

      free((void *)newstr);
      return (void *)0;
    }

    else
    {
      reg->preg=ci_regex_build(newstr, flags);
      if(reg->preg == NULL)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error compiling regular expression :%s (%s)\n", str, newstr);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error compiling regular expression :%s (%s)\n", str, newstr);

        }

        allocator->free(allocator, (void *)reg);
        free((void *)newstr);
        return (void *)0;
      }

      else
      {
        reg->str = newstr;
        reg->flags = flags;
        return (void *)reg;
      }
    }
  }
}

// regex_equal
// file types_ops.c line 279
signed int regex_equal(const void *key1, const void *key2)
{
  struct ci_acl_regex *reg = (struct ci_acl_regex *)key1;
  if(key2 == NULL)
    return 0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen((const char *)key2);
    signed int return_value_ci_regex_apply$2;
    return_value_ci_regex_apply$2=ci_regex_apply(reg->preg, (const char *)key2, (signed int)return_value_strlen$1, 0, (struct ci_list *)(void *)0, (void *)0);
    return (signed int)(return_value_ci_regex_apply$2 != 0);
  }
}

// regex_free
// file types_ops.c line 292
void regex_free(void *key, struct ci_mem_allocator *allocator)
{
  struct ci_acl_regex *reg = (struct ci_acl_regex *)key;
  ci_regex_free(reg->preg);
  allocator->free(allocator, (void *)reg->str);
  allocator->free(allocator, (void *)reg);
}

// regex_len
// file types_ops.c line 287
unsigned long int regex_len(const void *key)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(((struct ci_acl_regex *)key)->str);
  return return_value_strlen$1;
}

// regex_table_close
// file lookup_file_table.c line 440
void regex_table_close(struct ci_lookup_table *table)
{
  file_table_close(table);
}

// regex_table_open
// file lookup_file_table.c line 419
void * regex_table_open(struct ci_lookup_table *table)
{
  struct text_table *text_table;
  if(!(table->key_ops == &ci_str_ops))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "This type of table is not compatible with regex tables!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("This type of table is not compatible with regex tables!\n");

    }

    return (void *)0;
  }

  else
  {
    table->key_ops = &ci_regex_ops;
    void *return_value_file_table_open$1;
    return_value_file_table_open$1=file_table_open(table);
    text_table = (struct text_table *)return_value_file_table_open$1;
    if(text_table == ((struct text_table *)NULL))
      return (void *)0;

    else
      return (void *)text_table;
  }
}

// regex_table_release_result
// file lookup_file_table.c line 461
void regex_table_release_result(struct ci_lookup_table *table_data, void **val)
{
  ;
}

// regex_table_search
// file lookup_file_table.c line 451
void * regex_table_search(struct ci_lookup_table *table, void *key, void ***vals)
{
  void *return_value_file_table_search$1;
  return_value_file_table_search$1=file_table_search(table, key, vals);
  return return_value_file_table_search$1;
}

// release_body_system
// file body.c line 74
void release_body_system()
{
  ci_object_pool_unregister(MEMBUF_POOL);
  ci_object_pool_unregister(CACHED_FILE_POOL);
  ci_object_pool_unregister(SIMPLE_FILE_POOL);
  ci_object_pool_unregister(RING_BUF_POOL);
}

// release_header_value
// file acl.c line 898
void release_header_value(struct ci_headers_list *headers, char *head)
{
  if(!(headers == ((struct ci_headers_list *)NULL)))
  {
    if(!(headers->packed == 0))
    {
      if(!(head == ((char *)NULL)))
        ci_buffer_free((void *)head);

    }

  }

}

// release_text_table_entry
// file lookup_file_table.c line 81
void release_text_table_entry(struct text_table_entry *e, struct ci_lookup_table *table)
{
  void **vals;
  signed int i;
  struct ci_mem_allocator *allocator = table->allocator;
  if(!(e == ((struct text_table_entry *)NULL)))
  {
    if(!(e->vals == ((void **)NULL)))
    {
      vals = (void **)e->vals;
      i = 0;
      if(!(vals[(signed long int)i] == NULL))
      {
        table->val_ops->free(vals[(signed long int)i], allocator);
        i = i + 1;
      }

      allocator->free(allocator, (void *)e->vals);
    }

    if(!(e->key == NULL))
      table->key_ops->free(e->key, allocator);

    allocator->free(allocator, (void *)e);
  }

}

// request_match_specslist
// file acl.c line 716
signed int request_match_specslist(struct ci_request *req, struct ci_specs_list *spec_list)
{
  const struct ci_acl_spec *spec;
  const struct ci_acl_type *type;
  signed int ret;
  signed int negate;
  signed int check_result;
  void *test_data;
  ret = 1;
  if(!(spec_list == ((struct ci_specs_list *)NULL)))
  {
    spec = spec_list->spec;
    negate = spec_list->negate;
    type = spec->type;
    test_data=type->get_test_data(req, spec->parameter);
    if(test_data == NULL)
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "No data to test for %s/%s, ignore\n", (const void *)type->name, spec->parameter);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("No data to test for %s/%s, ignore\n", (const void *)type->name, spec->parameter);

      }

      return 0;
    }

    check_result=spec_data_check(spec, test_data);
    if(check_result == 0 && negate == 0)
      ret = 0;

    else
      if(!(check_result == 0) && !(negate == 0))
        ret = 0;

    if(!(type->free_test_data == ((void (*)(struct ci_request *, void *))NULL)))
      type->free_test_data(req, test_data);

    if(ret == 0)
      return 0;

    spec_list = spec_list->next;
  }

  return 1;
}

// resize_buffer
// file body.c line 343
signed int resize_buffer(struct ci_cached_file *body, signed int new_size)
{
  char *newbuf;
  if(!(new_size >= body->bufsize))
    return 1;

  else
    if(!(CI_BODY_MAX_MEM >= new_size))
      return 0;

    else
    {
      void *return_value_ci_buffer_realloc$1;
      return_value_ci_buffer_realloc$1=ci_buffer_realloc((void *)body->buf, new_size);
      newbuf = (char *)return_value_ci_buffer_realloc$1;
      if(!(newbuf == ((char *)NULL)))
      {
        body->buf = newbuf;
        body->bufsize = new_size;
      }

      return 1;
    }
}

// search_options_table
// file cfg_lib.c line 76
struct ci_options_entry * search_options_table(const char *directive, struct ci_options_entry *options)
{
  signed int i;
  const char *option_search;
  if(!((signed int)*directive == 45))
    option_search = "$$";

  else
    option_search = directive;
  i = 0;
  for( ; !((options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(option_search, (options + (signed long int)i)->name);
    if(return_value_strcmp$1 == 0)
      return &options[(signed long int)i];

  }
  return (struct ci_options_entry *)(void *)0;
}

// serial_allocation
// file mem.c line 476
static void * serial_allocation(struct serial_allocator *serial_alloc, unsigned long int size)
{
  signed int max_size;
  void *mem;
  size = size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1);
  max_size = (signed int)(serial_alloc->endpos - serial_alloc->memchunk);
  if(!((unsigned long int)max_size >= size))
    return (void *)0;

  else
  {
    for( ; !((unsigned long int)(serial_alloc->endpos - serial_alloc->curpos) >= size); serial_alloc = serial_alloc->next)
      if(serial_alloc->next == ((struct serial_allocator *)NULL))
      {
        serial_alloc->next=serial_allocator_build(max_size);
        if(serial_alloc->next == ((struct serial_allocator *)NULL))
          return (void *)0;

      }

    mem = serial_alloc->curpos;
    serial_alloc->curpos = serial_alloc->curpos + (signed long int)size;
    return mem;
  }
}

// serial_allocator_alloc
// file mem.c line 499
static void * serial_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  struct serial_allocator *serial_alloc = (struct serial_allocator *)allocator->data;
  if(serial_alloc == ((struct serial_allocator *)NULL))
    return (void *)0;

  else
  {
    void *return_value_serial_allocation$1;
    return_value_serial_allocation$1=serial_allocation(serial_alloc, size);
    return return_value_serial_allocation$1;
  }
}

// serial_allocator_build
// file mem.c line 453
static struct serial_allocator * serial_allocator_build(signed int size)
{
  struct serial_allocator *serial_alloc;
  void *buffer;
  size = (signed int)((unsigned long int)size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
  if(!((unsigned long int)size >= sizeof(struct serial_allocator) * 2 + 24 /*88ul*/ ))
    return (struct serial_allocator *)(void *)0;

  else
  {
    buffer=ci_buffer_alloc(size);
    serial_alloc = (struct serial_allocator *)buffer;
    unsigned long int return_value_ci_buffer_blocksize$1;
    return_value_ci_buffer_blocksize$1=ci_buffer_blocksize(buffer);
    size = (signed int)return_value_ci_buffer_blocksize$1;
    serial_alloc->memchunk = buffer + (signed long int)sizeof(struct serial_allocator) /*32ul*/ ;
    size = size - (signed int)sizeof(struct serial_allocator) /*32ul*/ ;
    serial_alloc->curpos = serial_alloc->memchunk;
    serial_alloc->endpos = serial_alloc->memchunk + (signed long int)size;
    serial_alloc->next = (struct serial_allocator *)(void *)0;
    return serial_alloc;
  }
}

// serial_allocator_destroy
// file mem.c line 530
static void serial_allocator_destroy(struct ci_mem_allocator *allocator)
{
  struct serial_allocator *cur;
  struct serial_allocator *next;
  if(!(allocator->data == NULL))
  {
    cur = (struct serial_allocator *)allocator->data;
    next = cur->next;
    while(!(cur == ((struct serial_allocator *)NULL)))
    {
      ci_buffer_free((void *)cur);
      cur = next;
      if(!(next == ((struct serial_allocator *)NULL)))
        next = next->next;

    }
  }

}

// serial_allocator_free
// file mem.c line 508
static void serial_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  ;
}

// serial_allocator_reset
// file mem.c line 513
static void serial_allocator_reset(struct ci_mem_allocator *allocator)
{
  struct serial_allocator *serial_alloc;
  struct serial_allocator *sa;
  void *tmp;
  serial_alloc = (struct serial_allocator *)allocator->data;
  serial_alloc->curpos = serial_alloc->memchunk + (signed long int)(sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
  sa = serial_alloc->next;
  serial_alloc->next = (struct serial_allocator *)(void *)0;
  for( ; !(sa == ((struct serial_allocator *)NULL)); sa = sa->next)
  {
    tmp = (void *)sa;
    ci_buffer_free(tmp);
  }
}

// sizeof_pack_allocator
// file mem.c line 735
static unsigned long int sizeof_pack_allocator()
{
  return sizeof(struct pack_allocator) /*40ul*/ ;
}

// sizeofencaps
// file header.c line 613
signed int sizeofencaps(struct ci_encaps_entity *e)
{
  _Bool tmp_if_expr$2;
  if(e->type == 0)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = e->type == 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    signed int return_value_sizeofheader$1;
    return_value_sizeofheader$1=sizeofheader((struct ci_headers_list *)e->entity);
    return return_value_sizeofheader$1;
  }

  return 0;
}

// sizeofheader
// file header.c line 600
signed int sizeofheader(struct ci_headers_list *h)
{
  return h->bufused + 2;
}

// spec_data_check
// file acl.c line 699
signed int spec_data_check(const struct ci_acl_spec *spec, const void *req_raw_data)
{
  struct ci_acl_data *spec_data = spec->data;
  const struct ci_type_ops *ops = spec->type->type;
  if(CI_DEBUG_LEVEL >= 9)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Check request with ci_acl_spec_t:%s\n", (const void *)spec->name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Check request with ci_acl_spec_t:%s\n", (const void *)spec->name);

  }

  if(!(spec_data == ((struct ci_acl_data *)NULL)))
  {
    signed int return_value;
    return_value=ops->equal(spec_data->data, (void *)req_raw_data);
    if(!(return_value == 0))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "The ci_acl_spec_t:%s matches\n", (const void *)spec->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("The ci_acl_spec_t:%s matches\n", (const void *)spec->name);

      }

      return 1;
    }

    spec_data = spec_data->next;
  }

  return 0;
}

// stat_entry_add
// file stats.c line 40
signed int stat_entry_add(struct stat_entry_list *list, const char *label, signed int type, signed int gid)
{
  struct stat_entry *l;
  signed int indx;
  if(list == ((struct stat_entry_list *)NULL))
    return -1;

  else
  {
    indx=stat_entry_by_name(list, label);
    if(indx >= 0)
      return indx;

    else
    {
      if(list->size == list->entries_num)
      {
        if(list->size == 0)
        {
          void *return_value_malloc$1;
          return_value_malloc$1=malloc((unsigned long int)128 * sizeof(struct stat_entry) /*16ul*/ );
          list->entries = (struct stat_entry *)return_value_malloc$1;
          if(list->entries == ((struct stat_entry *)NULL))
            return -1;

        }

        else
        {
          void *return_value_realloc$2;
          return_value_realloc$2=realloc((void *)list->entries, (unsigned long int)(list->size + 128) * sizeof(struct stat_entry) /*16ul*/ );
          l = (struct stat_entry *)return_value_realloc$2;
          if(l == ((struct stat_entry *)NULL))
            return -1;

          list->entries = l;
        }
        list->size = list->size + 128;
      }

      (list->entries + (signed long int)list->entries_num)->label=strdup(label);
      (list->entries + (signed long int)list->entries_num)->type = type;
      (list->entries + (signed long int)list->entries_num)->gid = gid;
      indx = list->entries_num;
      list->entries_num = list->entries_num + 1;
      return indx;
    }
  }
}

// stat_entry_by_name
// file stats.c line 88
signed int stat_entry_by_name(struct stat_entry_list *list, const char *label)
{
  signed int i;
  signed int return_value_strcmp$1;
  if(list->entries == ((struct stat_entry *)NULL))
    return -1;

  else
  {
    i = 0;
    for( ; !(i >= list->entries_num); i = i + 1)
    {
      return_value_strcmp$1=strcmp(label, (list->entries + (signed long int)i)->label);
      if(return_value_strcmp$1 == 0)
        return i;

    }
    return -1;
  }
}

// stat_entry_release_list
// file stats.c line 75
void stat_entry_release_list(struct stat_entry_list *list)
{
  signed int i;
  if(!(list->entries == ((struct stat_entry *)NULL)))
  {
    i = 0;
    for( ; !(i >= list->entries_num); i = i + 1)
      free((void *)(list->entries + (signed long int)i)->label);
    free((void *)list->entries);
    list->entries = (struct stat_entry *)(void *)0;
    list->size = 0;
    list->entries_num = 0;
  }

}

// stat_group_add
// file stats.c line 100
signed int stat_group_add(char *group)
{
  char **group_list;
  signed int gid = 0;
  gid = 0;
  for( ; !(gid >= STAT_GROUPS.entries_num); gid = gid + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(STAT_GROUPS.groups[(signed long int)gid], group);
    if(return_value_strcmp$1 == 0)
      return gid;

  }
  if(STAT_GROUPS.size == 0)
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)128 * sizeof(char *) /*8ul*/ );
    STAT_GROUPS.groups = (char **)return_value_malloc$2;
    if(STAT_GROUPS.groups == ((char **)NULL))
      return -1;

    STAT_GROUPS.size = 128;
  }

  else
    if(STAT_GROUPS.size == STAT_GROUPS.entries_num)
    {
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)STAT_GROUPS.groups, (unsigned long int)(STAT_GROUPS.size + 128) * sizeof(char *) /*8ul*/ );
      group_list = (char **)return_value_realloc$3;
      if(group_list == ((char **)NULL))
        return -1;

      STAT_GROUPS.groups = group_list;
      STAT_GROUPS.size = STAT_GROUPS.size + 128;
    }

  STAT_GROUPS.groups[(signed long int)STAT_GROUPS.entries_num]=strdup(group);
  gid = STAT_GROUPS.entries_num;
  STAT_GROUPS.entries_num = STAT_GROUPS.entries_num + 1;
  return gid;
}

// stat_memblock_fix
// file stats.c line 273
void stat_memblock_fix(struct stat_memblock *mem_block)
{
  /* assertion mem_block->sig == 0xFAFA */
  assert(mem_block->sig == (unsigned int)0xFAFA);
  mem_block->counters64_size = STAT_INT64.entries_num;
  mem_block->counterskbs_size = STAT_KBS.entries_num;
  mem_block->counters64 = (unsigned long int *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  mem_block->counterskbs = (struct kbs *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)mem_block->counters64_size * sizeof(unsigned long int) /*8ul*/ ));
}

// stat_memblock_reconstruct
// file stats.c line 284
void stat_memblock_reconstruct(struct stat_memblock *mem_block)
{
  /* assertion mem_block->sig == 0xFAFA */
  assert(mem_block->sig == (unsigned int)0xFAFA);
  mem_block->counters64 = (unsigned long int *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  mem_block->counterskbs = (struct kbs *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)mem_block->counters64_size * sizeof(unsigned long int) /*8ul*/ ));
}

// string_ext_cmp
// file types_ops.c line 73
signed int string_ext_cmp(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return -1;

  else
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)key1, "*");
    if(return_value_strcmp$1 == 0)
      return 0;

    else
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp((const char *)key1, (const char *)key2);
      return return_value_strcmp$2;
    }
  }
}

// string_ext_equal
// file types_ops.c line 84
signed int string_ext_equal(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return 0;

  else
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)key1, "*");
    if(return_value_strcmp$1 == 0)
      return 1;

    else
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp((const char *)key1, (const char *)key2);
      return (signed int)(return_value_strcmp$2 == 0);
    }
  }
}

// stringcmp
// file types_ops.c line 41
signed int stringcmp(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return -1;

  else
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)key1, (const char *)key2);
    return return_value_strcmp$1;
  }
}

// stringdup
// file types_ops.c line 33
void * stringdup(const char *str, struct ci_mem_allocator *allocator)
{
  char *new_s;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  void *return_value;
  return_value=allocator->alloc(allocator, return_value_strlen$1 + (unsigned long int)1);
  new_s = (char *)return_value;
  if(!(new_s == ((char *)NULL)))
    strcpy(new_s, str);

  return (void *)new_s;
}

// stringequal
// file types_ops.c line 48
signed int stringequal(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return 0;

  else
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)key1, (const char *)key2);
    return (signed int)(return_value_strcmp$1 == 0);
  }
}

// stringfree
// file types_ops.c line 60
void stringfree(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// stringlen
// file types_ops.c line 55
unsigned long int stringlen(const void *key)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen((const char *)key);
  return return_value_strlen$1 + (unsigned long int)1;
}

// sysv_proc_mutex_destroy
// file os/unix/proc_mutex.c line 74
static signed int sysv_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  signed int return_value_semctl$1;
  return_value_semctl$1=semctl(mutex->$anon0.sysv.id, 0, 0, 0);
  if(!(return_value_semctl$1 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error removing mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error removing mutex\n");

    }

    return 0;
  }

  else
    return 1;
}

// sysv_proc_mutex_init
// file os/unix/proc_mutex.c line 56
static signed int sysv_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  union semun arg;
  mutex->$anon0.sysv.id=semget((signed int)0, 1, 01000 | 0600);
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  if(!(mutex->$anon0.sysv.id >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error creating mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error creating mutex\n");

    }

    return 0;
  }

  else
  {
    arg.val = 0;
    signed int return_value_semctl$3;
    return_value_semctl$3=semctl(mutex->$anon0.sysv.id, 0, 16, arg);
    if(!(return_value_semctl$3 >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location$1=__errno_location();
          __log_error((void *)0, "Error setting default value for mutex, errno:%d\n", *return_value___errno_location$1);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location$2=__errno_location();
          printf("Error setting default value for mutex, errno:%d\n", *return_value___errno_location$2);
        }

      }

      return 0;
    }

    else
    {
      strncpy(mutex->name, name, (unsigned long int)64);
      mutex->name[(signed long int)(64 - 1)] = (char)0;
      return 1;
    }
  }
}

// sysv_proc_mutex_lock
// file os/unix/proc_mutex.c line 83
static signed int sysv_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  signed int return_value_semop$1;
  return_value_semop$1=semop(mutex->$anon0.sysv.id, (struct sembuf *)&op_lock, (unsigned long int)2);
  if(!(return_value_semop$1 >= 0))
    return 0;

  else
    return 1;
}

// sysv_proc_mutex_print_info
// file os/unix/proc_mutex.c line 99
static signed int sysv_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "sysv:%s/%d", (const void *)mutex->name, mutex->$anon0.sysv.id);
  return return_value_snprintf$1;
}

// sysv_proc_mutex_unlock
// file os/unix/proc_mutex.c line 91
static signed int sysv_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  signed int return_value_semop$1;
  return_value_semop$1=semop(mutex->$anon0.sysv.id, (struct sembuf *)&op_unlock, (unsigned long int)1);
  if(!(return_value_semop$1 >= 0))
    return 0;

  else
    return 1;
}

// sysv_shared_mem_attach
// file os/unix/shared_mem.c line 56
void * sysv_shared_mem_attach(struct ci_shared_mem_id *id)
{
  id->mem=shmat(id->$anon0.sysv.id, (void *)0, 0);
  if(id->mem == (void *)-1)
    return (void *)0;

  else
    return id->mem;
}

// sysv_shared_mem_create
// file os/unix/shared_mem.c line 40
void * sysv_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  id->$anon0.sysv.id=shmget((signed int)0, (unsigned long int)size, 0600 | 01000);
  if(!(id->$anon0.sysv.id >= 0))
    return (void *)0;

  else
  {
    id->mem=shmat(id->$anon0.sysv.id, (void *)0, 0);
    if(id->mem == (void *)-1)
      return (void *)0;

    else
    {
      id->size = (unsigned long int)size;
      snprintf(id->name, (unsigned long int)64, "%s", name);
      return id->mem;
    }
  }
}

// sysv_shared_mem_destroy
// file os/unix/shared_mem.c line 73
signed int sysv_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  signed int return_value_shmdt$1;
  return_value_shmdt$1=shmdt(id->mem);
  if(!(return_value_shmdt$1 >= 0))
    return 0;

  else
  {
    signed int return_value_shmctl$2;
    return_value_shmctl$2=shmctl(id->$anon0.sysv.id, 0, (struct shmid_ds *)(void *)0);
    if(!(return_value_shmctl$2 >= 0))
      return 0;

    else
      return 1;
  }
}

// sysv_shared_mem_detach
// file os/unix/shared_mem.c line 64
signed int sysv_shared_mem_detach(struct ci_shared_mem_id *id)
{
  signed int return_value_shmdt$1;
  return_value_shmdt$1=shmdt(id->mem);
  if(!(return_value_shmdt$1 >= 0))
    return 0;

  else
    return 1;
}

// sysv_shared_mem_print_info
// file os/unix/shared_mem.c line 84
signed int sysv_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "sysv:%s/%d %ld kbs", (const void *)id->name, id->$anon0.sysv.id, (signed long int)(id->size / (unsigned long int)1024));
  return return_value_snprintf$1;
}

// templateExpired
// file txtTemplate.c line 109
static signed int templateExpired(struct anonymous$20 *template)
{
  char path[4096l];
  struct stat file;
  signed long int current_time;
  time(&current_time);
  if(current_time + -template->loaded >= (signed long int)TEMPLATE_RELOAD_TIME)
  {
    makeTemplatePathFileName(path, 4096, template->SERVICE_NAME, template->TEMPLATE_NAME, template->LANGUAGE);
    signed int return_value_stat64$1;
    return_value_stat64$1=stat64(path, &file);
    if(!(return_value_stat64$1 >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Can not found the text template file %s!", (const void *)path);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Can not found the text template file %s!", (const void *)path);

      }

      return 0;
    }

    if(!(template->modified >= file.st_mtim.tv_sec))
    {
      if(CI_DEBUG_LEVEL >= 4)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "templateFind: found: %s, %s, %s updated on disk, expired.\n", template->SERVICE_NAME, template->LANGUAGE, template->TEMPLATE_NAME);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("templateFind: found: %s, %s, %s updated on disk, expired.\n", template->SERVICE_NAME, template->LANGUAGE, template->TEMPLATE_NAME);

      }

      return 1;
    }

  }

  return 0;
}

// templateFind
// file txtTemplate.c line 208
static struct anonymous$20 * templateFind(const char *SERVICE_NAME, const char *TEMPLATE_NAME, const char *LANGUAGE)
{
  signed int i = 0;
  i = 0;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    if(!((templates + (signed long int)i)->data == ((struct ci_membuf *)NULL)))
    {
      if((templates + (signed long int)i)->must_free == 0)
      {
        signed int return_value_strcmp$3;
        return_value_strcmp$3=strcmp((templates + (signed long int)i)->SERVICE_NAME, SERVICE_NAME);
        if(return_value_strcmp$3 == 0)
        {
          return_value_strcmp$2=strcmp((templates + (signed long int)i)->TEMPLATE_NAME, TEMPLATE_NAME);
          if(return_value_strcmp$2 == 0)
          {
            return_value_strcmp$1=strcmp((templates + (signed long int)i)->LANGUAGE, LANGUAGE);
            if(return_value_strcmp$1 == 0)
            {
              if(CI_DEBUG_LEVEL >= 4)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "templateFind: found: %s, %s, %s in cache at index %d\n", SERVICE_NAME, LANGUAGE, TEMPLATE_NAME, i);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("templateFind: found: %s, %s, %s in cache at index %d\n", SERVICE_NAME, LANGUAGE, TEMPLATE_NAME, i);

              }

              return &templates[(signed long int)i];
            }

          }

        }

      }

    }

  return (struct anonymous$20 *)(void *)0;
}

// templateFindFree
// file txtTemplate.c line 228
static struct anonymous$20 * templateFindFree(void)
{
  signed long int oldest = (signed long int)0;
  struct anonymous$20 *useme = (struct anonymous$20 *)(void *)0;
  signed int i = 0;
  i = 0;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    if((templates + (signed long int)i)->data == ((struct ci_membuf *)NULL))
      return &templates[(signed long int)i];

  i = 0;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    if(!((templates + (signed long int)i)->last_used >= oldest))
    {
      if(!((templates + (signed long int)i)->locked >= 1))
      {
        oldest = (templates + (signed long int)i)->last_used;
        useme = &templates[(signed long int)i];
      }

    }

  if(!(useme == ((struct anonymous$20 *)NULL)))
  {
    if(!(useme->data == ((struct ci_membuf *)NULL)))
      templateFree(useme);

  }

  return useme;
}

// templateFree
// file txtTemplate.c line 136
static void templateFree(struct anonymous$20 *template)
{
  /* assertion template != ((void *)0) */
  assert(template != (struct anonymous$20 *)(void *)0);
  if(!(template->data == ((struct ci_membuf *)NULL)))
  {
    if(!(template->TEMPLATE_NAME == ((char *)NULL)))
      free((void *)template->TEMPLATE_NAME);

    if(!(template->SERVICE_NAME == ((char *)NULL)))
      free((void *)template->SERVICE_NAME);

    if(!(template->LANGUAGE == ((char *)NULL)))
      free((void *)template->LANGUAGE);

    template->LANGUAGE = (char *)(void *)0;
    template->SERVICE_NAME = template->LANGUAGE;
    template->TEMPLATE_NAME = template->SERVICE_NAME;
    ci_membuf_free(template->data);
    template->data = (struct ci_membuf *)(void *)0;
  }

}

// templateLoadText
// file txtTemplate.c line 347
static struct anonymous$20 * templateLoadText(const struct ci_request *req, const char *service_name, const char *page_name)
{
  const char *acceptLangHeader;
  const char *s;
  char preferred[32l];
  signed int i;
  struct anonymous$20 *template = (struct anonymous$20 *)(void *)0;
  acceptLangHeader=ci_http_request_get_header((struct ci_request *)req, "Accept-Language");
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  if(!(acceptLangHeader == ((const char *)NULL)))
  {
    s = acceptLangHeader;
    if(CI_DEBUG_LEVEL >= 4)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "templateLoadText: Languages are: '%s'\n", s);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("templateLoadText: Languages are: '%s'\n", s);

    }

    while(!((signed int)*s == 0))
    {
      for( ; !((signed int)*s == 0); s = s + 1l)
      {
        return_value___ctype_b_loc$1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*s]) == 0)
          break;

      }
      i = 0;
      do
      {
        if(!((signed int)*s == 0))
          tmp_if_expr$2 = (signed int)*s != 44 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 59 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          return_value___ctype_b_loc$4=__ctype_b_loc();
          tmp_if_expr$5 = !(((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*s] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5 = (_Bool)0;
        if((unsigned long int)i >= 31ul || !tmp_if_expr$5)
          break;

        preferred[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      preferred[(signed long int)i] = (char)0;
      if(CI_DEBUG_LEVEL >= 6)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Try load the error message on language:%s\n", (const void *)preferred);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Try load the error message on language:%s\n", (const void *)preferred);

      }

      template=templateTryLoadText(req, service_name, page_name, preferred);
      if(!(template == ((struct anonymous$20 *)NULL)))
        return template;

      for( ; !((signed int)*s == 0); s = s + 1l)
        if((signed int)*s == 44)
          break;

      if((signed int)*s == 44)
        s = s + 1l;

    }
  }

  if(CI_DEBUG_LEVEL >= 4)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "templateLoadText: Accept-Language header not found or was empty!\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("templateLoadText: Accept-Language header not found or was empty!\n");

  }

  struct anonymous$20 *return_value_templateTryLoadText$6;
  return_value_templateTryLoadText$6=templateTryLoadText(req, service_name, page_name, TEMPLATE_DEF_LANG);
  return return_value_templateTryLoadText$6;
}

// templateTryLoadText
// file txtTemplate.c line 251
static struct anonymous$20 * templateTryLoadText(const struct ci_request *req, const char *service_name, const char *page_name, const char *lang)
{
  signed int fd;
  char path[4096l];
  char buf[4096l];
  struct stat file;
  signed long int len;
  struct ci_membuf *textbuff = (struct ci_membuf *)(void *)0;
  struct anonymous$20 *tempTemplate = (struct anonymous$20 *)(void *)0;
  signed long int current_time;
  time(&current_time);
  pthread_mutex_lock(&templates_mutex);
  tempTemplate=templateFind(service_name, page_name, lang);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  signed int *return_value___errno_location$7;
  char *return_value_strerror$8;
  if(!(tempTemplate == ((struct anonymous$20 *)NULL)))
  {
    tempTemplate->last_used = current_time;
    tempTemplate->locked = tempTemplate->locked + 1;
    pthread_mutex_unlock(&templates_mutex);
    return tempTemplate;
  }

  else
  {
    pthread_mutex_unlock(&templates_mutex);
    makeTemplatePathFileName(path, 4096, service_name, page_name, lang);
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "templateTryLoadText: %s\n", (const void *)path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("templateTryLoadText: %s\n", (const void *)path);

    }

    fd=open64(path, 00);
    if(!(fd >= 0))
    {
      if(CI_DEBUG_LEVEL >= 4)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          __log_error((void *)0, "templateTryLoadText: '%s': %s\n", (const void *)path, return_value_strerror$2);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location$3=__errno_location();
          return_value_strerror$4=strerror(*return_value___errno_location$3);
          printf("templateTryLoadText: '%s': %s\n", (const void *)path, return_value_strerror$4);
        }

      }

      return (struct anonymous$20 *)(void *)0;
    }

    else
    {
      fstat64(fd, &file);
      textbuff=ci_membuf_new_sized((signed int)(file.st_size + (signed long int)1));
      if(textbuff == ((struct ci_membuf *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "templateTryLoadText: membuf allocation failed!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("templateTryLoadText: membuf allocation failed!\n");

        }

        return (struct anonymous$20 *)(void *)0;
      }

      else
      {
        do
        {
          len=read(fd, (void *)buf, sizeof(char [4096l]) /*4096ul*/ );
          if(!(len >= 1l))
            break;

          ci_membuf_write(textbuff, buf, (signed int)len, 0);
        }
        while((_Bool)1);
        close(fd);
        if(!(len >= 0l))
        {
          if(CI_DEBUG_LEVEL >= 4)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value___errno_location$5=__errno_location();
              return_value_strerror$6=strerror(*return_value___errno_location$5);
              __log_error((void *)0, "templateTryLoadText: failed to fully read: '%s': %s\n", (const void *)path, return_value_strerror$6);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value___errno_location$7=__errno_location();
              return_value_strerror$8=strerror(*return_value___errno_location$7);
              printf("templateTryLoadText: failed to fully read: '%s': %s\n", (const void *)path, return_value_strerror$8);
            }

          }

          ci_membuf_free(textbuff);
          return (struct anonymous$20 *)(void *)0;
        }

        else
        {
          ci_membuf_write(textbuff, "\0", 1, 1);
          pthread_mutex_lock(&templates_mutex);
          tempTemplate=templateFindFree();
          if(!(tempTemplate == ((struct anonymous$20 *)NULL)))
          {
            tempTemplate->locked = tempTemplate->locked + 1;
            tempTemplate->non_cached = 0;
          }

          else
          {
            if(CI_DEBUG_LEVEL >= 4)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "templateTryLoadText: Unable to find free template slot.\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("templateTryLoadText: Unable to find free template slot.\n");

            }

            void *return_value_malloc$9;
            return_value_malloc$9=malloc(sizeof(struct anonymous$20) /*72ul*/ );
            tempTemplate = (struct anonymous$20 *)return_value_malloc$9;
            if(tempTemplate == ((struct anonymous$20 *)NULL))
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "templateTryLoadText: memory allocation error!\n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("templateTryLoadText: memory allocation error!\n");

              }

              pthread_mutex_unlock(&templates_mutex);
              ci_membuf_free(textbuff);
              return (struct anonymous$20 *)(void *)0;
            }

            tempTemplate->non_cached = 1;
          }
          tempTemplate->SERVICE_NAME=strdup(service_name);
          tempTemplate->TEMPLATE_NAME=strdup(page_name);
          tempTemplate->LANGUAGE=strdup(lang);
          tempTemplate->data = textbuff;
          tempTemplate->loaded = current_time;
          tempTemplate->modified = file.st_mtim.tv_sec;
          tempTemplate->last_used = current_time;
          tempTemplate->must_free = 0;
          pthread_mutex_unlock(&templates_mutex);
          return tempTemplate;
        }
      }
    }
  }
}

// template_release
// file txtTemplate.c line 152
static void template_release(struct anonymous$20 *template)
{
  signed int must_free = 0;
  signed int return_value_templateExpired$1;
  if(!(template == ((struct anonymous$20 *)NULL)))
  {
    if(!(template->non_cached == 0))
    {
      templateFree(template);
      free((void *)template);
    }

    else
    {
      _Bool tmp_if_expr$2;
      if(!(template->must_free == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value_templateExpired$1=templateExpired(template);
        tmp_if_expr$2 = return_value_templateExpired$1 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$2)
        must_free = 1;

      pthread_mutex_lock(&templates_mutex);
      template->locked = template->locked - 1;
      if(!(template->locked >= 0))
        template->locked = 0;

      _Bool tmp_if_expr$3;
      if(!(must_free == 0))
        tmp_if_expr$3 = template->locked == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        templateFree(template);

      else
        template->must_free = must_free;
      pthread_mutex_unlock(&templates_mutex);
    }
  }

}

// types_add
// file filetype.c line 86
signed int types_add(struct ci_magics_db *db, const char *name, const char *descr, signed int *groups)
{
  struct ci_data_type *newdata;
  signed int indx;
  signed int i;
  if(db->types_num >= db->types_size)
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)db->types, (unsigned long int)(db->types_size + 50) * sizeof(struct ci_data_type) /*324ul*/ );
    newdata = (struct ci_data_type *)return_value_realloc$1;
    if(newdata == ((struct ci_data_type *)NULL))
      return -1;

    db->types_size = db->types_size + 50;
    db->types = newdata;
  }

  indx = db->types_num;
  db->types_num = db->types_num + 1;
  strcpy((db->types + (signed long int)indx)->name, name);
  strcpy((db->types + (signed long int)indx)->descr, descr);
  i = 0;
  for( ; groups[(signed long int)i] >= 0; i = i + 1)
  {
    if(i >= 64)
      break;

    (db->types + (signed long int)indx)->groups[(signed long int)i] = groups[(signed long int)i];
  }
  (db->types + (signed long int)indx)->groups[(signed long int)i] = -1;
  return indx;
}

// types_init
// file filetype.c line 81
signed int types_init(struct ci_magics_db *db)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)50 * sizeof(struct ci_data_type) /*324ul*/ );
  db->types = (struct ci_data_type *)return_value_malloc$1;
  if(db->types == ((struct ci_data_type *)NULL))
    return 0;

  else
  {
    db->types_num = 0;
    db->types_size = 50;
    return 1;
  }
}

// uint64_cmp
// file types_ops.c line 183
signed int uint64_cmp(const void *key1, const void *key2)
{
  unsigned long int k1;
  unsigned long int k2;
  k1 = *((unsigned long int *)key1);
  k2 = *((unsigned long int *)key2);
  if(!(k1 >= k2))
    return -1;

  else
    if(!(k2 >= k1))
      return 1;

    else
      return 0;
}

// uint64_dup
// file types_ops.c line 166
void * uint64_dup(const char *str, struct ci_mem_allocator *allocator)
{
  unsigned long int *i;
  char *e = (char *)(void *)0;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(unsigned long int) /*8ul*/ );
  i = (unsigned long int *)return_value;
  if(!(i == ((unsigned long int *)NULL)))
  {
    signed long long int return_value_strtoll$1;
    return_value_strtoll$1=strtoll(str, &e, 10);
    *i = (unsigned long int)return_value_strtoll$1;
    _Bool tmp_if_expr$4;
    if((signed int)*e == 75)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)*e == 107 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      *i = *i * (unsigned long int)1000;

    else
    {
      _Bool tmp_if_expr$3;
      if((signed int)*e == 77)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*e == 109 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        *i = *i * (unsigned long int)1000000;

      else
      {
        _Bool tmp_if_expr$2;
        if((signed int)*e == 71)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)*e == 103 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          *i = *i * (unsigned long int)1000000000;

      }
    }
  }

  return (void *)i;
}

// uint64_equal
// file types_ops.c line 196
signed int uint64_equal(const void *key1, const void *key2)
{
  unsigned long int k1;
  unsigned long int k2;
  k1 = *((unsigned long int *)key1);
  k2 = *((unsigned long int *)key2);
  return (signed int)(k1 == k2);
}

// uint64_free
// file types_ops.c line 204
void uint64_free(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// uint64_len
// file types_ops.c line 209
unsigned long int uint64_len(const void *key)
{
  return (unsigned long int)sizeof(unsigned long int) /*8ul*/ ;
}

// url_decoder
// file decode.c line 131
signed int url_decoder(const char *input, char *output, signed int output_len)
{
  signed int i;
  signed int k;
  char str[3l];
  i = 0;
  k = 0;
  for( ; !((signed int)input[(signed long int)i] == 0); k = k + 1)
  {
    if(k >= output_len + -1)
      break;

    if((signed int)input[(signed long int)i] == 37)
    {
      str[(signed long int)0] = input[(signed long int)(i + 1)];
      str[(signed long int)1] = input[(signed long int)(i + 2)];
      str[(signed long int)2] = (char)0;
      signed long int return_value_strtol$1;
      return_value_strtol$1=strtol(str, (char ** restrict )(void *)0, 16);
      output[(signed long int)k] = (char)return_value_strtol$1;
      i = i + 3;
    }

    else
      if((signed int)input[(signed long int)i] == 43)
      {
        output[(signed long int)k] = (char)32;
        i = i + 1;
      }

      else
      {
        output[(signed long int)k] = input[(signed long int)i];
        i = i + 1;
      }
  }
  output[(signed long int)k] = (char)0;
  if(k == output_len + -1)
    return -1;

  else
    return 1;
}

// url_decoder2
// file decode.c line 164
signed int url_decoder2(char *input)
{
  signed int i;
  signed int k;
  char str[3l];
  i = 0;
  k = 0;
  for( ; !((signed int)input[(signed long int)i] == 0); k = k + 1)
    if((signed int)input[(signed long int)i] == 37)
    {
      str[(signed long int)0] = input[(signed long int)(i + 1)];
      str[(signed long int)1] = input[(signed long int)(i + 2)];
      str[(signed long int)2] = (char)0;
      signed long int return_value_strtol$1;
      return_value_strtol$1=strtol(str, (char ** restrict )(void *)0, 16);
      input[(signed long int)k] = (char)return_value_strtol$1;
      i = i + 3;
    }

    else
      if((signed int)input[(signed long int)i] == 43)
      {
        input[(signed long int)k] = (char)32;
        i = i + 1;
      }

      else
      {
        input[(signed long int)k] = input[(signed long int)i];
        i = i + 1;
      }
  input[(signed long int)k] = (char)0;
  return 1;
}

// zlib_inflate
// file decode.c line 208
static signed int zlib_inflate(const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len)
{
  signed int ret;
  signed int retriable;
  struct z_stream_s strm;
  strm.zalloc = alloc_a_buffer;
  strm.zfree = free_a_buffer;
  strm.opaque = NULL;
  strm.avail_in = (unsigned int)0;
  strm.next_in = ((unsigned char *)NULL);
  ret=inflateInit2_(&strm, 32 + 15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
  retriable = 1;

zlib_inflate_retry:
  ;
  for( ; (_Bool)1; retriable = 0)
  {
    if(!(ret == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error initializing  zlib (inflateInit2 return:%d)\n", ret);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error initializing  zlib (inflateInit2 return:%d)\n", ret);

      }

      return -1;
    }

    strm.next_in = (unsigned char *)buf;
    strm.avail_in = (unsigned int)len;
    strm.avail_out = (unsigned int)*unzipped_buf_len;
    strm.next_out = (unsigned char *)unzipped_buf;
    ret=inflate(&strm, 0);
    inflateEnd(&strm);
    if(!(ret == 2) && !(ret == -3))
    {
      if(ret == -4)
        break;

      goto __CPROVER_DUMP_L7;
    }

    if(retriable == 0)
      break;

    ret=inflateInit2_(&strm, -15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
  }
  return -1;

__CPROVER_DUMP_L7:
  ;
  if((unsigned int)*unzipped_buf_len == strm.avail_out)
  {
    if(ret == 1)
      goto __CPROVER_DUMP_L8;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L8:
    ;
    *unzipped_buf_len = (signed int)((unsigned int)*unzipped_buf_len - strm.avail_out);
    return 1;
  }
}
