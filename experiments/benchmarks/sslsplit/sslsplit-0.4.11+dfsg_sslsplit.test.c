// tag-#anon#ST[*{S8}$S8$'filename'|]
// file log.c line 236
struct anonymous$6;

// tag-#anon#ST[*{S8}$S8$'header_req'||*{S8}$S8$'header_resp'|]
// file log.c line 232
struct anonymous$4;

// tag-#anon#ST[*{SYM#tag-_ftsent#}$SYM#tag-_ftsent#$'fts_cur'||*{SYM#tag-_ftsent#}$SYM#tag-_ftsent#$'fts_child'||*{*{SYM#tag-_ftsent#}$SYM#tag-_ftsent#$}$*{SYM#tag-_ftsent#}$SYM#tag-_ftsent#$$'fts_array'||U64'fts_dev'||*{S8}$S8$'fts_path'||S32'fts_rfd'||S32'fts_pathlen'||S32'fts_nitems'||U32'$pad0'||*{S32(*{cV}$cV$|*{cV}$cV$)->S32}$S32(*{cV}$cV$|*{cV}$cV$)->S32$'fts_compar'||S32'fts_options'||U32'$pad1'|]
// file /usr/include/fts.h line 45
struct anonymous$11;

// tag-#anon#ST[ARR128{U8}$U8$'cert_verify_md'||ARR128{U8}$U8$'finish_md'||S32'finish_md_len'||ARR128{U8}$U8$'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'$pad0'||*{cSYM#tag-ssl_cipher_st#}$cSYM#tag-ssl_cipher_st#$'new_cipher'||*{SYM#tag-dh_st#}$SYM#tag-dh_st#$'dh'||*{SYM#tag-ec_key_st#}$SYM#tag-ec_key_st#$'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}$S8$'ctype'||U56'$pad1'||*{SYM#tag-stack_st_X509_NAME#}$SYM#tag-stack_st_X509_NAME#$'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}$U8$'key_block'||*{cSYM#tag-evp_cipher_st#}$cSYM#tag-evp_cipher_st#$'new_sym_enc'||*{cSYM#tag-env_md_st#}$cSYM#tag-env_md_st#$'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}$cSYM#tag-ssl_comp_st#$'new_compression'||S32'cert_request'||U32'$pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous$5;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$19;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}$U8$'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous$3;

// tag-#anon#ST[U32'n_buckets'||U32'size'||U32'n_occupied'||U32'upper_bound'||*{U32}$U32$'flags'||*{*{S8}$S8$}$*{S8}$S8$$'keys'||*{*{V}$V$}$*{V}$V$$'vals'|]
// file cachetgcrt.c line 42
struct anonymous$2;

// tag-#anon#ST[U32'n_buckets'||U32'size'||U32'n_occupied'||U32'upper_bound'||*{U32}$U32$'flags'||*{*{SYM#tag-dynbuf#}$SYM#tag-dynbuf#$}$*{SYM#tag-dynbuf#}$SYM#tag-dynbuf#$$'keys'||*{*{SYM#tag-dynbuf#}$SYM#tag-dynbuf#$}$*{SYM#tag-dynbuf#}$SYM#tag-dynbuf#$$'vals'|]
// file cachedsess.c line 68
struct anonymous$9;

// tag-#anon#ST[U32'n_buckets'||U32'size'||U32'n_occupied'||U32'upper_bound'||*{U32}$U32$'flags'||*{*{V}$V$}$*{V}$V$$'keys'||*{*{V}$V$}$*{V}$V$$'vals'|]
// file cachefkcrt.c line 56
struct anonymous$0;

// tag-#anon#UN[*{S32}$S32$'inherit'||*{SYM#tag-stack_st_ASIdOrRange#}$SYM#tag-stack_st_ASIdOrRange#$'asIdsOrRanges'|]
// file /usr/include/openssl/x509v3.h line 783
union anonymous$14;

// tag-#anon#UN[*{S8}$S8$'ptr'||*{SYM#tag-otherName_st#}$SYM#tag-otherName_st#$'otherName'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'rfc822Name'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'dNSName'||*{SYM#tag-asn1_type_st#}$SYM#tag-asn1_type_st#$'x400Address'||*{SYM#tag-X509_name_st#}$SYM#tag-X509_name_st#$'directoryName'||*{SYM#tag-EDIPartyName_st#}$SYM#tag-EDIPartyName_st#$'ediPartyName'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'uniformResourceIdentifier'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'iPAddress'||*{SYM#tag-asn1_object_st#}$SYM#tag-asn1_object_st#$'registeredID'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'ip'||*{SYM#tag-X509_name_st#}$SYM#tag-X509_name_st#$'dirn'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'ia5'||*{SYM#tag-asn1_object_st#}$SYM#tag-asn1_object_st#$'rid'||*{SYM#tag-asn1_type_st#}$SYM#tag-asn1_type_st#$'other'|]
// file /usr/include/openssl/x509v3.h line 188
union anonymous$21;

// tag-#anon#UN[*{S8}$S8$'ptr'||*{SYM#tag-rsa_st#}$SYM#tag-rsa_st#$'rsa'||*{SYM#tag-dsa_st#}$SYM#tag-dsa_st#$'dsa'||*{SYM#tag-dh_st#}$SYM#tag-dh_st#$'dh'||*{SYM#tag-ec_key_st#}$SYM#tag-ec_key_st#$'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous$17;

// tag-#anon#UN[*{S8}$S8$'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'asn1_string'||*{SYM#tag-asn1_object_st#}$SYM#tag-asn1_object_st#$'object'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'integer'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'enumerated'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'bit_string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'octet_string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'printablestring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'t61string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'ia5string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'generalstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'bmpstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'universalstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'utctime'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'generalizedtime'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'visiblestring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'utf8string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'set'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'sequence'||*{SYM#tag-ASN1_VALUE_st#}$SYM#tag-ASN1_VALUE_st#$'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous$16;

// tag-#anon#UN[*{SYM#tag-stack_st_GENERAL_NAME#}$SYM#tag-stack_st_GENERAL_NAME#$'fullname'||*{SYM#tag-stack_st_X509_NAME_ENTRY#}$SYM#tag-stack_st_X509_NAME_ENTRY#$'relativename'|]
// file /usr/include/openssl/x509v3.h line 228
union anonymous$8;

// tag-#anon#UN[*{V(S32|S32|*{V}$V$)->V}$V(S32|S32|*{V}$V$)->V$'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}$SYM#tag-bn_gencb_st#$)->S32}$S32(S32|S32|*{SYM#tag-bn_gencb_st#}$SYM#tag-bn_gencb_st#$)->S32$'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous$13;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$1;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$15;

// tag-#anon#UN[SYM#tag-#anon#ST[*{S8}$S8$'header_req'||*{S8}$S8$'header_resp'|]#'file'||SYM#tag-#anon#ST[*{S8}$S8$'filename'|]#'dir'||SYM#tag-#anon#ST[*{S8}$S8$'filename'|]#'spec'|]
// file log.c line 231
union anonymous$7;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$18;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$10;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$12;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$20;

// tag-ACCESS_DESCRIPTION_st
// file /usr/include/openssl/x509v3.h line 211
struct ACCESS_DESCRIPTION_st;

// tag-ASIdentifierChoice_st
// file /usr/include/openssl/x509v3.h line 781
struct ASIdentifierChoice_st;

// tag-ASIdentifiers_st
// file /usr/include/openssl/x509.h line 293
struct ASIdentifiers_st;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-CRYPTO_dynlock_value
// file /usr/include/openssl/crypto.h line 264
struct CRYPTO_dynlock_value;

// tag-DIST_POINT_NAME_st
// file /usr/include/openssl/x509v3.h line 226
struct DIST_POINT_NAME_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-EDIPartyName_st
// file /usr/include/openssl/x509v3.h line 172
struct EDIPartyName_st;

// tag-GENERAL_NAME_st
// file /usr/include/openssl/x509v3.h line 177
struct GENERAL_NAME_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-SRunner
// file /usr/include/check.h line 819
struct SRunner;

// tag-Suite
// file /usr/include/check.h line 115
struct Suite;

// tag-TCase
// file /usr/include/check.h line 100
struct TCase;

// tag-X509V3_CONF_METHOD_st
// file /usr/include/openssl/x509v3.h line 126
struct X509V3_CONF_METHOD_st;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_extension_st
// file /usr/include/openssl/x509.h line 196
struct X509_extension_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_req_info_st
// file /usr/include/openssl/x509.h line 226
struct X509_req_info_st;

// tag-X509_req_st
// file /usr/include/openssl/x509.h line 235
struct X509_req_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_ftsent
// file /usr/include/fts.h line 46
struct _ftsent;

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-bufferevent
// file /usr/include/event2/bufferevent.h line 111
struct bufferevent;

// tag-bufferevent_ssl_state
// file /usr/include/event2/bufferevent_ssl.h line 49
enum bufferevent_ssl_state { BUFFEREVENT_SSL_OPEN=0, BUFFEREVENT_SSL_CONNECTING=1, BUFFEREVENT_SSL_ACCEPTING=2 };

// tag-cache
// file cache.h line 54
struct cache;

// tag-cert
// file cert.h line 37
struct cert;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-crypto_threadid_st
// file /usr/include/openssl/crypto.h line 448
struct crypto_threadid_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-dynbuf
// file dynbuf.h line 36
struct dynbuf;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine
// file nat.c line 400
struct engine;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-evbuffer
// file /usr/include/event2/bufferevent.h line 117
struct evbuffer;

// tag-evbuffer_eol_style
// file /usr/include/event2/buffer.h line 362
enum evbuffer_eol_style { EVBUFFER_EOL_ANY=0, EVBUFFER_EOL_CRLF=1, EVBUFFER_EOL_CRLF_STRICT=2, EVBUFFER_EOL_LF=3 };

// tag-evconnlistener
// file /usr/include/event2/listener.h line 37
struct evconnlistener;

// tag-evdns_base
// file /usr/include/event2/dns.h line 201
struct evdns_base;

// tag-evdns_getaddrinfo_request
// file /usr/include/event2/dns.h line 610
struct evdns_getaddrinfo_request;

// tag-event
// file /usr/include/event2/event.h line 272
struct event;

// tag-event_base
// file /usr/include/event2/event.h line 213
struct event_base;

// tag-event_method_feature
// file /usr/include/event2/event.h line 430
enum event_method_feature { EV_FEATURE_ET=1, EV_FEATURE_O1=2, EV_FEATURE_FDS=4 };

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lhash_st_CONF_VALUE
// file /usr/include/openssl/conf.h line 81
struct lhash_st_CONF_VALUE;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-log_content_ctx
// file log.h line 60
struct log_content_ctx;

// tag-logbuf
// file logbuf.h line 37
struct logbuf;

// tag-logger
// file logger.h line 42
struct logger;

// tag-ocsp_req_info_st
// file /usr/include/openssl/ocsp.h line 129
struct ocsp_req_info_st;

// tag-ocsp_request_st
// file /usr/include/openssl/ocsp.h line 151
struct ocsp_request_st;

// tag-ocsp_signature_st
// file /usr/include/openssl/ocsp.h line 141
struct ocsp_signature_st;

// tag-opts
// file opts.h line 57
struct opts;

// tag-otherName_st
// file /usr/include/openssl/x509v3.h line 167
struct otherName_st;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-print_output
// file /usr/include/check.h line 799
enum print_output { CK_SILENT=0, CK_MINIMAL=1, CK_NORMAL=2, CK_VERBOSE=3, CK_ENV=4, CK_SUBUNIT=5, CK_LAST=6 };

// tag-proxy_ctx
// file proxy.h line 35
struct proxy_ctx;

// tag-proxy_listener_ctx
// file proxy.c line 66
struct proxy_listener_ctx;

// tag-proxyspec
// file opts.h line 40
struct proxyspec;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-pxy_conn_ctx
// file pxyconn.c line 116
struct pxy_conn_ctx;

// tag-pxy_conn_desc
// file pxyconn.c line 91
struct pxy_conn_desc;

// tag-pxy_ssl_shutdown_ctx
// file pxysslshut.c line 53
struct pxy_ssl_shutdown_ctx;

// tag-pxy_thr_ctx
// file pxythrmgr.c line 46
struct pxy_thr_ctx;

// tag-pxy_thrmgr_ctx
// file pxythrmgr.h line 41
struct pxy_thrmgr_ctx;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ACCESS_DESCRIPTION
// file /usr/include/openssl/x509v3.h line 216
struct stack_st_ACCESS_DESCRIPTION;

// tag-stack_st_ASIdOrRange
// file /usr/include/openssl/x509v3.h line 775
struct stack_st_ASIdOrRange;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_CONF_VALUE
// file /usr/include/openssl/conf.h line 80
struct stack_st_CONF_VALUE;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_GENERAL_SUBTREE
// file /usr/include/openssl/x509v3.h line 330
struct stack_st_GENERAL_SUBTREE;

// tag-stack_st_IPAddressFamily
// file /usr/include/openssl/x509.h line 292
struct stack_st_IPAddressFamily;

// tag-stack_st_OCSP_ONEREQ
// file /usr/include/openssl/ocsp.h line 120
struct stack_st_OCSP_ONEREQ;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-thrqueue
// file thrqueue.h line 36
struct thrqueue;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-v3_ext_ctx
// file /usr/include/openssl/ossl_typ.h line 166
struct v3_ext_ctx;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// ACCESS_DESCRIPTION_free
// file /usr/include/openssl/x509v3.h line 582
void ACCESS_DESCRIPTION_free(struct ACCESS_DESCRIPTION_st *);
// ASN1_INTEGER_set
// file /usr/include/openssl/asn1.h line 927
signed int ASN1_INTEGER_set(struct asn1_string_st *, signed long int);
// ASN1_INTEGER_to_BN
// file /usr/include/openssl/asn1.h line 930
struct bignum_st * ASN1_INTEGER_to_BN(const struct asn1_string_st *, struct bignum_st *);
// ASN1_STRING_length
// file /usr/include/openssl/asn1.h line 809
signed int ASN1_STRING_length(const struct asn1_string_st *);
// ASN1_STRING_set
// file /usr/include/openssl/asn1.h line 807
signed int ASN1_STRING_set(struct asn1_string_st *, const void *, signed int);
// ASN1_STRING_to_UTF8
// file /usr/include/openssl/asn1.h line 1010
signed int ASN1_STRING_to_UTF8(unsigned char **, struct asn1_string_st *);
// ASN1_STRING_type_new
// file /usr/include/openssl/asn1.h line 801
struct asn1_string_st * ASN1_STRING_type_new(signed int);
// BIO_ctrl
// file /usr/include/openssl/bio.h line 664
signed long int BIO_ctrl(struct bio_st *, signed int, signed long int, void *);
// BIO_free
// file /usr/include/openssl/bio.h line 657
signed int BIO_free(struct bio_st *);
// BIO_new
// file /usr/include/openssl/bio.h line 655
struct bio_st * BIO_new(struct bio_method_st *);
// BIO_s_mem
// file /usr/include/openssl/bio.h line 687
struct bio_method_st * BIO_s_mem(void);
// BN_add_word
// file /usr/include/openssl/bn.h line 486
signed int BN_add_word(struct bignum_st *, unsigned long int);
// BN_bin2bn
// file /usr/include/openssl/bn.h line 441
struct bignum_st * BN_bin2bn(const unsigned char *, signed int, struct bignum_st *);
// BN_free
// file /usr/include/openssl/bn.h line 492
void BN_free(struct bignum_st *);
// BN_to_ASN1_INTEGER
// file /usr/include/openssl/asn1.h line 929
struct asn1_string_st * BN_to_ASN1_INTEGER(const struct bignum_st *, struct asn1_string_st *);
// CONF_modules_finish
// file /usr/include/openssl/conf.h line 190
void CONF_modules_finish(void);
// CONF_modules_free
// file /usr/include/openssl/conf.h line 191
void CONF_modules_free(void);
// CONF_modules_unload
// file /usr/include/openssl/conf.h line 189
void CONF_modules_unload(signed int);
// CRYPTO_THREADID_set_callback
// file /usr/include/openssl/crypto.h line 455
signed int CRYPTO_THREADID_set_callback(void (*)(struct crypto_threadid_st *));
// CRYPTO_THREADID_set_numeric
// file /usr/include/openssl/crypto.h line 453
void CRYPTO_THREADID_set_numeric(struct crypto_threadid_st *, unsigned long int);
// CRYPTO_add_lock
// file /usr/include/openssl/crypto.h line 468
signed int CRYPTO_add_lock(signed int *, signed int, signed int, const char *, signed int);
// CRYPTO_cleanup_all_ex_data
// file /usr/include/openssl/crypto.h line 431
void CRYPTO_cleanup_all_ex_data(void);
// CRYPTO_free
// file /usr/include/openssl/crypto.h line 536
void CRYPTO_free(void *);
// CRYPTO_num_locks
// file /usr/include/openssl/crypto.h line 435
signed int CRYPTO_num_locks(void);
// CRYPTO_set_dynlock_create_callback
// file /usr/include/openssl/crypto.h line 474
void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value * (*)(const char *, signed int));
// CRYPTO_set_dynlock_destroy_callback
// file /usr/include/openssl/crypto.h line 482
void CRYPTO_set_dynlock_destroy_callback(void (*)(struct CRYPTO_dynlock_value *, const char *, signed int));
// CRYPTO_set_dynlock_lock_callback
// file /usr/include/openssl/crypto.h line 478
void CRYPTO_set_dynlock_lock_callback(void (*)(signed int, struct CRYPTO_dynlock_value *, const char *, signed int));
// CRYPTO_set_locking_callback
// file /usr/include/openssl/crypto.h line 437
void CRYPTO_set_locking_callback(void (*)(signed int, signed int, const char *, signed int));
// DH_free
// file /usr/include/openssl/dh.h line 201
void DH_free(struct dh_st *);
// DH_new
// file /usr/include/openssl/dh.h line 200
struct dh_st * DH_new(void);
// EC_KEY_free
// file /usr/include/openssl/ec.h line 772
void EC_KEY_free(struct ec_key_st *);
// EC_KEY_new_by_curve_name
// file /usr/include/openssl/ec.h line 767
struct ec_key_st * EC_KEY_new_by_curve_name(signed int);
// ENGINE_cleanup
// file /usr/include/openssl/engine.h line 591
void ENGINE_cleanup(void);
// ERR_free_strings
// file /usr/include/openssl/err.h line 353
void ERR_free_strings(void);
// ERR_func_error_string
// file /usr/include/openssl/err.h line 337
const char * ERR_func_error_string(unsigned long int);
// ERR_lib_error_string
// file /usr/include/openssl/err.h line 336
const char * ERR_lib_error_string(unsigned long int);
// ERR_reason_error_string
// file /usr/include/openssl/err.h line 338
const char * ERR_reason_error_string(unsigned long int);
// ERR_remove_state
// file /usr/include/openssl/err.h line 357
void ERR_remove_state(unsigned long int);
// EVP_PKEY_assign
// file /usr/include/openssl/evp.h line 956
signed int EVP_PKEY_assign(struct evp_pkey_st *, signed int, void *);
// EVP_PKEY_free
// file /usr/include/openssl/evp.h line 981
void EVP_PKEY_free(struct evp_pkey_st *);
// EVP_PKEY_new
// file /usr/include/openssl/evp.h line 980
struct evp_pkey_st * EVP_PKEY_new(void);
// EVP_PKEY_type
// file /usr/include/openssl/evp.h line 949
signed int EVP_PKEY_type(signed int);
// EVP_cleanup
// file /usr/include/openssl/evp.h line 927
void EVP_cleanup(void);
// EVP_dss1
// file /usr/include/openssl/evp.h line 722
const struct env_md_st * EVP_dss1(void);
// EVP_ecdsa
// file /usr/include/openssl/evp.h line 723
const struct env_md_st * EVP_ecdsa(void);
// EVP_sha1
// file /usr/include/openssl/evp.h line 720
const struct env_md_st * EVP_sha1(void);
// GENERAL_NAMES_free
// file /usr/include/openssl/x509v3.h line 541
void GENERAL_NAMES_free(struct stack_st_GENERAL_NAME *);
// GENERAL_NAME_free
// file /usr/include/openssl/x509v3.h line 525
void GENERAL_NAME_free(struct GENERAL_NAME_st *);
// GENERAL_NAME_new
// file /usr/include/openssl/x509v3.h line 525
struct GENERAL_NAME_st * GENERAL_NAME_new(void);
// OBJ_obj2nid
// file /usr/include/openssl/objects.h line 1011
signed int OBJ_obj2nid(const struct asn1_object_st *);
// OBJ_sn2nid
// file /usr/include/openssl/objects.h line 1016
signed int OBJ_sn2nid(const char *);
// OCSP_REQUEST_free
// file /usr/include/openssl/ocsp.h line 556
void OCSP_REQUEST_free(struct ocsp_request_st *);
// OPENSSL_add_all_algorithms_noconf
// file /usr/include/openssl/evp.h line 905
void OPENSSL_add_all_algorithms_noconf(void);
// PEM_read_DHparams
// file /usr/include/openssl/pem.h line 477
struct dh_st * PEM_read_DHparams(struct _IO_FILE *, struct dh_st **, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_read_SSL_SESSION
// file /usr/include/openssl/ssl.h line 1808
struct ssl_session_st * PEM_read_SSL_SESSION(struct _IO_FILE *, struct ssl_session_st **, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_bio_X509
// file /usr/include/openssl/pem.h line 451
signed int PEM_write_bio_X509(struct bio_st *, struct x509_st *);
// RAND_bytes
// file /usr/include/openssl/rand.h line 101
signed int RAND_bytes(unsigned char *, signed int);
// RAND_poll
// file /usr/include/openssl/rand.h line 112
signed int RAND_poll(void);
// RAND_pseudo_bytes
// file /usr/include/openssl/rand.h line 102
signed int RAND_pseudo_bytes(unsigned char *, signed int);
// RAND_seed
// file /usr/include/openssl/rand.h line 103
void RAND_seed(const void *, signed int);
// RAND_status
// file /usr/include/openssl/rand.h line 108
signed int RAND_status(void);
// RSA_generate_key
// file /usr/include/openssl/rsa.h line 326
struct rsa_st * RSA_generate_key(signed int, unsigned long int, void (*)(signed int, signed int, void *), void *);
// SSL_CIPHER_get_name
// file /usr/include/openssl/ssl.h line 2145
const char * SSL_CIPHER_get_name(const struct ssl_cipher_st *);
// SSL_CTX_callback_ctrl
// file /usr/include/openssl/ssl.h line 2340
signed long int SSL_CTX_callback_ctrl(struct ssl_ctx_st *, signed int, void (*)(void));
// SSL_CTX_ctrl
// file /usr/include/openssl/ssl.h line 2339
signed long int SSL_CTX_ctrl(struct ssl_ctx_st *, signed int, signed long int, void *);
// SSL_CTX_free
// file /usr/include/openssl/ssl.h line 2132
void SSL_CTX_free(struct ssl_ctx_st *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_sess_set_get_cb
// file /usr/include/openssl/ssl.h line 1237
void SSL_CTX_sess_set_get_cb(struct ssl_ctx_st *, struct ssl_session_st * (*)(struct ssl_st *, unsigned char *, signed int, signed int *));
// SSL_CTX_sess_set_new_cb
// file /usr/include/openssl/ssl.h line 1225
void SSL_CTX_sess_set_new_cb(struct ssl_ctx_st *, signed int (*)(struct ssl_st *, struct ssl_session_st *));
// SSL_CTX_sess_set_remove_cb
// file /usr/include/openssl/ssl.h line 1230
void SSL_CTX_sess_set_remove_cb(struct ssl_ctx_st *, void (*)(struct ssl_ctx_st *, struct ssl_session_st *));
// SSL_CTX_set_cipher_list
// file /usr/include/openssl/ssl.h line 2130
signed int SSL_CTX_set_cipher_list(struct ssl_ctx_st *, const char *);
// SSL_CTX_set_tmp_dh_callback
// file /usr/include/openssl/ssl.h line 2519
void SSL_CTX_set_tmp_dh_callback(struct ssl_ctx_st *, struct dh_st * (*)(struct ssl_st *, signed int, signed int));
// SSL_CTX_set_verify
// file /usr/include/openssl/ssl.h line 2262
void SSL_CTX_set_verify(struct ssl_ctx_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_CTX_use_PrivateKey
// file /usr/include/openssl/ssl.h line 2275
signed int SSL_CTX_use_PrivateKey(struct ssl_ctx_st *, struct evp_pkey_st *);
// SSL_CTX_use_PrivateKey_file
// file /usr/include/openssl/ssl.h line 2199
signed int SSL_CTX_use_PrivateKey_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_CTX_use_certificate
// file /usr/include/openssl/ssl.h line 2278
signed int SSL_CTX_use_certificate(struct ssl_ctx_st *, struct x509_st *);
// SSL_CTX_use_certificate_chain_file
// file /usr/include/openssl/ssl.h line 2202
signed int SSL_CTX_use_certificate_chain_file(struct ssl_ctx_st *, const char *);
// SSL_CTX_use_certificate_file
// file /usr/include/openssl/ssl.h line 2200
signed int SSL_CTX_use_certificate_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_SESSION_free
// file /usr/include/openssl/ssl.h line 2240
void SSL_SESSION_free(struct ssl_session_st *);
// SSL_SESSION_get_time
// file /usr/include/openssl/ssl.h line 2221
signed long int SSL_SESSION_get_time(const struct ssl_session_st *);
// SSL_SESSION_get_timeout
// file /usr/include/openssl/ssl.h line 2223
signed long int SSL_SESSION_get_timeout(const struct ssl_session_st *);
// SSL_SESSION_print
// file /usr/include/openssl/ssl.h line 2238
signed int SSL_SESSION_print(struct bio_st *, const struct ssl_session_st *);
// SSL_ctrl
// file /usr/include/openssl/ssl.h line 2337
signed long int SSL_ctrl(struct ssl_st *, signed int, signed long int, void *);
// SSL_free
// file /usr/include/openssl/ssl.h line 2331
void SSL_free(struct ssl_st *);
// SSL_get_certificate
// file /usr/include/openssl/ssl.h line 2426
struct x509_st * SSL_get_certificate(const struct ssl_st *);
// SSL_get_current_cipher
// file /usr/include/openssl/ssl.h line 2142
const struct ssl_cipher_st * SSL_get_current_cipher(const struct ssl_st *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_get_peer_certificate
// file /usr/include/openssl/ssl.h line 2253
struct x509_st * SSL_get_peer_certificate(const struct ssl_st *);
// SSL_get_privatekey
// file /usr/include/openssl/ssl.h line 2429
struct evp_pkey_st * SSL_get_privatekey(const struct ssl_st *);
// SSL_get_servername
// file /usr/include/openssl/tls1.h line 309
const char * SSL_get_servername(const struct ssl_st *, const signed int);
// SSL_get_session
// file /usr/include/openssl/ssl.h line 2445
struct ssl_session_st * SSL_get_session(const struct ssl_st *);
// SSL_get_version
// file /usr/include/openssl/ssl.h line 2343
const char * SSL_get_version(const struct ssl_st *);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_set_SSL_CTX
// file /usr/include/openssl/ssl.h line 2448
struct ssl_ctx_st * SSL_set_SSL_CTX(struct ssl_st *, struct ssl_ctx_st *);
// SSL_set_session
// file /usr/include/openssl/ssl.h line 2242
signed int SSL_set_session(struct ssl_st *, struct ssl_session_st *);
// SSL_shutdown
// file /usr/include/openssl/ssl.h line 2397
signed int SSL_shutdown(struct ssl_st *);
// SSL_state_string
// file /usr/include/openssl/ssl.h line 2217
const char * SSL_state_string(const struct ssl_st *);
// SSL_state_string_long
// file /usr/include/openssl/ssl.h line 2219
const char * SSL_state_string_long(const struct ssl_st *);
// SSLeay
// file /usr/include/openssl/crypto.h line 397
unsigned long int SSLeay(void);
// SSLeay_version
// file /usr/include/openssl/crypto.h line 396
const char * SSLeay_version(signed int);
// SSLv23_method
// file /usr/include/openssl/ssl.h line 2360
const struct ssl_method_st * SSLv23_method(void);
// SSLv23_server_method
// file /usr/include/openssl/ssl.h line 2362
const struct ssl_method_st * SSLv23_server_method(void);
// TLSv1_1_method
// file /usr/include/openssl/ssl.h line 2371
const struct ssl_method_st * TLSv1_1_method(void);
// TLSv1_2_method
// file /usr/include/openssl/ssl.h line 2375
const struct ssl_method_st * TLSv1_2_method(void);
// TLSv1_method
// file /usr/include/openssl/ssl.h line 2367
const struct ssl_method_st * TLSv1_method(void);
// X509V3_EXT_conf
// file /usr/include/openssl/x509v3.h line 628
struct X509_extension_st * X509V3_EXT_conf(struct lhash_st_CONF_VALUE *, struct v3_ext_ctx *, char *, char *);
// X509V3_EXT_i2d
// file /usr/include/openssl/x509v3.h line 679
struct X509_extension_st * X509V3_EXT_i2d(signed int, signed int, void *);
// X509V3_set_ctx
// file /usr/include/openssl/x509v3.h line 649
void X509V3_set_ctx(struct v3_ext_ctx *, struct x509_st *, struct x509_st *, struct X509_req_st *, struct X509_crl_st *, signed int);
// X509_EXTENSION_free
// file /usr/include/openssl/x509.h line 812
void X509_EXTENSION_free(struct X509_extension_st *);
// X509_NAME_get_text_by_NID
// file /usr/include/openssl/x509.h line 1011
signed int X509_NAME_get_text_by_NID(struct X509_name_st *, signed int, char *, signed int);
// X509_NAME_oneline
// file /usr/include/openssl/x509.h line 875
char * X509_NAME_oneline(struct X509_name_st *, char *, signed int);
// X509_add_ext
// file /usr/include/openssl/x509.h line 1070
signed int X509_add_ext(struct x509_st *, struct X509_extension_st *, signed int);
// X509_cmp_current_time
// file /usr/include/openssl/x509.h line 765
signed int X509_cmp_current_time(const struct asn1_string_st *);
// X509_digest
// file /usr/include/openssl/x509.h line 659
signed int X509_digest(const struct x509_st *, const struct env_md_st *, unsigned char *, unsigned int *);
// X509_free
// file /usr/include/openssl/x509.h line 823
void X509_free(struct x509_st *);
// X509_get_ext
// file /usr/include/openssl/x509.h line 1068
struct X509_extension_st * X509_get_ext(struct x509_st *, signed int);
// X509_get_ext_by_NID
// file /usr/include/openssl/x509.h line 1065
signed int X509_get_ext_by_NID(struct x509_st *, signed int, signed int);
// X509_get_ext_d2i
// file /usr/include/openssl/x509.h line 1071
void * X509_get_ext_d2i(struct x509_st *, signed int, signed int *, signed int *);
// X509_get_serialNumber
// file /usr/include/openssl/x509.h line 903
struct asn1_string_st * X509_get_serialNumber(struct x509_st *);
// X509_get_subject_name
// file /usr/include/openssl/x509.h line 907
struct X509_name_st * X509_get_subject_name(struct x509_st *);
// X509_gmtime_adj
// file /usr/include/openssl/x509.h line 769
struct asn1_string_st * X509_gmtime_adj(struct asn1_string_st *, signed long int);
// X509_new
// file /usr/include/openssl/x509.h line 823
struct x509_st * X509_new(void);
// X509_print
// file /usr/include/openssl/x509.h line 1001
signed int X509_print(struct bio_st *, struct x509_st *);
// X509_set_issuer_name
// file /usr/include/openssl/x509.h line 904
signed int X509_set_issuer_name(struct x509_st *, struct X509_name_st *);
// X509_set_pubkey
// file /usr/include/openssl/x509.h line 910
signed int X509_set_pubkey(struct x509_st *, struct evp_pkey_st *);
// X509_set_subject_name
// file /usr/include/openssl/x509.h line 906
signed int X509_set_subject_name(struct x509_st *, struct X509_name_st *);
// X509_set_version
// file /usr/include/openssl/x509.h line 901
signed int X509_set_version(struct x509_st *, signed long int);
// X509_sign
// file /usr/include/openssl/x509.h line 647
signed int X509_sign(struct x509_st *, struct evp_pkey_st *, const struct env_md_st *);
// __ac_X31_hash_string
// file khash.h line 387
static inline unsigned int __ac_X31_hash_string(const char *s);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _ck_assert_failed
// file /usr/include/check.h line 419
void _ck_assert_failed(const char *, signed int, const char *, ...);
// _mark_point
// file /usr/include/check.h line 782
void _mark_point(const char *, signed int);
// _tcase_add_test
// file /usr/include/check.h line 274
void _tcase_add_test(struct TCase *, void (*)(signed int), const char *, signed int, signed int, signed int, signed int);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// base64_dec
// file base64.h line 36
unsigned char * base64_dec(const char *in, unsigned long int insz, unsigned long int *outsz);
// base64_dec_01
// file base64.t.c line 136
static void base64_dec_01(signed int _i);
// base64_dec_02
// file base64.t.c line 149
static void base64_dec_02(signed int _i);
// base64_dec_03
// file base64.t.c line 162
static void base64_dec_03(signed int _i);
// base64_dec_04
// file base64.t.c line 175
static void base64_dec_04(signed int _i);
// base64_dec_05
// file base64.t.c line 188
static void base64_dec_05(signed int _i);
// base64_dec_06
// file base64.t.c line 201
static void base64_dec_06(signed int _i);
// base64_dec_07
// file base64.t.c line 211
static void base64_dec_07(signed int _i);
// base64_dec_08
// file base64.t.c line 221
static void base64_dec_08(signed int _i);
// base64_dec_09
// file base64.t.c line 231
static void base64_dec_09(signed int _i);
// base64_dec_10
// file base64.t.c line 241
static void base64_dec_10(signed int _i);
// base64_dec_11
// file base64.t.c line 251
static void base64_dec_11(signed int _i);
// base64_dec_12
// file base64.t.c line 261
static void base64_dec_12(signed int _i);
// base64_dec_13
// file base64.t.c line 271
static void base64_dec_13(signed int _i);
// base64_dec_14
// file base64.t.c line 281
static void base64_dec_14(signed int _i);
// base64_dec_15
// file base64.t.c line 291
static void base64_dec_15(signed int _i);
// base64_dec_16
// file base64.t.c line 301
static void base64_dec_16(signed int _i);
// base64_enc
// file base64.h line 37
char * base64_enc(const unsigned char *in, unsigned long int insz, unsigned long int *outsz);
// base64_enc_01
// file base64.t.c line 58
static void base64_enc_01(signed int _i);
// base64_enc_02
// file base64.t.c line 71
static void base64_enc_02(signed int _i);
// base64_enc_03
// file base64.t.c line 84
static void base64_enc_03(signed int _i);
// base64_enc_04
// file base64.t.c line 97
static void base64_enc_04(signed int _i);
// base64_enc_05
// file base64.t.c line 110
static void base64_enc_05(signed int _i);
// base64_enc_06
// file base64.t.c line 123
static void base64_enc_06(signed int _i);
// base64_suite
// file base64.t.c line 315
struct Suite * base64_suite(void);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$20, unsigned int);
// blank_suite
// file main.t.c line 39
struct Suite * blank_suite(void);
// buf_setup
// file dynbuf.t.c line 42
static void buf_setup(void);
// buf_teardown
// file dynbuf.t.c line 50
static void buf_teardown(void);
// bufferevent_disable
// file /usr/include/event2/bufferevent.h line 418
signed int bufferevent_disable(struct bufferevent *, signed short int);
// bufferevent_enable
// file /usr/include/event2/bufferevent.h line 408
signed int bufferevent_enable(struct bufferevent *, signed short int);
// bufferevent_free
// file /usr/include/event2/bufferevent.h line 282
void bufferevent_free(struct bufferevent *);
// bufferevent_free_and_close_fd
// file pxyconn.c line 1060
static void bufferevent_free_and_close_fd(struct bufferevent *bev, struct pxy_conn_ctx *ctx);
// bufferevent_get_input
// file /usr/include/event2/bufferevent.h line 384
struct evbuffer * bufferevent_get_input(struct bufferevent *);
// bufferevent_get_openssl_error
// file /usr/include/event2/bufferevent_ssl.h line 99
unsigned long int bufferevent_get_openssl_error(struct bufferevent *);
// bufferevent_get_output
// file /usr/include/event2/bufferevent.h line 398
struct evbuffer * bufferevent_get_output(struct bufferevent *);
// bufferevent_getfd
// file /usr/include/event2/bufferevent.h line 316
signed int bufferevent_getfd(struct bufferevent *);
// bufferevent_openssl_get_ssl
// file /usr/include/event2/bufferevent_ssl.h line 93
struct ssl_st * bufferevent_openssl_get_ssl(struct bufferevent *);
// bufferevent_openssl_socket_new
// file /usr/include/event2/bufferevent_ssl.h line 85
struct bufferevent * bufferevent_openssl_socket_new(struct event_base *, signed int, struct ssl_st *, enum bufferevent_ssl_state, signed int);
// bufferevent_setcb
// file /usr/include/event2/bufferevent.h line 299
void bufferevent_setcb(struct bufferevent *, void (*)(struct bufferevent *, void *), void (*)(struct bufferevent *, void *), void (*)(struct bufferevent *, signed short int, void *), void *);
// bufferevent_setwatermark
// file /usr/include/event2/bufferevent.h line 475
void bufferevent_setwatermark(struct bufferevent *, signed short int, unsigned long int, unsigned long int);
// bufferevent_socket_connect
// file /usr/include/event2/bufferevent.h line 205
signed int bufferevent_socket_connect(struct bufferevent *, struct sockaddr *, signed int);
// bufferevent_socket_new
// file /usr/include/event2/bufferevent.h line 184
struct bufferevent * bufferevent_socket_new(struct event_base *, signed int, signed int);
// build_date_01
// file main.t.c line 46
static void build_date_01(signed int _i);
// cache_del
// file cache.h line 80
void cache_del(struct cache *cache, void *key);
// cache_dsess_01
// file cachedsess.t.c line 77
static void cache_dsess_01(signed int _i);
// cache_dsess_02
// file cachedsess.t.c line 94
static void cache_dsess_02(signed int _i);
// cache_dsess_03
// file cachedsess.t.c line 108
static void cache_dsess_03(signed int _i);
// cache_dsess_04
// file cachedsess.t.c line 124
static void cache_dsess_04(signed int _i);
// cache_fkcrt_01
// file cachefkcrt.t.c line 53
static void cache_fkcrt_01(signed int _i);
// cache_fkcrt_02
// file cachefkcrt.t.c line 67
static void cache_fkcrt_02(signed int _i);
// cache_fkcrt_03
// file cachefkcrt.t.c line 79
static void cache_fkcrt_03(signed int _i);
// cache_fkcrt_04
// file cachefkcrt.t.c line 93
static void cache_fkcrt_04(signed int _i);
// cache_free
// file cache.c line 72
void cache_free(struct cache *cache);
// cache_gc
// file cache.c line 88
void cache_gc(struct cache *cache);
// cache_get
// file cache.h line 78
void * cache_get(struct cache *cache, void *key);
// cache_new
// file cache.c line 44
struct cache * cache_new(void (*init_cb)(struct cache *));
// cache_new::init_cb$object
//
void init_cb$object(struct cache *);
// cache_reinit
// file cache.c line 62
void cache_reinit(struct cache *cache);
// cache_set
// file cache.h line 79
void cache_set(struct cache *cache, void *key, void *val);
// cache_ssess_01
// file cachessess.t.c line 69
static void cache_ssess_01(signed int _i);
// cache_ssess_02
// file cachessess.t.c line 86
static void cache_ssess_02(signed int _i);
// cache_ssess_03
// file cachessess.t.c line 100
static void cache_ssess_03(signed int _i);
// cache_ssess_04
// file cachessess.t.c line 116
static void cache_ssess_04(signed int _i);
// cache_tgcrt_01
// file cachetgcrt.t.c line 54
static void cache_tgcrt_01(signed int _i);
// cache_tgcrt_02
// file cachetgcrt.t.c line 68
static void cache_tgcrt_02(signed int _i);
// cache_tgcrt_03
// file cachetgcrt.t.c line 77
static void cache_tgcrt_03(signed int _i);
// cache_tgcrt_04
// file cachetgcrt.t.c line 91
static void cache_tgcrt_04(signed int _i);
// cache_types_01
// file cachemgr.t.c line 37
static void cache_types_01(signed int _i);
// cachedsess_begin_cb
// file cachedsess.c line 74
static unsigned int cachedsess_begin_cb(void);
// cachedsess_del_cb
// file cachedsess.c line 92
static void cachedsess_del_cb(unsigned int it);
// cachedsess_end_cb
// file cachedsess.c line 80
static unsigned int cachedsess_end_cb(void);
// cachedsess_exist_cb
// file cachedsess.c line 86
static signed int cachedsess_exist_cb(unsigned int it);
// cachedsess_fini_cb
// file cachedsess.c line 161
static void cachedsess_fini_cb(void);
// cachedsess_free_key_cb
// file cachedsess.c line 110
static void cachedsess_free_key_cb(void *key);
// cachedsess_free_val_cb
// file cachedsess.c line 116
static void cachedsess_free_val_cb(void *val);
// cachedsess_get_cb
// file cachedsess.c line 98
static unsigned int cachedsess_get_cb(void *key);
// cachedsess_get_key_cb
// file cachedsess.c line 122
static void * cachedsess_get_key_cb(unsigned int it);
// cachedsess_get_val_cb
// file cachedsess.c line 128
static void * cachedsess_get_val_cb(unsigned int it);
// cachedsess_init_cb
// file cachedsess.h line 40
void cachedsess_init_cb(struct cache *cache);
// cachedsess_mkkey
// file cachedsess.h line 42
void * cachedsess_mkkey(struct sockaddr *addr, const unsigned int addrlen, const char *sni);
// cachedsess_mkval
// file cachedsess.h line 44
void * cachedsess_mkval(struct ssl_session_st *sess);
// cachedsess_put_cb
// file cachedsess.c line 104
static unsigned int cachedsess_put_cb(void *key, signed int *ret);
// cachedsess_set_val_cb
// file cachedsess.c line 134
static void cachedsess_set_val_cb(unsigned int it, void *val);
// cachedsess_suite
// file cachedsess.t.c line 151
struct Suite * cachedsess_suite(void);
// cachedsess_unpackverify_val_cb
// file cachedsess.c line 140
static void * cachedsess_unpackverify_val_cb(void *val, signed int copy);
// cachefkcrt_begin_cb
// file cachefkcrt.c line 62
static unsigned int cachefkcrt_begin_cb(void);
// cachefkcrt_del_cb
// file cachefkcrt.c line 80
static void cachefkcrt_del_cb(unsigned int it);
// cachefkcrt_end_cb
// file cachefkcrt.c line 68
static unsigned int cachefkcrt_end_cb(void);
// cachefkcrt_exist_cb
// file cachefkcrt.c line 74
static signed int cachefkcrt_exist_cb(unsigned int it);
// cachefkcrt_fini_cb
// file cachefkcrt.c line 140
static void cachefkcrt_fini_cb(void);
// cachefkcrt_free_key_cb
// file cachefkcrt.c line 98
static void cachefkcrt_free_key_cb(void *key);
// cachefkcrt_free_val_cb
// file cachefkcrt.c line 104
static void cachefkcrt_free_val_cb(void *val);
// cachefkcrt_get_cb
// file cachefkcrt.c line 86
static unsigned int cachefkcrt_get_cb(void *key);
// cachefkcrt_get_key_cb
// file cachefkcrt.c line 110
static void * cachefkcrt_get_key_cb(unsigned int it);
// cachefkcrt_get_val_cb
// file cachefkcrt.c line 116
static void * cachefkcrt_get_val_cb(unsigned int it);
// cachefkcrt_init_cb
// file cachefkcrt.c line 146
void cachefkcrt_init_cb(struct cache *cache);
// cachefkcrt_mkkey
// file cachefkcrt.h line 39
void * cachefkcrt_mkkey(struct x509_st *keycrt);
// cachefkcrt_mkval
// file cachefkcrt.h line 40
void * cachefkcrt_mkval(struct x509_st *valcrt);
// cachefkcrt_put_cb
// file cachefkcrt.c line 92
static unsigned int cachefkcrt_put_cb(void *key, signed int *ret);
// cachefkcrt_set_val_cb
// file cachefkcrt.c line 122
static void cachefkcrt_set_val_cb(unsigned int it, void *val);
// cachefkcrt_suite
// file cachefkcrt.t.c line 122
struct Suite * cachefkcrt_suite(void);
// cachefkcrt_unpackverify_val_cb
// file cachefkcrt.c line 128
static void * cachefkcrt_unpackverify_val_cb(void *val, signed int copy);
// cachemgr_fini
// file cachemgr.h line 45
void cachemgr_fini(void);
// cachemgr_gc
// file cachemgr.c line 122
void cachemgr_gc(void);
// cachemgr_gc_thread
// file cachemgr.c line 53
static void * cachemgr_gc_thread(void *arg);
// cachemgr_init
// file cachemgr.c line 92
signed int cachemgr_init(void);
// cachemgr_preinit
// file cachemgr.h line 43
signed int cachemgr_preinit(void);
// cachemgr_setup
// file cachedsess.t.c line 61
static void cachemgr_setup(void);
// cachemgr_setup$link1
// file cachessess.t.c line 56
static void cachemgr_setup$link1(void);
// cachemgr_setup$link2
// file cachefkcrt.t.c line 40
static void cachemgr_setup$link2(void);
// cachemgr_setup$link3
// file cachetgcrt.t.c line 41
static void cachemgr_setup$link3(void);
// cachemgr_suite
// file cachemgr.t.c line 45
struct Suite * cachemgr_suite(void);
// cachemgr_teardown
// file cachedsess.t.c line 71
static void cachemgr_teardown(void);
// cachemgr_teardown$link1
// file cachessess.t.c line 63
static void cachemgr_teardown$link1(void);
// cachemgr_teardown$link2
// file cachefkcrt.t.c line 47
static void cachemgr_teardown$link2(void);
// cachemgr_teardown$link3
// file cachetgcrt.t.c line 48
static void cachemgr_teardown$link3(void);
// cachessess_begin_cb
// file cachessess.c line 72
static unsigned int cachessess_begin_cb(void);
// cachessess_del_cb
// file cachessess.c line 90
static void cachessess_del_cb(unsigned int it);
// cachessess_end_cb
// file cachessess.c line 78
static unsigned int cachessess_end_cb(void);
// cachessess_exist_cb
// file cachessess.c line 84
static signed int cachessess_exist_cb(unsigned int it);
// cachessess_fini_cb
// file cachessess.c line 159
static void cachessess_fini_cb(void);
// cachessess_free_key_cb
// file cachessess.c line 108
static void cachessess_free_key_cb(void *key);
// cachessess_free_val_cb
// file cachessess.c line 114
static void cachessess_free_val_cb(void *val);
// cachessess_get_cb
// file cachessess.c line 96
static unsigned int cachessess_get_cb(void *key);
// cachessess_get_key_cb
// file cachessess.c line 120
static void * cachessess_get_key_cb(unsigned int it);
// cachessess_get_val_cb
// file cachessess.c line 126
static void * cachessess_get_val_cb(unsigned int it);
// cachessess_init_cb
// file cachessess.h line 37
void cachessess_init_cb(struct cache *cache);
// cachessess_mkkey
// file cachessess.h line 39
void * cachessess_mkkey(const unsigned char *id, const unsigned long int idlen);
// cachessess_mkval
// file cachessess.h line 41
void * cachessess_mkval(struct ssl_session_st *sess);
// cachessess_put_cb
// file cachessess.c line 102
static unsigned int cachessess_put_cb(void *key, signed int *ret);
// cachessess_set_val_cb
// file cachessess.c line 132
static void cachessess_set_val_cb(unsigned int it, void *val);
// cachessess_suite
// file cachessess.t.c line 143
struct Suite * cachessess_suite(void);
// cachessess_unpackverify_val_cb
// file cachessess.c line 138
static void * cachessess_unpackverify_val_cb(void *val, signed int copy);
// cachetgcrt_begin_cb
// file cachetgcrt.c line 47
static unsigned int cachetgcrt_begin_cb(void);
// cachetgcrt_del_cb
// file cachetgcrt.c line 65
static void cachetgcrt_del_cb(unsigned int it);
// cachetgcrt_end_cb
// file cachetgcrt.c line 53
static unsigned int cachetgcrt_end_cb(void);
// cachetgcrt_exist_cb
// file cachetgcrt.c line 59
static signed int cachetgcrt_exist_cb(unsigned int it);
// cachetgcrt_fini_cb
// file cachetgcrt.c line 123
static void cachetgcrt_fini_cb(void);
// cachetgcrt_free_key_cb
// file cachetgcrt.c line 83
static void cachetgcrt_free_key_cb(void *key);
// cachetgcrt_free_val_cb
// file cachetgcrt.c line 89
static void cachetgcrt_free_val_cb(void *val);
// cachetgcrt_get_cb
// file cachetgcrt.c line 71
static unsigned int cachetgcrt_get_cb(void *key);
// cachetgcrt_get_key_cb
// file cachetgcrt.c line 95
static void * cachetgcrt_get_key_cb(unsigned int it);
// cachetgcrt_get_val_cb
// file cachetgcrt.c line 101
static void * cachetgcrt_get_val_cb(unsigned int it);
// cachetgcrt_init_cb
// file cachetgcrt.c line 129
void cachetgcrt_init_cb(struct cache *cache);
// cachetgcrt_mkkey
// file cachetgcrt.h line 38
void * cachetgcrt_mkkey(const char *keycn);
// cachetgcrt_mkval
// file cachetgcrt.h line 39
void * cachetgcrt_mkval(struct cert *valcrt);
// cachetgcrt_put_cb
// file cachetgcrt.c line 77
static unsigned int cachetgcrt_put_cb(void *key, signed int *ret);
// cachetgcrt_set_val_cb
// file cachetgcrt.c line 107
static void cachetgcrt_set_val_cb(unsigned int it, void *val);
// cachetgcrt_suite
// file cachetgcrt.t.c line 120
struct Suite * cachetgcrt_suite(void);
// cachetgcrt_unpackverify_val_cb
// file cachetgcrt.c line 113
static void * cachetgcrt_unpackverify_val_cb(void *val, signed int copy);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cert_free
// file cert.h line 53
void cert_free(struct cert *c);
// cert_new
// file cert.c line 40
struct cert * cert_new(void);
// cert_new3
// file cert.c line 57
struct cert * cert_new3(struct evp_pkey_st *key, struct x509_st *crt, struct stack_st_X509 *chain);
// cert_new3_copy
// file cert.c line 76
struct cert * cert_new3_copy(struct evp_pkey_st *key, struct x509_st *crt, struct stack_st_X509 *chain);
// cert_new_load
// file cert.h line 46
struct cert * cert_new_load(const char *filename);
// cert_new_load_01
// file cert.t.c line 39
static void cert_new_load_01(signed int _i);
// cert_refcount_inc
// file cert.h line 49
void cert_refcount_inc(struct cert *c);
// cert_refcount_inc_01
// file cert.t.c line 53
static void cert_refcount_inc_01(signed int _i);
// cert_set_chain
// file cert.c line 166
void cert_set_chain(struct cert *c, struct stack_st_X509 *chain);
// cert_set_crt
// file cert.c line 153
void cert_set_crt(struct cert *c, struct x509_st *crt);
// cert_set_key
// file cert.c line 140
void cert_set_key(struct cert *c, struct evp_pkey_st *key);
// cert_suite
// file cert.t.c line 71
struct Suite * cert_suite(void);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// d2i_OCSP_REQUEST
// file /usr/include/openssl/ocsp.h line 556
struct ocsp_request_st * d2i_OCSP_REQUEST(struct ocsp_request_st **, const unsigned char **, signed long int);
// d2i_SSL_SESSION
// file /usr/include/openssl/ssl.h line 2249
struct ssl_session_st * d2i_SSL_SESSION(struct ssl_session_st **, const unsigned char **, signed long int);
// dirname
// file /usr/include/libgen.h line 26
extern char * dirname(char *);
// dynbuf_free
// file dynbuf.h line 45
void dynbuf_free(struct dynbuf *db);
// dynbuf_new
// file dynbuf.h line 41
struct dynbuf * dynbuf_new(unsigned char *buf, unsigned long int sz);
// dynbuf_new_01
// file dynbuf.t.c line 57
static void dynbuf_new_01(signed int _i);
// dynbuf_new_alloc
// file dynbuf.h line 42
struct dynbuf * dynbuf_new_alloc(unsigned long int sz);
// dynbuf_new_alloc_01
// file dynbuf.t.c line 71
static void dynbuf_new_alloc_01(signed int _i);
// dynbuf_new_copy
// file dynbuf.h line 43
struct dynbuf * dynbuf_new_copy(const unsigned char *buf, const unsigned long int sz);
// dynbuf_new_copy_01
// file dynbuf.t.c line 83
static void dynbuf_new_copy_01(signed int _i);
// dynbuf_new_file
// file dynbuf.h line 44
struct dynbuf * dynbuf_new_file(const char *filename);
// dynbuf_new_file_01
// file dynbuf.t.c line 97
static void dynbuf_new_file_01(signed int _i);
// dynbuf_suite
// file dynbuf.t.c line 115
struct Suite * dynbuf_suite(void);
// endpwent
// file /usr/include/pwd.h line 78
extern void endpwent(void);
// evbuffer_add_buffer
// file /usr/include/event2/buffer.h line 411
signed int evbuffer_add_buffer(struct evbuffer *, struct evbuffer *);
// evbuffer_add_printf
// file /usr/include/event2/buffer.h line 477
signed int evbuffer_add_printf(struct evbuffer *, const char *, ...);
// evbuffer_copyout
// file /usr/include/event2/buffer.h line 342
signed long int evbuffer_copyout(struct evbuffer *, void *, unsigned long int);
// evbuffer_drain
// file /usr/include/event2/buffer.h line 505
signed int evbuffer_drain(struct evbuffer *, unsigned long int);
// evbuffer_get_length
// file /usr/include/event2/buffer.h line 218
unsigned long int evbuffer_get_length(struct evbuffer *);
// evbuffer_readln
// file /usr/include/event2/buffer.h line 396
char * evbuffer_readln(struct evbuffer *, unsigned long int *, enum evbuffer_eol_style);
// evconnlistener_free
// file /usr/include/event2/listener.h line 114
void evconnlistener_free(struct evconnlistener *);
// evconnlistener_get_base
// file /usr/include/event2/listener.h line 125
struct event_base * evconnlistener_get_base(struct evconnlistener *);
// evconnlistener_new
// file /usr/include/event2/listener.h line 90
struct evconnlistener * evconnlistener_new(struct event_base *, void (*)(struct evconnlistener *, signed int, struct sockaddr *, signed int, void *), void *, unsigned int, signed int, signed int);
// evconnlistener_set_error_cb
// file /usr/include/event2/listener.h line 136
void evconnlistener_set_error_cb(struct evconnlistener *, void (*)(struct evconnlistener *, void *));
// evdns_base_free
// file /usr/include/event2/dns.h line 231
void evdns_base_free(struct evdns_base *, signed int);
// evdns_base_new
// file /usr/include/event2/dns.h line 216
struct evdns_base * evdns_base_new(struct event_base *, signed int);
// evdns_base_resolv_conf_parse
// file /usr/include/event2/dns.h line 429
signed int evdns_base_resolv_conf_parse(struct evdns_base *, signed int, const char *);
// evdns_getaddrinfo
// file /usr/include/event2/dns.h line 628
struct evdns_getaddrinfo_request * evdns_getaddrinfo(struct evdns_base *, const char *, const char *, struct addrinfo *, void (*)(signed int, struct addrinfo *, void *), void *);
// event_add
// file /usr/include/event2/event.h line 937
signed int event_add(struct event *, struct timeval *);
// event_base_dispatch
// file /usr/include/event2/event.h line 364
signed int event_base_dispatch(struct event_base *);
// event_base_dump_events
// file /usr/include/event2/event.h line 1184
void event_base_dump_events(struct event_base *, struct _IO_FILE *);
// event_base_free
// file /usr/include/event2/event.h line 561
void event_base_free(struct event_base *);
// event_base_get_features
// file /usr/include/event2/event.h line 494
signed int event_base_get_features(struct event_base *);
// event_base_get_method
// file /usr/include/event2/event.h line 372
const char * event_base_get_method(struct event_base *);
// event_base_loopbreak
// file /usr/include/event2/event.h line 692
signed int event_base_loopbreak(struct event_base *);
// event_base_new
// file /usr/include/event2/event.h line 337
struct event_base * event_base_new(void);
// event_enable_debug_mode
// file /usr/include/event2/event.h line 317
void event_enable_debug_mode(void);
// event_free
// file /usr/include/event2/event.h line 889
void event_free(struct event *);
// event_new
// file /usr/include/event2/event.h line 840
struct event * event_new(struct event_base *, signed int, signed short int, void (*)(signed int, signed short int, void *), void *);
// event_reinit
// file /usr/include/event2/event.h line 349
signed int event_reinit(struct event_base *);
// evthread_use_pthreads
// file /usr/include/event2/thread.h line 208
signed int evthread_use_pthreads(void);
// evutil_closesocket
// file /usr/include/event2/util.h line 323
signed int evutil_closesocket(signed int);
// evutil_freeaddrinfo
// file /usr/include/event2/util.h line 645
void evutil_freeaddrinfo(struct addrinfo *);
// evutil_gai_strerror
// file /usr/include/event2/util.h line 647
const char * evutil_gai_strerror(signed int);
// evutil_getaddrinfo
// file /usr/include/event2/util.h line 641
signed int evutil_getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo **);
// evutil_make_listen_socket_reuseable
// file /usr/include/event2/util.h line 307
signed int evutil_make_listen_socket_reuseable(signed int);
// evutil_make_socket_nonblocking
// file /usr/include/event2/util.h line 294
signed int evutil_make_socket_nonblocking(signed int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// flock
// file /usr/include/x86_64-linux-gnu/sys/file.h line 51
extern signed int flock(signed int, signed int);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// fsync
// file /usr/include/unistd.h line 956
extern signed int fsync(signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// fts_close
// file /usr/include/fts.h line 124
signed int fts_close(struct anonymous$11 *);
// fts_open
// file /usr/include/fts.h line 125
struct anonymous$11 * fts_open(char * const *, signed int, signed int (*)(const struct _ftsent **, const struct _ftsent **));
// fts_read
// file /usr/include/fts.h line 127
struct _ftsent * fts_read(struct anonymous$11 *);
// fts_set
// file /usr/include/fts.h line 128
signed int fts_set(struct anonymous$11 *, struct _ftsent *, signed int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getgrgid_r
// file /usr/include/grp.h line 143
extern signed int getgrgid_r(unsigned int, struct group *, char *, unsigned long int, struct group ** restrict );
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid_r
// file /usr/include/pwd.h line 144
extern signed int getpwuid_r(unsigned int, struct passwd *, char *, unsigned long int, struct passwd ** restrict );
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, union anonymous$20, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gmtime
// file /usr/include/time.h line 239
extern struct tm * gmtime(const signed long int *);
// i2d_SSL_SESSION
// file /usr/include/openssl/ssl.h line 2241
signed int i2d_SSL_SESSION(struct ssl_session_st *, unsigned char **);
// initgroups
// file /usr/include/grp.h line 200
extern signed int initgroups(const char *, unsigned int);
// kh_del_cstrmap_t
// file cachetgcrt.c line 42
static inline void kh_del_cstrmap_t(struct anonymous$2 *h, unsigned int x);
// kh_del_dynbufmap_t
// file cachedsess.c line 68
static inline void kh_del_dynbufmap_t(struct anonymous$9 *h, unsigned int x);
// kh_del_dynbufmap_t$link1
// file cachessess.c line 66
static inline void kh_del_dynbufmap_t$link1(struct anonymous$9 *h$link1, unsigned int x$link1);
// kh_del_sha1map_t
// file cachefkcrt.c line 56
static inline void kh_del_sha1map_t(struct anonymous$0 *h, unsigned int x);
// kh_destroy_cstrmap_t
// file cachetgcrt.c line 42
static inline void kh_destroy_cstrmap_t(struct anonymous$2 *h);
// kh_destroy_dynbufmap_t
// file cachedsess.c line 68
static inline void kh_destroy_dynbufmap_t(struct anonymous$9 *h);
// kh_destroy_dynbufmap_t$link1
// file cachessess.c line 66
static inline void kh_destroy_dynbufmap_t$link1(struct anonymous$9 *h$link1);
// kh_destroy_sha1map_t
// file cachefkcrt.c line 56
static inline void kh_destroy_sha1map_t(struct anonymous$0 *h);
// kh_dynbuf_hash_func
// file cachedsess.c line 45
static inline unsigned int kh_dynbuf_hash_func(struct dynbuf *b);
// kh_dynbuf_hash_func$link1
// file cachessess.c line 43
static inline unsigned int kh_dynbuf_hash_func$link1(struct dynbuf *b$link1);
// kh_get_cstrmap_t
// file cachetgcrt.c line 42
static inline unsigned int kh_get_cstrmap_t(const struct anonymous$2 *h, char *key);
// kh_get_dynbufmap_t
// file cachedsess.c line 68
static inline unsigned int kh_get_dynbufmap_t(const struct anonymous$9 *h, struct dynbuf *key);
// kh_get_dynbufmap_t$link1
// file cachessess.c line 66
static inline unsigned int kh_get_dynbufmap_t$link1(const struct anonymous$9 *h$link1, struct dynbuf *key$link1);
// kh_get_sha1map_t
// file cachefkcrt.c line 56
static inline unsigned int kh_get_sha1map_t(const struct anonymous$0 *h, void *key);
// kh_init_cstrmap_t
// file cachetgcrt.c line 42
static inline struct anonymous$2 * kh_init_cstrmap_t(void);
// kh_init_dynbufmap_t
// file cachedsess.c line 68
static inline struct anonymous$9 * kh_init_dynbufmap_t(void);
// kh_init_dynbufmap_t$link1
// file cachessess.c line 66
static inline struct anonymous$9 * kh_init_dynbufmap_t$link1(void);
// kh_init_sha1map_t
// file cachefkcrt.c line 56
static inline struct anonymous$0 * kh_init_sha1map_t(void);
// kh_put_cstrmap_t
// file cachetgcrt.c line 42
static inline unsigned int kh_put_cstrmap_t(struct anonymous$2 *h, char *key, signed int *ret);
// kh_put_dynbufmap_t
// file cachedsess.c line 68
static inline unsigned int kh_put_dynbufmap_t(struct anonymous$9 *h, struct dynbuf *key, signed int *ret);
// kh_put_dynbufmap_t$link1
// file cachessess.c line 66
static inline unsigned int kh_put_dynbufmap_t$link1(struct anonymous$9 *h$link1, struct dynbuf *key$link1, signed int *ret$link1);
// kh_put_sha1map_t
// file cachefkcrt.c line 56
static inline unsigned int kh_put_sha1map_t(struct anonymous$0 *h, void *key, signed int *ret);
// kh_resize_cstrmap_t
// file cachetgcrt.c line 42
static inline signed int kh_resize_cstrmap_t(struct anonymous$2 *h, unsigned int new_n_buckets);
// kh_resize_dynbufmap_t
// file cachedsess.c line 68
static inline signed int kh_resize_dynbufmap_t(struct anonymous$9 *h, unsigned int new_n_buckets);
// kh_resize_dynbufmap_t$link1
// file cachessess.c line 66
static inline signed int kh_resize_dynbufmap_t$link1(struct anonymous$9 *h$link1, unsigned int new_n_buckets$link1);
// kh_resize_sha1map_t
// file cachefkcrt.c line 56
static inline signed int kh_resize_sha1map_t(struct anonymous$0 *h, unsigned int new_n_buckets);
// kh_x509fpr_hash_func
// file cachefkcrt.c line 42
static inline unsigned int kh_x509fpr_hash_func(void *b);
// log_connect_close
// file log.c line 210
static void log_connect_close(void);
// log_connect_open
// file log.c line 169
static signed int log_connect_open(const char *logfile);
// log_connect_writecb
// file log.c line 187
static signed long int log_connect_writecb(void *fh, const void *buf, unsigned long int sz);
// log_content_close
// file log.c line 489
signed int log_content_close(struct log_content_ctx **pctx);
// log_content_common_writecb
// file log.c line 507
static signed long int log_content_common_writecb(void *fh, const void *buf, unsigned long int sz);
// log_content_dir_closecb
// file log.c line 534
static void log_content_dir_closecb(void *fh);
// log_content_dir_opencb
// file log.c line 520
static signed int log_content_dir_opencb(void *fh);
// log_content_file_closecb
// file log.c line 603
static void log_content_file_closecb(void *fh);
// log_content_file_fini
// file log.c line 261
static void log_content_file_fini(void);
// log_content_file_preinit
// file log.c line 249
static signed int log_content_file_preinit(const char *logfile);
// log_content_file_prepcb
// file log.c line 618
static struct logbuf * log_content_file_prepcb(void *fh, unsigned long int prepflags, struct logbuf *lb);
// log_content_format_pathspec
// file log.c line 279
static char * log_content_format_pathspec(const char *logspec, char *srcaddr, char *dstaddr, char *exec_path, char *user, char *group);
// log_content_open
// file log.c line 399
signed int log_content_open(struct log_content_ctx **pctx, struct opts *opts, char *srcaddr, char *dstaddr, char *exec_path, char *user, char *group);
// log_content_spec_closecb
// file log.c line 583
static void log_content_spec_closecb(void *fh);
// log_content_spec_opencb
// file log.c line 546
static signed int log_content_spec_opencb(void *fh);
// log_content_submit
// file log.c line 474
signed int log_content_submit(struct log_content_ctx *ctx, struct logbuf *lb, signed int is_request);
// log_dbg_mode
// file log.c line 154
void log_dbg_mode(signed int mode);
// log_dbg_print_free
// file log.h line 42
signed int log_dbg_print_free(char *s);
// log_dbg_printf
// file log.h line 41
signed int log_dbg_printf(const char *fmt, ...);
// log_dbg_write_free
// file log.c line 115
signed int log_dbg_write_free(void *buf, unsigned long int sz);
// log_err_mode
// file log.c line 100
void log_err_mode(signed int mode);
// log_err_printf
// file log.h line 36
signed int log_err_printf(const char *fmt, ...);
// log_err_writecb
// file log.c line 65
static signed long int log_err_writecb(void *fh, const void *buf, unsigned long int sz);
// log_fini
// file log.c line 761
void log_fini(void);
// log_init
// file log.c line 739
signed int log_init(struct opts *opts);
// log_preinit
// file log.c line 677
signed int log_preinit(struct opts *opts);
// log_preinit::1::closecb$object
//
void closecb$object(void *);
// log_preinit::1::opencb$object
//
signed int opencb$object(void *);
// log_preinit::1::prepcb$object
//
struct logbuf * prepcb$object(void *, unsigned long int, struct logbuf *);
// log_preinit::1::writecb$object
//
signed long int writecb$object(void *, const void *, unsigned long int);
// logbuf_free
// file logbuf.c line 176
void logbuf_free(struct logbuf *lb);
// logbuf_new
// file logbuf.c line 47
struct logbuf * logbuf_new(void *buf, unsigned long int sz, void *fh, struct logbuf *next);
// logbuf_new_alloc
// file logbuf.c line 65
struct logbuf * logbuf_new_alloc(unsigned long int sz, void *fh, struct logbuf *next);
// logbuf_new_copy
// file logbuf.c line 86
struct logbuf * logbuf_new_copy(const void *buf, unsigned long int sz, void *fh, struct logbuf *next);
// logbuf_new_printf
// file logbuf.c line 108
struct logbuf * logbuf_new_printf(void *fh, struct logbuf *next, const char *fmt, ...);
// logbuf_size
// file logbuf.c line 132
signed long int logbuf_size(struct logbuf *lb);
// logbuf_write_free
// file logbuf.c line 149
signed long int logbuf_write_free(struct logbuf *lb, signed long int (*writefunc)(void *, const void *, unsigned long int));
// logbuf_write_free::writefunc$object
//
signed long int writefunc$object(void *, const void *, unsigned long int);
// logger_clear
// file logger.c line 59
static void logger_clear(struct logger *logger);
// logger_close
// file logger.h line 53
signed int logger_close(struct logger *logger, void *fh);
// logger_free
// file logger.h line 47
void logger_free(struct logger *logger);
// logger_join
// file logger.h line 50
signed int logger_join(struct logger *logger);
// logger_leave
// file logger.h line 49
void logger_leave(struct logger *logger);
// logger_new
// file logger.h line 44
struct logger * logger_new(signed int (*openfunc)(void *), void (*closefunc)(void *), signed long int (*writefunc)(void *, const void *, unsigned long int), struct logbuf * (*prepfunc)(void *, unsigned long int, struct logbuf *));
// logger_new::closefunc$object
//
void closefunc$object(void *);
// logger_new::openfunc$object
//
signed int openfunc$object(void *);
// logger_new::prepfunc$object
//
struct logbuf * prepfunc$object(void *, unsigned long int, struct logbuf *);
// logger_new::writefunc$object
//
signed long int writefunc$object(void *, const void *, unsigned long int);
// logger_open
// file logger.h line 52
signed int logger_open(struct logger *logger, void *fh);
// logger_print
// file logger.c line 273
signed int logger_print(struct logger *logger, void *fh, unsigned long int prepflags, const char *s);
// logger_print_freebuf
// file logger.c line 293
signed int logger_print_freebuf(struct logger *logger, void *fh, unsigned long int prepflags, char *s);
// logger_printf
// file logger.c line 244
signed int logger_printf(struct logger *logger, void *fh, unsigned long int prepflags, const char *fmt, ...);
// logger_start
// file logger.h line 48
signed int logger_start(struct logger *logger);
// logger_stop
// file logger.c line 224
signed int logger_stop(struct logger *logger);
// logger_submit
// file logger.h line 54
signed int logger_submit(struct logger *logger, void *fh, unsigned long int prepflags, struct logbuf *lb);
// logger_thread
// file logger.c line 159
static void * logger_thread(void *arg);
// logger_write
// file logger.c line 263
signed int logger_write(struct logger *logger, void *fh, unsigned long int prepflags, const void *buf, unsigned long int sz);
// logger_write_freebuf
// file logger.h line 64
signed int logger_write_freebuf(struct logger *logger, void *fh, unsigned long int prepflags, void *buf, unsigned long int sz);
// main_suite
// file main.t.c line 55
struct Suite * main_suite(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mkdtemp
// file /usr/include/stdlib.h line 662
extern char * mkdtemp(char *);
// nat_exist
// file nat.c line 484
signed int nat_exist(const char *name);
// nat_fini
// file nat.c line 603
void nat_fini(void);
// nat_getdefaultname
// file nat.c line 459
const char * nat_getdefaultname(void);
// nat_getlookupcb
// file nat.c line 509
signed int (*nat_getlookupcb(const char *name))(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int);
// nat_getsocketcb
// file nat.c line 525
signed int (*nat_getsocketcb(const char *name))(signed int);
// nat_getsockname_lookup_cb
// file nat.c line 378
static signed int nat_getsockname_lookup_cb(struct sockaddr *dst_addr, unsigned int *dst_addrlen, signed int s, struct sockaddr *src_addr, unsigned int src_addrlen);
// nat_index
// file nat.c line 470
static signed int nat_index(const char *name);
// nat_init
// file nat.c line 588
signed int nat_init(void);
// nat_iptransparent_socket_cb
// file nat.c line 352
static signed int nat_iptransparent_socket_cb(signed int s);
// nat_ipv6ready
// file nat.c line 537
signed int nat_ipv6ready(const char *name);
// nat_list_engines
// file nat.c line 548
void nat_list_engines(void);
// nat_netfilter_lookup_cb
// file nat.c line 325
static signed int nat_netfilter_lookup_cb(struct sockaddr *dst_addr, unsigned int *dst_addrlen, signed int s, struct sockaddr *src_addr, unsigned int src_addrlen);
// nat_preinit
// file nat.c line 569
signed int nat_preinit(void);
// nat_used
// file nat.c line 496
signed int nat_used(const char *name);
// nat_version
// file nat.c line 615
void nat_version(void);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opts_debug_01
// file opts.t.c line 365
static void opts_debug_01(signed int _i);
// opts_free
// file opts.h line 106
void opts_free(struct opts *opts);
// opts_has_ssl_spec
// file opts.c line 116
signed int opts_has_ssl_spec(struct opts *opts);
// opts_new
// file opts.h line 105
struct opts * opts_new(void);
// opts_proto_dbg_dump
// file opts.c line 216
void opts_proto_dbg_dump(struct opts *opts);
// opts_proto_disable
// file opts.c line 178
void opts_proto_disable(struct opts *opts, const char *optarg, const char *argv0);
// opts_proto_force
// file opts.c line 134
void opts_proto_force(struct opts *opts, const char *optarg, const char *argv0);
// opts_suite
// file opts.t.c line 381
struct Suite * opts_suite(void);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// proxy_debug_base
// file proxy.c line 145
static void proxy_debug_base(struct event_base *ev_base);
// proxy_free
// file proxy.c line 423
void proxy_free(struct proxy_ctx *ctx);
// proxy_gc_cb
// file proxy.c line 261
static void proxy_gc_cb(signed int fd, signed short int what, void *arg);
// proxy_listener_acceptcb
// file proxy.c line 117
static void proxy_listener_acceptcb(struct evconnlistener *listener, signed int fd, struct sockaddr *peeraddr, signed int peeraddrlen, void *arg);
// proxy_listener_ctx_free
// file proxy.c line 102
static void proxy_listener_ctx_free(struct proxy_listener_ctx *ctx);
// proxy_listener_ctx_new
// file proxy.c line 86
static struct proxy_listener_ctx * proxy_listener_ctx_new(struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts);
// proxy_listener_errorcb
// file proxy.c line 132
static void proxy_listener_errorcb(struct evconnlistener *listener, void *ctx);
// proxy_listener_setup
// file proxy.c line 163
static struct proxy_listener_ctx * proxy_listener_setup(struct event_base *evbase, struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts);
// proxy_new
// file proxy.c line 279
struct proxy_ctx * proxy_new(struct opts *opts);
// proxy_run
// file proxy.c line 396
void proxy_run(struct proxy_ctx *ctx);
// proxy_signal_cb
// file proxy.c line 242
static void proxy_signal_cb(signed int fd, signed short int what, void *arg);
// proxyspec_free
// file opts.h line 114
void proxyspec_free(struct proxyspec *spec);
// proxyspec_parse
// file opts.h line 113
struct proxyspec * proxyspec_parse(signed int *argc, char ***argv, const char *natengine);
// proxyspec_parse_01
// file opts.t.c line 73
static void proxyspec_parse_01(signed int _i);
// proxyspec_parse_02
// file opts.t.c line 96
static void proxyspec_parse_02(signed int _i);
// proxyspec_parse_03
// file opts.t.c line 119
static void proxyspec_parse_03(signed int _i);
// proxyspec_parse_04
// file opts.t.c line 132
static void proxyspec_parse_04(signed int _i);
// proxyspec_parse_05
// file opts.t.c line 145
static void proxyspec_parse_05(signed int _i);
// proxyspec_parse_06
// file opts.t.c line 168
static void proxyspec_parse_06(signed int _i);
// proxyspec_parse_07
// file opts.t.c line 191
static void proxyspec_parse_07(signed int _i);
// proxyspec_parse_08
// file opts.t.c line 214
static void proxyspec_parse_08(signed int _i);
// proxyspec_parse_09
// file opts.t.c line 236
static void proxyspec_parse_09(signed int _i);
// proxyspec_parse_10
// file opts.t.c line 249
static void proxyspec_parse_10(signed int _i);
// proxyspec_parse_11
// file opts.t.c line 262
static void proxyspec_parse_11(signed int _i);
// proxyspec_parse_12
// file opts.t.c line 285
static void proxyspec_parse_12(signed int _i);
// proxyspec_parse_13
// file opts.t.c line 298
static void proxyspec_parse_13(signed int _i);
// proxyspec_parse_14
// file opts.t.c line 331
static void proxyspec_parse_14(signed int _i);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$18 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$18 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$18 *, const union anonymous$15 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$18 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$18 *, union anonymous$10 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_create_01
// file sys.t.c line 180
static void pthread_create_01(signed int _i);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$10 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$10 *, const union anonymous$15 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$10 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$10 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pxy_bev_eventcb
// file pxyconn.c line 1635
static void pxy_bev_eventcb(struct bufferevent *bev, signed short int events, void *arg);
// pxy_bev_readcb
// file pxyconn.c line 1439
static void pxy_bev_readcb(struct bufferevent *bev, void *arg);
// pxy_bev_writecb
// file pxyconn.c line 1602
static void pxy_bev_writecb(struct bufferevent *bev, void *arg);
// pxy_bufferevent_setup
// file pxyconn.c line 1097
static struct bufferevent * pxy_bufferevent_setup(struct pxy_conn_ctx *ctx, signed int fd, struct ssl_st *ssl);
// pxy_conn_connect
// file pxyconn.c line 1949
static void pxy_conn_connect(struct pxy_conn_ctx *ctx);
// pxy_conn_ctx_free
// file pxyconn.c line 215
static void pxy_conn_ctx_free(struct pxy_conn_ctx *ctx);
// pxy_conn_ctx_new
// file pxyconn.c line 188
static struct pxy_conn_ctx * pxy_conn_ctx_new(struct proxyspec *spec, struct opts *opts, struct pxy_thrmgr_ctx *thrmgr, signed int fd);
// pxy_conn_setup
// file pxyconn.h line 42
void pxy_conn_setup(signed int fd, struct sockaddr *peeraddr, signed int peeraddrlen, struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts);
// pxy_conn_terminate_free
// file pxyconn.c line 1421
void pxy_conn_terminate_free(struct pxy_conn_ctx *ctx);
// pxy_debug_crt
// file pxyconn.c line 301
static void pxy_debug_crt(struct x509_st *crt);
// pxy_dstssl_create
// file pxyconn.c line 960
static struct ssl_st * pxy_dstssl_create(struct pxy_conn_ctx *ctx);
// pxy_fd_readcb
// file pxyconn.c line 2030
static void pxy_fd_readcb(signed int fd, signed short int what, void *arg);
// pxy_http_reqhdr_filter_line
// file pxyconn.c line 1142
static char * pxy_http_reqhdr_filter_line(const char *line, struct pxy_conn_ctx *ctx);
// pxy_http_resphdr_filter_line
// file pxyconn.c line 1228
static char * pxy_http_resphdr_filter_line(const char *line, struct pxy_conn_ctx *ctx);
// pxy_log_connect_http
// file pxyconn.c line 419
static void pxy_log_connect_http(struct pxy_conn_ctx *ctx);
// pxy_log_connect_nonhttp
// file pxyconn.c line 336
static void pxy_log_connect_nonhttp(struct pxy_conn_ctx *ctx);
// pxy_ocsp_deny
// file pxyconn.c line 1355
static void pxy_ocsp_deny(struct pxy_conn_ctx *ctx);
// pxy_ocsp_is_valid_uri
// file pxyconn.c line 1299
static signed int pxy_ocsp_is_valid_uri(const char *uri, struct pxy_conn_ctx *ctx);
// pxy_ossl_servername_cb
// file pxyconn.c line 877
static signed int pxy_ossl_servername_cb(struct ssl_st *ssl, signed int *al, void *arg);
// pxy_ossl_sessget_cb
// file pxyconn.c line 580
static struct ssl_session_st * pxy_ossl_sessget_cb(struct ssl_st *ssl, unsigned char *id, signed int idlen, signed int *copy);
// pxy_ossl_sessnew_cb
// file pxyconn.c line 529
static signed int pxy_ossl_sessnew_cb(struct ssl_st *ssl, struct ssl_session_st *sess);
// pxy_ossl_sessremove_cb
// file pxyconn.c line 561
static void pxy_ossl_sessremove_cb(struct ssl_ctx_st *sslctx, struct ssl_session_st *sess);
// pxy_sni_resolve_cb
// file pxyconn.c line 1999
static void pxy_sni_resolve_cb(signed int errcode, struct addrinfo *ai, void *arg);
// pxy_srccert_create
// file pxyconn.c line 728
static struct cert * pxy_srccert_create(struct pxy_conn_ctx *ctx);
// pxy_srcssl_create
// file pxyconn.c line 810
static struct ssl_st * pxy_srcssl_create(struct pxy_conn_ctx *ctx, struct ssl_st *origssl);
// pxy_srcsslctx_create
// file pxyconn.c line 606
static struct ssl_ctx_st * pxy_srcsslctx_create(struct pxy_conn_ctx *ctx, struct x509_st *crt, struct stack_st_X509 *chain, struct evp_pkey_st *key);
// pxy_ssl_shutdown
// file pxysslshut.c line 168
void pxy_ssl_shutdown(struct opts *opts, struct event_base *evbase, struct ssl_st *ssl, signed int fd);
// pxy_ssl_shutdown_cb
// file pxysslshut.c line 90
static void pxy_ssl_shutdown_cb(signed int fd, signed short int what, void *arg);
// pxy_ssl_shutdown_ctx_free
// file pxysslshut.c line 78
static void pxy_ssl_shutdown_ctx_free(struct pxy_ssl_shutdown_ctx *ctx);
// pxy_ssl_shutdown_ctx_new
// file pxysslshut.c line 62
static struct pxy_ssl_shutdown_ctx * pxy_ssl_shutdown_ctx_new(struct opts *opts, struct event_base *evbase, struct ssl_st *ssl);
// pxy_thrmgr_attach
// file pxythrmgr.h line 47
signed int pxy_thrmgr_attach(struct pxy_thrmgr_ctx *ctx, struct event_base **evbase, struct evdns_base **dnsbase);
// pxy_thrmgr_detach
// file pxythrmgr.h line 49
void pxy_thrmgr_detach(struct pxy_thrmgr_ctx *ctx, signed int thridx);
// pxy_thrmgr_free
// file pxythrmgr.h line 45
void pxy_thrmgr_free(struct pxy_thrmgr_ctx *ctx);
// pxy_thrmgr_new
// file pxythrmgr.h line 43
struct pxy_thrmgr_ctx * pxy_thrmgr_new(struct opts *opts);
// pxy_thrmgr_run
// file pxythrmgr.h line 44
signed int pxy_thrmgr_run(struct pxy_thrmgr_ctx *ctx);
// pxy_thrmgr_thr
// file pxythrmgr.c line 76
static void * pxy_thrmgr_thr(void *arg);
// pxy_thrmgr_timer_cb
// file pxythrmgr.c line 65
static void pxy_thrmgr_timer_cb(signed int fd, signed short int what, void *arg);
// pxythrmgr_libevent_01
// file pxythrmgr.t.c line 35
static void pxythrmgr_libevent_01(signed int _i);
// pxythrmgr_libevent_02
// file pxythrmgr.t.c line 45
static void pxythrmgr_libevent_02(signed int _i);
// pxythrmgr_libevent_03
// file pxythrmgr.t.c line 59
static void pxythrmgr_libevent_03(signed int _i);
// pxythrmgr_libevent_04
// file pxythrmgr.t.c line 77
static void pxythrmgr_libevent_04(signed int _i);
// pxythrmgr_libevent_05
// file pxythrmgr.t.c line 91
static void pxythrmgr_libevent_05(signed int _i);
// pxythrmgr_suite
// file pxythrmgr.t.c line 111
struct Suite * pxythrmgr_suite(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// sched_yield
// file /usr/include/sched.h line 65
extern signed int sched_yield(void);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// sk_dup
// file /usr/include/openssl/stack.h line 99
struct stack_st * sk_dup(struct stack_st *);
// sk_new_null
// file /usr/include/openssl/stack.h line 83
struct stack_st * sk_new_null(void);
// sk_num
// file /usr/include/openssl/stack.h line 77
signed int sk_num(const struct stack_st *);
// sk_pop_free
// file /usr/include/openssl/stack.h line 85
void sk_pop_free(struct stack_st *, void (*)(void *));
// sk_push
// file /usr/include/openssl/stack.h line 92
signed int sk_push(struct stack_st *, void *);
// sk_value
// file /usr/include/openssl/stack.h line 78
void * sk_value(const struct stack_st *, signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// srunner_add_suite
// file /usr/include/check.h line 933
void srunner_add_suite(struct SRunner *, struct Suite *);
// srunner_create
// file /usr/include/check.h line 920
struct SRunner * srunner_create(struct Suite *);
// srunner_free
// file /usr/include/check.h line 946
void srunner_free(struct SRunner *);
// srunner_ntests_failed
// file /usr/include/check.h line 997
signed int srunner_ntests_failed(struct SRunner *);
// srunner_run_all
// file /usr/include/check.h line 963
void srunner_run_all(struct SRunner *, enum print_output);
// ssl_dh_load
// file ssl.c line 584
struct dh_st * ssl_dh_load(const char *filename);
// ssl_dh_refcount_inc
// file ssl.c line 1096
void ssl_dh_refcount_inc(struct dh_st *dh);
// ssl_dnsname_match
// file ssl.h line 167
signed int ssl_dnsname_match(const char *certname, unsigned long int certnamesz, const char *hostname, unsigned long int hostnamesz);
// ssl_dnsname_match_01
// file ssl.t.c line 96
static void ssl_dnsname_match_01(signed int _i);
// ssl_dnsname_match_02
// file ssl.t.c line 105
static void ssl_dnsname_match_02(signed int _i);
// ssl_dnsname_match_03
// file ssl.t.c line 114
static void ssl_dnsname_match_03(signed int _i);
// ssl_dnsname_match_04
// file ssl.t.c line 123
static void ssl_dnsname_match_04(signed int _i);
// ssl_dnsname_match_05
// file ssl.t.c line 132
static void ssl_dnsname_match_05(signed int _i);
// ssl_dnsname_match_06
// file ssl.t.c line 141
static void ssl_dnsname_match_06(signed int _i);
// ssl_dnsname_match_07
// file ssl.t.c line 150
static void ssl_dnsname_match_07(signed int _i);
// ssl_dnsname_match_08
// file ssl.t.c line 159
static void ssl_dnsname_match_08(signed int _i);
// ssl_dnsname_match_09
// file ssl.t.c line 168
static void ssl_dnsname_match_09(signed int _i);
// ssl_dnsname_match_10
// file ssl.t.c line 177
static void ssl_dnsname_match_10(signed int _i);
// ssl_dnsname_match_11
// file ssl.t.c line 186
static void ssl_dnsname_match_11(signed int _i);
// ssl_dnsname_match_12
// file ssl.t.c line 195
static void ssl_dnsname_match_12(signed int _i);
// ssl_dnsname_match_13
// file ssl.t.c line 204
static void ssl_dnsname_match_13(signed int _i);
// ssl_dnsname_match_14
// file ssl.t.c line 213
static void ssl_dnsname_match_14(signed int _i);
// ssl_dnsname_match_15
// file ssl.t.c line 222
static void ssl_dnsname_match_15(signed int _i);
// ssl_dnsname_match_16
// file ssl.t.c line 231
static void ssl_dnsname_match_16(signed int _i);
// ssl_ec_by_name
// file ssl.c line 607
struct ec_key_st * ssl_ec_by_name(const char *curvename);
// ssl_features_01
// file ssl.t.c line 550
static void ssl_features_01(signed int _i);
// ssl_fini
// file ssl.h line 114
void ssl_fini(void);
// ssl_ia5string_strdup
// file ssl.c line 1369
static char * ssl_ia5string_strdup(struct asn1_string_st *ia5);
// ssl_init
// file ssl.h line 112
signed int ssl_init(void);
// ssl_is_ocspreq
// file ssl.h line 161
signed int ssl_is_ocspreq(const unsigned char *buf, unsigned long int sz);
// ssl_is_ocspreq_01
// file ssl.t.c line 539
static void ssl_is_ocspreq_01(signed int _i);
// ssl_key_genrsa
// file ssl.c line 1028
struct evp_pkey_st * ssl_key_genrsa(const signed int keysize);
// ssl_key_load
// file ssl.c line 994
struct evp_pkey_st * ssl_key_load(const char *filename);
// ssl_key_refcount_inc
// file ssl.c line 1111
void ssl_key_refcount_inc(struct evp_pkey_st *key);
// ssl_openssl_version
// file ssl.c line 97
void ssl_openssl_version(void);
// ssl_rand
// file ssl.c line 670
signed int ssl_rand(void *p, unsigned long int sz);
// ssl_reinit
// file ssl.c line 373
void ssl_reinit(void);
// ssl_session_from_file
// file cachedsess.t.c line 43
static struct ssl_session_st * ssl_session_from_file(const char *filename);
// ssl_session_from_file$link1
// file cachessess.t.c line 42
static struct ssl_session_st * ssl_session_from_file$link1(const char *filename$link1);
// ssl_session_is_valid
// file ssl.h line 159
signed int ssl_session_is_valid(struct ssl_session_st *sess);
// ssl_session_to_str
// file ssl.c line 1507
char * ssl_session_to_str(struct ssl_session_st *sess);
// ssl_setup
// file ssl.t.c line 40
static void ssl_setup(void);
// ssl_ssl_state_to_str
// file ssl.c line 428
char * ssl_ssl_state_to_str(struct ssl_st *ssl);
// ssl_suite
// file ssl.t.c line 561
struct Suite * ssl_suite(void);
// ssl_teardown
// file ssl.t.c line 47
static void ssl_teardown(void);
// ssl_thr_dyn_create_cb
// file ssl.c line 232
static struct CRYPTO_dynlock_value * ssl_thr_dyn_create_cb(const char *file, signed int line);
// ssl_thr_dyn_destroy_cb
// file ssl.c line 260
static void ssl_thr_dyn_destroy_cb(struct CRYPTO_dynlock_value *dl, const char *file, signed int line);
// ssl_thr_dyn_lock_cb
// file ssl.c line 246
static void ssl_thr_dyn_lock_cb(signed int mode, struct CRYPTO_dynlock_value *dl, const char *file, signed int line);
// ssl_thr_id_cb
// file ssl.c line 280
static void ssl_thr_id_cb(struct crypto_threadid_st *id);
// ssl_thr_locking_cb
// file ssl.c line 218
static void ssl_thr_locking_cb(signed int mode, signed int type, const char *file, signed int line);
// ssl_tls_clienthello_parse_sni
// file ssl.h line 164
char * ssl_tls_clienthello_parse_sni(const unsigned char *buf, signed long int *sz);
// ssl_tls_clienthello_parse_sni_01
// file ssl.t.c line 315
static void ssl_tls_clienthello_parse_sni_01(signed int _i);
// ssl_tls_clienthello_parse_sni_02
// file ssl.t.c line 327
static void ssl_tls_clienthello_parse_sni_02(signed int _i);
// ssl_tls_clienthello_parse_sni_03
// file ssl.t.c line 339
static void ssl_tls_clienthello_parse_sni_03(signed int _i);
// ssl_tls_clienthello_parse_sni_04
// file ssl.t.c line 352
static void ssl_tls_clienthello_parse_sni_04(signed int _i);
// ssl_tls_clienthello_parse_sni_05
// file ssl.t.c line 365
static void ssl_tls_clienthello_parse_sni_05(signed int _i);
// ssl_tls_clienthello_parse_sni_06
// file ssl.t.c line 379
static void ssl_tls_clienthello_parse_sni_06(signed int _i);
// ssl_tls_clienthello_parse_sni_07
// file ssl.t.c line 392
static void ssl_tls_clienthello_parse_sni_07(signed int _i);
// ssl_tmp_dh_callback
// file ssl.c line 541
struct dh_st * ssl_tmp_dh_callback(struct ssl_st *s, signed int is_export, signed int keylength);
// ssl_wildcardify
// file ssl.h line 169
char * ssl_wildcardify(const char *hostname);
// ssl_wildcardify_01
// file ssl.t.c line 72
static void ssl_wildcardify_01(signed int _i);
// ssl_wildcardify_02
// file ssl.t.c line 80
static void ssl_wildcardify_02(signed int _i);
// ssl_wildcardify_03
// file ssl.t.c line 88
static void ssl_wildcardify_03(signed int _i);
// ssl_x509_aias
// file ssl.c line 1389
char ** ssl_x509_aias(struct x509_st *crt, const signed int type);
// ssl_x509_fingerprint_sha1
// file ssl.c line 1083
signed int ssl_x509_fingerprint_sha1(struct x509_st *crt, unsigned char *fpr);
// ssl_x509_forge
// file ssl.c line 731
struct x509_st * ssl_x509_forge(struct x509_st *cacrt, struct evp_pkey_st *cakey, struct x509_st *origcrt, const char *extraname, struct evp_pkey_st *key);
// ssl_x509_is_valid
// file ssl.c line 1438
signed int ssl_x509_is_valid(struct x509_st *crt);
// ssl_x509_load
// file ssl.h line 140
struct x509_st * ssl_x509_load(const char *filename);
// ssl_x509_names
// file ssl.h line 145
char ** ssl_x509_names(struct x509_st *crt);
// ssl_x509_names_01
// file ssl.t.c line 407
static void ssl_x509_names_01(signed int _i);
// ssl_x509_names_match
// file ssl.c line 1212
signed int ssl_x509_names_match(struct x509_st *crt, const char *dnsname);
// ssl_x509_names_to_str
// file ssl.h line 147
char * ssl_x509_names_to_str(struct x509_st *crt);
// ssl_x509_names_to_str_01
// file ssl.t.c line 433
static void ssl_x509_names_to_str_01(signed int _i);
// ssl_x509_names_to_str_02
// file ssl.t.c line 449
static void ssl_x509_names_to_str_02(signed int _i);
// ssl_x509_ocsps
// file ssl.h line 149
char ** ssl_x509_ocsps(struct x509_st *crt);
// ssl_x509_ocsps_01
// file ssl.t.c line 501
static void ssl_x509_ocsps_01(signed int _i);
// ssl_x509_ocsps_02
// file ssl.t.c line 522
static void ssl_x509_ocsps_02(signed int _i);
// ssl_x509_refcount_inc
// file ssl.c line 1126
void ssl_x509_refcount_inc(struct x509_st *crt);
// ssl_x509_serial_copyrand
// file ssl.c line 693
signed int ssl_x509_serial_copyrand(struct x509_st *dstcrt, struct x509_st *srccrt);
// ssl_x509_subject
// file ssl.h line 141
char * ssl_x509_subject(struct x509_st *crt);
// ssl_x509_subject_01
// file ssl.t.c line 463
static void ssl_x509_subject_01(signed int _i);
// ssl_x509_subject_cn
// file ssl.h line 142
char * ssl_x509_subject_cn(struct x509_st *crt, unsigned long int *psz);
// ssl_x509_subject_cn_01
// file ssl.t.c line 479
static void ssl_x509_subject_cn_01(signed int _i);
// ssl_x509_to_pem
// file ssl.c line 1480
char * ssl_x509_to_pem(struct x509_st *crt);
// ssl_x509_to_str
// file ssl.c line 1453
char * ssl_x509_to_str(struct x509_st *crt);
// ssl_x509_v3ext_add
// file ssl.c line 626
signed int ssl_x509_v3ext_add(struct v3_ext_ctx *ctx, struct x509_st *crt, char *k, char *v);
// ssl_x509_v3ext_copy_by_nid
// file ssl.c line 648
signed int ssl_x509_v3ext_copy_by_nid(struct x509_st *crt, struct x509_st *origcrt, signed int nid);
// ssl_x509chain_load
// file ssl.c line 869
signed int ssl_x509chain_load(struct x509_st **crt, struct stack_st_X509 **chain, const char *filename);
// ssl_x509chain_use
// file ssl.c line 939
void ssl_x509chain_use(struct ssl_ctx_st *sslctx, struct x509_st *crt, struct stack_st_X509 *chain);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strpbrk
// file /usr/include/string.h line 314
extern char * strpbrk(const char *, const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// suite_add_tcase
// file /usr/include/check.h line 155
void suite_add_tcase(struct Suite *, struct TCase *);
// suite_create
// file /usr/include/check.h line 131
struct Suite * suite_create(const char *);
// symlink
// file /usr/include/unistd.h line 803
extern signed int symlink(const char *, const char *);
// sys_dir_eachfile
// file sys.h line 55
signed int sys_dir_eachfile(const char *dirname, void (*cb)(const char *, void *), void *arg);
// sys_dir_eachfile::cb$object
//
void cb$object(const char *, void *);
// sys_dir_eachfile_01
// file sys.t.c line 157
static void sys_dir_eachfile_01(signed int _i);
// sys_dir_eachfile_cb
// file sys.t.c line 151
void sys_dir_eachfile_cb(const char *fn, void *arg);
// sys_get_cpu_cores
// file sys.h line 57
unsigned int sys_get_cpu_cores(void);
// sys_get_cpu_cores_01
// file sys.t.c line 167
static void sys_get_cpu_cores_01(signed int _i);
// sys_group_str
// file sys.h line 45
char * sys_group_str(unsigned int gid);
// sys_group_str_01
// file sys.t.c line 200
static void sys_group_str_01(signed int _i);
// sys_isdir
// file sys.h line 51
signed int sys_isdir(const char *path);
// sys_isdir_01
// file sys.t.c line 85
static void sys_isdir_01(signed int _i);
// sys_isdir_02
// file sys.t.c line 91
static void sys_isdir_02(signed int _i);
// sys_isdir_03
// file sys.t.c line 97
static void sys_isdir_03(signed int _i);
// sys_isdir_04
// file sys.t.c line 103
static void sys_isdir_04(signed int _i);
// sys_isdir_05
// file sys.t.c line 109
static void sys_isdir_05(signed int _i);
// sys_isdir_setup
// file sys.t.c line 48
static void sys_isdir_setup(void);
// sys_isdir_teardown
// file sys.t.c line 71
static void sys_isdir_teardown(void);
// sys_mkpath
// file sys.h line 52
signed int sys_mkpath(const char *path, unsigned int mode);
// sys_mkpath_01
// file sys.t.c line 136
static void sys_mkpath_01(signed int _i);
// sys_mkpath_setup
// file sys.t.c line 116
static void sys_mkpath_setup(void);
// sys_mkpath_teardown
// file sys.t.c line 126
static void sys_mkpath_teardown(void);
// sys_pidf_close
// file sys.c line 194
void sys_pidf_close(signed int fd, const char *fn);
// sys_pidf_open
// file sys.c line 149
signed int sys_pidf_open(const char *fn);
// sys_pidf_write
// file sys.c line 173
signed int sys_pidf_write(signed int fd);
// sys_privdrop
// file sys.c line 72
signed int sys_privdrop(const char *username, const char *groupname, const char *jaildir);
// sys_sockaddr_parse
// file sys.h line 47
signed int sys_sockaddr_parse(struct sockaddr_storage *addr, unsigned int *addrlen, char *naddr, char *nport, signed int af, signed int flags);
// sys_sockaddr_str
// file sys.c line 342
char * sys_sockaddr_str(struct sockaddr *addr, unsigned int addrlen);
// sys_suite
// file sys.t.c line 208
struct Suite * sys_suite(void);
// sys_user_str
// file sys.h line 44
char * sys_user_str(unsigned int uid);
// sys_user_str_01
// file sys.t.c line 193
static void sys_user_str_01(signed int _i);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tcase_add_checked_fixture
// file /usr/include/check.h line 333
void tcase_add_checked_fixture(struct TCase *, void (*)(void), void (*)(void));
// tcase_add_unchecked_fixture
// file /usr/include/check.h line 304
void tcase_add_unchecked_fixture(struct TCase *, void (*)(void), void (*)(void));
// tcase_create
// file /usr/include/check.h line 170
struct TCase * tcase_create(const char *);
// tcase_fn_start
// file /usr/include/check.h line 359
void tcase_fn_start(const char *, const char *, signed int);
// thrmain
// file sys.t.c line 174
void * thrmain(void *arg);
// thrqueue_dequeue
// file thrqueue.c line 158
void * thrqueue_dequeue(struct thrqueue *queue);
// thrqueue_dequeue_nb
// file thrqueue.c line 184
void * thrqueue_dequeue_nb(struct thrqueue *queue);
// thrqueue_enqueue
// file thrqueue.c line 112
void * thrqueue_enqueue(struct thrqueue *queue, void *item);
// thrqueue_enqueue_nb
// file thrqueue.c line 136
void * thrqueue_enqueue_nb(struct thrqueue *queue, void *item);
// thrqueue_free
// file thrqueue.c line 96
void thrqueue_free(struct thrqueue *queue);
// thrqueue_new
// file thrqueue.c line 56
struct thrqueue * thrqueue_new(unsigned long int sz);
// thrqueue_unblock_dequeue
// file thrqueue.c line 222
void thrqueue_unblock_dequeue(struct thrqueue *queue);
// thrqueue_unblock_enqueue
// file thrqueue.c line 208
void thrqueue_unblock_enqueue(struct thrqueue *queue);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// url_dec
// file url.h line 36
char * url_dec(const char *in, unsigned long int insz, unsigned long int *outsz);
// url_dec_01
// file url.t.c line 45
static void url_dec_01(signed int _i);
// url_dec_02
// file url.t.c line 58
static void url_dec_02(signed int _i);
// url_dec_03
// file url.t.c line 71
static void url_dec_03(signed int _i);
// url_dec_04
// file url.t.c line 81
static void url_dec_04(signed int _i);
// url_dec_05
// file url.t.c line 91
static void url_dec_05(signed int _i);
// url_dec_06
// file url.t.c line 101
static void url_dec_06(signed int _i);
// url_suite
// file url.t.c line 116
struct Suite * url_suite(void);
// util_skipws
// file util.h line 34
char * util_skipws(const char *s);
// util_skipws_01
// file util.t.c line 41
static void util_skipws_01(signed int _i);
// util_skipws_02
// file util.t.c line 51
static void util_skipws_02(signed int _i);
// util_skipws_03
// file util.t.c line 61
static void util_skipws_03(signed int _i);
// util_skipws_04
// file util.t.c line 71
static void util_skipws_04(signed int _i);
// util_skipws_05
// file util.t.c line 81
static void util_skipws_05(signed int _i);
// util_skipws_06
// file util.t.c line 91
static void util_skipws_06(signed int _i);
// util_suite
// file main.t.c line 80
struct Suite * util_suite(void);
// vasprintf
// file /usr/include/stdio.h line 399
extern signed int vasprintf(char ** restrict , const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$6
{
  // filename
  char *filename;
};

struct anonymous$4
{
  // header_req
  char *header_req;
  // header_resp
  char *header_resp;
};

struct anonymous$11
{
  // fts_cur
  struct _ftsent *fts_cur;
  // fts_child
  struct _ftsent *fts_child;
  // fts_array
  struct _ftsent **fts_array;
  // fts_dev
  unsigned long int fts_dev;
  // fts_path
  char *fts_path;
  // fts_rfd
  signed int fts_rfd;
  // fts_pathlen
  signed int fts_pathlen;
  // fts_nitems
  signed int fts_nitems;
  // fts_compar
  signed int (*fts_compar)(const void *, const void *);
  // fts_options
  signed int fts_options;
};

struct anonymous$5
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous$19
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous$3
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

struct anonymous$2
{
  // n_buckets
  unsigned int n_buckets;
  // size
  unsigned int size;
  // n_occupied
  unsigned int n_occupied;
  // upper_bound
  unsigned int upper_bound;
  // flags
  unsigned int *flags;
  // keys
  char **keys;
  // vals
  void **vals;
};

struct anonymous$9
{
  // n_buckets
  unsigned int n_buckets;
  // size
  unsigned int size;
  // n_occupied
  unsigned int n_occupied;
  // upper_bound
  unsigned int upper_bound;
  // flags
  unsigned int *flags;
  // keys
  struct dynbuf **keys;
  // vals
  struct dynbuf **vals;
};

struct anonymous$0
{
  // n_buckets
  unsigned int n_buckets;
  // size
  unsigned int size;
  // n_occupied
  unsigned int n_occupied;
  // upper_bound
  unsigned int upper_bound;
  // flags
  unsigned int *flags;
  // keys
  void **keys;
  // vals
  void **vals;
};

union anonymous$14
{
  // inherit
  signed int *inherit;
  // asIdsOrRanges
  struct stack_st_ASIdOrRange *asIdsOrRanges;
};

union anonymous$21
{
  // ptr
  char *ptr;
  // otherName
  struct otherName_st *otherName;
  // rfc822Name
  struct asn1_string_st *rfc822Name;
  // dNSName
  struct asn1_string_st *dNSName;
  // x400Address
  struct asn1_type_st *x400Address;
  // directoryName
  struct X509_name_st *directoryName;
  // ediPartyName
  struct EDIPartyName_st *ediPartyName;
  // uniformResourceIdentifier
  struct asn1_string_st *uniformResourceIdentifier;
  // iPAddress
  struct asn1_string_st *iPAddress;
  // registeredID
  struct asn1_object_st *registeredID;
  // ip
  struct asn1_string_st *ip;
  // dirn
  struct X509_name_st *dirn;
  // ia5
  struct asn1_string_st *ia5;
  // rid
  struct asn1_object_st *rid;
  // other
  struct asn1_type_st *other;
};

union anonymous$17
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous$16
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous$8
{
  // fullname
  struct stack_st_GENERAL_NAME *fullname;
  // relativename
  struct stack_st_X509_NAME_ENTRY *relativename;
};

union anonymous$13
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous$1
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$15
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$7
{
  // file
  struct anonymous$4 file;
  // dir
  struct anonymous$6 dir;
  // spec
  struct anonymous$6 spec;
};

union anonymous$18
{
  // __data
  struct anonymous$19 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$10
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$12
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$20
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct ACCESS_DESCRIPTION_st
{
  // method
  struct asn1_object_st *method;
  // location
  struct GENERAL_NAME_st *location;
};

struct ASIdentifierChoice_st
{
  // type
  signed int type;
  // u
  union anonymous$14 u;
};

struct ASIdentifiers_st
{
  // asnum
  struct ASIdentifierChoice_st *asnum;
  // rdi
  struct ASIdentifierChoice_st *rdi;
};

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct AUTHORITY_KEYID_st
{
  // keyid
  struct asn1_string_st *keyid;
  // issuer
  struct stack_st_GENERAL_NAME *issuer;
  // serial
  struct asn1_string_st *serial;
};

struct CRYPTO_dynlock_value
{
  // mutex
  union anonymous$10 mutex;
};

struct DIST_POINT_NAME_st
{
  // type
  signed int type;
  // name
  union anonymous$8 name;
  // dpname
  struct X509_name_st *dpname;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct EDIPartyName_st
{
  // nameAssigner
  struct asn1_string_st *nameAssigner;
  // partyName
  struct asn1_string_st *partyName;
};

struct GENERAL_NAME_st
{
  // type
  signed int type;
  // d
  union anonymous$21 d;
};

struct ISSUING_DIST_POINT_st
{
  // distpoint
  struct DIST_POINT_NAME_st *distpoint;
  // onlyuser
  signed int onlyuser;
  // onlyCA
  signed int onlyCA;
  // onlysomereasons
  struct asn1_string_st *onlysomereasons;
  // indirectCRL
  signed int indirectCRL;
  // onlyattr
  signed int onlyattr;
};

struct NAME_CONSTRAINTS_st
{
  // permittedSubtrees
  struct stack_st_GENERAL_SUBTREE *permittedSubtrees;
  // excludedSubtrees
  struct stack_st_GENERAL_SUBTREE *excludedSubtrees;
};

struct X509V3_CONF_METHOD_st
{
  // get_string
  char * (*get_string)(void *, char *, char *);
  // get_section
  struct stack_st_CONF_VALUE * (*get_section)(void *, char *);
  // free_string
  void (*free_string)(void *, char *);
  // free_section
  void (*free_section)(void *, struct stack_st_CONF_VALUE *);
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_extension_st
{
  // object
  struct asn1_object_st *object;
  // critical
  signed int critical;
  // value
  struct asn1_string_st *value;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_req_info_st
{
  // enc
  struct ASN1_ENCODING_st enc;
  // version
  struct asn1_string_st *version;
  // subject
  struct X509_name_st *subject;
  // pubkey
  struct X509_pubkey_st *pubkey;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct X509_req_st
{
  // req_info
  struct X509_req_info_st *req_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _ftsent
{
  // fts_cycle
  struct _ftsent *fts_cycle;
  // fts_parent
  struct _ftsent *fts_parent;
  // fts_link
  struct _ftsent *fts_link;
  // fts_number
  signed long int fts_number;
  // fts_pointer
  void *fts_pointer;
  // fts_accpath
  char *fts_accpath;
  // fts_path
  char *fts_path;
  // fts_errno
  signed int fts_errno;
  // fts_symfd
  signed int fts_symfd;
  // fts_pathlen
  unsigned short int fts_pathlen;
  // fts_namelen
  unsigned short int fts_namelen;
  // fts_ino
  unsigned long int fts_ino;
  // fts_dev
  unsigned long int fts_dev;
  // fts_nlink
  unsigned long int fts_nlink;
  // fts_level
  signed short int fts_level;
  // fts_info
  unsigned short int fts_info;
  // fts_flags
  unsigned short int fts_flags;
  // fts_instr
  unsigned short int fts_instr;
  // fts_statp
  struct stat *fts_statp;
  // fts_name
  char fts_name[1l];
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous$16 value;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous$13 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct cache
{
  // mutex
  union anonymous$10 mutex;
  // begin_cb
  unsigned int (*begin_cb)(void);
  // end_cb
  unsigned int (*end_cb)(void);
  // exist_cb
  signed int (*exist_cb)(unsigned int);
  // del_cb
  void (*del_cb)(unsigned int);
  // get_cb
  unsigned int (*get_cb)(void *);
  // put_cb
  unsigned int (*put_cb)(void *, signed int *);
  // free_key_cb
  void (*free_key_cb)(void *);
  // free_val_cb
  void (*free_val_cb)(void *);
  // get_key_cb
  void * (*get_key_cb)(unsigned int);
  // get_val_cb
  void * (*get_val_cb)(unsigned int);
  // set_val_cb
  void (*set_val_cb)(unsigned int, void *);
  // unpackverify_val_cb
  void * (*unpackverify_val_cb)(void *, signed int);
  // fini_cb
  void (*fini_cb)(void);
};

struct cert
{
  // key
  struct evp_pkey_st *key;
  // crt
  struct x509_st *crt;
  // chain
  struct stack_st_X509 *chain;
  // mutex
  union anonymous$10 mutex;
  // references
  unsigned long int references;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct crypto_threadid_st
{
  // ptr
  void *ptr;
  // val
  unsigned long int val;
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct dynbuf
{
  // buf
  unsigned char *buf;
  // sz
  unsigned long int sz;
};

struct engine
{
  // name
  const char *name;
  // ipv6
  unsigned int ipv6 : 1;
  // used
  unsigned int used : 1;
  // preinitcb
  signed int (*preinitcb)(void);
  // initcb
  signed int (*initcb)(void);
  // finicb
  void (*finicb)(void);
  // lookupcb
  signed int (*lookupcb)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int);
  // socketcb
  signed int (*socketcb)(signed int);
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous$17 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct in6_addr
{
  // __in6_u
  union anonymous$1 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lhash_st_CONF_VALUE
{
  // dummy
  signed int dummy;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct log_content_ctx
{
  // open
  unsigned int open : 1;
  // fd
  signed int fd;
  // u
  union anonymous$7 u;
};

struct logbuf
{
  // buf
  unsigned char *buf;
  // sz
  signed long int sz;
  // fh
  void *fh;
  // ctl
  unsigned long int ctl;
  // next
  struct logbuf *next;
};

struct logger
{
  // thr
  unsigned long int thr;
  // open
  signed int (*open)(void *);
  // close
  void (*close)(void *);
  // prep
  struct logbuf * (*prep)(void *, unsigned long int, struct logbuf *);
  // write
  signed long int (*write)(void *, const void *, unsigned long int);
  // queue
  struct thrqueue *queue;
};

struct ocsp_req_info_st
{
  // version
  struct asn1_string_st *version;
  // requestorName
  struct GENERAL_NAME_st *requestorName;
  // requestList
  struct stack_st_OCSP_ONEREQ *requestList;
  // requestExtensions
  struct stack_st_X509_EXTENSION *requestExtensions;
};

struct ocsp_request_st
{
  // tbsRequest
  struct ocsp_req_info_st *tbsRequest;
  // optionalSignature
  struct ocsp_signature_st *optionalSignature;
};

struct ocsp_signature_st
{
  // signatureAlgorithm
  struct X509_algor_st *signatureAlgorithm;
  // signature
  struct asn1_string_st *signature;
  // certs
  struct stack_st_X509 *certs;
};

struct opts
{
  // debug
  unsigned int debug : 1;
  // detach
  unsigned int detach : 1;
  // sslcomp
  unsigned int sslcomp : 1;
  // no_ssl3
  unsigned int no_ssl3 : 1;
  // no_tls10
  unsigned int no_tls10 : 1;
  // no_tls11
  unsigned int no_tls11 : 1;
  // no_tls12
  unsigned int no_tls12 : 1;
  // passthrough
  unsigned int passthrough : 1;
  // deny_ocsp
  unsigned int deny_ocsp : 1;
  // contentlog_isdir
  unsigned int contentlog_isdir : 1;
  // contentlog_isspec
  unsigned int contentlog_isspec : 1;
  // ciphers
  char *ciphers;
  // tgcrtdir
  char *tgcrtdir;
  // dropuser
  char *dropuser;
  // dropgroup
  char *dropgroup;
  // jaildir
  char *jaildir;
  // pidfile
  char *pidfile;
  // connectlog
  char *connectlog;
  // contentlog
  char *contentlog;
  // sslmethod
  const struct ssl_method_st * (*sslmethod)(void);
  // cacrt
  struct x509_st *cacrt;
  // cakey
  struct evp_pkey_st *cakey;
  // key
  struct evp_pkey_st *key;
  // chain
  struct stack_st_X509 *chain;
  // dh
  struct dh_st *dh;
  // ecdhcurve
  char *ecdhcurve;
  // spec
  struct proxyspec *spec;
};

struct otherName_st
{
  // type_id
  struct asn1_object_st *type_id;
  // value
  struct asn1_type_st *value;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct proxy_ctx
{
  // thrmgr
  struct pxy_thrmgr_ctx *thrmgr;
  // evbase
  struct event_base *evbase;
  // sev
  struct event *sev[4l];
  // gcev
  struct event *gcev;
  // lctx
  struct proxy_listener_ctx *lctx;
  // opts
  struct opts *opts;
};

struct proxy_listener_ctx
{
  // thrmgr
  struct pxy_thrmgr_ctx *thrmgr;
  // spec
  struct proxyspec *spec;
  // opts
  struct opts *opts;
  // evcl
  struct evconnlistener *evcl;
  // next
  struct proxy_listener_ctx *next;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct proxyspec
{
  // ssl
  unsigned int ssl : 1;
  // http
  unsigned int http : 1;
  // listen_addr
  struct sockaddr_storage listen_addr;
  // listen_addrlen
  unsigned int listen_addrlen;
  // connect_addr
  struct sockaddr_storage connect_addr;
  // connect_addrlen
  unsigned int connect_addrlen;
  // sni_port
  unsigned short int sni_port;
  // natengine
  char *natengine;
  // natlookup
  signed int (*natlookup)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int);
  // natsocket
  signed int (*natsocket)(signed int);
  // next
  struct proxyspec *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct pxy_conn_desc
{
  // bev
  struct bufferevent *bev;
  // ssl
  struct ssl_st *ssl;
  // closed
  unsigned int closed : 1;
};

struct pxy_conn_ctx
{
  // src
  struct pxy_conn_desc src;
  // dst
  struct pxy_conn_desc dst;
  // immutable_cert
  unsigned int immutable_cert : 1;
  // connected
  unsigned int connected : 1;
  // seen_req_header
  unsigned int seen_req_header : 1;
  // seen_resp_header
  unsigned int seen_resp_header : 1;
  // sent_http_conn_close
  unsigned int sent_http_conn_close : 1;
  // passthrough
  unsigned int passthrough : 1;
  // ocsp_denied
  unsigned int ocsp_denied : 1;
  // enomem
  unsigned int enomem : 1;
  // sni_peek_retries
  unsigned int sni_peek_retries : 6;
  // sni
  char *sni;
  // src_str
  char *src_str;
  // dst_str
  char *dst_str;
  // http_method
  char *http_method;
  // http_uri
  char *http_uri;
  // http_host
  char *http_host;
  // http_content_type
  char *http_content_type;
  // http_status_code
  char *http_status_code;
  // http_status_text
  char *http_status_text;
  // http_content_length
  char *http_content_length;
  // ssl_names
  char *ssl_names;
  // logctx
  struct log_content_ctx *logctx;
  // fd
  signed int fd;
  // ev
  struct event *ev;
  // addr
  struct sockaddr_storage addr;
  // addrlen
  unsigned int addrlen;
  // af
  signed int af;
  // origcrt
  struct x509_st *origcrt;
  // evbase
  struct event_base *evbase;
  // dnsbase
  struct evdns_base *dnsbase;
  // thridx
  signed int thridx;
  // thrmgr
  struct pxy_thrmgr_ctx *thrmgr;
  // spec
  struct proxyspec *spec;
  // opts
  struct opts *opts;
};

struct pxy_ssl_shutdown_ctx
{
  // opts
  struct opts *opts;
  // evbase
  struct event_base *evbase;
  // ev
  struct event *ev;
  // ssl
  struct ssl_st *ssl;
  // retries
  unsigned int retries;
};

struct pxy_thr_ctx
{
  // thr
  unsigned long int thr;
  // load
  unsigned long int load;
  // evbase
  struct event_base *evbase;
  // dnsbase
  struct evdns_base *dnsbase;
  // running
  signed int running;
};

struct pxy_thrmgr_ctx
{
  // num_thr
  signed int num_thr;
  // thr
  struct pxy_thr_ctx **thr;
  // mutex
  union anonymous$10 mutex;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous$3 tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous$5 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ACCESS_DESCRIPTION
{
  // stack
  struct stack_st stack;
};

struct stack_st_ASIdOrRange
{
  // stack
  struct stack_st stack;
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_CONF_VALUE
{
  // stack
  struct stack_st stack;
};

struct stack_st_DIST_POINT
{
  // stack
  struct stack_st stack;
};

struct stack_st_GENERAL_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_GENERAL_SUBTREE
{
  // stack
  struct stack_st stack;
};

struct stack_st_IPAddressFamily
{
  // stack
  struct stack_st stack;
};

struct stack_st_OCSP_ONEREQ
{
  // stack
  struct stack_st stack;
};

struct stack_st_OCSP_RESPID
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct thrqueue
{
  // data
  void **data;
  // sz
  unsigned long int sz;
  // n
  unsigned long int n;
  // in
  unsigned long int in;
  // out
  unsigned long int out;
  // block_enqueue
  unsigned int block_enqueue : 1;
  // block_dequeue
  unsigned int block_dequeue : 1;
  // mutex
  union anonymous$10 mutex;
  // notempty
  union anonymous$18 notempty;
  // notfull
  union anonymous$18 notfull;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct v3_ext_ctx
{
  // flags
  signed int flags;
  // issuer_cert
  struct x509_st *issuer_cert;
  // subject_cert
  struct x509_st *subject_cert;
  // subject_req
  struct X509_req_st *subject_req;
  // crl
  struct X509_crl_st *crl;
  // db_meth
  struct X509V3_CONF_METHOD_st *db_meth;
  // db
  void *db;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // rfc3779_addr
  struct stack_st_IPAddressFamily *rfc3779_addr;
  // rfc3779_asid
  struct ASIdentifiers_st *rfc3779_asid;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// __ac_HASH_UPPER
// file khash.h line 184
static const double __ac_HASH_UPPER = 0.77;
// __ac_HASH_UPPER$link1
// file khash.h line 184
static const double __ac_HASH_UPPER$link1 = 0.77;
// __ac_HASH_UPPER$link2
// file khash.h line 184
static const double __ac_HASH_UPPER$link2 = 0.77;
// __ac_HASH_UPPER$link3
// file khash.h line 184
static const double __ac_HASH_UPPER$link3 = 0.77;
// addr
// file cachedsess.t.c line 56
static struct sockaddr_storage addr;
// addrlen
// file cachedsess.t.c line 57
static unsigned int addrlen;
// argv01
// file opts.t.c line 38
static char *argv01[5l] = { "https", "127.0.0.1", "10443", "127.0.0.2", "443" };
// argv02
// file opts.t.c line 41
static char *argv02[5l] = { "https", "::1", "10443", "::2", "443" };
// argv03
// file opts.t.c line 44
static char *argv03[5l] = { "http", "127.0.0.1", "10443", "127.0.0.2", "443" };
// argv04
// file opts.t.c line 47
static char *argv04[5l] = { "ssl", "127.0.0.1", "10443", "127.0.0.2", "443" };
// argv05
// file opts.t.c line 50
static char *argv05[5l] = { "tcp", "127.0.0.1", "10443", "127.0.0.2", "443" };
// argv06
// file opts.t.c line 53
static char *argv06[5l] = { "https", "127.0.0.1", "10443", "sni", "443" };
// argv07
// file opts.t.c line 56
static char *argv07[5l] = { "http", "127.0.0.1", "10443", "sni", "443" };
// argv08
// file opts.t.c line 59
static char *argv08[4l] = { "https", "127.0.0.1", "10443", "no_such_engine" };
// argv09
// file opts.t.c line 62
static char *argv09[10l] = { "https", "127.0.0.1", "10443", "127.0.0.2", "443", "https", "::1", "10443", "::2", "443" };
// argv10
// file opts.t.c line 66
static char *argv10[6l] = { "https", "127.0.0.1", "10443", "https", "::1", "10443" };
// basedir
// file sys.t.c line 44
static char *basedir;
// buf
// file dynbuf.t.c line 38
static unsigned char *buf;
// build_date
// file version.c line 36
const char *build_date = "2016-01-26";
// build_info
// file version.c line 37
const char *build_info = "V:FILE";
// cachemgr_dsess
// file cachemgr.c line 46
struct cache *cachemgr_dsess;
// cachemgr_fkcrt
// file cachemgr.c line 43
struct cache *cachemgr_fkcrt;
// cachemgr_ssess
// file cachemgr.c line 45
struct cache *cachemgr_ssess;
// cachemgr_tgcrt
// file cachemgr.c line 44
struct cache *cachemgr_tgcrt;
// certmap
// file cachefkcrt.c line 59
static struct anonymous$0 *certmap;
// certmap$link1
// file cachetgcrt.c line 44
static struct anonymous$2 *certmap$link1;
// clienthello01
// file ssl.t.c line 241
static unsigned char clienthello01[106l] = { 128, 'g', 1, 3, 0, 0, 'N', 0, 0, 0, 16, 1, 0, 128, 3, 0, 128, 7, 0, 192, 6, 0, '@', 2, 0, 128, 4, 0, 128, 0, 0, '9', 0, 0, '8', 0, 0, '5', 0, 0, '3', 0, 0, '2', 0, 0, 4, 0, 0, 5, 0, 0, '/', 0, 0, 22, 0, 0, 19, 0, 254, 255, 0, 0, 10, 0, 0, 21, 0, 0, 18, 0, 254, 254, 0, 0, 9, 0, 0, 'd', 0, 0, 'b', 0, 0, 3, 0, 0, 6, 168, 184, 147, 187, 144, 233, '*', 162, 'M', 'm', 204, 28, 231, '*', 128, '!', 0 };
// clienthello02
// file ssl.t.c line 251
static unsigned char clienthello02[121l] = { 22, 3, 0, 0, 's', 1, 0, 0, 'o', 3, 0, 0, '4', 1, 30, 'g', ':', 250, 206, 217, 'Q', 186, 228, 252, 'd', 149, 3, 130, 'c', 15, 227, '9', 'k', 199, 189, '+', 229, 'Q', '7', '#', 'H', '[', 251, ' ', 163, 202, 173, 'F', 149, ']', 'd', 187, '3', 236, 181, 18, 145, '!', 163, 'P', 210, 192, 197, 246, 'g', 195, 204, 158, 192, 'J', 'q', 27, 146, 220, 'X', 'U', 0, '(', 0, '9', 0, '8', 0, '5', 0, '3', 0, '2', 0, 4, 0, 5, 0, '/', 0, 22, 0, 19, 254, 255, 0, 10, 0, 21, 0, 18, 254, 254, 0, 9, 0, 'd', 0, 'b', 0, 3, 0, 6, 1, 0, 0 };
// clienthello03
// file ssl.t.c line 262
static unsigned char clienthello03[161l] = { 22, 3, 1, 0, 155, 1, 0, 0, 151, 3, 1, 'K', 153, 'F', 172, '8', 8, 187, 167, 28, 155, 234, 'y', 197, 214, 'p', '=', 237, ' ', 128, '`', 180, '~', 181, 7, 19, 207, 154, 28, 236, 'o', 'd', 229, 0, 0, 'F', 192, 10, 192, 9, 192, 7, 192, 8, 192, 19, 192, 20, 192, 17, 192, 18, 192, 4, 192, 5, 192, 2, 192, 3, 192, 14, 192, 15, 192, 12, 192, 13, 0, '/', 0, 5, 0, 4, 0, '5', 0, 10, 0, 9, 0, 3, 0, 8, 0, 6, 0, '2', 0, '3', 0, '8', 0, '9', 0, 22, 0, 21, 0, 20, 0, 19, 0, 18, 0, 17, 1, 0, 0, '(', 0, 0, 0, 18, 0, 16, 0, 0, 13, '1', '9', '2', '.', '1', '6', '8', '.', '1', '0', '0', '.', '4', 0, 10, 0, 8, 0, 6, 0, 23, 0, 24, 0, 25, 0, 11, 0, 2, 1, 0, 0 };
// clienthello04
// file ssl.t.c line 276
static unsigned char clienthello04[114l] = { 22, 3, 1, 0, 'l', 1, 0, 0, 'h', 3, 1, 'J', 157, 'I', 'u', 178, '~', 249, 188, 195, 'v', 172, 25, 'x', 251, 'j', 238, 'P', 'U', '^', '5', 'L', 202, 242, '!', 21, 243, 138, '*', 252, 181, '5', 237, 0, 0, '(', 0, '9', 0, '8', 0, '5', 0, 22, 0, 19, 0, 10, 0, '3', 0, '2', 0, '/', 0, 7, 0, 5, 0, 4, 0, 21, 0, 18, 0, 9, 0, 20, 0, 17, 0, 8, 0, 6, 0, 3, 1, 0, 0, 23, 0, 0, 0, 15, 0, 13, 0, 0, 10, 'k', 'a', 'm', 'e', 's', 'h', '.', 'c', 'o', 'm', 0, '#', 0, 0, 0 };
// clienthello05
// file ssl.t.c line 287
static unsigned char clienthello05[387l] = { 22, 3, 3, 1, '}', 1, 0, 1, 'y', 3, 3, 'O', 127, '\'', 208, 'v', '_', 193, ';', 186, 's', 213, 7, 139, 217, 'y', 249, 'Q', 212, 206, '}', 154, 219, 223, 248, 'N', 149, 134, '8', 'a', 221, 132, '*', 0, 0, 202, 192, '0', 192, ',', 192, '(', 192, '$', 192, 20, 192, 10, 192, '"', 192, '!', 0, 163, 0, 159, 0, 'k', 0, 'j', 0, '9', 0, '8', 0, 136, 0, 135, 192, 25, 192, ' ', 0, 167, 0, 'm', 0, ':', 0, 137, 192, '2', 192, '.', 192, '*', 192, '&', 192, 15, 192, 5, 0, 157, 0, '=', 0, '5', 0, 132, 192, 18, 192, 8, 192, 28, 192, 27, 0, 22, 0, 19, 192, 23, 192, 26, 0, 27, 192, 13, 192, 3, 0, 10, 192, '/', 192, '+', 192, '\'', 192, '#', 192, 19, 192, 9, 192, 31, 192, 30, 0, 162, 0, 158, 0, 'g', 0, '@', 0, '3', 0, '2', 0, 154, 0, 153, 0, 'E', 0, 'D', 192, 24, 192, 29, 0, 166, 0, 'l', 0, '4', 0, 155, 0, 'F', 192, '1', 192, '-', 192, ')', 192, '%', 192, 14, 192, 4, 0, 156, 0, '<', 0, '/', 0, 150, 0, 'A', 0, 7, 192, 17, 192, 7, 192, 22, 0, 24, 192, 12, 192, 2, 0, 5, 0, 4, 0, 21, 0, 18, 0, 26, 0, 9, 0, 20, 0, 17, 0, 25, 0, 8, 0, 6, 0, 23, 0, 3, 0, 255, 2, 1, 0, 0, 133, 0, 0, 0, 18, 0, 16, 0, 0, 13, 'd', 'a', 'n', 'i', 'e', 'l', '.', 'r', 'o', 'e', '.', 'c', 'h', 0, 11, 0, 4, 3, 0, 1, 2, 0, 10, 0, '4', 0, '2', 0, 14, 0, 13, 0, 25, 0, 11, 0, 12, 0, 24, 0, 9, 0, 10, 0, 22, 0, 23, 0, 8, 0, 6, 0, 7, 0, 20, 0, 21, 0, 4, 0, 5, 0, 18, 0, 19, 0, 1, 0, 2, 0, 3, 0, 15, 0, 16, 0, 17, 0, '#', 0, 0, 0, 13, 0, '"', 0, ' ', 6, 1, 6, 2, 6, 3, 5, 1, 5, 2, 5, 3, 4, 1, 4, 2, 4, 3, 3, 1, 3, 2, 3, 3, 2, 1, 2, 2, 2, 3, 1, 1, 0, 15, 0, 1, 1, 0 };
// coded01
// file base64.t.c line 41
static const char *coded01 = "YW55IGNhcm5hbCBwbGVhc3VyZS4=";
// coded01$link1
// file url.t.c line 38
static const char *coded01$link1 = "%3D%3D%3D1234%3D%3D%3D";
// coded02
// file base64.t.c line 42
static const char *coded02 = "YW55IGNhcm5hbCBwbGVhc3VyZQ==";
// coded02$link1
// file url.t.c line 39
static const char *coded02$link1 = "%00%01%7F%FF";
// coded03
// file base64.t.c line 43
static const char *coded03 = "YW55IGNhcm5hbCBwbGVhc3Vy";
// coded03$link1
// file url.t.c line 41
static const char *coded03$link1 = "%";
// coded04
// file base64.t.c line 44
static const char *coded04 = "YW55IGNhcm5hbCBwbGVhc3U=";
// coded04$link1
// file url.t.c line 42
static const char *coded04$link1 = "foo%zzbar";
// coded05
// file base64.t.c line 45
static const char *coded05 = "YW55IGNhcm5hbCBwbGVhcw==";
// coded05$link1
// file url.t.c line 43
static const char *coded05$link1 = "foo%a%3Dbar";
// coded06
// file base64.t.c line 47
static const char *coded06 = "YW55=GNhcm5hbCBwbGVhcw==";
// coded07
// file base64.t.c line 48
static const char *coded07 = "YW55I=Nhcm5hbCBwbGVhcw==";
// coded08
// file base64.t.c line 49
static const char *coded08 = "YW55IG=hcm5hbCBwbGVhcw==";
// coded09
// file base64.t.c line 50
static const char *coded09 = "YW55IGN=cm5hbCBwbGVhcw==";
// coded10
// file base64.t.c line 51
static const char *coded10 = "YW55\nGNhcm5hbCBwbGVhcw==";
// coded11
// file base64.t.c line 52
static const char *coded11 = "YW55 GNhcm5hbCBwbGVhcw==";
// coded12
// file base64.t.c line 53
static const char *coded12 = "YW55-GNhcm5hbCBwbGVhcw==";
// coded13
// file base64.t.c line 54
static const char *coded13 = "YW55%GNhcm5hbCBwbGVhcw==";
// coded14
// file base64.t.c line 55
static const char *coded14 = "YW55IGNhcm5hbCBwbGVhcw=";
// coded15
// file base64.t.c line 56
static const char *coded15 = "YW55IGNhcm5hbCBwbGVhcw";
// connect_fd
// file log.c line 166
static signed int connect_fd = -1;
// connect_log
// file log.c line 165
struct logger *connect_log = (struct logger *)(void *)0;
// content_fd
// file log.c line 246
static signed int content_fd = -1;
// content_log
// file log.c line 245
struct logger *content_log = (struct logger *)(void *)0;
// dbg_mode
// file log.c line 112
static signed int dbg_mode = 0;
// dh1024_p
// file ssl.c line 456
static unsigned char dh1024_p[128l] = { (unsigned char)0x99, (unsigned char)0x28, (unsigned char)0x34, (unsigned char)0x48, (unsigned char)0x9E, (unsigned char)0xB7, (unsigned char)0xD1, (unsigned char)0x4F, (unsigned char)0x0D, (unsigned char)0x17, (unsigned char)0x09, (unsigned char)0x97, (unsigned char)0xB9, (unsigned char)0x9B, (unsigned char)0x20, (unsigned char)0xFE, (unsigned char)0xE5, (unsigned char)0x65, (unsigned char)0xE0, (unsigned char)0xE2, (unsigned char)0x56, (unsigned char)0x37, (unsigned char)0x80, (unsigned char)0xA2, (unsigned char)0x9F, (unsigned char)0x2C, (unsigned char)0x2D, (unsigned char)0x87, (unsigned char)0x10, (unsigned char)0x58, (unsigned char)0x39, (unsigned char)0xAD, (unsigned char)0xF3, (unsigned char)0xC5, (unsigned char)0xA9, (unsigned char)0x08, (unsigned char)0x24, (unsigned char)0xC7, (unsigned char)0xAA, (unsigned char)0xA9, (unsigned char)0x29, (unsigned char)0x3A, (unsigned char)0x13, (unsigned char)0xDF, (unsigned char)0x4E, (unsigned char)0x0A, (unsigned char)0x6D, (unsigned char)0x11, (unsigned char)0x39, (unsigned char)0xB1, (unsigned char)0x1C, (unsigned char)0x3F, (unsigned char)0xFE, (unsigned char)0xFE, (unsigned char)0x0A, (unsigned char)0x5E, (unsigned char)0xAD, (unsigned char)0x2E, (unsigned char)0x5C, (unsigned char)0x10, (unsigned char)0x97, (unsigned char)0x38, (unsigned char)0xAC, (unsigned char)0xE8, (unsigned char)0xEB, (unsigned char)0xAA, (unsigned char)0x4A, (unsigned char)0xA1, (unsigned char)0xC0, (unsigned char)0x5C, (unsigned char)0x1D, (unsigned char)0x27, (unsigned char)0x65, (unsigned char)0x9C, (unsigned char)0xC8, (unsigned char)0x53, (unsigned char)0xAC, (unsigned char)0x35, (unsigned char)0xDD, (unsigned char)0x84, (unsigned char)0x1F, (unsigned char)0x47, (unsigned char)0x0E, (unsigned char)0x04, (unsigned char)0xF1, (unsigned char)0x90, (unsigned char)0x61, (unsigned char)0x62, (unsigned char)0x2E, (unsigned char)0x29, (unsigned char)0x2C, (unsigned char)0xC6, (unsigned char)0x28, (unsigned char)0x91, (unsigned char)0x6D, (unsigned char)0xF0, (unsigned char)0xE2, (unsigned char)0x5E, (unsigned char)0xCE, (unsigned char)0x60, (unsigned char)0x3E, (unsigned char)0xF7, (unsigned char)0xF8, (unsigned char)0x37, (unsigned char)0x99, (unsigned char)0x4D, (unsigned char)0x9F, (unsigned char)0xFB, (unsigned char)0x68, (unsigned char)0xEC, (unsigned char)0x7F, (unsigned char)0x9D, (unsigned char)0x32, (unsigned char)0x74, (unsigned char)0xD1, (unsigned char)0xAA, (unsigned char)0xD4, (unsigned char)0x4C, (unsigned char)0xF5, (unsigned char)0xCD, (unsigned char)0xC2, (unsigned char)0xD7, (unsigned char)0xD7, (unsigned char)0xAC, (unsigned char)0xDA, (unsigned char)0x69, (unsigned char)0xF5, (unsigned char)0x2B };
// dh2048_p
// file ssl.c line 468
static unsigned char dh2048_p[256l] = { (unsigned char)0xAB, (unsigned char)0x88, (unsigned char)0x97, (unsigned char)0xCA, (unsigned char)0xF1, (unsigned char)0xE1, (unsigned char)0x60, (unsigned char)0x39, (unsigned char)0xFA, (unsigned char)0xB1, (unsigned char)0xA8, (unsigned char)0x7D, (unsigned char)0xB3, (unsigned char)0x7A, (unsigned char)0x38, (unsigned char)0x08, (unsigned char)0xF0, (unsigned char)0x7A, (unsigned char)0x3D, (unsigned char)0x21, (unsigned char)0xC4, (unsigned char)0xE6, (unsigned char)0xB8, (unsigned char)0x32, (unsigned char)0x3D, (unsigned char)0xAB, (unsigned char)0x0F, (unsigned char)0xE7, (unsigned char)0x8C, (unsigned char)0xA1, (unsigned char)0x59, (unsigned char)0x47, (unsigned char)0xB2, (unsigned char)0x0A, (unsigned char)0x7A, (unsigned char)0x3A, (unsigned char)0x20, (unsigned char)0x2A, (unsigned char)0x1B, (unsigned char)0xD4, (unsigned char)0xBA, (unsigned char)0xFC, (unsigned char)0x4C, (unsigned char)0xC5, (unsigned char)0xEE, (unsigned char)0xA2, (unsigned char)0xB9, (unsigned char)0xB9, (unsigned char)0x65, (unsigned char)0x47, (unsigned char)0xCC, (unsigned char)0x13, (unsigned char)0x99, (unsigned char)0xD7, (unsigned char)0xA6, (unsigned char)0xCA, (unsigned char)0xFF, (unsigned char)0x23, (unsigned char)0x05, (unsigned char)0x91, (unsigned char)0xAB, (unsigned char)0x5C, (unsigned char)0x82, (unsigned char)0xB8, (unsigned char)0xB4, (unsigned char)0xFD, (unsigned char)0xB1, (unsigned char)0x2E, (unsigned char)0x5B, (unsigned char)0x0F, (unsigned char)0x8E, (unsigned char)0x03, (unsigned char)0x3C, (unsigned char)0x23, (unsigned char)0xD6, (unsigned char)0x6A, (unsigned char)0xE2, (unsigned char)0x83, (unsigned char)0x95, (unsigned char)0xD2, (unsigned char)0x8E, (unsigned char)0xEB, (unsigned char)0xDF, (unsigned char)0x3A, (unsigned char)0xAF, (unsigned char)0x89, (unsigned char)0xF0, (unsigned char)0xA0, (unsigned char)0x14, (unsigned char)0x09, (unsigned char)0x12, (unsigned char)0xF6, (unsigned char)0x54, (unsigned char)0x54, (unsigned char)0x93, (unsigned char)0xF4, (unsigned char)0xD4, (unsigned char)0x41, (unsigned char)0x56, (unsigned char)0x7A, (unsigned char)0x0E, (unsigned char)0x56, (unsigned char)0x20, (unsigned char)0x1F, (unsigned char)0x1D, (unsigned char)0xBA, (unsigned char)0x3F, (unsigned char)0x07, (unsigned char)0xD2, (unsigned char)0x89, (unsigned char)0x1B, (unsigned char)0x40, (unsigned char)0xD0, (unsigned char)0x1C, (unsigned char)0x08, (unsigned char)0xDF, (unsigned char)0x00, (unsigned char)0x7F, (unsigned char)0x34, (unsigned char)0xF4, (unsigned char)0x28, (unsigned char)0x4E, (unsigned char)0xF7, (unsigned char)0x53, (unsigned char)0x8D, (unsigned char)0x4A, (unsigned char)0x00, (unsigned char)0xC3, (unsigned char)0xC0, (unsigned char)0x89, (unsigned char)0x9E, (unsigned char)0x63, (unsigned char)0x96, (unsigned char)0xE9, (unsigned char)0x52, (unsigned char)0xDF, (unsigned char)0xA5, (unsigned char)0x2C, (unsigned char)0x00, (unsigned char)0x4E, (unsigned char)0xB0, (unsigned char)0x82, (unsigned char)0x6A, (unsigned char)0x10, (unsigned char)0x28, (unsigned char)0x8D, (unsigned char)0xB9, (unsigned char)0xE7, (unsigned char)0x7A, (unsigned char)0xCB, (unsigned char)0xC3, (unsigned char)0xD6, (unsigned char)0xC1, (unsigned char)0xC0, (unsigned char)0x4D, (unsigned char)0x91, (unsigned char)0xC4, (unsigned char)0x6F, (unsigned char)0xD3, (unsigned char)0x99, (unsigned char)0xD1, (unsigned char)0x86, (unsigned char)0x71, (unsigned char)0x67, (unsigned char)0x0A, (unsigned char)0xA1, (unsigned char)0xFC, (unsigned char)0xF4, (unsigned char)0x7D, (unsigned char)0x40, (unsigned char)0x88, (unsigned char)0x8D, (unsigned char)0xAC, (unsigned char)0xCB, (unsigned char)0xBC, (unsigned char)0xEA, (unsigned char)0x17, (unsigned char)0x85, (unsigned char)0x0B, (unsigned char)0xC6, (unsigned char)0x12, (unsigned char)0x3E, (unsigned char)0x4A, (unsigned char)0xB9, (unsigned char)0x60, (unsigned char)0x74, (unsigned char)0x93, (unsigned char)0x54, (unsigned char)0x14, (unsigned char)0x39, (unsigned char)0x10, (unsigned char)0xBF, (unsigned char)0x21, (unsigned char)0xB0, (unsigned char)0x8B, (unsigned char)0xB1, (unsigned char)0x55, (unsigned char)0x3F, (unsigned char)0xBB, (unsigned char)0x6A, (unsigned char)0x1F, (unsigned char)0x42, (unsigned char)0x82, (unsigned char)0x0A, (unsigned char)0x40, (unsigned char)0x3A, (unsigned char)0x15, (unsigned char)0xCD, (unsigned char)0xD3, (unsigned char)0x79, (unsigned char)0xD0, (unsigned char)0x02, (unsigned char)0xA4, (unsigned char)0xF5, (unsigned char)0x79, (unsigned char)0x78, (unsigned char)0x03, (unsigned char)0xBD, (unsigned char)0x47, (unsigned char)0xCC, (unsigned char)0xD5, (unsigned char)0x08, (unsigned char)0x6A, (unsigned char)0x46, (unsigned char)0xAE, (unsigned char)0x36, (unsigned char)0xE4, (unsigned char)0xCD, (unsigned char)0xB1, (unsigned char)0x17, (unsigned char)0x48, (unsigned char)0x30, (unsigned char)0xB4, (unsigned char)0x02, (unsigned char)0xBC, (unsigned char)0x50, (unsigned char)0x68, (unsigned char)0xE3, (unsigned char)0xA2, (unsigned char)0x76, (unsigned char)0xD0, (unsigned char)0x5C, (unsigned char)0xB9, (unsigned char)0xE6, (unsigned char)0xBE, (unsigned char)0x4C, (unsigned char)0xFD, (unsigned char)0x50, (unsigned char)0xEF, (unsigned char)0xD0, (unsigned char)0x3F, (unsigned char)0x39, (unsigned char)0x4F, (unsigned char)0x53, (unsigned char)0x16, (unsigned char)0x3B };
// dh4096_p
// file ssl.c line 491
static unsigned char dh4096_p[512l] = { (unsigned char)0xB1, (unsigned char)0xCC, (unsigned char)0x09, (unsigned char)0x86, (unsigned char)0xEE, (unsigned char)0xF9, (unsigned char)0xB9, (unsigned char)0xC9, (unsigned char)0xB9, (unsigned char)0x87, (unsigned char)0xC4, (unsigned char)0xB9, (unsigned char)0xD7, (unsigned char)0x31, (unsigned char)0x95, (unsigned char)0x84, (unsigned char)0x94, (unsigned char)0x65, (unsigned char)0xED, (unsigned char)0x82, (unsigned char)0x64, (unsigned char)0x11, (unsigned char)0xA7, (unsigned char)0x0A, (unsigned char)0xFE, (unsigned char)0xC2, (unsigned char)0x60, (unsigned char)0xAE, (unsigned char)0x7C, (unsigned char)0x74, (unsigned char)0xFB, (unsigned char)0x72, (unsigned char)0x8F, (unsigned char)0x0D, (unsigned char)0xA6, (unsigned char)0xDD, (unsigned char)0x02, (unsigned char)0x49, (unsigned char)0x5B, (unsigned char)0x69, (unsigned char)0xD6, (unsigned char)0x96, (unsigned char)0x05, (unsigned char)0xBE, (unsigned char)0x5E, (unsigned char)0x9B, (unsigned char)0x09, (unsigned char)0x83, (unsigned char)0xD8, (unsigned char)0xF3, (unsigned char)0x91, (unsigned char)0x55, (unsigned char)0x30, (unsigned char)0x86, (unsigned char)0x97, (unsigned char)0x6C, (unsigned char)0x48, (unsigned char)0x7B, (unsigned char)0x99, (unsigned char)0x82, (unsigned char)0xCC, (unsigned char)0x1E, (unsigned char)0x1E, (unsigned char)0x25, (unsigned char)0xE6, (unsigned char)0x25, (unsigned char)0xCC, (unsigned char)0xA3, (unsigned char)0x66, (unsigned char)0xDE, (unsigned char)0x8A, (unsigned char)0x78, (unsigned char)0xEE, (unsigned char)0x7F, (unsigned char)0x4F, (unsigned char)0x86, (unsigned char)0x95, (unsigned char)0x06, (unsigned char)0xBE, (unsigned char)0x64, (unsigned char)0x86, (unsigned char)0xFD, (unsigned char)0x60, (unsigned char)0x6A, (unsigned char)0x3F, (unsigned char)0x0D, (unsigned char)0x8F, (unsigned char)0x62, (unsigned char)0x17, (unsigned char)0x89, (unsigned char)0xDB, (unsigned char)0xE1, (unsigned char)0x01, (unsigned char)0xC1, (unsigned char)0x75, (unsigned char)0x3A, (unsigned char)0x78, (unsigned char)0x42, (unsigned char)0xA8, (unsigned char)0x26, (unsigned char)0xEC, (unsigned char)0x00, (unsigned char)0x78, (unsigned char)0xF3, (unsigned char)0xDA, (unsigned char)0x40, (unsigned char)0x8D, (unsigned char)0x0D, (unsigned char)0x4D, (unsigned char)0x53, (unsigned char)0x82, (unsigned char)0xD7, (unsigned char)0x21, (unsigned char)0xC8, (unsigned char)0x46, (unsigned char)0xC9, (unsigned char)0xE3, (unsigned char)0x80, (unsigned char)0xB4, (unsigned char)0xCF, (unsigned char)0xEA, (unsigned char)0x46, (unsigned char)0x85, (unsigned char)0xE9, (unsigned char)0xC4, (unsigned char)0x9D, (unsigned char)0xD0, (unsigned char)0xC0, (unsigned char)0x4D, (unsigned char)0x27, (unsigned char)0x0F, (unsigned char)0xF8, (unsigned char)0x34, (unsigned char)0x3B, (unsigned char)0x86, (unsigned char)0x8F, (unsigned char)0xFC, (unsigned char)0x40, (unsigned char)0x56, (unsigned char)0x49, (unsigned char)0x64, (unsigned char)0x76, (unsigned char)0x61, (unsigned char)0xBC, (unsigned char)0x35, (unsigned char)0x6A, (unsigned char)0xB8, (unsigned char)0xC5, (unsigned char)0x32, (unsigned char)0x19, (unsigned char)0x00, (unsigned char)0x5E, (unsigned char)0x21, (unsigned char)0x1C, (unsigned char)0x34, (unsigned char)0xCB, (unsigned char)0x74, (unsigned char)0x5B, (unsigned char)0x60, (unsigned char)0x85, (unsigned char)0x8C, (unsigned char)0x38, (unsigned char)0x52, (unsigned char)0x50, (unsigned char)0x4D, (unsigned char)0xAA, (unsigned char)0x25, (unsigned char)0xE4, (unsigned char)0x1A, (unsigned char)0xE6, (unsigned char)0xE4, (unsigned char)0xDF, (unsigned char)0x0A, (unsigned char)0xD2, (unsigned char)0x8F, (unsigned char)0x2B, (unsigned char)0xD1, (unsigned char)0x35, (unsigned char)0xC7, (unsigned char)0x92, (unsigned char)0x7D, (unsigned char)0x6F, (unsigned char)0x54, (unsigned char)0x61, (unsigned char)0x8E, (unsigned char)0x3F, (unsigned char)0xFB, (unsigned char)0xE2, (unsigned char)0xC8, (unsigned char)0x81, (unsigned char)0xD0, (unsigned char)0xAC, (unsigned char)0x64, (unsigned char)0xE2, (unsigned char)0xA8, (unsigned char)0x30, (unsigned char)0xEA, (unsigned char)0x8E, (unsigned char)0xAD, (unsigned char)0xFE, (unsigned char)0xC0, (unsigned char)0x9E, (unsigned char)0x0B, (unsigned char)0xBF, (unsigned char)0x34, (unsigned char)0xAC, (unsigned char)0x79, (unsigned char)0x96, (unsigned char)0x38, (unsigned char)0x31, (unsigned char)0x1E, (unsigned char)0xEA, (unsigned char)0xF2, (unsigned char)0x7E, (unsigned char)0xEE, (unsigned char)0x0A, (unsigned char)0x10, (unsigned char)0x34, (unsigned char)0x7C, (unsigned char)0x1A, (unsigned char)0x30, (unsigned char)0x5F, (unsigned char)0xAF, (unsigned char)0x96, (unsigned char)0x2F, (unsigned char)0x7F, (unsigned char)0xB5, (unsigned char)0x1D, (unsigned char)0xA7, (unsigned char)0x3D, (unsigned char)0x35, (unsigned char)0x7A, (unsigned char)0x30, (unsigned char)0x70, (unsigned char)0x40, (unsigned char)0xE7, (unsigned char)0xD6, (unsigned char)0x22, (unsigned char)0x1E, (unsigned char)0xD0, (unsigned char)0x9A, (unsigned char)0x34, (unsigned char)0xC7, (unsigned char)0x6B, (unsigned char)0xE4, (unsigned char)0xF1, (unsigned char)0x78, (unsigned char)0xED, (unsigned char)0xD9, (unsigned char)0xCD, (unsigned char)0x18, (unsigned char)0xBF, (unsigned char)0x2A, (unsigned char)0x1A, (unsigned char)0x98, (unsigned char)0xB7, (unsigned char)0x6C, (unsigned char)0x6E, (unsigned char)0x18, (unsigned char)0x40, (unsigned char)0xB5, (unsigned char)0xBE, (unsigned char)0xDF, (unsigned char)0xE4, (unsigned char)0x78, (unsigned char)0x8E, (unsigned char)0x34, (unsigned char)0xB2, (unsigned char)0x7B, (unsigned char)0xE5, (unsigned char)0x88, (unsigned char)0xE6, (unsigned char)0xFD, (unsigned char)0x24, (unsigned char)0xBD, (unsigned char)0xBB, (unsigned char)0x2E, (unsigned char)0x30, (unsigned char)0x72, (unsigned char)0x54, (unsigned char)0xC7, (unsigned char)0xF4, (unsigned char)0xA0, (unsigned char)0xF1, (unsigned char)0x25, (unsigned char)0xFF, (unsigned char)0xB1, (unsigned char)0x37, (unsigned char)0x42, (unsigned char)0x07, (unsigned char)0x8C, (unsigned char)0xF2, (unsigned char)0xB9, (unsigned char)0xA1, (unsigned char)0xA4, (unsigned char)0xA7, (unsigned char)0x76, (unsigned char)0x39, (unsigned char)0xB8, (unsigned char)0x11, (unsigned char)0x17, (unsigned char)0xF3, (unsigned char)0xA8, (unsigned char)0x2E, (unsigned char)0x78, (unsigned char)0x68, (unsigned char)0xF4, (unsigned char)0xBF, (unsigned char)0x98, (unsigned char)0x25, (unsigned char)0x59, (unsigned char)0x17, (unsigned char)0x59, (unsigned char)0x9B, (unsigned char)0x0D, (unsigned char)0x0B, (unsigned char)0x9B, (unsigned char)0xE3, (unsigned char)0x0F, (unsigned char)0xFF, (unsigned char)0xDC, (unsigned char)0xC8, (unsigned char)0x47, (unsigned char)0x21, (unsigned char)0xE1, (unsigned char)0x0B, (unsigned char)0x9A, (unsigned char)0x44, (unsigned char)0x79, (unsigned char)0xC7, (unsigned char)0x5F, (unsigned char)0x8E, (unsigned char)0x83, (unsigned char)0x1E, (unsigned char)0x04, (unsigned char)0xA1, (unsigned char)0xB2, (unsigned char)0x9F, (unsigned char)0x9B, (unsigned char)0xFC, (unsigned char)0xB3, (unsigned char)0x4E, (unsigned char)0xD9, (unsigned char)0xF9, (unsigned char)0x8F, (unsigned char)0x03, (unsigned char)0xBC, (unsigned char)0x0A, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x5C, (unsigned char)0x59, (unsigned char)0xB7, (unsigned char)0x51, (unsigned char)0xAA, (unsigned char)0x75, (unsigned char)0xF8, (unsigned char)0x7A, (unsigned char)0x03, (unsigned char)0x07, (unsigned char)0x81, (unsigned char)0x6D, (unsigned char)0x67, (unsigned char)0x3E, (unsigned char)0x28, (unsigned char)0x37, (unsigned char)0xE4, (unsigned char)0x74, (unsigned char)0x5B, (unsigned char)0x8C, (unsigned char)0x2A, (unsigned char)0x4B, (unsigned char)0x6C, (unsigned char)0x10, (unsigned char)0x92, (unsigned char)0x75, (unsigned char)0xA5, (unsigned char)0x79, (unsigned char)0x4B, (unsigned char)0x6D, (unsigned char)0x30, (unsigned char)0xB7, (unsigned char)0x6E, (unsigned char)0xD6, (unsigned char)0x9E, (unsigned char)0x16, (unsigned char)0xC2, (unsigned char)0x87, (unsigned char)0x69, (unsigned char)0x34, (unsigned char)0xFE, (unsigned char)0xD7, (unsigned char)0x2A, (unsigned char)0x4F, (unsigned char)0xD6, (unsigned char)0xC0, (unsigned char)0xF3, (unsigned char)0xCD, (unsigned char)0x9C, (unsigned char)0x46, (unsigned char)0xED, (unsigned char)0xC0, (unsigned char)0xB2, (unsigned char)0x84, (unsigned char)0x8D, (unsigned char)0x7E, (unsigned char)0x93, (unsigned char)0xD2, (unsigned char)0xE9, (unsigned char)0xBE, (unsigned char)0x59, (unsigned char)0x18, (unsigned char)0x92, (unsigned char)0xC1, (unsigned char)0x2C, (unsigned char)0xD6, (unsigned char)0x6C, (unsigned char)0x71, (unsigned char)0x50, (unsigned char)0xA1, (unsigned char)0x98, (unsigned char)0xDA, (unsigned char)0xD1, (unsigned char)0xAC, (unsigned char)0xDB, (unsigned char)0x88, (unsigned char)0x40, (unsigned char)0x1F, (unsigned char)0x69, (unsigned char)0xDC, (unsigned char)0xDB, (unsigned char)0xB2, (unsigned char)0xA0, (unsigned char)0x90, (unsigned char)0x01, (unsigned char)0x8E, (unsigned char)0x12, (unsigned char)0xD6, (unsigned char)0x40, (unsigned char)0x1A, (unsigned char)0x8E, (unsigned char)0xC5, (unsigned char)0x69, (unsigned char)0x9C, (unsigned char)0x91, (unsigned char)0x67, (unsigned char)0xAC, (unsigned char)0xD8, (unsigned char)0x4C, (unsigned char)0x27, (unsigned char)0xCD, (unsigned char)0x08, (unsigned char)0xB8, (unsigned char)0x32, (unsigned char)0x97, (unsigned char)0xE1, (unsigned char)0x13, (unsigned char)0x0C, (unsigned char)0xFF, (unsigned char)0xB1, (unsigned char)0x06, (unsigned char)0x65, (unsigned char)0x03, (unsigned char)0x98, (unsigned char)0x6F, (unsigned char)0x9E, (unsigned char)0xF7, (unsigned char)0xB8, (unsigned char)0xA8, (unsigned char)0x75, (unsigned char)0xBA, (unsigned char)0x59, (unsigned char)0xFD, (unsigned char)0x23, (unsigned char)0x98, (unsigned char)0x94, (unsigned char)0x80, (unsigned char)0x9C, (unsigned char)0xA7, (unsigned char)0x46, (unsigned char)0x32, (unsigned char)0x98, (unsigned char)0x28, (unsigned char)0x7A, (unsigned char)0x0A, (unsigned char)0x3A, (unsigned char)0xA6, (unsigned char)0x95, (unsigned char)0x16, (unsigned char)0x6A, (unsigned char)0x52, (unsigned char)0x8E, (unsigned char)0x8F, (unsigned char)0x2C, (unsigned char)0xC9, (unsigned char)0x49, (unsigned char)0xB7, (unsigned char)0x59, (unsigned char)0x99, (unsigned char)0x2A, (unsigned char)0xE6, (unsigned char)0xCA, (unsigned char)0x82, (unsigned char)0x88, (unsigned char)0x36, (unsigned char)0xD3, (unsigned char)0x2B, (unsigned char)0xA4, (unsigned char)0x73, (unsigned char)0xFA, (unsigned char)0x89, (unsigned char)0xBB };
// dh512_p
// file ssl.c line 449
static unsigned char dh512_p[64l] = { (unsigned char)0xAB, (unsigned char)0xC0, (unsigned char)0x34, (unsigned char)0x16, (unsigned char)0x95, (unsigned char)0x8B, (unsigned char)0x57, (unsigned char)0xE5, (unsigned char)0x5C, (unsigned char)0xB3, (unsigned char)0x4E, (unsigned char)0x6E, (unsigned char)0x16, (unsigned char)0x0B, (unsigned char)0x35, (unsigned char)0xC5, (unsigned char)0x6A, (unsigned char)0xCC, (unsigned char)0x4F, (unsigned char)0xD3, (unsigned char)0xE5, (unsigned char)0x46, (unsigned char)0xE2, (unsigned char)0x23, (unsigned char)0x6A, (unsigned char)0x5B, (unsigned char)0xBB, (unsigned char)0x5D, (unsigned char)0x3D, (unsigned char)0x52, (unsigned char)0xEA, (unsigned char)0xCE, (unsigned char)0x4F, (unsigned char)0x7D, (unsigned char)0xCA, (unsigned char)0xFF, (unsigned char)0xB4, (unsigned char)0x8B, (unsigned char)0xC9, (unsigned char)0x78, (unsigned char)0xDC, (unsigned char)0xA0, (unsigned char)0xFC, (unsigned char)0xBE, (unsigned char)0xF3, (unsigned char)0xB5, (unsigned char)0xE6, (unsigned char)0x61, (unsigned char)0xA6, (unsigned char)0x6D, (unsigned char)0x58, (unsigned char)0xFC, (unsigned char)0xA0, (unsigned char)0x0F, (unsigned char)0xF7, (unsigned char)0x9B, (unsigned char)0x97, (unsigned char)0xE6, (unsigned char)0xC7, (unsigned char)0xE8, (unsigned char)0x1F, (unsigned char)0xCD, (unsigned char)0x16, (unsigned char)0x73 };
// dh_g
// file ssl.c line 448
static unsigned char dh_g[1l] = { (unsigned char)0x02 };
// dir
// file sys.t.c line 45
static char *dir;
// dstsessmap
// file cachedsess.c line 71
static struct anonymous$9 *dstsessmap;
// engines
// file nat.c line 411
struct engine engines[3l];
// engines
// file nat.c line 411
struct engine engines[3l] = { { .name="netfilter", .ipv6=0, .used=0, .preinitcb=(signed int (*)(void))(void *)0, .initcb=(signed int (*)(void))(void *)0,
    .finicb=(void (*)(void))(void *)0,
    .lookupcb=nat_netfilter_lookup_cb, .socketcb=(signed int (*)(signed int))(void *)0 },
    { .name="tproxy", .ipv6=1, .used=0, .preinitcb=(signed int (*)(void))(void *)0, .initcb=(signed int (*)(void))(void *)0,
    .finicb=(void (*)(void))(void *)0,
    .lookupcb=nat_getsockname_lookup_cb, .socketcb=nat_iptransparent_socket_cb },
    { .name=(const char *)(void *)0, .ipv6=0, .used=0,
    .preinitcb=(signed int (*)(void))(void *)0, .initcb=(signed int (*)(void))(void *)0,
    .finicb=(void (*)(void))(void *)0,
    .lookupcb=(signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))(void *)0, .socketcb=(signed int (*)(signed int))(void *)0 } };
// err_log
// file log.c line 60
static struct logger *err_log = (struct logger *)(void *)0;
// err_mode
// file log.c line 62
static signed int err_mode = 0;
// err_started
// file log.c line 61
static signed int err_started = 0;
// features
// file version.c line 38
const char *features = "-DHAVE_NETFILTER";
// file
// file sys.t.c line 45
static char *file;
// ldir
// file sys.t.c line 45
static char *ldir;
// lfile
// file sys.t.c line 45
static char *lfile;
// name1
// file ssl.t.c line 60
static char name1[16l] = { 'w', 'w', 'w', '.', 'e', 'x', 'a', 'm', 'p', 'l', 'e', '.', 'o', 'r', 'g', 0 };
// name10
// file ssl.t.c line 69
static char name10[23l] = { 'x', 'n', '-', '-', 'r', '-', '1', 'g', 'a', '.', 'x', 'n', '-', '-', 'r', '-', '1', 'g', 'a', '.', 'c', 'h', 0 };
// name11
// file ssl.t.c line 70
static char name11[1l] = { 0 };
// name2
// file ssl.t.c line 61
static char name2[16l] = { 'w', 'w', 'w', '.', 'e', 'x', 'a', 'm', 'p', 'l', 'e', '.', 'c', 'o', 'm', 0 };
// name3
// file ssl.t.c line 62
static char name3[12l] = { 'e', 'x', 'a', 'm', 'p', 'l', 'e', '.', 'o', 'r', 'g', 0 };
// name4
// file ssl.t.c line 63
static char name4[22l] = { 'w', 'w', 'w', '.', 'e', 'x', 'a', 'm', 'p', 'l', 'e', '.', 'o', 'r', 'g', '.', 'c', 'o', '.', 'u', 'k', 0 };
// name5
// file ssl.t.c line 64
static char name5[21l] = { 't', 'e', 's', 't', '.', 'w', 'w', 'w', '.', 'e', 'x', 'a', 'm', 'p', 'l', 'e', '.', 'o', 'r', 'g', 0 };
// name6
// file ssl.t.c line 65
static char name6[21l] = { 'w', 'w', 'w', '.', 't', 'e', 's', 't', '.', 'e', 'x', 'a', 'm', 'p', 'l', 'e', '.', 'o', 'r', 'g', 0 };
// name7
// file ssl.t.c line 66
static char name7[20l] = { 'w', 'w', 'w', 't', 'e', 's', 't', '.', 'e', 'x', 'a', 'm', 'p', 'l', 'e', '.', 'o', 'r', 'g', 0 };
// name8
// file ssl.t.c line 67
static char name8[3l] = { 'c', 'h', 0 };
// name9
// file ssl.t.c line 68
static char name9[17l] = { 'w', 'w', 'w', '.', 'x', 'n', '-', '-', 'r', '-', '1', 'g', 'a', '.', 'c', 'h', 0 };
// notexist
// file sys.t.c line 45
static char *notexist;
// ocspreq01
// file ssl.t.c line 535
static char ocspreq01[93l] = { 'M', 'E', 'I', 'w', 'Q', 'D', 'A', '+', 'M', 'D', 'w', 'w', 'O', 'j', 'A', 'J', 'B', 'g', 'U', 'r', 'D', 'g', 'M', 'C', 'G', 'g', 'U', 'A', 'B', 'B', 'T', '4', 'c', 'y', 'A', 'B', 'k', 'y', 'i', 'C', 'I', 'h', 'U', '4', 'J', 'p', 'm', 'I', 'B', 'e', 'w', 'd', 'D', 'n', 'n', '8', 'Z', 'g', 'Q', 'U', 'b', 'y', 'B', 'Z', '4', '4', 'k', 'g', 'y', '3', '5', 'o', '7', 'x', 'W', '5', 'B', 'M', 'z', 'M', '8', 'F', 'T', 'v', 'y', 'T', 'w', 'C', 'A', 'Q', 'E', '=', 0 };
// plain01
// file base64.t.c line 35
static const char *plain01 = "any carnal pleasure.";
// plain01$link1
// file url.t.c line 35
static const char *plain01$link1 = "===1234===";
// plain02
// file base64.t.c line 36
static const char *plain02 = "any carnal pleasure";
// plain02$link1
// file url.t.c line 36
static const char *plain02$link1 = "\0\001\177";
// plain03
// file base64.t.c line 37
static const char *plain03 = "any carnal pleasur";
// plain04
// file base64.t.c line 38
static const char *plain04 = "any carnal pleasu";
// plain05
// file base64.t.c line 39
static const char *plain05 = "any carnal pleas";
// signals
// file proxy.c line 59
static signed int signals[4l] = { 3, 1, 2, 13 };
// sni
// file cachedsess.t.c line 58
static char sni[14l] = { 'd', 'a', 'n', 'i', 'e', 'l', '.', 'r', 'o', 'e', '.', 'c', 'h', 0 };
// srcsessmap
// file cachessess.c line 69
static struct anonymous$9 *srcsessmap;
// ssl_initialized
// file ssl.c line 205
static signed int ssl_initialized = 0;
// ssl_mutex
// file ssl.c line 211
static union anonymous$10 *ssl_mutex;
// ssl_mutex_num
// file ssl.c line 212
static signed int ssl_mutex_num;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// string01
// file util.t.c line 35
static const char *string01 = "test";
// string02
// file util.t.c line 36
static const char *string02 = "    test";
// string03
// file util.t.c line 37
static const char *string03 = "\t\t\t\ttest";
// string04
// file util.t.c line 38
static const char *string04 = "\t \t test";
// string05
// file util.t.c line 39
static const char *string05 = "    \r\ntest";
// sz
// file dynbuf.t.c line 39
static unsigned long int sz;
// template
// file dynbuf.t.c line 37
static const unsigned char template[13l] = { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!', 0 };
// template$link1
// file sys.t.c line 43
static char template$link1[26l] = { '/', 't', 'm', 'p', '/', 's', 's', 'l', 's', 'p', 'l', 'i', 't', '.', 't', 'e', 's', 't', '.', 'X', 'X', 'X', 'X', 'X', 'X', 0 };
// version
// file version.c line 35
const char *version = "0.4.11";
// wildcard1
// file ssl.t.c line 52
static char wildcard1[14l] = { '*', '.', 'e', 'x', 'a', 'm', 'p', 'l', 'e', '.', 'o', 'r', 'g', 0 };
// wildcard2
// file ssl.t.c line 53
static char wildcard2[18l] = { 'w', 'w', 'w', '.', '*', '.', 'e', 'x', 'a', 'm', 'p', 'l', 'e', '.', 'o', 'r', 'g', 0 };
// wildcard3
// file ssl.t.c line 54
static char wildcard3[8l] = { '*', '.', '*', '.', 'o', 'r', 'g', 0 };
// wildcard4
// file ssl.t.c line 55
static char wildcard4[17l] = { 'w', 'w', 'w', '*', '.', 'e', 'x', 'a', 'm', 'p', 'l', 'e', '.', 'o', 'r', 'g', 0 };
// wildcard5
// file ssl.t.c line 56
static char wildcard5[2l] = { '*', 0 };
// wildcard6
// file ssl.t.c line 57
static char wildcard6[15l] = { '*', '.', 'x', 'n', '-', '-', 'r', '-', '1', 'g', 'a', '.', 'c', 'h', 0 };
// wildcard7
// file ssl.t.c line 58
static char wildcard7[24l] = { 'x', 'n', '-', '-', 'r', '-', '1', 'g', 'a', '*', '.', 'x', 'n', '-', '-', 'r', '-', '1', 'g', 'a', '.', 'c', 'h', 0 };
// wildcard8
// file ssl.t.c line 59
static char wildcard8[25l] = { 'x', 'n', '-', '-', 'r', '-', '1', 'g', 'a', '.', '*', '.', 'x', 'n', '-', '-', 'r', '-', '1', 'g', 'a', '.', 'c', 'h', 0 };

// __ac_X31_hash_string
// file khash.h line 387
static inline unsigned int __ac_X31_hash_string(const char *s)
{
  unsigned int h = (unsigned int)*s;
  if(!(h == 0u))
  {
    s = s + 1l;
    for( ; !(*s == 0); s = s + 1l)
      h = ((h << 5) - h) + (unsigned int)*s;
  }

  return h;
}

// base64_dec
// file base64.h line 36
unsigned char * base64_dec(const char *in, unsigned long int insz, unsigned long int *outsz)
{
  unsigned long int i;
  unsigned long int o;
  signed int tmp;
  signed int digit;
  unsigned char *out;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!(insz % 4ul == 0ul))
    return (unsigned char *)(void *)0;

  else
  {
    if(insz == 0ul)
    {
      *outsz = (unsigned long int)0;
      char *return_value_strdup$1;
      return_value_strdup$1=strdup("");
      return (unsigned char *)return_value_strdup$1;
    }

    if((signed int)in[-2l + (signed long int)insz] == 61)
      *outsz = (insz / (unsigned long int)4) * (unsigned long int)3 - (unsigned long int)2;

    else
      if((signed int)in[-1l + (signed long int)insz] == 61)
        *outsz = (insz / (unsigned long int)4) * (unsigned long int)3 - (unsigned long int)1;

      else
        *outsz = (insz / (unsigned long int)4) * (unsigned long int)3;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(*outsz + (unsigned long int)1);
    out = (unsigned char *)return_value_malloc$2;
    if(out == ((unsigned char *)NULL))
    {
      *outsz = (unsigned long int)0;
      return (unsigned char *)(void *)0;
    }

    else
    {
      i = (unsigned long int)0;
      o = (unsigned long int)0;
      for( ; !(i >= insz); o = o + (unsigned long int)3)
      {
        static const signed int revalphabet[256l] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
        digit = revalphabet[(signed long int)(unsigned char)in[(signed long int)i]];
        if(digit == -1)
          goto leave;

        tmp = digit << 18;
        digit = revalphabet[(signed long int)(unsigned char)in[(signed long int)(i + (unsigned long int)1)]];
        if(digit == -1)
          goto leave;

        tmp = tmp + (digit << 12);
        digit = revalphabet[(signed long int)(unsigned char)in[(signed long int)(i + (unsigned long int)2)]];
        if(digit == -1)
        {
          if(i == insz + 18446744073709551612ul)
            tmp_if_expr$3 = (signed int)in[(signed long int)(i + (unsigned long int)2)] == 61 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
            digit = 0;

          else
            goto leave;
        }

        tmp = tmp + (digit << 6);
        digit = revalphabet[(signed long int)(unsigned char)in[(signed long int)(i + (unsigned long int)3)]];
        if(digit == -1)
        {
          if(i == insz + 18446744073709551612ul)
            tmp_if_expr$4 = (signed int)in[(signed long int)(i + (unsigned long int)3)] == 61 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
            digit = 0;

          else
            goto leave;
        }

        tmp = tmp + digit;
        out[(signed long int)o] = (unsigned char)(tmp >> 16 & 0xff);
        if(!(1ul + o >= *outsz))
          out[(signed long int)(o + (unsigned long int)1)] = (unsigned char)(tmp >> 8 & 0xff);

        if(!(2ul + o >= *outsz))
          out[(signed long int)(o + (unsigned long int)2)] = (unsigned char)(tmp & 0xff);

        i = i + (unsigned long int)4;
      }
      out[(signed long int)*outsz] = (unsigned char)0;
      return out;

    leave:
      ;
      free((void *)out);
      return (unsigned char *)(void *)0;
    }
  }
}

// base64_dec_01
// file base64.t.c line 136
static void base64_dec_01(signed int _i)
{
  tcase_fn_start("base64_dec_01", "base64.t.c", 136);
  unsigned char *base64_dec_01$$1$$1$$buf;
  unsigned long int base64_dec_01$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded01);
  base64_dec_01$$1$$1$$buf=base64_dec(coded01, return_value_strlen$1, &base64_dec_01$$1$$1$$sz);
  if(!(base64_dec_01$$1$$1$$buf == ((unsigned char *)NULL)))
    _mark_point("base64.t.c", 142);

  else
    _ck_assert_failed("base64.t.c", 142, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(plain01);
  if(base64_dec_01$$1$$1$$sz == return_value_strlen$2)
    _mark_point("base64.t.c", 143);

  else
    _ck_assert_failed("base64.t.c", 143, "Assertion 'sz == strlen(plain01)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)plain01, (const void *)base64_dec_01$$1$$1$$buf, base64_dec_01$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("base64.t.c", 144);

  else
    _ck_assert_failed("base64.t.c", 144, "Assertion '!memcmp(plain01, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)base64_dec_01$$1$$1$$buf);
}

// base64_dec_02
// file base64.t.c line 149
static void base64_dec_02(signed int _i)
{
  tcase_fn_start("base64_dec_02", "base64.t.c", 149);
  unsigned char *base64_dec_02$$1$$1$$buf;
  unsigned long int base64_dec_02$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded02);
  base64_dec_02$$1$$1$$buf=base64_dec(coded02, return_value_strlen$1, &base64_dec_02$$1$$1$$sz);
  if(!(base64_dec_02$$1$$1$$buf == ((unsigned char *)NULL)))
    _mark_point("base64.t.c", 155);

  else
    _ck_assert_failed("base64.t.c", 155, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(plain02);
  if(base64_dec_02$$1$$1$$sz == return_value_strlen$2)
    _mark_point("base64.t.c", 156);

  else
    _ck_assert_failed("base64.t.c", 156, "Assertion 'sz == strlen(plain02)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)plain02, (const void *)base64_dec_02$$1$$1$$buf, base64_dec_02$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("base64.t.c", 157);

  else
    _ck_assert_failed("base64.t.c", 157, "Assertion '!memcmp(plain02, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)base64_dec_02$$1$$1$$buf);
}

// base64_dec_03
// file base64.t.c line 162
static void base64_dec_03(signed int _i)
{
  tcase_fn_start("base64_dec_03", "base64.t.c", 162);
  unsigned char *base64_dec_03$$1$$1$$buf;
  unsigned long int base64_dec_03$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded03);
  base64_dec_03$$1$$1$$buf=base64_dec(coded03, return_value_strlen$1, &base64_dec_03$$1$$1$$sz);
  if(!(base64_dec_03$$1$$1$$buf == ((unsigned char *)NULL)))
    _mark_point("base64.t.c", 168);

  else
    _ck_assert_failed("base64.t.c", 168, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(plain03);
  if(base64_dec_03$$1$$1$$sz == return_value_strlen$2)
    _mark_point("base64.t.c", 169);

  else
    _ck_assert_failed("base64.t.c", 169, "Assertion 'sz == strlen(plain03)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)plain03, (const void *)base64_dec_03$$1$$1$$buf, base64_dec_03$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("base64.t.c", 170);

  else
    _ck_assert_failed("base64.t.c", 170, "Assertion '!memcmp(plain03, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)base64_dec_03$$1$$1$$buf);
}

// base64_dec_04
// file base64.t.c line 175
static void base64_dec_04(signed int _i)
{
  tcase_fn_start("base64_dec_04", "base64.t.c", 175);
  unsigned char *base64_dec_04$$1$$1$$buf;
  unsigned long int base64_dec_04$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded04);
  base64_dec_04$$1$$1$$buf=base64_dec(coded04, return_value_strlen$1, &base64_dec_04$$1$$1$$sz);
  if(!(base64_dec_04$$1$$1$$buf == ((unsigned char *)NULL)))
    _mark_point("base64.t.c", 181);

  else
    _ck_assert_failed("base64.t.c", 181, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(plain04);
  if(base64_dec_04$$1$$1$$sz == return_value_strlen$2)
    _mark_point("base64.t.c", 182);

  else
    _ck_assert_failed("base64.t.c", 182, "Assertion 'sz == strlen(plain04)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)plain04, (const void *)base64_dec_04$$1$$1$$buf, base64_dec_04$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("base64.t.c", 183);

  else
    _ck_assert_failed("base64.t.c", 183, "Assertion '!memcmp(plain04, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)base64_dec_04$$1$$1$$buf);
}

// base64_dec_05
// file base64.t.c line 188
static void base64_dec_05(signed int _i)
{
  tcase_fn_start("base64_dec_05", "base64.t.c", 188);
  unsigned char *base64_dec_05$$1$$1$$buf;
  unsigned long int base64_dec_05$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded05);
  base64_dec_05$$1$$1$$buf=base64_dec(coded05, return_value_strlen$1, &base64_dec_05$$1$$1$$sz);
  if(!(base64_dec_05$$1$$1$$buf == ((unsigned char *)NULL)))
    _mark_point("base64.t.c", 194);

  else
    _ck_assert_failed("base64.t.c", 194, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(plain05);
  if(base64_dec_05$$1$$1$$sz == return_value_strlen$2)
    _mark_point("base64.t.c", 195);

  else
    _ck_assert_failed("base64.t.c", 195, "Assertion 'sz == strlen(plain05)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)plain05, (const void *)base64_dec_05$$1$$1$$buf, base64_dec_05$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("base64.t.c", 196);

  else
    _ck_assert_failed("base64.t.c", 196, "Assertion '!memcmp(plain05, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)base64_dec_05$$1$$1$$buf);
}

// base64_dec_06
// file base64.t.c line 201
static void base64_dec_06(signed int _i)
{
  tcase_fn_start("base64_dec_06", "base64.t.c", 201);
  unsigned char *base64_dec_06$$1$$1$$buf;
  unsigned long int base64_dec_06$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded06);
  base64_dec_06$$1$$1$$buf=base64_dec(coded06, return_value_strlen$1, &base64_dec_06$$1$$1$$sz);
  if(base64_dec_06$$1$$1$$buf == ((unsigned char *)NULL))
    _mark_point("base64.t.c", 207);

  else
    _ck_assert_failed("base64.t.c", 207, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// base64_dec_07
// file base64.t.c line 211
static void base64_dec_07(signed int _i)
{
  tcase_fn_start("base64_dec_07", "base64.t.c", 211);
  unsigned char *base64_dec_07$$1$$1$$buf;
  unsigned long int base64_dec_07$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded07);
  base64_dec_07$$1$$1$$buf=base64_dec(coded07, return_value_strlen$1, &base64_dec_07$$1$$1$$sz);
  if(base64_dec_07$$1$$1$$buf == ((unsigned char *)NULL))
    _mark_point("base64.t.c", 217);

  else
    _ck_assert_failed("base64.t.c", 217, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// base64_dec_08
// file base64.t.c line 221
static void base64_dec_08(signed int _i)
{
  tcase_fn_start("base64_dec_08", "base64.t.c", 221);
  unsigned char *base64_dec_08$$1$$1$$buf;
  unsigned long int base64_dec_08$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded08);
  base64_dec_08$$1$$1$$buf=base64_dec(coded08, return_value_strlen$1, &base64_dec_08$$1$$1$$sz);
  if(base64_dec_08$$1$$1$$buf == ((unsigned char *)NULL))
    _mark_point("base64.t.c", 227);

  else
    _ck_assert_failed("base64.t.c", 227, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// base64_dec_09
// file base64.t.c line 231
static void base64_dec_09(signed int _i)
{
  tcase_fn_start("base64_dec_09", "base64.t.c", 231);
  unsigned char *base64_dec_09$$1$$1$$buf;
  unsigned long int base64_dec_09$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded09);
  base64_dec_09$$1$$1$$buf=base64_dec(coded09, return_value_strlen$1, &base64_dec_09$$1$$1$$sz);
  if(base64_dec_09$$1$$1$$buf == ((unsigned char *)NULL))
    _mark_point("base64.t.c", 237);

  else
    _ck_assert_failed("base64.t.c", 237, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// base64_dec_10
// file base64.t.c line 241
static void base64_dec_10(signed int _i)
{
  tcase_fn_start("base64_dec_10", "base64.t.c", 241);
  unsigned char *base64_dec_10$$1$$1$$buf;
  unsigned long int base64_dec_10$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded10);
  base64_dec_10$$1$$1$$buf=base64_dec(coded10, return_value_strlen$1, &base64_dec_10$$1$$1$$sz);
  if(base64_dec_10$$1$$1$$buf == ((unsigned char *)NULL))
    _mark_point("base64.t.c", 247);

  else
    _ck_assert_failed("base64.t.c", 247, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// base64_dec_11
// file base64.t.c line 251
static void base64_dec_11(signed int _i)
{
  tcase_fn_start("base64_dec_11", "base64.t.c", 251);
  unsigned char *base64_dec_11$$1$$1$$buf;
  unsigned long int base64_dec_11$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded11);
  base64_dec_11$$1$$1$$buf=base64_dec(coded11, return_value_strlen$1, &base64_dec_11$$1$$1$$sz);
  if(base64_dec_11$$1$$1$$buf == ((unsigned char *)NULL))
    _mark_point("base64.t.c", 257);

  else
    _ck_assert_failed("base64.t.c", 257, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// base64_dec_12
// file base64.t.c line 261
static void base64_dec_12(signed int _i)
{
  tcase_fn_start("base64_dec_12", "base64.t.c", 261);
  unsigned char *base64_dec_12$$1$$1$$buf;
  unsigned long int base64_dec_12$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded12);
  base64_dec_12$$1$$1$$buf=base64_dec(coded12, return_value_strlen$1, &base64_dec_12$$1$$1$$sz);
  if(base64_dec_12$$1$$1$$buf == ((unsigned char *)NULL))
    _mark_point("base64.t.c", 267);

  else
    _ck_assert_failed("base64.t.c", 267, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// base64_dec_13
// file base64.t.c line 271
static void base64_dec_13(signed int _i)
{
  tcase_fn_start("base64_dec_13", "base64.t.c", 271);
  unsigned char *base64_dec_13$$1$$1$$buf;
  unsigned long int base64_dec_13$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded13);
  base64_dec_13$$1$$1$$buf=base64_dec(coded13, return_value_strlen$1, &base64_dec_13$$1$$1$$sz);
  if(base64_dec_13$$1$$1$$buf == ((unsigned char *)NULL))
    _mark_point("base64.t.c", 277);

  else
    _ck_assert_failed("base64.t.c", 277, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// base64_dec_14
// file base64.t.c line 281
static void base64_dec_14(signed int _i)
{
  tcase_fn_start("base64_dec_14", "base64.t.c", 281);
  unsigned char *base64_dec_14$$1$$1$$buf;
  unsigned long int base64_dec_14$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded14);
  base64_dec_14$$1$$1$$buf=base64_dec(coded14, return_value_strlen$1, &base64_dec_14$$1$$1$$sz);
  if(base64_dec_14$$1$$1$$buf == ((unsigned char *)NULL))
    _mark_point("base64.t.c", 287);

  else
    _ck_assert_failed("base64.t.c", 287, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// base64_dec_15
// file base64.t.c line 291
static void base64_dec_15(signed int _i)
{
  tcase_fn_start("base64_dec_15", "base64.t.c", 291);
  unsigned char *base64_dec_15$$1$$1$$buf;
  unsigned long int base64_dec_15$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded15);
  base64_dec_15$$1$$1$$buf=base64_dec(coded15, return_value_strlen$1, &base64_dec_15$$1$$1$$sz);
  if(base64_dec_15$$1$$1$$buf == ((unsigned char *)NULL))
    _mark_point("base64.t.c", 297);

  else
    _ck_assert_failed("base64.t.c", 297, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// base64_dec_16
// file base64.t.c line 301
static void base64_dec_16(signed int _i)
{
  tcase_fn_start("base64_dec_16", "base64.t.c", 301);
  unsigned char *base64_dec_16$$1$$1$$buf;
  unsigned long int base64_dec_16$$1$$1$$sz;
  base64_dec_16$$1$$1$$buf=base64_dec("", (unsigned long int)0, &base64_dec_16$$1$$1$$sz);
  if(!(base64_dec_16$$1$$1$$buf == ((unsigned char *)NULL)))
    _mark_point("base64.t.c", 307);

  else
    _ck_assert_failed("base64.t.c", 307, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  if(base64_dec_16$$1$$1$$sz == 0ul)
    _mark_point("base64.t.c", 308);

  else
    _ck_assert_failed("base64.t.c", 308, "Assertion '!sz' failed", (const void *)"length not 0", (void *)0);
  if(*base64_dec_16$$1$$1$$buf == 0)
    _mark_point("base64.t.c", 309);

  else
    _ck_assert_failed("base64.t.c", 309, "Assertion '!buf[0]' failed", (const void *)"not empty string", (void *)0);
  free((void *)base64_dec_16$$1$$1$$buf);
}

// base64_enc
// file base64.h line 37
char * base64_enc(const unsigned char *in, unsigned long int insz, unsigned long int *outsz)
{
  unsigned long int i;
  unsigned long int o;
  char *out;
  if(insz == 0ul)
  {
    *outsz = (unsigned long int)0;
    char *return_value_strdup$1;
    return_value_strdup$1=strdup("");
    return return_value_strdup$1;
  }

  *outsz = ((insz + (unsigned long int)2) / (unsigned long int)3) * (unsigned long int)4;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(*outsz + (unsigned long int)1);
  out = (char *)return_value_malloc$2;
  if(out == ((char *)NULL))
  {
    *outsz = (unsigned long int)0;
    return (char *)(void *)0;
  }

  else
  {
    i = (unsigned long int)0;
    o = (unsigned long int)0;
    for( ; !(i >= insz); o = o + (unsigned long int)4)
    {
      signed int tmp = (signed int)in[(signed long int)i] << 16;
      if(!(1ul + i >= insz))
        tmp = tmp + ((signed int)in[(signed long int)(i + (unsigned long int)1)] << 8);

      if(!(2ul + i >= insz))
        tmp = tmp + (signed int)in[(signed long int)(i + (unsigned long int)2)];

      static const signed int alphabet[64l] = { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 };
      out[(signed long int)o] = (char)alphabet[(signed long int)(tmp >> 18 & 0x3f)];
      out[(signed long int)(o + (unsigned long int)1)] = (char)alphabet[(signed long int)(tmp >> 12 & 0x3f)];
      out[(signed long int)(o + (unsigned long int)2)] = (char)alphabet[(signed long int)(tmp >> 6 & 0x3f)];
      out[(signed long int)(o + (unsigned long int)3)] = (char)alphabet[(signed long int)(tmp & 0x3f)];
      if(!(insz >= 2ul + i))
        out[(signed long int)(o + (unsigned long int)2)] = (char)61;

      if(!(insz >= 3ul + i))
        out[(signed long int)(o + (unsigned long int)3)] = (char)61;

      i = i + (unsigned long int)3;
    }
    out[(signed long int)*outsz] = (char)0;
    return out;
  }
}

// base64_enc_01
// file base64.t.c line 58
static void base64_enc_01(signed int _i)
{
  tcase_fn_start("base64_enc_01", "base64.t.c", 58);
  char *base64_enc_01$$1$$1$$buf;
  unsigned long int base64_enc_01$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(plain01);
  base64_enc_01$$1$$1$$buf=base64_enc((unsigned char *)plain01, return_value_strlen$1, &base64_enc_01$$1$$1$$sz);
  if(!(base64_enc_01$$1$$1$$buf == ((char *)NULL)))
    _mark_point("base64.t.c", 64);

  else
    _ck_assert_failed("base64.t.c", 64, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(coded01);
  if(base64_enc_01$$1$$1$$sz == return_value_strlen$2)
    _mark_point("base64.t.c", 65);

  else
    _ck_assert_failed("base64.t.c", 65, "Assertion 'sz == strlen(coded01)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)coded01, (const void *)base64_enc_01$$1$$1$$buf, base64_enc_01$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("base64.t.c", 66);

  else
    _ck_assert_failed("base64.t.c", 66, "Assertion '!memcmp(coded01, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)base64_enc_01$$1$$1$$buf);
}

// base64_enc_02
// file base64.t.c line 71
static void base64_enc_02(signed int _i)
{
  tcase_fn_start("base64_enc_02", "base64.t.c", 71);
  char *base64_enc_02$$1$$1$$buf;
  unsigned long int base64_enc_02$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(plain02);
  base64_enc_02$$1$$1$$buf=base64_enc((unsigned char *)plain02, return_value_strlen$1, &base64_enc_02$$1$$1$$sz);
  if(!(base64_enc_02$$1$$1$$buf == ((char *)NULL)))
    _mark_point("base64.t.c", 77);

  else
    _ck_assert_failed("base64.t.c", 77, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(coded02);
  if(base64_enc_02$$1$$1$$sz == return_value_strlen$2)
    _mark_point("base64.t.c", 78);

  else
    _ck_assert_failed("base64.t.c", 78, "Assertion 'sz == strlen(coded02)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)coded02, (const void *)base64_enc_02$$1$$1$$buf, base64_enc_02$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("base64.t.c", 79);

  else
    _ck_assert_failed("base64.t.c", 79, "Assertion '!memcmp(coded02, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)base64_enc_02$$1$$1$$buf);
}

// base64_enc_03
// file base64.t.c line 84
static void base64_enc_03(signed int _i)
{
  tcase_fn_start("base64_enc_03", "base64.t.c", 84);
  char *base64_enc_03$$1$$1$$buf;
  unsigned long int base64_enc_03$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(plain03);
  base64_enc_03$$1$$1$$buf=base64_enc((unsigned char *)plain03, return_value_strlen$1, &base64_enc_03$$1$$1$$sz);
  if(!(base64_enc_03$$1$$1$$buf == ((char *)NULL)))
    _mark_point("base64.t.c", 90);

  else
    _ck_assert_failed("base64.t.c", 90, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(coded03);
  if(base64_enc_03$$1$$1$$sz == return_value_strlen$2)
    _mark_point("base64.t.c", 91);

  else
    _ck_assert_failed("base64.t.c", 91, "Assertion 'sz == strlen(coded03)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)coded03, (const void *)base64_enc_03$$1$$1$$buf, base64_enc_03$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("base64.t.c", 92);

  else
    _ck_assert_failed("base64.t.c", 92, "Assertion '!memcmp(coded03, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)base64_enc_03$$1$$1$$buf);
}

// base64_enc_04
// file base64.t.c line 97
static void base64_enc_04(signed int _i)
{
  tcase_fn_start("base64_enc_04", "base64.t.c", 97);
  char *base64_enc_04$$1$$1$$buf;
  unsigned long int base64_enc_04$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(plain04);
  base64_enc_04$$1$$1$$buf=base64_enc((unsigned char *)plain04, return_value_strlen$1, &base64_enc_04$$1$$1$$sz);
  if(!(base64_enc_04$$1$$1$$buf == ((char *)NULL)))
    _mark_point("base64.t.c", 103);

  else
    _ck_assert_failed("base64.t.c", 103, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(coded04);
  if(base64_enc_04$$1$$1$$sz == return_value_strlen$2)
    _mark_point("base64.t.c", 104);

  else
    _ck_assert_failed("base64.t.c", 104, "Assertion 'sz == strlen(coded04)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)coded04, (const void *)base64_enc_04$$1$$1$$buf, base64_enc_04$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("base64.t.c", 105);

  else
    _ck_assert_failed("base64.t.c", 105, "Assertion '!memcmp(coded04, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)base64_enc_04$$1$$1$$buf);
}

// base64_enc_05
// file base64.t.c line 110
static void base64_enc_05(signed int _i)
{
  tcase_fn_start("base64_enc_05", "base64.t.c", 110);
  char *base64_enc_05$$1$$1$$buf;
  unsigned long int base64_enc_05$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(plain05);
  base64_enc_05$$1$$1$$buf=base64_enc((unsigned char *)plain05, return_value_strlen$1, &base64_enc_05$$1$$1$$sz);
  if(!(base64_enc_05$$1$$1$$buf == ((char *)NULL)))
    _mark_point("base64.t.c", 116);

  else
    _ck_assert_failed("base64.t.c", 116, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(coded05);
  if(base64_enc_05$$1$$1$$sz == return_value_strlen$2)
    _mark_point("base64.t.c", 117);

  else
    _ck_assert_failed("base64.t.c", 117, "Assertion 'sz == strlen(coded05)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)coded05, (const void *)base64_enc_05$$1$$1$$buf, base64_enc_05$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("base64.t.c", 118);

  else
    _ck_assert_failed("base64.t.c", 118, "Assertion '!memcmp(coded05, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)base64_enc_05$$1$$1$$buf);
}

// base64_enc_06
// file base64.t.c line 123
static void base64_enc_06(signed int _i)
{
  tcase_fn_start("base64_enc_06", "base64.t.c", 123);
  char *base64_enc_06$$1$$1$$buf;
  unsigned long int base64_enc_06$$1$$1$$sz;
  base64_enc_06$$1$$1$$buf=base64_enc((unsigned char *)"", (unsigned long int)0, &base64_enc_06$$1$$1$$sz);
  if(!(base64_enc_06$$1$$1$$buf == ((char *)NULL)))
    _mark_point("base64.t.c", 129);

  else
    _ck_assert_failed("base64.t.c", 129, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  if(base64_enc_06$$1$$1$$sz == 0ul)
    _mark_point("base64.t.c", 130);

  else
    _ck_assert_failed("base64.t.c", 130, "Assertion '!sz' failed", (const void *)"length not 0", (void *)0);
  if(*base64_enc_06$$1$$1$$buf == 0)
    _mark_point("base64.t.c", 131);

  else
    _ck_assert_failed("base64.t.c", 131, "Assertion '!buf[0]' failed", (const void *)"not empty string", (void *)0);
  free((void *)base64_enc_06$$1$$1$$buf);
}

// base64_suite
// file base64.t.c line 315
struct Suite * base64_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("base64");
  tc=tcase_create("base64_enc");
  _tcase_add_test(tc, base64_enc_01, "base64_enc_01", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_enc_02, "base64_enc_02", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_enc_03, "base64_enc_03", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_enc_04, "base64_enc_04", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_enc_05, "base64_enc_05", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_enc_06, "base64_enc_06", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("base64_dec");
  _tcase_add_test(tc, base64_dec_01, "base64_dec_01", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_02, "base64_dec_02", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_03, "base64_dec_03", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_04, "base64_dec_04", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_05, "base64_dec_05", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_06, "base64_dec_06", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_07, "base64_dec_07", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_08, "base64_dec_08", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_09, "base64_dec_09", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_10, "base64_dec_10", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_11, "base64_dec_11", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_12, "base64_dec_12", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_13, "base64_dec_13", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_14, "base64_dec_14", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_15, "base64_dec_15", 0, 0, 0, 1);
  _tcase_add_test(tc, base64_dec_16, "base64_dec_16", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// blank_suite
// file main.t.c line 39
struct Suite * blank_suite(void)
{
  struct Suite *s;
  s=suite_create("");
  return s;
}

// buf_setup
// file dynbuf.t.c line 42
static void buf_setup(void)
{
  sz = sizeof(const unsigned char [13l]) /*13ul*/ ;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sz);
  buf = (unsigned char *)return_value_malloc$1;
  memcpy((void *)buf, (const void *)template, sz);
}

// buf_teardown
// file dynbuf.t.c line 50
static void buf_teardown(void)
{
  free((void *)buf);
  buf = (unsigned char *)(void *)0;
  sz = (unsigned long int)0;
}

// bufferevent_free_and_close_fd
// file pxyconn.c line 1060
static void bufferevent_free_and_close_fd(struct bufferevent *bev, struct pxy_conn_ctx *ctx)
{
  signed int fd;
  fd=bufferevent_getfd(bev);
  struct ssl_st *ssl = (struct ssl_st *)(void *)0;
  if(!(ctx->spec->ssl == 0u))
  {
    if(ctx->passthrough == 0u)
      ssl=bufferevent_openssl_get_ssl(bev);

  }

  bufferevent_free(bev);
  if(!(ssl == ((struct ssl_st *)NULL)))
    pxy_ssl_shutdown(ctx->opts, ctx->evbase, ssl, fd);

  else
    evutil_closesocket(fd);
}

// build_date_01
// file main.t.c line 46
static void build_date_01(signed int _i)
{
  tcase_fn_start("build_date_01", "main.t.c", 46);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(build_date);
  if(return_value_strlen$1 == 10ul)
    _mark_point("main.t.c", 48);

  else
    _ck_assert_failed("main.t.c", 48, "Assertion 'strlen(build_date) == 10' failed", (const void *)"length mismatch", (void *)0);
  if((signed int)build_date[4l] == 45)
    _mark_point("main.t.c", 49);

  else
    _ck_assert_failed("main.t.c", 49, "Assertion 'build_date[4] == '-'' failed", (const void *)"year/month separator not dash", (void *)0);
  if((signed int)build_date[7l] == 45)
    _mark_point("main.t.c", 50);

  else
    _ck_assert_failed("main.t.c", 50, "Assertion 'build_date[7] == '-'' failed", (const void *)"month/day separator not dash", (void *)0);
}

// cache_del
// file cache.h line 80
void cache_del(struct cache *cache, void *key)
{
  unsigned int it;
  pthread_mutex_lock(&cache->mutex);
  it=cache->get_cb(key);
  unsigned int return_value_2;
  return_value_2=cache->end_cb();
  if(!(it == return_value_2))
  {
    void *return_value;
    return_value=cache->get_val_cb(it);
    cache->free_val_cb(return_value);
    void *return_value_1;
    return_value_1=cache->get_key_cb(it);
    cache->free_key_cb(return_value_1);
    cache->del_cb(it);
  }

  cache->free_key_cb(key);
  pthread_mutex_unlock(&cache->mutex);
}

// cache_dsess_01
// file cachedsess.t.c line 77
static void cache_dsess_01(signed int _i)
{
  tcase_fn_start("cache_dsess_01", "cachedsess.t.c", 77);
  struct ssl_session_st *s1;
  struct ssl_session_st *s2;
  s1=ssl_session_from_file("extra/pki/session.pem");
  if(!(s1 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachedsess.t.c", 82);

  else
    _ck_assert_failed("cachedsess.t.c", 82, "Assertion '!!s1' failed", (const void *)"creating session failed", (void *)0);
  signed int return_value_ssl_session_is_valid$1;
  return_value_ssl_session_is_valid$1=ssl_session_is_valid(s1);
  if(!(return_value_ssl_session_is_valid$1 == 0))
    _mark_point("cachedsess.t.c", 83);

  else
    _ck_assert_failed("cachedsess.t.c", 83, "Assertion 'ssl_session_is_valid(s1)' failed", (const void *)"session invalid", (void *)0);
  void *return_value_cachedsess_mkkey$2;
  return_value_cachedsess_mkkey$2=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  void *return_value_cachedsess_mkval$3;
  return_value_cachedsess_mkval$3=cachedsess_mkval(s1);
  cache_set(cachemgr_dsess, return_value_cachedsess_mkkey$2, return_value_cachedsess_mkval$3);
  void *return_value_cachedsess_mkkey$4;
  return_value_cachedsess_mkkey$4=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  void *return_value_cache_get$5;
  return_value_cache_get$5=cache_get(cachemgr_dsess, return_value_cachedsess_mkkey$4);
  s2 = (struct ssl_session_st *)return_value_cache_get$5;
  if(!(s2 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachedsess.t.c", 87);

  else
    _ck_assert_failed("cachedsess.t.c", 87, "Assertion '!!s2' failed", (const void *)"cache returned no session", (void *)0);
  if(!(s2 == s1))
    _mark_point("cachedsess.t.c", 88);

  else
    _ck_assert_failed("cachedsess.t.c", 88, "Assertion 's2 != s1' failed", (const void *)"cache returned same pointer", (void *)0);
  SSL_SESSION_free(s1);
  SSL_SESSION_free(s2);
}

// cache_dsess_02
// file cachedsess.t.c line 94
static void cache_dsess_02(signed int _i)
{
  tcase_fn_start("cache_dsess_02", "cachedsess.t.c", 94);
  struct ssl_session_st *s1;
  struct ssl_session_st *s2;
  s1=ssl_session_from_file("extra/pki/session.pem");
  if(!(s1 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachedsess.t.c", 99);

  else
    _ck_assert_failed("cachedsess.t.c", 99, "Assertion '!!s1' failed", (const void *)"creating session failed", (void *)0);
  signed int return_value_ssl_session_is_valid$1;
  return_value_ssl_session_is_valid$1=ssl_session_is_valid(s1);
  if(!(return_value_ssl_session_is_valid$1 == 0))
    _mark_point("cachedsess.t.c", 100);

  else
    _ck_assert_failed("cachedsess.t.c", 100, "Assertion 'ssl_session_is_valid(s1)' failed", (const void *)"session invalid", (void *)0);
  void *return_value_cachedsess_mkkey$2;
  return_value_cachedsess_mkkey$2=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  void *return_value_cache_get$3;
  return_value_cache_get$3=cache_get(cachemgr_dsess, return_value_cachedsess_mkkey$2);
  s2 = (struct ssl_session_st *)return_value_cache_get$3;
  if(s2 == ((struct ssl_session_st *)NULL))
    _mark_point("cachedsess.t.c", 103);

  else
    _ck_assert_failed("cachedsess.t.c", 103, "Assertion 's2 == NULL' failed", (const void *)"session was already in empty cache", (void *)0);
  SSL_SESSION_free(s1);
}

// cache_dsess_03
// file cachedsess.t.c line 108
static void cache_dsess_03(signed int _i)
{
  tcase_fn_start("cache_dsess_03", "cachedsess.t.c", 108);
  struct ssl_session_st *s1;
  struct ssl_session_st *s2;
  s1=ssl_session_from_file("extra/pki/session.pem");
  if(!(s1 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachedsess.t.c", 113);

  else
    _ck_assert_failed("cachedsess.t.c", 113, "Assertion '!!s1' failed", (const void *)"creating session failed", (void *)0);
  signed int return_value_ssl_session_is_valid$1;
  return_value_ssl_session_is_valid$1=ssl_session_is_valid(s1);
  if(!(return_value_ssl_session_is_valid$1 == 0))
    _mark_point("cachedsess.t.c", 114);

  else
    _ck_assert_failed("cachedsess.t.c", 114, "Assertion 'ssl_session_is_valid(s1)' failed", (const void *)"session invalid", (void *)0);
  void *return_value_cachedsess_mkkey$2;
  return_value_cachedsess_mkkey$2=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  void *return_value_cachedsess_mkval$3;
  return_value_cachedsess_mkval$3=cachedsess_mkval(s1);
  cache_set(cachemgr_dsess, return_value_cachedsess_mkkey$2, return_value_cachedsess_mkval$3);
  void *return_value_cachedsess_mkkey$4;
  return_value_cachedsess_mkkey$4=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  cache_del(cachemgr_dsess, return_value_cachedsess_mkkey$4);
  void *return_value_cachedsess_mkkey$5;
  return_value_cachedsess_mkkey$5=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  void *return_value_cache_get$6;
  return_value_cache_get$6=cache_get(cachemgr_dsess, return_value_cachedsess_mkkey$5);
  s2 = (struct ssl_session_st *)return_value_cache_get$6;
  if(s2 == ((struct ssl_session_st *)NULL))
    _mark_point("cachedsess.t.c", 119);

  else
    _ck_assert_failed("cachedsess.t.c", 119, "Assertion 's2 == NULL' failed", (const void *)"cache returned deleted session", (void *)0);
  SSL_SESSION_free(s1);
}

// cache_dsess_04
// file cachedsess.t.c line 124
static void cache_dsess_04(signed int _i)
{
  tcase_fn_start("cache_dsess_04", "cachedsess.t.c", 124);
  struct ssl_session_st *s1;
  struct ssl_session_st *s2;
  s1=ssl_session_from_file("extra/pki/session.pem");
  if(!(s1 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachedsess.t.c", 129);

  else
    _ck_assert_failed("cachedsess.t.c", 129, "Assertion '!!s1' failed", (const void *)"creating session failed", (void *)0);
  signed int return_value_ssl_session_is_valid$1;
  return_value_ssl_session_is_valid$1=ssl_session_is_valid(s1);
  if(!(return_value_ssl_session_is_valid$1 == 0))
    _mark_point("cachedsess.t.c", 130);

  else
    _ck_assert_failed("cachedsess.t.c", 130, "Assertion 'ssl_session_is_valid(s1)' failed", (const void *)"session invalid", (void *)0);
  if(s1->references == 1)
    _mark_point("cachedsess.t.c", 132);

  else
    _ck_assert_failed("cachedsess.t.c", 132, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachedsess_mkkey$2;
  return_value_cachedsess_mkkey$2=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  void *return_value_cachedsess_mkval$3;
  return_value_cachedsess_mkval$3=cachedsess_mkval(s1);
  cache_set(cachemgr_dsess, return_value_cachedsess_mkkey$2, return_value_cachedsess_mkval$3);
  if(s1->references == 1)
    _mark_point("cachedsess.t.c", 134);

  else
    _ck_assert_failed("cachedsess.t.c", 134, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachedsess_mkkey$4;
  return_value_cachedsess_mkkey$4=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  void *return_value_cache_get$5;
  return_value_cache_get$5=cache_get(cachemgr_dsess, return_value_cachedsess_mkkey$4);
  s2 = (struct ssl_session_st *)return_value_cache_get$5;
  if(s1->references == 1)
    _mark_point("cachedsess.t.c", 136);

  else
    _ck_assert_failed("cachedsess.t.c", 136, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  if(!(s2 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachedsess.t.c", 137);

  else
    _ck_assert_failed("cachedsess.t.c", 137, "Assertion '!!s2' failed", (const void *)"cache returned no session", (void *)0);
  if(s2->references == 1)
    _mark_point("cachedsess.t.c", 138);

  else
    _ck_assert_failed("cachedsess.t.c", 138, "Assertion 's2->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachedsess_mkkey$6;
  return_value_cachedsess_mkkey$6=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  void *return_value_cachedsess_mkval$7;
  return_value_cachedsess_mkval$7=cachedsess_mkval(s1);
  cache_set(cachemgr_dsess, return_value_cachedsess_mkkey$6, return_value_cachedsess_mkval$7);
  if(s1->references == 1)
    _mark_point("cachedsess.t.c", 140);

  else
    _ck_assert_failed("cachedsess.t.c", 140, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachedsess_mkkey$8;
  return_value_cachedsess_mkkey$8=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  cache_del(cachemgr_dsess, return_value_cachedsess_mkkey$8);
  if(s1->references == 1)
    _mark_point("cachedsess.t.c", 142);

  else
    _ck_assert_failed("cachedsess.t.c", 142, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachedsess_mkkey$9;
  return_value_cachedsess_mkkey$9=cachedsess_mkkey((struct sockaddr *)&addr, addrlen, sni);
  void *return_value_cachedsess_mkval$10;
  return_value_cachedsess_mkval$10=cachedsess_mkval(s1);
  cache_set(cachemgr_dsess, return_value_cachedsess_mkkey$9, return_value_cachedsess_mkval$10);
  if(s1->references == 1)
    _mark_point("cachedsess.t.c", 144);

  else
    _ck_assert_failed("cachedsess.t.c", 144, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  SSL_SESSION_free(s1);
  SSL_SESSION_free(s2);
}

// cache_fkcrt_01
// file cachefkcrt.t.c line 53
static void cache_fkcrt_01(signed int _i)
{
  tcase_fn_start("cache_fkcrt_01", "cachefkcrt.t.c", 53);
  struct x509_st *c1;
  struct x509_st *c2;
  c1=ssl_x509_load("extra/pki/rsa.crt");
  if(!(c1 == ((struct x509_st *)NULL)))
    _mark_point("cachefkcrt.t.c", 58);

  else
    _ck_assert_failed("cachefkcrt.t.c", 58, "Assertion '!!c1' failed", (const void *)"loading certificate failed", (void *)0);
  void *return_value_cachefkcrt_mkkey$1;
  return_value_cachefkcrt_mkkey$1=cachefkcrt_mkkey(c1);
  void *return_value_cachefkcrt_mkval$2;
  return_value_cachefkcrt_mkval$2=cachefkcrt_mkval(c1);
  cache_set(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$1, return_value_cachefkcrt_mkval$2);
  void *return_value_cachefkcrt_mkkey$3;
  return_value_cachefkcrt_mkkey$3=cachefkcrt_mkkey(c1);
  void *return_value_cache_get$4;
  return_value_cache_get$4=cache_get(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$3);
  c2 = (struct x509_st *)return_value_cache_get$4;
  if(c2 == c1)
    _mark_point("cachefkcrt.t.c", 61);

  else
    _ck_assert_failed("cachefkcrt.t.c", 61, "Assertion 'c2 == c1' failed", (const void *)"cache did not return same pointer", (void *)0);
  X509_free(c1);
  X509_free(c2);
}

// cache_fkcrt_02
// file cachefkcrt.t.c line 67
static void cache_fkcrt_02(signed int _i)
{
  tcase_fn_start("cache_fkcrt_02", "cachefkcrt.t.c", 67);
  struct x509_st *c1;
  struct x509_st *c2;
  c1=ssl_x509_load("extra/pki/rsa.crt");
  if(!(c1 == ((struct x509_st *)NULL)))
    _mark_point("cachefkcrt.t.c", 72);

  else
    _ck_assert_failed("cachefkcrt.t.c", 72, "Assertion '!!c1' failed", (const void *)"loading certificate failed", (void *)0);
  void *return_value_cachefkcrt_mkkey$1;
  return_value_cachefkcrt_mkkey$1=cachefkcrt_mkkey(c1);
  void *return_value_cache_get$2;
  return_value_cache_get$2=cache_get(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$1);
  c2 = (struct x509_st *)return_value_cache_get$2;
  if(c2 == ((struct x509_st *)NULL))
    _mark_point("cachefkcrt.t.c", 74);

  else
    _ck_assert_failed("cachefkcrt.t.c", 74, "Assertion 'c2 == NULL' failed", (const void *)"certificate was already in empty cache", (void *)0);
  X509_free(c1);
}

// cache_fkcrt_03
// file cachefkcrt.t.c line 79
static void cache_fkcrt_03(signed int _i)
{
  tcase_fn_start("cache_fkcrt_03", "cachefkcrt.t.c", 79);
  struct x509_st *c1;
  struct x509_st *c2;
  c1=ssl_x509_load("extra/pki/rsa.crt");
  if(!(c1 == ((struct x509_st *)NULL)))
    _mark_point("cachefkcrt.t.c", 84);

  else
    _ck_assert_failed("cachefkcrt.t.c", 84, "Assertion '!!c1' failed", (const void *)"loading certificate failed", (void *)0);
  void *return_value_cachefkcrt_mkkey$1;
  return_value_cachefkcrt_mkkey$1=cachefkcrt_mkkey(c1);
  void *return_value_cachefkcrt_mkval$2;
  return_value_cachefkcrt_mkval$2=cachefkcrt_mkval(c1);
  cache_set(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$1, return_value_cachefkcrt_mkval$2);
  void *return_value_cachefkcrt_mkkey$3;
  return_value_cachefkcrt_mkkey$3=cachefkcrt_mkkey(c1);
  cache_del(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$3);
  void *return_value_cachefkcrt_mkkey$4;
  return_value_cachefkcrt_mkkey$4=cachefkcrt_mkkey(c1);
  void *return_value_cache_get$5;
  return_value_cache_get$5=cache_get(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$4);
  c2 = (struct x509_st *)return_value_cache_get$5;
  if(c2 == ((struct x509_st *)NULL))
    _mark_point("cachefkcrt.t.c", 88);

  else
    _ck_assert_failed("cachefkcrt.t.c", 88, "Assertion 'c2 == NULL' failed", (const void *)"cache returned deleted certificate", (void *)0);
  X509_free(c1);
}

// cache_fkcrt_04
// file cachefkcrt.t.c line 93
static void cache_fkcrt_04(signed int _i)
{
  tcase_fn_start("cache_fkcrt_04", "cachefkcrt.t.c", 93);
  struct x509_st *c1;
  struct x509_st *c2;
  c1=ssl_x509_load("extra/pki/rsa.crt");
  if(!(c1 == ((struct x509_st *)NULL)))
    _mark_point("cachefkcrt.t.c", 98);

  else
    _ck_assert_failed("cachefkcrt.t.c", 98, "Assertion '!!c1' failed", (const void *)"loading certificate failed", (void *)0);
  if(c1->references == 1)
    _mark_point("cachefkcrt.t.c", 99);

  else
    _ck_assert_failed("cachefkcrt.t.c", 99, "Assertion 'c1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachefkcrt_mkkey$1;
  return_value_cachefkcrt_mkkey$1=cachefkcrt_mkkey(c1);
  void *return_value_cachefkcrt_mkval$2;
  return_value_cachefkcrt_mkval$2=cachefkcrt_mkval(c1);
  cache_set(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$1, return_value_cachefkcrt_mkval$2);
  if(c1->references == 2)
    _mark_point("cachefkcrt.t.c", 101);

  else
    _ck_assert_failed("cachefkcrt.t.c", 101, "Assertion 'c1->references == 2' failed", (const void *)"refcount != 2", (void *)0);
  void *return_value_cachefkcrt_mkkey$3;
  return_value_cachefkcrt_mkkey$3=cachefkcrt_mkkey(c1);
  void *return_value_cache_get$4;
  return_value_cache_get$4=cache_get(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$3);
  c2 = (struct x509_st *)return_value_cache_get$4;
  if(c1->references == 3)
    _mark_point("cachefkcrt.t.c", 103);

  else
    _ck_assert_failed("cachefkcrt.t.c", 103, "Assertion 'c1->references == 3' failed", (const void *)"refcount != 3", (void *)0);
  void *return_value_cachefkcrt_mkkey$5;
  return_value_cachefkcrt_mkkey$5=cachefkcrt_mkkey(c1);
  void *return_value_cachefkcrt_mkval$6;
  return_value_cachefkcrt_mkval$6=cachefkcrt_mkval(c1);
  cache_set(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$5, return_value_cachefkcrt_mkval$6);
  if(c1->references == 3)
    _mark_point("cachefkcrt.t.c", 105);

  else
    _ck_assert_failed("cachefkcrt.t.c", 105, "Assertion 'c1->references == 3' failed", (const void *)"refcount != 3", (void *)0);
  void *return_value_cachefkcrt_mkkey$7;
  return_value_cachefkcrt_mkkey$7=cachefkcrt_mkkey(c1);
  cache_del(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$7);
  if(c1->references == 2)
    _mark_point("cachefkcrt.t.c", 107);

  else
    _ck_assert_failed("cachefkcrt.t.c", 107, "Assertion 'c1->references == 2' failed", (const void *)"refcount != 2", (void *)0);
  void *return_value_cachefkcrt_mkkey$8;
  return_value_cachefkcrt_mkkey$8=cachefkcrt_mkkey(c1);
  void *return_value_cachefkcrt_mkval$9;
  return_value_cachefkcrt_mkval$9=cachefkcrt_mkval(c1);
  cache_set(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$8, return_value_cachefkcrt_mkval$9);
  if(c1->references == 3)
    _mark_point("cachefkcrt.t.c", 109);

  else
    _ck_assert_failed("cachefkcrt.t.c", 109, "Assertion 'c1->references == 3' failed", (const void *)"refcount != 3", (void *)0);
  X509_free(c1);
  if(c1->references == 2)
    _mark_point("cachefkcrt.t.c", 111);

  else
    _ck_assert_failed("cachefkcrt.t.c", 111, "Assertion 'c1->references == 2' failed", (const void *)"refcount != 2", (void *)0);
  cachemgr_fini();
  if(c1->references == 1)
    _mark_point("cachefkcrt.t.c", 113);

  else
    _ck_assert_failed("cachefkcrt.t.c", 113, "Assertion 'c1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  X509_free(c2);
  if(c1->references == 0)
    _mark_point("cachefkcrt.t.c", 116);

  else
    _ck_assert_failed("cachefkcrt.t.c", 116, "Assertion 'c1->references == 0' failed", (const void *)"refcount != 0", (void *)0);
  signed int return_value_cachemgr_preinit$10;
  return_value_cachemgr_preinit$10=cachemgr_preinit();
  if(!(return_value_cachemgr_preinit$10 == -1))
    _mark_point("cachefkcrt.t.c", 117);

  else
    _ck_assert_failed("cachefkcrt.t.c", 117, "Assertion 'cachemgr_preinit() != -1' failed", (const void *)"reinit", (void *)0);
}

// cache_free
// file cache.c line 72
void cache_free(struct cache *cache)
{
  unsigned int it;
  it=cache->begin_cb();
  unsigned int return_value;
  return_value=cache->end_cb();
  if(!(it == return_value))
  {
    signed int return_value_3;
    return_value_3=cache->exist_cb(it);
    if(!(return_value_3 == 0))
    {
      void *return_value_1;
      return_value_1=cache->get_key_cb(it);
      cache->free_key_cb(return_value_1);
      void *return_value_2;
      return_value_2=cache->get_val_cb(it);
      cache->free_val_cb(return_value_2);
    }

    it = it + 1u;
  }

  cache->fini_cb();
  pthread_mutex_destroy(&cache->mutex);
  free((void *)cache);
}

// cache_gc
// file cache.c line 88
void cache_gc(struct cache *cache)
{
  unsigned int it;
  void *val;
  pthread_mutex_lock(&cache->mutex);
  it=cache->begin_cb();
  unsigned int return_value;
  return_value=cache->end_cb();
  if(!(it == return_value))
  {
    signed int return_value_3;
    return_value_3=cache->exist_cb(it);
    if(!(return_value_3 == 0))
    {
      val=cache->get_val_cb(it);
      void *return_value_2;
      return_value_2=cache->unpackverify_val_cb(val, 0);
      if(return_value_2 == NULL)
      {
        cache->free_val_cb(val);
        void *return_value_1;
        return_value_1=cache->get_key_cb(it);
        cache->free_key_cb(return_value_1);
        cache->del_cb(it);
      }

    }

    it = it + 1u;
  }

  pthread_mutex_unlock(&cache->mutex);
}

// cache_get
// file cache.h line 78
void * cache_get(struct cache *cache, void *key)
{
  void *rval = (void *)0;
  unsigned int it;
  if(key == NULL)
    return (void *)0;

  else
  {
    pthread_mutex_lock(&cache->mutex);
    it=cache->get_cb(key);
    unsigned int return_value_1;
    return_value_1=cache->end_cb();
    if(!(it == return_value_1))
    {
      void *val;
      val=cache->get_val_cb(it);
      rval=cache->unpackverify_val_cb(val, 1);
      if(rval == NULL)
      {
        cache->free_val_cb(val);
        void *return_value;
        return_value=cache->get_key_cb(it);
        cache->free_key_cb(return_value);
        cache->del_cb(it);
      }

    }

    cache->free_key_cb(key);
    pthread_mutex_unlock(&cache->mutex);
    return rval;
  }
}

// cache_new
// file cache.c line 44
struct cache * cache_new(void (*init_cb)(struct cache *))
{
  struct cache *cache;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct cache) /*144ul*/ );
  cache = (struct cache *)return_value_malloc$1;
  if(cache == ((struct cache *)NULL))
    return (struct cache *)(void *)0;

  else
  {
    init_cb(cache);
    pthread_mutex_init(&cache->mutex, (const union anonymous$15 *)(void *)0);
    return cache;
  }
}

// cache_reinit
// file cache.c line 62
void cache_reinit(struct cache *cache)
{
  pthread_mutex_init(&cache->mutex, (const union anonymous$15 *)(void *)0);
}

// cache_set
// file cache.h line 79
void cache_set(struct cache *cache, void *key, void *val)
{
  unsigned int it;
  signed int ret;
  if(!(key == NULL) && !(val == NULL))
  {
    pthread_mutex_lock(&cache->mutex);
    it=cache->put_cb(key, &ret);
    if(ret == 0)
    {
      cache->free_key_cb(key);
      void *return_value;
      return_value=cache->get_val_cb(it);
      cache->free_val_cb(return_value);
    }

    cache->set_val_cb(it, val);
    pthread_mutex_unlock(&cache->mutex);
  }

}

// cache_ssess_01
// file cachessess.t.c line 69
static void cache_ssess_01(signed int _i)
{
  tcase_fn_start("cache_ssess_01", "cachessess.t.c", 69);
  struct ssl_session_st *s1;
  struct ssl_session_st *s2;
  s1=ssl_session_from_file$link1("extra/pki/session.pem");
  if(!(s1 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachessess.t.c", 74);

  else
    _ck_assert_failed("cachessess.t.c", 74, "Assertion '!!s1' failed", (const void *)"creating session failed", (void *)0);
  signed int return_value_ssl_session_is_valid$1;
  return_value_ssl_session_is_valid$1=ssl_session_is_valid(s1);
  if(!(return_value_ssl_session_is_valid$1 == 0))
    _mark_point("cachessess.t.c", 75);

  else
    _ck_assert_failed("cachessess.t.c", 75, "Assertion 'ssl_session_is_valid(s1)' failed", (const void *)"session invalid", (void *)0);
  void *return_value_cachessess_mkkey$2;
  return_value_cachessess_mkkey$2=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  void *return_value_cachessess_mkval$3;
  return_value_cachessess_mkval$3=cachessess_mkval(s1);
  cache_set(cachemgr_ssess, return_value_cachessess_mkkey$2, return_value_cachessess_mkval$3);
  void *return_value_cachessess_mkkey$4;
  return_value_cachessess_mkkey$4=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  void *return_value_cache_get$5;
  return_value_cache_get$5=cache_get(cachemgr_ssess, return_value_cachessess_mkkey$4);
  s2 = (struct ssl_session_st *)return_value_cache_get$5;
  if(!(s2 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachessess.t.c", 79);

  else
    _ck_assert_failed("cachessess.t.c", 79, "Assertion '!!s2' failed", (const void *)"cache returned no session", (void *)0);
  if(!(s2 == s1))
    _mark_point("cachessess.t.c", 80);

  else
    _ck_assert_failed("cachessess.t.c", 80, "Assertion 's2 != s1' failed", (const void *)"cache returned same pointer", (void *)0);
  SSL_SESSION_free(s1);
  SSL_SESSION_free(s2);
}

// cache_ssess_02
// file cachessess.t.c line 86
static void cache_ssess_02(signed int _i)
{
  tcase_fn_start("cache_ssess_02", "cachessess.t.c", 86);
  struct ssl_session_st *s1;
  struct ssl_session_st *s2;
  s1=ssl_session_from_file$link1("extra/pki/session.pem");
  if(!(s1 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachessess.t.c", 91);

  else
    _ck_assert_failed("cachessess.t.c", 91, "Assertion '!!s1' failed", (const void *)"creating session failed", (void *)0);
  signed int return_value_ssl_session_is_valid$1;
  return_value_ssl_session_is_valid$1=ssl_session_is_valid(s1);
  if(!(return_value_ssl_session_is_valid$1 == 0))
    _mark_point("cachessess.t.c", 92);

  else
    _ck_assert_failed("cachessess.t.c", 92, "Assertion 'ssl_session_is_valid(s1)' failed", (const void *)"session invalid", (void *)0);
  void *return_value_cachessess_mkkey$2;
  return_value_cachessess_mkkey$2=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  void *return_value_cache_get$3;
  return_value_cache_get$3=cache_get(cachemgr_ssess, return_value_cachessess_mkkey$2);
  s2 = (struct ssl_session_st *)return_value_cache_get$3;
  if(s2 == ((struct ssl_session_st *)NULL))
    _mark_point("cachessess.t.c", 95);

  else
    _ck_assert_failed("cachessess.t.c", 95, "Assertion 's2 == NULL' failed", (const void *)"session was already in empty cache", (void *)0);
  SSL_SESSION_free(s1);
}

// cache_ssess_03
// file cachessess.t.c line 100
static void cache_ssess_03(signed int _i)
{
  tcase_fn_start("cache_ssess_03", "cachessess.t.c", 100);
  struct ssl_session_st *s1;
  struct ssl_session_st *s2;
  s1=ssl_session_from_file$link1("extra/pki/session.pem");
  if(!(s1 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachessess.t.c", 105);

  else
    _ck_assert_failed("cachessess.t.c", 105, "Assertion '!!s1' failed", (const void *)"creating session failed", (void *)0);
  signed int return_value_ssl_session_is_valid$1;
  return_value_ssl_session_is_valid$1=ssl_session_is_valid(s1);
  if(!(return_value_ssl_session_is_valid$1 == 0))
    _mark_point("cachessess.t.c", 106);

  else
    _ck_assert_failed("cachessess.t.c", 106, "Assertion 'ssl_session_is_valid(s1)' failed", (const void *)"session invalid", (void *)0);
  void *return_value_cachessess_mkkey$2;
  return_value_cachessess_mkkey$2=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  void *return_value_cachessess_mkval$3;
  return_value_cachessess_mkval$3=cachessess_mkval(s1);
  cache_set(cachemgr_ssess, return_value_cachessess_mkkey$2, return_value_cachessess_mkval$3);
  void *return_value_cachessess_mkkey$4;
  return_value_cachessess_mkkey$4=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  cache_del(cachemgr_ssess, return_value_cachessess_mkkey$4);
  void *return_value_cachessess_mkkey$5;
  return_value_cachessess_mkkey$5=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  void *return_value_cache_get$6;
  return_value_cache_get$6=cache_get(cachemgr_ssess, return_value_cachessess_mkkey$5);
  s2 = (struct ssl_session_st *)return_value_cache_get$6;
  if(s2 == ((struct ssl_session_st *)NULL))
    _mark_point("cachessess.t.c", 111);

  else
    _ck_assert_failed("cachessess.t.c", 111, "Assertion 's2 == NULL' failed", (const void *)"cache returned deleted session", (void *)0);
  SSL_SESSION_free(s1);
}

// cache_ssess_04
// file cachessess.t.c line 116
static void cache_ssess_04(signed int _i)
{
  tcase_fn_start("cache_ssess_04", "cachessess.t.c", 116);
  struct ssl_session_st *s1;
  struct ssl_session_st *s2;
  s1=ssl_session_from_file$link1("extra/pki/session.pem");
  if(!(s1 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachessess.t.c", 121);

  else
    _ck_assert_failed("cachessess.t.c", 121, "Assertion '!!s1' failed", (const void *)"creating session failed", (void *)0);
  signed int return_value_ssl_session_is_valid$1;
  return_value_ssl_session_is_valid$1=ssl_session_is_valid(s1);
  if(!(return_value_ssl_session_is_valid$1 == 0))
    _mark_point("cachessess.t.c", 122);

  else
    _ck_assert_failed("cachessess.t.c", 122, "Assertion 'ssl_session_is_valid(s1)' failed", (const void *)"session invalid", (void *)0);
  if(s1->references == 1)
    _mark_point("cachessess.t.c", 124);

  else
    _ck_assert_failed("cachessess.t.c", 124, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachessess_mkkey$2;
  return_value_cachessess_mkkey$2=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  void *return_value_cachessess_mkval$3;
  return_value_cachessess_mkval$3=cachessess_mkval(s1);
  cache_set(cachemgr_ssess, return_value_cachessess_mkkey$2, return_value_cachessess_mkval$3);
  if(s1->references == 1)
    _mark_point("cachessess.t.c", 126);

  else
    _ck_assert_failed("cachessess.t.c", 126, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachessess_mkkey$4;
  return_value_cachessess_mkkey$4=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  void *return_value_cache_get$5;
  return_value_cache_get$5=cache_get(cachemgr_ssess, return_value_cachessess_mkkey$4);
  s2 = (struct ssl_session_st *)return_value_cache_get$5;
  if(s1->references == 1)
    _mark_point("cachessess.t.c", 128);

  else
    _ck_assert_failed("cachessess.t.c", 128, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  if(!(s2 == ((struct ssl_session_st *)NULL)))
    _mark_point("cachessess.t.c", 129);

  else
    _ck_assert_failed("cachessess.t.c", 129, "Assertion '!!s2' failed", (const void *)"cache returned no session", (void *)0);
  if(s2->references == 1)
    _mark_point("cachessess.t.c", 130);

  else
    _ck_assert_failed("cachessess.t.c", 130, "Assertion 's2->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachessess_mkkey$6;
  return_value_cachessess_mkkey$6=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  void *return_value_cachessess_mkval$7;
  return_value_cachessess_mkval$7=cachessess_mkval(s1);
  cache_set(cachemgr_ssess, return_value_cachessess_mkkey$6, return_value_cachessess_mkval$7);
  if(s1->references == 1)
    _mark_point("cachessess.t.c", 132);

  else
    _ck_assert_failed("cachessess.t.c", 132, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachessess_mkkey$8;
  return_value_cachessess_mkkey$8=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  cache_del(cachemgr_ssess, return_value_cachessess_mkkey$8);
  if(s1->references == 1)
    _mark_point("cachessess.t.c", 134);

  else
    _ck_assert_failed("cachessess.t.c", 134, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachessess_mkkey$9;
  return_value_cachessess_mkkey$9=cachessess_mkkey(s1->session_id, (const unsigned long int)s1->session_id_length);
  void *return_value_cachessess_mkval$10;
  return_value_cachessess_mkval$10=cachessess_mkval(s1);
  cache_set(cachemgr_ssess, return_value_cachessess_mkkey$9, return_value_cachessess_mkval$10);
  if(s1->references == 1)
    _mark_point("cachessess.t.c", 136);

  else
    _ck_assert_failed("cachessess.t.c", 136, "Assertion 's1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  SSL_SESSION_free(s1);
  SSL_SESSION_free(s2);
}

// cache_tgcrt_01
// file cachetgcrt.t.c line 54
static void cache_tgcrt_01(signed int _i)
{
  tcase_fn_start("cache_tgcrt_01", "cachetgcrt.t.c", 54);
  struct cert *c1;
  struct cert *c2;
  c1=cert_new_load("extra/pki/targets/daniel.roe.ch.pem");
  if(!(c1 == ((struct cert *)NULL)))
    _mark_point("cachetgcrt.t.c", 59);

  else
    _ck_assert_failed("cachetgcrt.t.c", 59, "Assertion '!!c1' failed", (const void *)"loading certificate failed", (void *)0);
  void *return_value_cachetgcrt_mkkey$1;
  return_value_cachetgcrt_mkkey$1=cachetgcrt_mkkey("daniel.roe.ch");
  void *return_value_cachetgcrt_mkval$2;
  return_value_cachetgcrt_mkval$2=cachetgcrt_mkval(c1);
  cache_set(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$1, return_value_cachetgcrt_mkval$2);
  void *return_value_cachetgcrt_mkkey$3;
  return_value_cachetgcrt_mkkey$3=cachetgcrt_mkkey("daniel.roe.ch");
  void *return_value_cache_get$4;
  return_value_cache_get$4=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$3);
  c2 = (struct cert *)return_value_cache_get$4;
  if(c2 == c1)
    _mark_point("cachetgcrt.t.c", 62);

  else
    _ck_assert_failed("cachetgcrt.t.c", 62, "Assertion 'c2 == c1' failed", (const void *)"cache did not return same pointer", (void *)0);
  cert_free(c1);
  cert_free(c2);
}

// cache_tgcrt_02
// file cachetgcrt.t.c line 68
static void cache_tgcrt_02(signed int _i)
{
  tcase_fn_start("cache_tgcrt_02", "cachetgcrt.t.c", 68);
  struct cert *c;
  void *return_value_cachetgcrt_mkkey$1;
  return_value_cachetgcrt_mkkey$1=cachetgcrt_mkkey("daniel.roe.ch");
  void *return_value_cache_get$2;
  return_value_cache_get$2=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$1);
  c = (struct cert *)return_value_cache_get$2;
  if(c == ((struct cert *)NULL))
    _mark_point("cachetgcrt.t.c", 73);

  else
    _ck_assert_failed("cachetgcrt.t.c", 73, "Assertion 'c == NULL' failed", (const void *)"certificate was already in empty cache", (void *)0);
}

// cache_tgcrt_03
// file cachetgcrt.t.c line 77
static void cache_tgcrt_03(signed int _i)
{
  tcase_fn_start("cache_tgcrt_03", "cachetgcrt.t.c", 77);
  struct cert *c1;
  struct cert *c2;
  c1=cert_new_load("extra/pki/targets/daniel.roe.ch.pem");
  if(!(c1 == ((struct cert *)NULL)))
    _mark_point("cachetgcrt.t.c", 82);

  else
    _ck_assert_failed("cachetgcrt.t.c", 82, "Assertion '!!c1' failed", (const void *)"loading certificate failed", (void *)0);
  void *return_value_cachetgcrt_mkkey$1;
  return_value_cachetgcrt_mkkey$1=cachetgcrt_mkkey("daniel.roe.ch");
  void *return_value_cachetgcrt_mkval$2;
  return_value_cachetgcrt_mkval$2=cachetgcrt_mkval(c1);
  cache_set(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$1, return_value_cachetgcrt_mkval$2);
  void *return_value_cachetgcrt_mkkey$3;
  return_value_cachetgcrt_mkkey$3=cachetgcrt_mkkey("daniel.roe.ch");
  cache_del(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$3);
  void *return_value_cachetgcrt_mkkey$4;
  return_value_cachetgcrt_mkkey$4=cachetgcrt_mkkey("daniel.roe.ch");
  void *return_value_cache_get$5;
  return_value_cache_get$5=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$4);
  c2 = (struct cert *)return_value_cache_get$5;
  if(c2 == ((struct cert *)NULL))
    _mark_point("cachetgcrt.t.c", 86);

  else
    _ck_assert_failed("cachetgcrt.t.c", 86, "Assertion 'c2 == NULL' failed", (const void *)"cache returned deleted certificate", (void *)0);
  cert_free(c1);
}

// cache_tgcrt_04
// file cachetgcrt.t.c line 91
static void cache_tgcrt_04(signed int _i)
{
  tcase_fn_start("cache_tgcrt_04", "cachetgcrt.t.c", 91);
  struct cert *c1;
  struct cert *c2;
  c1=cert_new_load("extra/pki/targets/daniel.roe.ch.pem");
  if(!(c1 == ((struct cert *)NULL)))
    _mark_point("cachetgcrt.t.c", 96);

  else
    _ck_assert_failed("cachetgcrt.t.c", 96, "Assertion '!!c1' failed", (const void *)"loading certificate failed", (void *)0);
  if(c1->references == 1ul)
    _mark_point("cachetgcrt.t.c", 97);

  else
    _ck_assert_failed("cachetgcrt.t.c", 97, "Assertion 'c1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  void *return_value_cachetgcrt_mkkey$1;
  return_value_cachetgcrt_mkkey$1=cachetgcrt_mkkey("daniel.roe.ch");
  void *return_value_cachetgcrt_mkval$2;
  return_value_cachetgcrt_mkval$2=cachetgcrt_mkval(c1);
  cache_set(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$1, return_value_cachetgcrt_mkval$2);
  if(c1->references == 2ul)
    _mark_point("cachetgcrt.t.c", 99);

  else
    _ck_assert_failed("cachetgcrt.t.c", 99, "Assertion 'c1->references == 2' failed", (const void *)"refcount != 2", (void *)0);
  void *return_value_cachetgcrt_mkkey$3;
  return_value_cachetgcrt_mkkey$3=cachetgcrt_mkkey("daniel.roe.ch");
  void *return_value_cache_get$4;
  return_value_cache_get$4=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$3);
  c2 = (struct cert *)return_value_cache_get$4;
  if(c1->references == 3ul)
    _mark_point("cachetgcrt.t.c", 101);

  else
    _ck_assert_failed("cachetgcrt.t.c", 101, "Assertion 'c1->references == 3' failed", (const void *)"refcount != 3", (void *)0);
  void *return_value_cachetgcrt_mkkey$5;
  return_value_cachetgcrt_mkkey$5=cachetgcrt_mkkey("daniel.roe.ch");
  void *return_value_cachetgcrt_mkval$6;
  return_value_cachetgcrt_mkval$6=cachetgcrt_mkval(c1);
  cache_set(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$5, return_value_cachetgcrt_mkval$6);
  if(c1->references == 3ul)
    _mark_point("cachetgcrt.t.c", 103);

  else
    _ck_assert_failed("cachetgcrt.t.c", 103, "Assertion 'c1->references == 3' failed", (const void *)"refcount != 3", (void *)0);
  void *return_value_cachetgcrt_mkkey$7;
  return_value_cachetgcrt_mkkey$7=cachetgcrt_mkkey("daniel.roe.ch");
  cache_del(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$7);
  if(c1->references == 2ul)
    _mark_point("cachetgcrt.t.c", 105);

  else
    _ck_assert_failed("cachetgcrt.t.c", 105, "Assertion 'c1->references == 2' failed", (const void *)"refcount != 2", (void *)0);
  void *return_value_cachetgcrt_mkkey$8;
  return_value_cachetgcrt_mkkey$8=cachetgcrt_mkkey("daniel.roe.ch");
  void *return_value_cachetgcrt_mkval$9;
  return_value_cachetgcrt_mkval$9=cachetgcrt_mkval(c1);
  cache_set(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$8, return_value_cachetgcrt_mkval$9);
  if(c1->references == 3ul)
    _mark_point("cachetgcrt.t.c", 107);

  else
    _ck_assert_failed("cachetgcrt.t.c", 107, "Assertion 'c1->references == 3' failed", (const void *)"refcount != 3", (void *)0);
  cert_free(c1);
  if(c1->references == 2ul)
    _mark_point("cachetgcrt.t.c", 109);

  else
    _ck_assert_failed("cachetgcrt.t.c", 109, "Assertion 'c1->references == 2' failed", (const void *)"refcount != 2", (void *)0);
  cachemgr_fini();
  if(c1->references == 1ul)
    _mark_point("cachetgcrt.t.c", 111);

  else
    _ck_assert_failed("cachetgcrt.t.c", 111, "Assertion 'c1->references == 1' failed", (const void *)"refcount != 1", (void *)0);
  cert_free(c2);
  if(c1->references == 0ul)
    _mark_point("cachetgcrt.t.c", 114);

  else
    _ck_assert_failed("cachetgcrt.t.c", 114, "Assertion 'c1->references == 0' failed", (const void *)"refcount != 0", (void *)0);
  signed int return_value_cachemgr_preinit$10;
  return_value_cachemgr_preinit$10=cachemgr_preinit();
  if(!(return_value_cachemgr_preinit$10 == -1))
    _mark_point("cachetgcrt.t.c", 115);

  else
    _ck_assert_failed("cachetgcrt.t.c", 115, "Assertion 'cachemgr_preinit() != -1' failed", (const void *)"reinit", (void *)0);
}

// cache_types_01
// file cachemgr.t.c line 37
static void cache_types_01(signed int _i)
{
  tcase_fn_start("cache_types_01", "cachemgr.t.c", 37);
  _mark_point("cachemgr.t.c", 39);
}

// cachedsess_begin_cb
// file cachedsess.c line 74
static unsigned int cachedsess_begin_cb(void)
{
  return (unsigned int)0;
}

// cachedsess_del_cb
// file cachedsess.c line 92
static void cachedsess_del_cb(unsigned int it)
{
  kh_del_dynbufmap_t(dstsessmap, it);
}

// cachedsess_end_cb
// file cachedsess.c line 80
static unsigned int cachedsess_end_cb(void)
{
  return dstsessmap->n_buckets;
}

// cachedsess_exist_cb
// file cachedsess.c line 86
static signed int cachedsess_exist_cb(unsigned int it)
{
  return (signed int)!((dstsessmap->flags[(signed long int)(it >> 4)] >> ((it & 0xfU) << 1) & (unsigned int)3) != 0u);
}

// cachedsess_fini_cb
// file cachedsess.c line 161
static void cachedsess_fini_cb(void)
{
  kh_destroy_dynbufmap_t(dstsessmap);
}

// cachedsess_free_key_cb
// file cachedsess.c line 110
static void cachedsess_free_key_cb(void *key)
{
  dynbuf_free((struct dynbuf *)key);
}

// cachedsess_free_val_cb
// file cachedsess.c line 116
static void cachedsess_free_val_cb(void *val)
{
  dynbuf_free((struct dynbuf *)val);
}

// cachedsess_get_cb
// file cachedsess.c line 98
static unsigned int cachedsess_get_cb(void *key)
{
  unsigned int return_value_kh_get_dynbufmap_t$1;
  return_value_kh_get_dynbufmap_t$1=kh_get_dynbufmap_t(dstsessmap, (struct dynbuf *)key);
  return return_value_kh_get_dynbufmap_t$1;
}

// cachedsess_get_key_cb
// file cachedsess.c line 122
static void * cachedsess_get_key_cb(unsigned int it)
{
  return (void *)dstsessmap->keys[(signed long int)it];
}

// cachedsess_get_val_cb
// file cachedsess.c line 128
static void * cachedsess_get_val_cb(unsigned int it)
{
  return (void *)dstsessmap->vals[(signed long int)it];
}

// cachedsess_init_cb
// file cachedsess.h line 40
void cachedsess_init_cb(struct cache *cache)
{
  dstsessmap=kh_init_dynbufmap_t();
  cache->begin_cb = cachedsess_begin_cb;
  cache->end_cb = cachedsess_end_cb;
  cache->exist_cb = cachedsess_exist_cb;
  cache->del_cb = cachedsess_del_cb;
  cache->get_cb = cachedsess_get_cb;
  cache->put_cb = cachedsess_put_cb;
  cache->free_key_cb = cachedsess_free_key_cb;
  cache->free_val_cb = cachedsess_free_val_cb;
  cache->get_key_cb = cachedsess_get_key_cb;
  cache->get_val_cb = cachedsess_get_val_cb;
  cache->set_val_cb = cachedsess_set_val_cb;
  cache->unpackverify_val_cb = cachedsess_unpackverify_val_cb;
  cache->fini_cb = cachedsess_fini_cb;
}

// cachedsess_mkkey
// file cachedsess.h line 42
void * cachedsess_mkkey(struct sockaddr *addr, const unsigned int addrlen, const char *sni)
{
  struct dynbuf tmp;
  struct dynbuf *db;
  signed short int port;
  unsigned long int snilen;
  switch((signed int)((struct sockaddr_storage *)addr)->ss_family)
  {
    case 2:
    {
      tmp.buf = (unsigned char *)&((struct sockaddr_in *)addr)->sin_addr;
      tmp.sz = sizeof(struct in_addr) /*4ul*/ ;
      port = (signed short int)((struct sockaddr_in *)addr)->sin_port;
      break;
    }
    case 10:
    {
      tmp.buf = (unsigned char *)&((struct sockaddr_in6 *)addr)->sin6_addr;
      tmp.sz = sizeof(struct in6_addr) /*16ul*/ ;
      port = (signed short int)((struct sockaddr_in6 *)addr)->sin6_port;
      break;
    }
    default:
      return (void *)0;
  }
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!(sni == ((const char *)NULL)))
  {
    return_value_strlen$1=strlen(sni);
    tmp_if_expr$2 = return_value_strlen$1;
  }

  else
    tmp_if_expr$2 = (unsigned long int)0;
  snilen = tmp_if_expr$2;
  db=dynbuf_new_alloc(tmp.sz + sizeof(signed short int) /*2ul*/  + snilen);
  if(db == ((struct dynbuf *)NULL))
    return (void *)0;

  else
  {
    memcpy((void *)db->buf, (const void *)tmp.buf, tmp.sz);
    memcpy((void *)(db->buf + (signed long int)tmp.sz), (const void *)(char *)&port, sizeof(signed short int) /*2ul*/ );
    memcpy((void *)(db->buf + (signed long int)tmp.sz + (signed long int)sizeof(signed short int) /*2ul*/ ), (const void *)sni, snilen);
    return (void *)db;
  }
}

// cachedsess_mkval
// file cachedsess.h line 44
void * cachedsess_mkval(struct ssl_session_st *sess)
{
  struct dynbuf *db;
  unsigned char *p;
  unsigned long int asn1sz;
  signed int return_value_i2d_SSL_SESSION$1;
  return_value_i2d_SSL_SESSION$1=i2d_SSL_SESSION(sess, (unsigned char **)(void *)0);
  asn1sz = (unsigned long int)return_value_i2d_SSL_SESSION$1;
  _Bool tmp_if_expr$2;
  if(asn1sz == 0ul)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    db=dynbuf_new_alloc(asn1sz);
    tmp_if_expr$2 = !(db != ((struct dynbuf *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return (void *)0;

  else
  {
    p = db->buf;
    i2d_SSL_SESSION(sess, &p);
    return (void *)db;
  }
}

// cachedsess_put_cb
// file cachedsess.c line 104
static unsigned int cachedsess_put_cb(void *key, signed int *ret)
{
  unsigned int return_value_kh_put_dynbufmap_t$1;
  return_value_kh_put_dynbufmap_t$1=kh_put_dynbufmap_t(dstsessmap, (struct dynbuf *)key, ret);
  return return_value_kh_put_dynbufmap_t$1;
}

// cachedsess_set_val_cb
// file cachedsess.c line 134
static void cachedsess_set_val_cb(unsigned int it, void *val)
{
  dstsessmap->vals[(signed long int)it] = (struct dynbuf *)val;
}

// cachedsess_suite
// file cachedsess.t.c line 151
struct Suite * cachedsess_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("cachedsess");
  tc=tcase_create("cache_dsess");
  tcase_add_checked_fixture(tc, cachemgr_setup, cachemgr_teardown);
  _tcase_add_test(tc, cache_dsess_01, "cache_dsess_01", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_dsess_02, "cache_dsess_02", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_dsess_03, "cache_dsess_03", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_dsess_04, "cache_dsess_04", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// cachedsess_unpackverify_val_cb
// file cachedsess.c line 140
static void * cachedsess_unpackverify_val_cb(void *val, signed int copy)
{
  struct dynbuf *valbuf = (struct dynbuf *)val;
  struct ssl_session_st *sess;
  const unsigned char *p = (const unsigned char *)valbuf->buf;
  sess=d2i_SSL_SESSION((struct ssl_session_st **)(void *)0, &p, (signed long int)valbuf->sz);
  if(sess == ((struct ssl_session_st *)NULL))
    return (void *)0;

  else
  {
    signed int return_value_ssl_session_is_valid$1;
    return_value_ssl_session_is_valid$1=ssl_session_is_valid(sess);
    if(return_value_ssl_session_is_valid$1 == 0)
    {
      SSL_SESSION_free(sess);
      return (void *)0;
    }

    else
      if(!(copy == 0))
        return (void *)sess;

      else
      {
        SSL_SESSION_free(sess);
        return (void *)-1;
      }
  }
}

// cachefkcrt_begin_cb
// file cachefkcrt.c line 62
static unsigned int cachefkcrt_begin_cb(void)
{
  return (unsigned int)0;
}

// cachefkcrt_del_cb
// file cachefkcrt.c line 80
static void cachefkcrt_del_cb(unsigned int it)
{
  kh_del_sha1map_t(certmap, it);
}

// cachefkcrt_end_cb
// file cachefkcrt.c line 68
static unsigned int cachefkcrt_end_cb(void)
{
  return certmap->n_buckets;
}

// cachefkcrt_exist_cb
// file cachefkcrt.c line 74
static signed int cachefkcrt_exist_cb(unsigned int it)
{
  return (signed int)!((certmap->flags[(signed long int)(it >> 4)] >> ((it & 0xfU) << 1) & (unsigned int)3) != 0u);
}

// cachefkcrt_fini_cb
// file cachefkcrt.c line 140
static void cachefkcrt_fini_cb(void)
{
  kh_destroy_sha1map_t(certmap);
}

// cachefkcrt_free_key_cb
// file cachefkcrt.c line 98
static void cachefkcrt_free_key_cb(void *key)
{
  free(key);
}

// cachefkcrt_free_val_cb
// file cachefkcrt.c line 104
static void cachefkcrt_free_val_cb(void *val)
{
  X509_free((struct x509_st *)val);
}

// cachefkcrt_get_cb
// file cachefkcrt.c line 86
static unsigned int cachefkcrt_get_cb(void *key)
{
  unsigned int return_value_kh_get_sha1map_t$1;
  return_value_kh_get_sha1map_t$1=kh_get_sha1map_t(certmap, key);
  return return_value_kh_get_sha1map_t$1;
}

// cachefkcrt_get_key_cb
// file cachefkcrt.c line 110
static void * cachefkcrt_get_key_cb(unsigned int it)
{
  return certmap->keys[(signed long int)it];
}

// cachefkcrt_get_val_cb
// file cachefkcrt.c line 116
static void * cachefkcrt_get_val_cb(unsigned int it)
{
  return certmap->vals[(signed long int)it];
}

// cachefkcrt_init_cb
// file cachefkcrt.c line 146
void cachefkcrt_init_cb(struct cache *cache)
{
  certmap=kh_init_sha1map_t();
  cache->begin_cb = cachefkcrt_begin_cb;
  cache->end_cb = cachefkcrt_end_cb;
  cache->exist_cb = cachefkcrt_exist_cb;
  cache->del_cb = cachefkcrt_del_cb;
  cache->get_cb = cachefkcrt_get_cb;
  cache->put_cb = cachefkcrt_put_cb;
  cache->free_key_cb = cachefkcrt_free_key_cb;
  cache->free_val_cb = cachefkcrt_free_val_cb;
  cache->get_key_cb = cachefkcrt_get_key_cb;
  cache->get_val_cb = cachefkcrt_get_val_cb;
  cache->set_val_cb = cachefkcrt_set_val_cb;
  cache->unpackverify_val_cb = cachefkcrt_unpackverify_val_cb;
  cache->fini_cb = cachefkcrt_fini_cb;
}

// cachefkcrt_mkkey
// file cachefkcrt.h line 39
void * cachefkcrt_mkkey(struct x509_st *keycrt)
{
  unsigned char *fpr;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)20);
  fpr = (unsigned char *)return_value_malloc$1;
  if(fpr == ((unsigned char *)NULL))
    return (void *)0;

  else
  {
    ssl_x509_fingerprint_sha1(keycrt, fpr);
    return (void *)fpr;
  }
}

// cachefkcrt_mkval
// file cachefkcrt.h line 40
void * cachefkcrt_mkval(struct x509_st *valcrt)
{
  ssl_x509_refcount_inc(valcrt);
  return (void *)valcrt;
}

// cachefkcrt_put_cb
// file cachefkcrt.c line 92
static unsigned int cachefkcrt_put_cb(void *key, signed int *ret)
{
  unsigned int return_value_kh_put_sha1map_t$1;
  return_value_kh_put_sha1map_t$1=kh_put_sha1map_t(certmap, key, ret);
  return return_value_kh_put_sha1map_t$1;
}

// cachefkcrt_set_val_cb
// file cachefkcrt.c line 122
static void cachefkcrt_set_val_cb(unsigned int it, void *val)
{
  certmap->vals[(signed long int)it] = val;
}

// cachefkcrt_suite
// file cachefkcrt.t.c line 122
struct Suite * cachefkcrt_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("cachefkcrt");
  tc=tcase_create("cache_fkcrt");
  tcase_add_checked_fixture(tc, cachemgr_setup$link2, cachemgr_teardown$link2);
  _tcase_add_test(tc, cache_fkcrt_01, "cache_fkcrt_01", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_fkcrt_02, "cache_fkcrt_02", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_fkcrt_03, "cache_fkcrt_03", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_fkcrt_04, "cache_fkcrt_04", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// cachefkcrt_unpackverify_val_cb
// file cachefkcrt.c line 128
static void * cachefkcrt_unpackverify_val_cb(void *val, signed int copy)
{
  signed int return_value_ssl_x509_is_valid$1;
  return_value_ssl_x509_is_valid$1=ssl_x509_is_valid((struct x509_st *)val);
  if(return_value_ssl_x509_is_valid$1 == 0)
    return (void *)0;

  else
    if(!(copy == 0))
    {
      ssl_x509_refcount_inc((struct x509_st *)val);
      return val;
    }

    else
      return (void *)-1;
}

// cachemgr_fini
// file cachemgr.h line 45
void cachemgr_fini(void)
{
  cache_free(cachemgr_dsess);
  cache_free(cachemgr_ssess);
  cache_free(cachemgr_tgcrt);
  cache_free(cachemgr_fkcrt);
}

// cachemgr_gc
// file cachemgr.c line 122
void cachemgr_gc(void)
{
  unsigned long int fkcrt_thr;
  unsigned long int dsess_thr;
  unsigned long int ssess_thr;
  signed int rv;
  rv=pthread_create(&fkcrt_thr, (const union pthread_attr_t *)(void *)0, cachemgr_gc_thread, (void *)cachemgr_fkcrt);
  if(!(rv == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_create failed: %s\n", return_value_strerror$1);
  }

  rv=pthread_create(&ssess_thr, (const union pthread_attr_t *)(void *)0, cachemgr_gc_thread, (void *)cachemgr_ssess);
  if(!(rv == 0))
  {
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_create failed: %s\n", return_value_strerror$2);
  }

  rv=pthread_create(&dsess_thr, (const union pthread_attr_t *)(void *)0, cachemgr_gc_thread, (void *)cachemgr_dsess);
  if(!(rv == 0))
  {
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_create failed: %s\n", return_value_strerror$3);
  }

  rv=pthread_join(fkcrt_thr, (void **)(void *)0);
  if(!(rv == 0))
  {
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_join failed: %s\n", return_value_strerror$4);
  }

  rv=pthread_join(ssess_thr, (void **)(void *)0);
  if(!(rv == 0))
  {
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_join failed: %s\n", return_value_strerror$5);
  }

  rv=pthread_join(dsess_thr, (void **)(void *)0);
  if(!(rv == 0))
  {
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(rv);
    log_err_printf("cachemgr_gc: pthread_join failed: %s\n", return_value_strerror$6);
  }

}

// cachemgr_gc_thread
// file cachemgr.c line 53
static void * cachemgr_gc_thread(void *arg)
{
  cache_gc((struct cache *)arg);
  return (void *)0;
}

// cachemgr_init
// file cachemgr.c line 92
signed int cachemgr_init(void)
{
  cache_reinit(cachemgr_fkcrt);
  cache_reinit(cachemgr_tgcrt);
  cache_reinit(cachemgr_ssess);
  cache_reinit(cachemgr_dsess);
  return 0;
}

// cachemgr_preinit
// file cachemgr.h line 43
signed int cachemgr_preinit(void)
{
  cachemgr_fkcrt=cache_new(cachefkcrt_init_cb);
  if(!(cachemgr_fkcrt == ((struct cache *)NULL)))
  {
    cachemgr_tgcrt=cache_new(cachetgcrt_init_cb);
    if(!(cachemgr_tgcrt == ((struct cache *)NULL)))
    {
      cachemgr_ssess=cache_new(cachessess_init_cb);
      if(!(cachemgr_ssess == ((struct cache *)NULL)))
      {
        cachemgr_dsess=cache_new(cachedsess_init_cb);
        if(!(cachemgr_dsess == ((struct cache *)NULL)))
          return 0;


      out1:
        ;
        cache_free(cachemgr_ssess);
      }


    out2:
      ;
      cache_free(cachemgr_tgcrt);
    }


  out3:
    ;
    cache_free(cachemgr_fkcrt);
  }


out4:
  ;
  return -1;
}

// cachemgr_setup
// file cachedsess.t.c line 61
static void cachemgr_setup(void)
{
  signed int return_value_ssl_init$1;
  return_value_ssl_init$1=ssl_init();
  _Bool tmp_if_expr$3;
  signed int return_value_cachemgr_preinit$2;
  if(return_value_ssl_init$1 == -1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_cachemgr_preinit$2=cachemgr_preinit();
    tmp_if_expr$3 = return_value_cachemgr_preinit$2 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    exit(1);

  addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  memset((void *)&addr, 0, (unsigned long int)addrlen);
  addr.ss_family = (unsigned short int)2;
}

// cachemgr_setup$link1
// file cachessess.t.c line 56
static void cachemgr_setup$link1(void)
{
  signed int return_value_ssl_init$1$link1;
  return_value_ssl_init$1$link1=ssl_init();
  _Bool tmp_if_expr$3$link1;
  signed int return_value_cachemgr_preinit$2$link1;
  if(return_value_ssl_init$1$link1 == -1)
    tmp_if_expr$3$link1 = (_Bool)1;

  else
  {
    return_value_cachemgr_preinit$2$link1=cachemgr_preinit();
    tmp_if_expr$3$link1 = return_value_cachemgr_preinit$2$link1 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3$link1)
    exit(1);

}

// cachemgr_setup$link2
// file cachefkcrt.t.c line 40
static void cachemgr_setup$link2(void)
{
  signed int return_value_ssl_init$1$link2;
  return_value_ssl_init$1$link2=ssl_init();
  _Bool tmp_if_expr$3$link2;
  signed int return_value_cachemgr_preinit$2$link2;
  if(return_value_ssl_init$1$link2 == -1)
    tmp_if_expr$3$link2 = (_Bool)1;

  else
  {
    return_value_cachemgr_preinit$2$link2=cachemgr_preinit();
    tmp_if_expr$3$link2 = return_value_cachemgr_preinit$2$link2 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3$link2)
    exit(1);

}

// cachemgr_setup$link3
// file cachetgcrt.t.c line 41
static void cachemgr_setup$link3(void)
{
  signed int return_value_ssl_init$1$link3;
  return_value_ssl_init$1$link3=ssl_init();
  _Bool tmp_if_expr$3$link3;
  signed int return_value_cachemgr_preinit$2$link3;
  if(return_value_ssl_init$1$link3 == -1)
    tmp_if_expr$3$link3 = (_Bool)1;

  else
  {
    return_value_cachemgr_preinit$2$link3=cachemgr_preinit();
    tmp_if_expr$3$link3 = return_value_cachemgr_preinit$2$link3 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3$link3)
    exit(1);

}

// cachemgr_suite
// file cachemgr.t.c line 45
struct Suite * cachemgr_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("cachemgr");
  tc=tcase_create("cache_types");
  _tcase_add_test(tc, cache_types_01, "cache_types_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// cachemgr_teardown
// file cachedsess.t.c line 71
static void cachemgr_teardown(void)
{
  cachemgr_fini();
  ssl_fini();
}

// cachemgr_teardown$link1
// file cachessess.t.c line 63
static void cachemgr_teardown$link1(void)
{
  cachemgr_fini();
  ssl_fini();
}

// cachemgr_teardown$link2
// file cachefkcrt.t.c line 47
static void cachemgr_teardown$link2(void)
{
  cachemgr_fini();
  ssl_fini();
}

// cachemgr_teardown$link3
// file cachetgcrt.t.c line 48
static void cachemgr_teardown$link3(void)
{
  cachemgr_fini();
  ssl_fini();
}

// cachessess_begin_cb
// file cachessess.c line 72
static unsigned int cachessess_begin_cb(void)
{
  return (unsigned int)0;
}

// cachessess_del_cb
// file cachessess.c line 90
static void cachessess_del_cb(unsigned int it)
{
  kh_del_dynbufmap_t$link1(srcsessmap, it);
}

// cachessess_end_cb
// file cachessess.c line 78
static unsigned int cachessess_end_cb(void)
{
  return srcsessmap->n_buckets;
}

// cachessess_exist_cb
// file cachessess.c line 84
static signed int cachessess_exist_cb(unsigned int it)
{
  return (signed int)!((srcsessmap->flags[(signed long int)(it >> 4)] >> ((it & 0xfU) << 1) & (unsigned int)3) != 0u);
}

// cachessess_fini_cb
// file cachessess.c line 159
static void cachessess_fini_cb(void)
{
  kh_destroy_dynbufmap_t$link1(srcsessmap);
}

// cachessess_free_key_cb
// file cachessess.c line 108
static void cachessess_free_key_cb(void *key)
{
  dynbuf_free((struct dynbuf *)key);
}

// cachessess_free_val_cb
// file cachessess.c line 114
static void cachessess_free_val_cb(void *val)
{
  dynbuf_free((struct dynbuf *)val);
}

// cachessess_get_cb
// file cachessess.c line 96
static unsigned int cachessess_get_cb(void *key)
{
  unsigned int return_value_kh_get_dynbufmap_t$1;
  return_value_kh_get_dynbufmap_t$1=kh_get_dynbufmap_t$link1(srcsessmap, (struct dynbuf *)key);
  return return_value_kh_get_dynbufmap_t$1;
}

// cachessess_get_key_cb
// file cachessess.c line 120
static void * cachessess_get_key_cb(unsigned int it)
{
  return (void *)srcsessmap->keys[(signed long int)it];
}

// cachessess_get_val_cb
// file cachessess.c line 126
static void * cachessess_get_val_cb(unsigned int it)
{
  return (void *)srcsessmap->vals[(signed long int)it];
}

// cachessess_init_cb
// file cachessess.h line 37
void cachessess_init_cb(struct cache *cache)
{
  srcsessmap=kh_init_dynbufmap_t$link1();
  cache->begin_cb = cachessess_begin_cb;
  cache->end_cb = cachessess_end_cb;
  cache->exist_cb = cachessess_exist_cb;
  cache->del_cb = cachessess_del_cb;
  cache->get_cb = cachessess_get_cb;
  cache->put_cb = cachessess_put_cb;
  cache->free_key_cb = cachessess_free_key_cb;
  cache->free_val_cb = cachessess_free_val_cb;
  cache->get_key_cb = cachessess_get_key_cb;
  cache->get_val_cb = cachessess_get_val_cb;
  cache->set_val_cb = cachessess_set_val_cb;
  cache->unpackverify_val_cb = cachessess_unpackverify_val_cb;
  cache->fini_cb = cachessess_fini_cb;
}

// cachessess_mkkey
// file cachessess.h line 39
void * cachessess_mkkey(const unsigned char *id, const unsigned long int idlen)
{
  struct dynbuf *return_value_dynbuf_new_copy$1;
  return_value_dynbuf_new_copy$1=dynbuf_new_copy(id, idlen);
  return (void *)return_value_dynbuf_new_copy$1;
}

// cachessess_mkval
// file cachessess.h line 41
void * cachessess_mkval(struct ssl_session_st *sess)
{
  struct dynbuf *db;
  unsigned char *p;
  unsigned long int asn1sz;
  signed int return_value_i2d_SSL_SESSION$1;
  return_value_i2d_SSL_SESSION$1=i2d_SSL_SESSION(sess, (unsigned char **)(void *)0);
  asn1sz = (unsigned long int)return_value_i2d_SSL_SESSION$1;
  _Bool tmp_if_expr$2;
  if(asn1sz == 0ul)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    db=dynbuf_new_alloc(asn1sz);
    tmp_if_expr$2 = !(db != ((struct dynbuf *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return (void *)0;

  else
  {
    p = db->buf;
    i2d_SSL_SESSION(sess, &p);
    return (void *)db;
  }
}

// cachessess_put_cb
// file cachessess.c line 102
static unsigned int cachessess_put_cb(void *key, signed int *ret)
{
  unsigned int return_value_kh_put_dynbufmap_t$1;
  return_value_kh_put_dynbufmap_t$1=kh_put_dynbufmap_t$link1(srcsessmap, (struct dynbuf *)key, ret);
  return return_value_kh_put_dynbufmap_t$1;
}

// cachessess_set_val_cb
// file cachessess.c line 132
static void cachessess_set_val_cb(unsigned int it, void *val)
{
  srcsessmap->vals[(signed long int)it] = (struct dynbuf *)val;
}

// cachessess_suite
// file cachessess.t.c line 143
struct Suite * cachessess_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("cachessess");
  tc=tcase_create("cache_ssess");
  tcase_add_checked_fixture(tc, cachemgr_setup$link1, cachemgr_teardown$link1);
  _tcase_add_test(tc, cache_ssess_01, "cache_ssess_01", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_ssess_02, "cache_ssess_02", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_ssess_03, "cache_ssess_03", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_ssess_04, "cache_ssess_04", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// cachessess_unpackverify_val_cb
// file cachessess.c line 138
static void * cachessess_unpackverify_val_cb(void *val, signed int copy)
{
  struct dynbuf *valbuf = (struct dynbuf *)val;
  struct ssl_session_st *sess;
  const unsigned char *p = (const unsigned char *)valbuf->buf;
  sess=d2i_SSL_SESSION((struct ssl_session_st **)(void *)0, &p, (signed long int)valbuf->sz);
  if(sess == ((struct ssl_session_st *)NULL))
    return (void *)0;

  else
  {
    signed int return_value_ssl_session_is_valid$1;
    return_value_ssl_session_is_valid$1=ssl_session_is_valid(sess);
    if(return_value_ssl_session_is_valid$1 == 0)
    {
      SSL_SESSION_free(sess);
      return (void *)0;
    }

    else
      if(!(copy == 0))
        return (void *)sess;

      else
      {
        SSL_SESSION_free(sess);
        return (void *)-1;
      }
  }
}

// cachetgcrt_begin_cb
// file cachetgcrt.c line 47
static unsigned int cachetgcrt_begin_cb(void)
{
  return (unsigned int)0;
}

// cachetgcrt_del_cb
// file cachetgcrt.c line 65
static void cachetgcrt_del_cb(unsigned int it)
{
  kh_del_cstrmap_t(certmap$link1, it);
}

// cachetgcrt_end_cb
// file cachetgcrt.c line 53
static unsigned int cachetgcrt_end_cb(void)
{
  return certmap$link1->n_buckets;
}

// cachetgcrt_exist_cb
// file cachetgcrt.c line 59
static signed int cachetgcrt_exist_cb(unsigned int it)
{
  return (signed int)!((certmap$link1->flags[(signed long int)(it >> 4)] >> ((it & 0xfU) << 1) & (unsigned int)3) != 0u);
}

// cachetgcrt_fini_cb
// file cachetgcrt.c line 123
static void cachetgcrt_fini_cb(void)
{
  kh_destroy_cstrmap_t(certmap$link1);
}

// cachetgcrt_free_key_cb
// file cachetgcrt.c line 83
static void cachetgcrt_free_key_cb(void *key)
{
  free(key);
}

// cachetgcrt_free_val_cb
// file cachetgcrt.c line 89
static void cachetgcrt_free_val_cb(void *val)
{
  cert_free((struct cert *)val);
}

// cachetgcrt_get_cb
// file cachetgcrt.c line 71
static unsigned int cachetgcrt_get_cb(void *key)
{
  unsigned int return_value_kh_get_cstrmap_t$1;
  return_value_kh_get_cstrmap_t$1=kh_get_cstrmap_t(certmap$link1, (char *)key);
  return return_value_kh_get_cstrmap_t$1;
}

// cachetgcrt_get_key_cb
// file cachetgcrt.c line 95
static void * cachetgcrt_get_key_cb(unsigned int it)
{
  return (void *)certmap$link1->keys[(signed long int)it];
}

// cachetgcrt_get_val_cb
// file cachetgcrt.c line 101
static void * cachetgcrt_get_val_cb(unsigned int it)
{
  return certmap$link1->vals[(signed long int)it];
}

// cachetgcrt_init_cb
// file cachetgcrt.c line 129
void cachetgcrt_init_cb(struct cache *cache)
{
  certmap$link1=kh_init_cstrmap_t();
  cache->begin_cb = cachetgcrt_begin_cb;
  cache->end_cb = cachetgcrt_end_cb;
  cache->exist_cb = cachetgcrt_exist_cb;
  cache->del_cb = cachetgcrt_del_cb;
  cache->get_cb = cachetgcrt_get_cb;
  cache->put_cb = cachetgcrt_put_cb;
  cache->free_key_cb = cachetgcrt_free_key_cb;
  cache->free_val_cb = cachetgcrt_free_val_cb;
  cache->get_key_cb = cachetgcrt_get_key_cb;
  cache->get_val_cb = cachetgcrt_get_val_cb;
  cache->set_val_cb = cachetgcrt_set_val_cb;
  cache->unpackverify_val_cb = cachetgcrt_unpackverify_val_cb;
  cache->fini_cb = cachetgcrt_fini_cb;
}

// cachetgcrt_mkkey
// file cachetgcrt.h line 38
void * cachetgcrt_mkkey(const char *keycn)
{
  char *return_value_strdup$1;
  return_value_strdup$1=strdup(keycn);
  return (void *)return_value_strdup$1;
}

// cachetgcrt_mkval
// file cachetgcrt.h line 39
void * cachetgcrt_mkval(struct cert *valcrt)
{
  cert_refcount_inc(valcrt);
  return (void *)valcrt;
}

// cachetgcrt_put_cb
// file cachetgcrt.c line 77
static unsigned int cachetgcrt_put_cb(void *key, signed int *ret)
{
  unsigned int return_value_kh_put_cstrmap_t$1;
  return_value_kh_put_cstrmap_t$1=kh_put_cstrmap_t(certmap$link1, (char *)key, ret);
  return return_value_kh_put_cstrmap_t$1;
}

// cachetgcrt_set_val_cb
// file cachetgcrt.c line 107
static void cachetgcrt_set_val_cb(unsigned int it, void *val)
{
  certmap$link1->vals[(signed long int)it] = val;
}

// cachetgcrt_suite
// file cachetgcrt.t.c line 120
struct Suite * cachetgcrt_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("cachetgcrt");
  tc=tcase_create("cache_tgcrt");
  tcase_add_checked_fixture(tc, cachemgr_setup$link3, cachemgr_teardown$link3);
  _tcase_add_test(tc, cache_tgcrt_01, "cache_tgcrt_01", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_tgcrt_02, "cache_tgcrt_02", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_tgcrt_03, "cache_tgcrt_03", 0, 0, 0, 1);
  _tcase_add_test(tc, cache_tgcrt_04, "cache_tgcrt_04", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// cachetgcrt_unpackverify_val_cb
// file cachetgcrt.c line 113
static void * cachetgcrt_unpackverify_val_cb(void *val, signed int copy)
{
  if(!(copy == 0))
  {
    cert_refcount_inc((struct cert *)val);
    return val;
  }

  else
    return (void *)-1;
}

// cert_free
// file cert.h line 53
void cert_free(struct cert *c)
{
  pthread_mutex_lock(&c->mutex);
  c->references = c->references - 1ul;
  if(!(c->references == 0ul))
    pthread_mutex_unlock(&c->mutex);

  else
  {
    pthread_mutex_unlock(&c->mutex);
    pthread_mutex_destroy(&c->mutex);
    if(!(c->key == ((struct evp_pkey_st *)NULL)))
      EVP_PKEY_free(c->key);

    if(!(c->crt == ((struct x509_st *)NULL)))
      X509_free(c->crt);

    if(!(c->chain == ((struct stack_st_X509 *)NULL)))
      sk_pop_free((struct stack_st *)c->chain, (void (*)(void *))(1 != 0 ? X509_free : (void (*)(struct x509_st *))0));

    free((void *)c);
  }
}

// cert_new
// file cert.c line 40
struct cert * cert_new(void)
{
  struct cert *c;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct cert) /*72ul*/ );
  c = (struct cert *)return_value_malloc$1;
  if(c == ((struct cert *)NULL))
    return (struct cert *)(void *)0;

  else
  {
    memset((void *)c, 0, sizeof(struct cert) /*72ul*/ );
    c->references = (unsigned long int)1;
    pthread_mutex_init(&c->mutex, (const union anonymous$15 *)(void *)0);
    return c;
  }
}

// cert_new3
// file cert.c line 57
struct cert * cert_new3(struct evp_pkey_st *key, struct x509_st *crt, struct stack_st_X509 *chain)
{
  struct cert *c;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct cert) /*72ul*/ );
  c = (struct cert *)return_value_malloc$1;
  if(c == ((struct cert *)NULL))
    return (struct cert *)(void *)0;

  else
  {
    c->key = key;
    c->crt = crt;
    c->chain = chain;
    c->references = (unsigned long int)1;
    pthread_mutex_init(&c->mutex, (const union anonymous$15 *)(void *)0);
    return c;
  }
}

// cert_new3_copy
// file cert.c line 76
struct cert * cert_new3_copy(struct evp_pkey_st *key, struct x509_st *crt, struct stack_st_X509 *chain)
{
  struct cert *c;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct cert) /*72ul*/ );
  c = (struct cert *)return_value_malloc$1;
  signed int return_value_sk_num$3;
  if(c == ((struct cert *)NULL))
    return (struct cert *)(void *)0;

  else
  {
    c->key = key;
    ssl_key_refcount_inc(c->key);
    c->crt = crt;
    ssl_x509_refcount_inc(c->crt);
    struct stack_st *return_value_sk_dup$2;
    return_value_sk_dup$2=sk_dup((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0));
    c->chain = (struct stack_st_X509 *)return_value_sk_dup$2;
    signed int i = 0;
    do
    {
      return_value_sk_num$3=sk_num((struct stack_st *)c->chain);
      if(i >= return_value_sk_num$3)
        break;

      void *return_value_sk_value$4;
      return_value_sk_value$4=sk_value((struct stack_st *)c->chain, i);
      ssl_x509_refcount_inc((struct x509_st *)return_value_sk_value$4);
      i = i + 1;
    }
    while((_Bool)1);
    c->references = (unsigned long int)1;
    pthread_mutex_init(&c->mutex, (const union anonymous$15 *)(void *)0);
    return c;
  }
}

// cert_new_load
// file cert.h line 46
struct cert * cert_new_load(const char *filename)
{
  struct cert *c;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct cert) /*72ul*/ );
  c = (struct cert *)return_value_malloc$1;
  if(c == ((struct cert *)NULL))
    return (struct cert *)(void *)0;

  else
  {
    memset((void *)c, 0, sizeof(struct cert) /*72ul*/ );
    signed int return_value_ssl_x509chain_load$2;
    return_value_ssl_x509chain_load$2=ssl_x509chain_load(&c->crt, &c->chain, filename);
    if(return_value_ssl_x509chain_load$2 == -1)
    {
      free((void *)c);
      return (struct cert *)(void *)0;
    }

    else
    {
      c->key=ssl_key_load(filename);
      if(c->key == ((struct evp_pkey_st *)NULL))
      {
        X509_free(c->crt);
        if(!(c->chain == ((struct stack_st_X509 *)NULL)))
          sk_pop_free((struct stack_st *)c->chain, (void (*)(void *))(1 != 0 ? X509_free : (void (*)(struct x509_st *))0));

        free((void *)c);
        return (struct cert *)(void *)0;
      }

      else
      {
        c->references = (unsigned long int)1;
        pthread_mutex_init(&c->mutex, (const union anonymous$15 *)(void *)0);
        return c;
      }
    }
  }
}

// cert_new_load_01
// file cert.t.c line 39
static void cert_new_load_01(signed int _i)
{
  tcase_fn_start("cert_new_load_01", "cert.t.c", 39);
  struct cert *c;
  c=cert_new_load("extra/pki/targets/daniel.roe.ch.pem");
  if(!(c == ((struct cert *)NULL)))
    _mark_point("cert.t.c", 44);

  else
    _ck_assert_failed("cert.t.c", 44, "Assertion '!!c' failed", (const void *)"loading PEM failed", (void *)0);
  if(!(c->crt == ((struct x509_st *)NULL)))
    _mark_point("cert.t.c", 45);

  else
    _ck_assert_failed("cert.t.c", 45, "Assertion '!!c->crt' failed", (const void *)"loading crt failed", (void *)0);
  if(!(c->key == ((struct evp_pkey_st *)NULL)))
    _mark_point("cert.t.c", 46);

  else
    _ck_assert_failed("cert.t.c", 46, "Assertion '!!c->key' failed", (const void *)"loading key failed", (void *)0);
  if(!(c->chain == ((struct stack_st_X509 *)NULL)))
    _mark_point("cert.t.c", 47);

  else
    _ck_assert_failed("cert.t.c", 47, "Assertion '!!c->chain' failed", (const void *)"initializing chain stack failed", (void *)0);
  signed int return_value_sk_num$1;
  return_value_sk_num$1=sk_num((struct stack_st *)c->chain);
  if(return_value_sk_num$1 == 1)
    _mark_point("cert.t.c", 48);

  else
    _ck_assert_failed("cert.t.c", 48, "Assertion 'sk_X509_num(c->chain) == 1' failed", (const void *)"loading chain failed", (void *)0);
  cert_free(c);
}

// cert_refcount_inc
// file cert.h line 49
void cert_refcount_inc(struct cert *c)
{
  pthread_mutex_lock(&c->mutex);
  c->references = c->references + 1ul;
  pthread_mutex_unlock(&c->mutex);
}

// cert_refcount_inc_01
// file cert.t.c line 53
static void cert_refcount_inc_01(signed int _i)
{
  tcase_fn_start("cert_refcount_inc_01", "cert.t.c", 53);
  struct cert *c;
  c=cert_new_load("extra/pki/targets/daniel.roe.ch.pem");
  if(!(c == ((struct cert *)NULL)))
    _mark_point("cert.t.c", 58);

  else
    _ck_assert_failed("cert.t.c", 58, "Assertion '!!c' failed", (const void *)"loading PEM failed", (void *)0);
  if(c->references == 1ul)
    _mark_point("cert.t.c", 59);

  else
    _ck_assert_failed("cert.t.c", 59, "Assertion 'c->references == 1' failed", (const void *)"refcount mismatch", (void *)0);
  cert_refcount_inc(c);
  if(c->references == 2ul)
    _mark_point("cert.t.c", 61);

  else
    _ck_assert_failed("cert.t.c", 61, "Assertion 'c->references == 2' failed", (const void *)"refcount mismatch", (void *)0);
  cert_free(c);
  if(c->references == 1ul)
    _mark_point("cert.t.c", 63);

  else
    _ck_assert_failed("cert.t.c", 63, "Assertion 'c->references == 1' failed", (const void *)"refcount mismatch", (void *)0);
  cert_free(c);
  if(c->references == 0ul)
    _mark_point("cert.t.c", 66);

  else
    _ck_assert_failed("cert.t.c", 66, "Assertion 'c->references == 0' failed", (const void *)"refcount mismatch", (void *)0);
}

// cert_set_chain
// file cert.c line 166
void cert_set_chain(struct cert *c, struct stack_st_X509 *chain)
{
  pthread_mutex_lock(&c->mutex);
  if(!(c->chain == ((struct stack_st_X509 *)NULL)))
    sk_pop_free((struct stack_st *)c->chain, (void (*)(void *))(1 != 0 ? X509_free : (void (*)(struct x509_st *))0));

  signed int return_value_sk_num$2;
  if(!(chain == ((struct stack_st_X509 *)NULL)))
  {
    struct stack_st *return_value_sk_dup$1;
    return_value_sk_dup$1=sk_dup((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0));
    c->chain = (struct stack_st_X509 *)return_value_sk_dup$1;
    signed int i = 0;
    do
    {
      return_value_sk_num$2=sk_num((struct stack_st *)c->chain);
      if(i >= return_value_sk_num$2)
        break;

      void *return_value_sk_value$3;
      return_value_sk_value$3=sk_value((struct stack_st *)c->chain, i);
      ssl_x509_refcount_inc((struct x509_st *)return_value_sk_value$3);
      i = i + 1;
    }
    while((_Bool)1);
  }

  else
    c->chain = (struct stack_st_X509 *)(void *)0;
  pthread_mutex_unlock(&c->mutex);
}

// cert_set_crt
// file cert.c line 153
void cert_set_crt(struct cert *c, struct x509_st *crt)
{
  pthread_mutex_lock(&c->mutex);
  if(!(c->crt == ((struct x509_st *)NULL)))
    X509_free(c->crt);

  c->crt = crt;
  if(!(c->crt == ((struct x509_st *)NULL)))
    ssl_x509_refcount_inc(c->crt);

  pthread_mutex_unlock(&c->mutex);
}

// cert_set_key
// file cert.c line 140
void cert_set_key(struct cert *c, struct evp_pkey_st *key)
{
  pthread_mutex_lock(&c->mutex);
  if(!(c->key == ((struct evp_pkey_st *)NULL)))
    EVP_PKEY_free(c->key);

  c->key = key;
  if(!(c->key == ((struct evp_pkey_st *)NULL)))
    ssl_key_refcount_inc(c->key);

  pthread_mutex_unlock(&c->mutex);
}

// cert_suite
// file cert.t.c line 71
struct Suite * cert_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("cert");
  tc=tcase_create("cert_new_load");
  _tcase_add_test(tc, cert_new_load_01, "cert_new_load_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("cert_refcount_inc");
  _tcase_add_test(tc, cert_refcount_inc_01, "cert_refcount_inc_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// dynbuf_free
// file dynbuf.h line 45
void dynbuf_free(struct dynbuf *db)
{
  free((void *)db->buf);
  free((void *)db);
}

// dynbuf_new
// file dynbuf.h line 41
struct dynbuf * dynbuf_new(unsigned char *buf, unsigned long int sz)
{
  struct dynbuf *db;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dynbuf) /*16ul*/ );
  db = (struct dynbuf *)return_value_malloc$1;
  if(db == ((struct dynbuf *)NULL))
    return (struct dynbuf *)(void *)0;

  else
  {
    db->buf = buf;
    db->sz = sz;
    return db;
  }
}

// dynbuf_new_01
// file dynbuf.t.c line 57
static void dynbuf_new_01(signed int _i)
{
  tcase_fn_start("dynbuf_new_01", "dynbuf.t.c", 57);
  struct dynbuf *db;
  db=dynbuf_new(buf, sz);
  if(!(db == ((struct dynbuf *)NULL)))
    _mark_point("dynbuf.t.c", 62);

  else
    _ck_assert_failed("dynbuf.t.c", 62, "Assertion '!!db' failed", (const void *)"dynbuf not allocated", (void *)0);
  if(!(db->buf == ((unsigned char *)NULL)))
    _mark_point("dynbuf.t.c", 63);

  else
    _ck_assert_failed("dynbuf.t.c", 63, "Assertion '!!db->buf' failed", (const void *)"buffer not set", (void *)0);
  if(db->buf == buf)
    _mark_point("dynbuf.t.c", 64);

  else
    _ck_assert_failed("dynbuf.t.c", 64, "Assertion 'db->buf == buf' failed", (const void *)"buffer incorrect", (void *)0);
  if(db->sz == sz)
    _mark_point("dynbuf.t.c", 65);

  else
    _ck_assert_failed("dynbuf.t.c", 65, "Assertion 'db->sz == sz' failed", (const void *)"size incorrect", (void *)0);
  dynbuf_free(db);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sz);
  buf = (unsigned char *)return_value_malloc$1;
}

// dynbuf_new_alloc
// file dynbuf.h line 42
struct dynbuf * dynbuf_new_alloc(unsigned long int sz)
{
  struct dynbuf *db;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dynbuf) /*16ul*/ );
  db = (struct dynbuf *)return_value_malloc$1;
  if(db == ((struct dynbuf *)NULL))
    return (struct dynbuf *)(void *)0;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sz);
    db->buf = (unsigned char *)return_value_malloc$2;
    if(db->buf == ((unsigned char *)NULL))
    {
      free((void *)db);
      return (struct dynbuf *)(void *)0;
    }

    else
    {
      db->sz = sz;
      return db;
    }
  }
}

// dynbuf_new_alloc_01
// file dynbuf.t.c line 71
static void dynbuf_new_alloc_01(signed int _i)
{
  tcase_fn_start("dynbuf_new_alloc_01", "dynbuf.t.c", 71);
  struct dynbuf *db;
  db=dynbuf_new_alloc(sz);
  if(!(db == ((struct dynbuf *)NULL)))
    _mark_point("dynbuf.t.c", 76);

  else
    _ck_assert_failed("dynbuf.t.c", 76, "Assertion '!!db' failed", (const void *)"dynbuf not allocated", (void *)0);
  if(!(db->buf == ((unsigned char *)NULL)))
    _mark_point("dynbuf.t.c", 77);

  else
    _ck_assert_failed("dynbuf.t.c", 77, "Assertion '!!db->buf' failed", (const void *)"buffer not set", (void *)0);
  if(db->sz == sz)
    _mark_point("dynbuf.t.c", 78);

  else
    _ck_assert_failed("dynbuf.t.c", 78, "Assertion 'db->sz == sz' failed", (const void *)"size incorrect", (void *)0);
  dynbuf_free(db);
}

// dynbuf_new_copy
// file dynbuf.h line 43
struct dynbuf * dynbuf_new_copy(const unsigned char *buf, const unsigned long int sz)
{
  struct dynbuf *db;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dynbuf) /*16ul*/ );
  db = (struct dynbuf *)return_value_malloc$1;
  if(db == ((struct dynbuf *)NULL))
    return (struct dynbuf *)(void *)0;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sz);
    db->buf = (unsigned char *)return_value_malloc$2;
    if(db->buf == ((unsigned char *)NULL))
    {
      free((void *)db);
      return (struct dynbuf *)(void *)0;
    }

    else
    {
      memcpy((void *)db->buf, (const void *)buf, sz);
      db->sz = sz;
      return db;
    }
  }
}

// dynbuf_new_copy_01
// file dynbuf.t.c line 83
static void dynbuf_new_copy_01(signed int _i)
{
  tcase_fn_start("dynbuf_new_copy_01", "dynbuf.t.c", 83);
  struct dynbuf *db;
  db=dynbuf_new_copy(buf, sz);
  if(!(db == ((struct dynbuf *)NULL)))
    _mark_point("dynbuf.t.c", 88);

  else
    _ck_assert_failed("dynbuf.t.c", 88, "Assertion '!!db' failed", (const void *)"dynbuf not allocated", (void *)0);
  if(!(db->buf == ((unsigned char *)NULL)))
    _mark_point("dynbuf.t.c", 89);

  else
    _ck_assert_failed("dynbuf.t.c", 89, "Assertion '!!db->buf' failed", (const void *)"buffer not set", (void *)0);
  if(!(db->buf == buf))
    _mark_point("dynbuf.t.c", 90);

  else
    _ck_assert_failed("dynbuf.t.c", 90, "Assertion 'db->buf != buf' failed", (const void *)"buffer incorrect", (void *)0);
  if(db->sz == sz)
    _mark_point("dynbuf.t.c", 91);

  else
    _ck_assert_failed("dynbuf.t.c", 91, "Assertion 'db->sz == sz' failed", (const void *)"size incorrect", (void *)0);
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)db->buf, (const void *)buf, sz);
  if(return_value_memcmp$1 == 0)
    _mark_point("dynbuf.t.c", 92);

  else
    _ck_assert_failed("dynbuf.t.c", 92, "Assertion '!memcmp(db->buf, buf, sz)' failed", (const void *)"buffer data incorrect", (void *)0);
  dynbuf_free(db);
}

// dynbuf_new_file
// file dynbuf.h line 44
struct dynbuf * dynbuf_new_file(const char *filename)
{
  struct dynbuf *db;
  struct _IO_FILE *f;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dynbuf) /*16ul*/ );
  db = (struct dynbuf *)return_value_malloc$1;
  if(db == ((struct dynbuf *)NULL))
    return (struct dynbuf *)(void *)0;

  else
  {
    f=fopen(filename, "rb");
    if(f == ((struct _IO_FILE *)NULL))
    {
      free((void *)db);
      return (struct dynbuf *)(void *)0;
    }

    else
    {
      fseek(f, (signed long int)0, 2);
      signed long int return_value_ftell$2;
      return_value_ftell$2=ftell(f);
      db->sz = (unsigned long int)return_value_ftell$2;
      fseek(f, (signed long int)0, 0);
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(db->sz);
      db->buf = (unsigned char *)return_value_malloc$3;
      if(db->buf == ((unsigned char *)NULL))
      {
        free((void *)db);
        fclose(f);
        return (struct dynbuf *)(void *)0;
      }

      else
      {
        unsigned long int return_value_fread$4;
        return_value_fread$4=fread((void *)db->buf, db->sz, (unsigned long int)1, f);
        if(!(return_value_fread$4 == 1ul))
        {
          free((void *)db->buf);
          free((void *)db);
          fclose(f);
          return (struct dynbuf *)(void *)0;
        }

        else
        {
          fclose(f);
          return db;
        }
      }
    }
  }
}

// dynbuf_new_file_01
// file dynbuf.t.c line 97
static void dynbuf_new_file_01(signed int _i)
{
  tcase_fn_start("dynbuf_new_file_01", "dynbuf.t.c", 97);
  struct dynbuf *db;
  db=dynbuf_new_file("extra/pki/targets/daniel.roe.ch.pem");
  if(!(db == ((struct dynbuf *)NULL)))
    _mark_point("dynbuf.t.c", 102);

  else
    _ck_assert_failed("dynbuf.t.c", 102, "Assertion '!!db' failed", (const void *)"dynbuf not allocated", (void *)0);
  if(!(db->buf == ((unsigned char *)NULL)))
    _mark_point("dynbuf.t.c", 103);

  else
    _ck_assert_failed("dynbuf.t.c", 103, "Assertion '!!db->buf' failed", (const void *)"buffer not set", (void *)0);
  if(!(db->buf == buf))
    _mark_point("dynbuf.t.c", 104);

  else
    _ck_assert_failed("dynbuf.t.c", 104, "Assertion 'db->buf != buf' failed", (const void *)"buffer incorrect", (void *)0);
  if(db->sz >= 1ul)
    _mark_point("dynbuf.t.c", 105);

  else
    _ck_assert_failed("dynbuf.t.c", 105, "Assertion 'db->sz > 0' failed", (const void *)"size incorrect", (void *)0);
  char *return_value_strstr$1;
  return_value_strstr$1=strstr((char *)db->buf, "-----BEGIN CERTIFICATE-----");
  if(!(return_value_strstr$1 == ((char *)NULL)))
    _mark_point("dynbuf.t.c", 106);

  else
    _ck_assert_failed("dynbuf.t.c", 106, "Assertion '!!strstr((char*)db->buf, \"-----BEGIN CERTIFICATE-----\")' failed", (const void *)"cannot find begin of cert", (void *)0);
  char *return_value_strstr$2;
  return_value_strstr$2=strstr((char *)db->buf, "-----END CERTIFICATE-----");
  if(!(return_value_strstr$2 == ((char *)NULL)))
    _mark_point("dynbuf.t.c", 108);

  else
    _ck_assert_failed("dynbuf.t.c", 108, "Assertion '!!strstr((char*)db->buf, \"-----END CERTIFICATE-----\")' failed", (const void *)"cannot find end of cert", (void *)0);
  dynbuf_free(db);
}

// dynbuf_suite
// file dynbuf.t.c line 115
struct Suite * dynbuf_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("dynbuf");
  tc=tcase_create("dynbuf_new_01");
  tcase_add_checked_fixture(tc, buf_setup, buf_teardown);
  _tcase_add_test(tc, dynbuf_new_01, "dynbuf_new_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("dynbuf_new_alloc_01");
  tcase_add_checked_fixture(tc, buf_setup, buf_teardown);
  _tcase_add_test(tc, dynbuf_new_alloc_01, "dynbuf_new_alloc_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("dynbuf_new_copy_01");
  tcase_add_checked_fixture(tc, buf_setup, buf_teardown);
  _tcase_add_test(tc, dynbuf_new_copy_01, "dynbuf_new_copy_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("dynbuf_new_file_01");
  tcase_add_checked_fixture(tc, buf_setup, buf_teardown);
  _tcase_add_test(tc, dynbuf_new_file_01, "dynbuf_new_file_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// kh_del_cstrmap_t
// file cachetgcrt.c line 42
static inline void kh_del_cstrmap_t(struct anonymous$2 *h, unsigned int x)
{
  if(!(x == h->n_buckets))
  {
    if((3u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u)
    {
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] | (unsigned int)(1ul << ((x & 0xfU) << 1));
      h->size = h->size - 1u;
    }

  }

}

// kh_del_dynbufmap_t
// file cachedsess.c line 68
static inline void kh_del_dynbufmap_t(struct anonymous$9 *h, unsigned int x)
{
  if(!(x == h->n_buckets))
  {
    if((3u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u)
    {
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] | (unsigned int)(1ul << ((x & 0xfU) << 1));
      h->size = h->size - 1u;
    }

  }

}

// kh_del_dynbufmap_t$link1
// file cachessess.c line 66
static inline void kh_del_dynbufmap_t$link1(struct anonymous$9 *h$link1, unsigned int x$link1)
{
  if(!(x$link1 == h$link1->n_buckets))
  {
    if((3u & h$link1->flags[(signed long int)(x$link1 >> 4)] >> ((0xfU & x$link1) << 1)) == 0u)
    {
      h$link1->flags[(signed long int)(x$link1 >> 4)] = h$link1->flags[(signed long int)(x$link1 >> 4)] | (unsigned int)(1ul << ((x$link1 & 0xfU) << 1));
      h$link1->size = h$link1->size - 1u;
    }

  }

}

// kh_del_sha1map_t
// file cachefkcrt.c line 56
static inline void kh_del_sha1map_t(struct anonymous$0 *h, unsigned int x)
{
  if(!(x == h->n_buckets))
  {
    if((3u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u)
    {
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] | (unsigned int)(1ul << ((x & 0xfU) << 1));
      h->size = h->size - 1u;
    }

  }

}

// kh_destroy_cstrmap_t
// file cachetgcrt.c line 42
static inline void kh_destroy_cstrmap_t(struct anonymous$2 *h)
{
  if(!(h == ((struct anonymous$2 *)NULL)))
  {
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
  }

}

// kh_destroy_dynbufmap_t
// file cachedsess.c line 68
static inline void kh_destroy_dynbufmap_t(struct anonymous$9 *h)
{
  if(!(h == ((struct anonymous$9 *)NULL)))
  {
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
  }

}

// kh_destroy_dynbufmap_t$link1
// file cachessess.c line 66
static inline void kh_destroy_dynbufmap_t$link1(struct anonymous$9 *h$link1)
{
  if(!(h$link1 == ((struct anonymous$9 *)NULL)))
  {
    free((void *)h$link1->keys);
    free((void *)h$link1->flags);
    free((void *)h$link1->vals);
    free((void *)h$link1);
  }

}

// kh_destroy_sha1map_t
// file cachefkcrt.c line 56
static inline void kh_destroy_sha1map_t(struct anonymous$0 *h)
{
  if(!(h == ((struct anonymous$0 *)NULL)))
  {
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
  }

}

// kh_dynbuf_hash_func
// file cachedsess.c line 45
static inline unsigned int kh_dynbuf_hash_func(struct dynbuf *b)
{
  unsigned int *p = (unsigned int *)b->buf;
  unsigned int h;
  signed int rem = (signed int)(b->sz % sizeof(unsigned int) /*4ul*/ );
  if(!(rem == 0))
    memcpy((void *)&h, (const void *)((b->buf + (signed long int)b->sz) - (signed long int)rem), (unsigned long int)rem);

  else
    h = (unsigned int)0;
  unsigned int *tmp_post$1;
  for( ; !(p >= (unsigned int *)(b->buf + (signed long int)b->sz + -((signed long int)rem))); h = h ^ *tmp_post$1)
  {
    tmp_post$1 = p;
    p = p + 1l;
  }
  return h;
}

// kh_dynbuf_hash_func$link1
// file cachessess.c line 43
static inline unsigned int kh_dynbuf_hash_func$link1(struct dynbuf *b$link1)
{
  unsigned int *p$link1 = (unsigned int *)b$link1->buf;
  unsigned int h$link1;
  signed int rem$link1 = (signed int)(b$link1->sz % sizeof(unsigned int) /*4ul*/ );
  if(!(rem$link1 == 0))
    memcpy((void *)&h$link1, (const void *)((b$link1->buf + (signed long int)b$link1->sz) - (signed long int)rem$link1), (unsigned long int)rem$link1);

  else
    h$link1 = (unsigned int)0;
  unsigned int *tmp_post$1$link1;
  for( ; !(p$link1 >= (unsigned int *)(b$link1->buf + (signed long int)b$link1->sz + -((signed long int)rem$link1))); h$link1 = h$link1 ^ *tmp_post$1$link1)
  {
    tmp_post$1$link1 = p$link1;
    p$link1 = p$link1 + 1l;
  }
  return h$link1;
}

// kh_get_cstrmap_t
// file cachetgcrt.c line 42
static inline unsigned int kh_get_cstrmap_t(const struct anonymous$2 *h, char *key)
{
  signed int return_value_strcmp$1;
  unsigned int tmp_if_expr$2;
  if(!(h->n_buckets == 0u))
  {
    unsigned int k;
    unsigned int i;
    unsigned int last;
    unsigned int mask;
    unsigned int step = (unsigned int)0;
    mask = h->n_buckets - (unsigned int)1;
    k=__ac_X31_hash_string(key);
    i = k & mask;
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        return_value_strcmp$1=strcmp(h->keys[(signed long int)i], key);
        if(return_value_strcmp$1 == 0)
          break;

      }

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
        return h->n_buckets;

    }
    if(!((3u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
      tmp_if_expr$2 = h->n_buckets;

    else
      tmp_if_expr$2 = i;
    return tmp_if_expr$2;
  }

  else
    return (unsigned int)0;
}

// kh_get_dynbufmap_t
// file cachedsess.c line 68
static inline unsigned int kh_get_dynbufmap_t(const struct anonymous$9 *h, struct dynbuf *key)
{
  signed int return_value_memcmp$1;
  unsigned int tmp_if_expr$2;
  if(!(h->n_buckets == 0u))
  {
    unsigned int k;
    unsigned int i;
    unsigned int last;
    unsigned int mask;
    unsigned int step = (unsigned int)0;
    mask = h->n_buckets - (unsigned int)1;
    k=kh_dynbuf_hash_func(key);
    i = k & mask;
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        if(h->keys[(signed long int)i]->sz == key->sz)
        {
          return_value_memcmp$1=memcmp((const void *)h->keys[(signed long int)i]->buf, (const void *)key->buf, h->keys[(signed long int)i]->sz);
          if(return_value_memcmp$1 == 0)
            break;

        }

      }

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
        return h->n_buckets;

    }
    if(!((3u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
      tmp_if_expr$2 = h->n_buckets;

    else
      tmp_if_expr$2 = i;
    return tmp_if_expr$2;
  }

  else
    return (unsigned int)0;
}

// kh_get_dynbufmap_t$link1
// file cachessess.c line 66
static inline unsigned int kh_get_dynbufmap_t$link1(const struct anonymous$9 *h$link1, struct dynbuf *key$link1)
{
  signed int return_value_memcmp$1$link1;
  unsigned int tmp_if_expr$2$link1;
  if(!(h$link1->n_buckets == 0u))
  {
    unsigned int k$link1;
    unsigned int i$link1;
    unsigned int last$link1;
    unsigned int mask$link1;
    unsigned int step$link1 = (unsigned int)0;
    mask$link1 = h$link1->n_buckets - (unsigned int)1;
    k$link1=kh_dynbuf_hash_func$link1(key$link1);
    i$link1 = k$link1 & mask$link1;
    last$link1 = i$link1;
    while((2u & h$link1->flags[(signed long int)(i$link1 >> 4)] >> ((0xfU & i$link1) << 1)) == 0u)
    {
      if((1u & h$link1->flags[(signed long int)(i$link1 >> 4)] >> ((0xfU & i$link1) << 1)) == 0u)
      {
        if(h$link1->keys[(signed long int)i$link1]->sz == key$link1->sz)
        {
          return_value_memcmp$1$link1=memcmp((const void *)h$link1->keys[(signed long int)i$link1]->buf, (const void *)key$link1->buf, h$link1->keys[(signed long int)i$link1]->sz);
          if(return_value_memcmp$1$link1 == 0)
            break;

        }

      }

      step$link1 = step$link1 + 1u;
      i$link1 = i$link1 + step$link1 & mask$link1;
      if(i$link1 == last$link1)
        return h$link1->n_buckets;

    }
    if(!((3u & h$link1->flags[(signed long int)(i$link1 >> 4)] >> ((0xfU & i$link1) << 1)) == 0u))
      tmp_if_expr$2$link1 = h$link1->n_buckets;

    else
      tmp_if_expr$2$link1 = i$link1;
    return tmp_if_expr$2$link1;
  }

  else
    return (unsigned int)0;
}

// kh_get_sha1map_t
// file cachefkcrt.c line 56
static inline unsigned int kh_get_sha1map_t(const struct anonymous$0 *h, void *key)
{
  signed int return_value_memcmp$1;
  unsigned int tmp_if_expr$2;
  if(!(h->n_buckets == 0u))
  {
    unsigned int k;
    unsigned int i;
    unsigned int last;
    unsigned int mask;
    unsigned int step = (unsigned int)0;
    mask = h->n_buckets - (unsigned int)1;
    k=kh_x509fpr_hash_func(key);
    i = k & mask;
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        return_value_memcmp$1=memcmp((const void *)(char *)h->keys[(signed long int)i], (const void *)(char *)key, (unsigned long int)20);
        if(return_value_memcmp$1 == 0)
          break;

      }

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
        return h->n_buckets;

    }
    if(!((3u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
      tmp_if_expr$2 = h->n_buckets;

    else
      tmp_if_expr$2 = i;
    return tmp_if_expr$2;
  }

  else
    return (unsigned int)0;
}

// kh_init_cstrmap_t
// file cachetgcrt.c line 42
static inline struct anonymous$2 * kh_init_cstrmap_t(void)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$2) /*40ul*/ );
  return (struct anonymous$2 *)return_value_calloc$1;
}

// kh_init_dynbufmap_t
// file cachedsess.c line 68
static inline struct anonymous$9 * kh_init_dynbufmap_t(void)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$9) /*40ul*/ );
  return (struct anonymous$9 *)return_value_calloc$1;
}

// kh_init_dynbufmap_t$link1
// file cachessess.c line 66
static inline struct anonymous$9 * kh_init_dynbufmap_t$link1(void)
{
  void *return_value_calloc$1$link1;
  return_value_calloc$1$link1=calloc((unsigned long int)1, sizeof(struct anonymous$9) /*40ul*/ );
  return (struct anonymous$9 *)return_value_calloc$1$link1;
}

// kh_init_sha1map_t
// file cachefkcrt.c line 56
static inline struct anonymous$0 * kh_init_sha1map_t(void)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$0) /*40ul*/ );
  return (struct anonymous$0 *)return_value_calloc$1;
}

// kh_put_cstrmap_t
// file cachetgcrt.c line 42
static inline unsigned int kh_put_cstrmap_t(struct anonymous$2 *h, char *key, signed int *ret)
{
  unsigned int x;
  signed int return_value_kh_resize_cstrmap_t$2;
  if(h->n_occupied >= h->upper_bound)
  {
    if(!(h->size << 1 >= h->n_buckets))
    {
      signed int return_value_kh_resize_cstrmap_t$1;
      return_value_kh_resize_cstrmap_t$1=kh_resize_cstrmap_t(h, h->n_buckets - (unsigned int)1);
      if(!(return_value_kh_resize_cstrmap_t$1 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }

    else
    {
      return_value_kh_resize_cstrmap_t$2=kh_resize_cstrmap_t(h, h->n_buckets + (unsigned int)1);
      if(!(return_value_kh_resize_cstrmap_t$2 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }
  }

  unsigned int k;
  unsigned int i;
  unsigned int site;
  unsigned int last;
  unsigned int mask = h->n_buckets - (unsigned int)1;
  unsigned int step = (unsigned int)0;
  site = h->n_buckets;
  x = site;
  k=__ac_X31_hash_string(key);
  i = k & mask;
  signed int return_value_strcmp$3;
  _Bool tmp_if_expr$4;
  if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
    x = i;

  else
  {
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        return_value_strcmp$3=strcmp(h->keys[(signed long int)i], key);
        if(return_value_strcmp$3 == 0)
          break;

      }

      if(!((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        site = i;

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
      {
        x = site;
        break;
      }

    }
    if(x == h->n_buckets)
    {
      if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        tmp_if_expr$4 = site != h->n_buckets ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        x = site;

      else
        x = i;
    }

  }
  if(!((2u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
  {
    h->keys[(signed long int)x] = key;
    h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
    h->size = h->size + 1u;
    h->n_occupied = h->n_occupied + 1u;
    *ret = 1;
  }

  else
    if(!((1u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
    {
      h->keys[(signed long int)x] = key;
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
      h->size = h->size + 1u;
      *ret = 2;
    }

    else
      *ret = 0;
  return x;
}

// kh_put_dynbufmap_t
// file cachedsess.c line 68
static inline unsigned int kh_put_dynbufmap_t(struct anonymous$9 *h, struct dynbuf *key, signed int *ret)
{
  unsigned int x;
  signed int return_value_kh_resize_dynbufmap_t$2;
  if(h->n_occupied >= h->upper_bound)
  {
    if(!(h->size << 1 >= h->n_buckets))
    {
      signed int return_value_kh_resize_dynbufmap_t$1;
      return_value_kh_resize_dynbufmap_t$1=kh_resize_dynbufmap_t(h, h->n_buckets - (unsigned int)1);
      if(!(return_value_kh_resize_dynbufmap_t$1 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }

    else
    {
      return_value_kh_resize_dynbufmap_t$2=kh_resize_dynbufmap_t(h, h->n_buckets + (unsigned int)1);
      if(!(return_value_kh_resize_dynbufmap_t$2 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }
  }

  unsigned int k;
  unsigned int i;
  unsigned int site;
  unsigned int last;
  unsigned int mask = h->n_buckets - (unsigned int)1;
  unsigned int step = (unsigned int)0;
  site = h->n_buckets;
  x = site;
  k=kh_dynbuf_hash_func(key);
  i = k & mask;
  signed int return_value_memcmp$3;
  _Bool tmp_if_expr$4;
  if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
    x = i;

  else
  {
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        if(h->keys[(signed long int)i]->sz == key->sz)
        {
          return_value_memcmp$3=memcmp((const void *)h->keys[(signed long int)i]->buf, (const void *)key->buf, h->keys[(signed long int)i]->sz);
          if(return_value_memcmp$3 == 0)
            break;

        }

      }

      if(!((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        site = i;

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
      {
        x = site;
        break;
      }

    }
    if(x == h->n_buckets)
    {
      if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        tmp_if_expr$4 = site != h->n_buckets ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        x = site;

      else
        x = i;
    }

  }
  if(!((2u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
  {
    h->keys[(signed long int)x] = key;
    h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
    h->size = h->size + 1u;
    h->n_occupied = h->n_occupied + 1u;
    *ret = 1;
  }

  else
    if(!((1u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
    {
      h->keys[(signed long int)x] = key;
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
      h->size = h->size + 1u;
      *ret = 2;
    }

    else
      *ret = 0;
  return x;
}

// kh_put_dynbufmap_t$link1
// file cachessess.c line 66
static inline unsigned int kh_put_dynbufmap_t$link1(struct anonymous$9 *h$link1, struct dynbuf *key$link1, signed int *ret$link1)
{
  unsigned int x$link1;
  signed int return_value_kh_resize_dynbufmap_t$2$link1;
  if(h$link1->n_occupied >= h$link1->upper_bound)
  {
    if(!(h$link1->size << 1 >= h$link1->n_buckets))
    {
      signed int return_value_kh_resize_dynbufmap_t$1$link1;
      return_value_kh_resize_dynbufmap_t$1$link1=kh_resize_dynbufmap_t$link1(h$link1, h$link1->n_buckets - (unsigned int)1);
      if(!(return_value_kh_resize_dynbufmap_t$1$link1 >= 0))
      {
        *ret$link1 = -1;
        return h$link1->n_buckets;
      }

    }

    else
    {
      return_value_kh_resize_dynbufmap_t$2$link1=kh_resize_dynbufmap_t$link1(h$link1, h$link1->n_buckets + (unsigned int)1);
      if(!(return_value_kh_resize_dynbufmap_t$2$link1 >= 0))
      {
        *ret$link1 = -1;
        return h$link1->n_buckets;
      }

    }
  }

  unsigned int k$link1;
  unsigned int i$link1;
  unsigned int site$link1;
  unsigned int last$link1;
  unsigned int mask$link1 = h$link1->n_buckets - (unsigned int)1;
  unsigned int step$link1 = (unsigned int)0;
  site$link1 = h$link1->n_buckets;
  x$link1 = site$link1;
  k$link1=kh_dynbuf_hash_func$link1(key$link1);
  i$link1 = k$link1 & mask$link1;
  signed int return_value_memcmp$3$link1;
  _Bool tmp_if_expr$4$link1;
  if(!((2u & h$link1->flags[(signed long int)(i$link1 >> 4)] >> ((0xfU & i$link1) << 1)) == 0u))
    x$link1 = i$link1;

  else
  {
    last$link1 = i$link1;
    while((2u & h$link1->flags[(signed long int)(i$link1 >> 4)] >> ((0xfU & i$link1) << 1)) == 0u)
    {
      if((1u & h$link1->flags[(signed long int)(i$link1 >> 4)] >> ((0xfU & i$link1) << 1)) == 0u)
      {
        if(h$link1->keys[(signed long int)i$link1]->sz == key$link1->sz)
        {
          return_value_memcmp$3$link1=memcmp((const void *)h$link1->keys[(signed long int)i$link1]->buf, (const void *)key$link1->buf, h$link1->keys[(signed long int)i$link1]->sz);
          if(return_value_memcmp$3$link1 == 0)
            break;

        }

      }

      if(!((1u & h$link1->flags[(signed long int)(i$link1 >> 4)] >> ((0xfU & i$link1) << 1)) == 0u))
        site$link1 = i$link1;

      step$link1 = step$link1 + 1u;
      i$link1 = i$link1 + step$link1 & mask$link1;
      if(i$link1 == last$link1)
      {
        x$link1 = site$link1;
        break;
      }

    }
    if(x$link1 == h$link1->n_buckets)
    {
      if(!((2u & h$link1->flags[(signed long int)(i$link1 >> 4)] >> ((0xfU & i$link1) << 1)) == 0u))
        tmp_if_expr$4$link1 = site$link1 != h$link1->n_buckets ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4$link1 = (_Bool)0;
      if(tmp_if_expr$4$link1)
        x$link1 = site$link1;

      else
        x$link1 = i$link1;
    }

  }
  if(!((2u & h$link1->flags[(signed long int)(x$link1 >> 4)] >> ((0xfU & x$link1) << 1)) == 0u))
  {
    h$link1->keys[(signed long int)x$link1] = key$link1;
    h$link1->flags[(signed long int)(x$link1 >> 4)] = h$link1->flags[(signed long int)(x$link1 >> 4)] & (unsigned int)~(3ul << ((x$link1 & 0xfU) << 1));
    h$link1->size = h$link1->size + 1u;
    h$link1->n_occupied = h$link1->n_occupied + 1u;
    *ret$link1 = 1;
  }

  else
    if(!((1u & h$link1->flags[(signed long int)(x$link1 >> 4)] >> ((0xfU & x$link1) << 1)) == 0u))
    {
      h$link1->keys[(signed long int)x$link1] = key$link1;
      h$link1->flags[(signed long int)(x$link1 >> 4)] = h$link1->flags[(signed long int)(x$link1 >> 4)] & (unsigned int)~(3ul << ((x$link1 & 0xfU) << 1));
      h$link1->size = h$link1->size + 1u;
      *ret$link1 = 2;
    }

    else
      *ret$link1 = 0;
  return x$link1;
}

// kh_put_sha1map_t
// file cachefkcrt.c line 56
static inline unsigned int kh_put_sha1map_t(struct anonymous$0 *h, void *key, signed int *ret)
{
  unsigned int x;
  signed int return_value_kh_resize_sha1map_t$2;
  if(h->n_occupied >= h->upper_bound)
  {
    if(!(h->size << 1 >= h->n_buckets))
    {
      signed int return_value_kh_resize_sha1map_t$1;
      return_value_kh_resize_sha1map_t$1=kh_resize_sha1map_t(h, h->n_buckets - (unsigned int)1);
      if(!(return_value_kh_resize_sha1map_t$1 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }

    else
    {
      return_value_kh_resize_sha1map_t$2=kh_resize_sha1map_t(h, h->n_buckets + (unsigned int)1);
      if(!(return_value_kh_resize_sha1map_t$2 >= 0))
      {
        *ret = -1;
        return h->n_buckets;
      }

    }
  }

  unsigned int k;
  unsigned int i;
  unsigned int site;
  unsigned int last;
  unsigned int mask = h->n_buckets - (unsigned int)1;
  unsigned int step = (unsigned int)0;
  site = h->n_buckets;
  x = site;
  k=kh_x509fpr_hash_func(key);
  i = k & mask;
  signed int return_value_memcmp$3;
  _Bool tmp_if_expr$4;
  if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
    x = i;

  else
  {
    last = i;
    while((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
    {
      if((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u)
      {
        return_value_memcmp$3=memcmp((const void *)(char *)h->keys[(signed long int)i], (const void *)(char *)key, (unsigned long int)20);
        if(return_value_memcmp$3 == 0)
          break;

      }

      if(!((1u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        site = i;

      step = step + 1u;
      i = i + step & mask;
      if(i == last)
      {
        x = site;
        break;
      }

    }
    if(x == h->n_buckets)
    {
      if(!((2u & h->flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u))
        tmp_if_expr$4 = site != h->n_buckets ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        x = site;

      else
        x = i;
    }

  }
  if(!((2u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
  {
    h->keys[(signed long int)x] = key;
    h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
    h->size = h->size + 1u;
    h->n_occupied = h->n_occupied + 1u;
    *ret = 1;
  }

  else
    if(!((1u & h->flags[(signed long int)(x >> 4)] >> ((0xfU & x) << 1)) == 0u))
    {
      h->keys[(signed long int)x] = key;
      h->flags[(signed long int)(x >> 4)] = h->flags[(signed long int)(x >> 4)] & (unsigned int)~(3ul << ((x & 0xfU) << 1));
      h->size = h->size + 1u;
      *ret = 2;
    }

    else
      *ret = 0;
  return x;
}

// kh_resize_cstrmap_t
// file cachetgcrt.c line 42
static inline signed int kh_resize_cstrmap_t(struct anonymous$2 *h, unsigned int new_n_buckets)
{
  unsigned int *new_flags = ((unsigned int *)NULL);
  unsigned int j = (unsigned int)1;
  new_n_buckets = new_n_buckets - 1u;
  new_n_buckets = new_n_buckets | new_n_buckets >> 1;
  new_n_buckets = new_n_buckets | new_n_buckets >> 2;
  new_n_buckets = new_n_buckets | new_n_buckets >> 4;
  new_n_buckets = new_n_buckets | new_n_buckets >> 8;
  new_n_buckets = new_n_buckets | new_n_buckets >> 16;
  new_n_buckets = new_n_buckets + 1u;
  if(!(new_n_buckets >= 4u))
    new_n_buckets = (unsigned int)4;

  if(h->size >= (unsigned int)((double)new_n_buckets * __ac_HASH_UPPER$link1 + 0.5))
    j = (unsigned int)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    new_flags = (unsigned int *)return_value_malloc$1;
    if(new_flags == ((unsigned int *)NULL))
      return -1;

    memset((void *)new_flags, 0xaa, (unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    if(!(h->n_buckets >= new_n_buckets))
    {
      char **new_keys;
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(char *) /*8ul*/ );
      new_keys = (char **)return_value_realloc$2;
      if(new_keys == ((char **)NULL))
      {
        free((void *)new_flags);
        return -1;
      }

      h->keys = new_keys;
      {
        void **new_vals;
        void *return_value_realloc$3;
        return_value_realloc$3=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
        new_vals = (void **)return_value_realloc$3;
        if(new_vals == ((void **)NULL))
        {
          free((void *)new_flags);
          return -1;
        }

        h->vals = new_vals;
      }
    }

  }
  _Bool tmp_if_expr$4;
  void *return_value_realloc$6;
  if(!(j == 0u))
  {
    j = (unsigned int)0;
    for( ; !(j == h->n_buckets); j = j + 1u)
      if((3u & h->flags[(signed long int)(j >> 4)] >> ((0xfU & j) << 1)) == 0u)
      {
        char *key = h->keys[(signed long int)j];
        void *val;
        unsigned int new_mask = new_n_buckets - (unsigned int)1;
        val = h->vals[(signed long int)j];
        h->flags[(signed long int)(j >> 4)] = h->flags[(signed long int)(j >> 4)] | (unsigned int)(1ul << ((j & 0xfU) << 1));
        while((_Bool)1)
        {
          unsigned int k;
          unsigned int i;
          unsigned int step = (unsigned int)0;
          k=__ac_X31_hash_string(key);
          i = k & new_mask;
          for( ; (2u & new_flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u; i = i + step & new_mask)
            step = step + 1u;
          new_flags[(signed long int)(i >> 4)] = new_flags[(signed long int)(i >> 4)] & (unsigned int)~(2ul << ((i & 0xfU) << 1));
          if(!(i >= h->n_buckets))
            tmp_if_expr$4 = (h->flags[(signed long int)(i >> 4)] >> ((i & 0xfU) << 1) & (unsigned int)3) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
          {
            char *tmp = h->keys[(signed long int)i];
            h->keys[(signed long int)i] = key;
            key = tmp;
            {
              void *kh_resize_cstrmap_t$$1$$2$$1$$1$$1$$1$$1$$2$$tmp = h->vals[(signed long int)i];
              h->vals[(signed long int)i] = val;
              val = kh_resize_cstrmap_t$$1$$2$$1$$1$$1$$1$$1$$2$$tmp;
            }
            h->flags[(signed long int)(i >> 4)] = h->flags[(signed long int)(i >> 4)] | (unsigned int)(1ul << ((i & 0xfU) << 1));
          }

          else
          {
            h->keys[(signed long int)i] = key;
            h->vals[(signed long int)i] = val;
            break;
          }
        }
      }

    if(!(new_n_buckets >= h->n_buckets))
    {
      void *return_value_realloc$5;
      return_value_realloc$5=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(char *) /*8ul*/ );
      h->keys = (char **)return_value_realloc$5;
      return_value_realloc$6=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
      h->vals = (void **)return_value_realloc$6;
    }

    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (unsigned int)((double)h->n_buckets * __ac_HASH_UPPER$link1 + 0.5);
  }

  return 0;
}

// kh_resize_dynbufmap_t
// file cachedsess.c line 68
static inline signed int kh_resize_dynbufmap_t(struct anonymous$9 *h, unsigned int new_n_buckets)
{
  unsigned int *new_flags = ((unsigned int *)NULL);
  unsigned int j = (unsigned int)1;
  new_n_buckets = new_n_buckets - 1u;
  new_n_buckets = new_n_buckets | new_n_buckets >> 1;
  new_n_buckets = new_n_buckets | new_n_buckets >> 2;
  new_n_buckets = new_n_buckets | new_n_buckets >> 4;
  new_n_buckets = new_n_buckets | new_n_buckets >> 8;
  new_n_buckets = new_n_buckets | new_n_buckets >> 16;
  new_n_buckets = new_n_buckets + 1u;
  if(!(new_n_buckets >= 4u))
    new_n_buckets = (unsigned int)4;

  if(h->size >= (unsigned int)((double)new_n_buckets * __ac_HASH_UPPER$link2 + 0.5))
    j = (unsigned int)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    new_flags = (unsigned int *)return_value_malloc$1;
    if(new_flags == ((unsigned int *)NULL))
      return -1;

    memset((void *)new_flags, 0xaa, (unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    if(!(h->n_buckets >= new_n_buckets))
    {
      struct dynbuf **new_keys;
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(struct dynbuf *) /*8ul*/ );
      new_keys = (struct dynbuf **)return_value_realloc$2;
      if(new_keys == ((struct dynbuf **)NULL))
      {
        free((void *)new_flags);
        return -1;
      }

      h->keys = new_keys;
      {
        struct dynbuf **new_vals;
        void *return_value_realloc$3;
        return_value_realloc$3=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(struct dynbuf *) /*8ul*/ );
        new_vals = (struct dynbuf **)return_value_realloc$3;
        if(new_vals == ((struct dynbuf **)NULL))
        {
          free((void *)new_flags);
          return -1;
        }

        h->vals = new_vals;
      }
    }

  }
  _Bool tmp_if_expr$4;
  void *return_value_realloc$6;
  if(!(j == 0u))
  {
    j = (unsigned int)0;
    for( ; !(j == h->n_buckets); j = j + 1u)
      if((3u & h->flags[(signed long int)(j >> 4)] >> ((0xfU & j) << 1)) == 0u)
      {
        struct dynbuf *key = h->keys[(signed long int)j];
        struct dynbuf *val;
        unsigned int new_mask = new_n_buckets - (unsigned int)1;
        val = h->vals[(signed long int)j];
        h->flags[(signed long int)(j >> 4)] = h->flags[(signed long int)(j >> 4)] | (unsigned int)(1ul << ((j & 0xfU) << 1));
        while((_Bool)1)
        {
          unsigned int k;
          unsigned int i;
          unsigned int step = (unsigned int)0;
          k=kh_dynbuf_hash_func(key);
          i = k & new_mask;
          for( ; (2u & new_flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u; i = i + step & new_mask)
            step = step + 1u;
          new_flags[(signed long int)(i >> 4)] = new_flags[(signed long int)(i >> 4)] & (unsigned int)~(2ul << ((i & 0xfU) << 1));
          if(!(i >= h->n_buckets))
            tmp_if_expr$4 = (h->flags[(signed long int)(i >> 4)] >> ((i & 0xfU) << 1) & (unsigned int)3) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
          {
            struct dynbuf *tmp = h->keys[(signed long int)i];
            h->keys[(signed long int)i] = key;
            key = tmp;
            {
              struct dynbuf *kh_resize_dynbufmap_t$$1$$2$$1$$1$$1$$1$$1$$2$$tmp = h->vals[(signed long int)i];
              h->vals[(signed long int)i] = val;
              val = kh_resize_dynbufmap_t$$1$$2$$1$$1$$1$$1$$1$$2$$tmp;
            }
            h->flags[(signed long int)(i >> 4)] = h->flags[(signed long int)(i >> 4)] | (unsigned int)(1ul << ((i & 0xfU) << 1));
          }

          else
          {
            h->keys[(signed long int)i] = key;
            h->vals[(signed long int)i] = val;
            break;
          }
        }
      }

    if(!(new_n_buckets >= h->n_buckets))
    {
      void *return_value_realloc$5;
      return_value_realloc$5=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(struct dynbuf *) /*8ul*/ );
      h->keys = (struct dynbuf **)return_value_realloc$5;
      return_value_realloc$6=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(struct dynbuf *) /*8ul*/ );
      h->vals = (struct dynbuf **)return_value_realloc$6;
    }

    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (unsigned int)((double)h->n_buckets * __ac_HASH_UPPER$link2 + 0.5);
  }

  return 0;
}

// kh_resize_dynbufmap_t$link1
// file cachessess.c line 66
static inline signed int kh_resize_dynbufmap_t$link1(struct anonymous$9 *h$link1, unsigned int new_n_buckets$link1)
{
  unsigned int *new_flags$link1 = ((unsigned int *)NULL);
  unsigned int j$link1 = (unsigned int)1;
  new_n_buckets$link1 = new_n_buckets$link1 - 1u;
  new_n_buckets$link1 = new_n_buckets$link1 | new_n_buckets$link1 >> 1;
  new_n_buckets$link1 = new_n_buckets$link1 | new_n_buckets$link1 >> 2;
  new_n_buckets$link1 = new_n_buckets$link1 | new_n_buckets$link1 >> 4;
  new_n_buckets$link1 = new_n_buckets$link1 | new_n_buckets$link1 >> 8;
  new_n_buckets$link1 = new_n_buckets$link1 | new_n_buckets$link1 >> 16;
  new_n_buckets$link1 = new_n_buckets$link1 + 1u;
  if(!(new_n_buckets$link1 >= 4u))
    new_n_buckets$link1 = (unsigned int)4;

  if(h$link1->size >= (unsigned int)((double)new_n_buckets$link1 * __ac_HASH_UPPER$link3 + 0.5))
    j$link1 = (unsigned int)0;

  else
  {
    void *return_value_malloc$1$link1;
    return_value_malloc$1$link1=malloc((unsigned long int)(new_n_buckets$link1 < (unsigned int)16 ? (unsigned int)1 : new_n_buckets$link1 >> 4) * sizeof(unsigned int) /*4ul*/ );
    new_flags$link1 = (unsigned int *)return_value_malloc$1$link1;
    if(new_flags$link1 == ((unsigned int *)NULL))
      return -1;

    memset((void *)new_flags$link1, 0xaa, (unsigned long int)(new_n_buckets$link1 < (unsigned int)16 ? (unsigned int)1 : new_n_buckets$link1 >> 4) * sizeof(unsigned int) /*4ul*/ );
    if(!(h$link1->n_buckets >= new_n_buckets$link1))
    {
      struct dynbuf **new_keys$link1;
      void *return_value_realloc$2$link1;
      return_value_realloc$2$link1=realloc((void *)h$link1->keys, (unsigned long int)new_n_buckets$link1 * sizeof(struct dynbuf *) /*8ul*/ );
      new_keys$link1 = (struct dynbuf **)return_value_realloc$2$link1;
      if(new_keys$link1 == ((struct dynbuf **)NULL))
      {
        free((void *)new_flags$link1);
        return -1;
      }

      h$link1->keys = new_keys$link1;
      {
        struct dynbuf **new_vals$link1;
        void *return_value_realloc$3$link1;
        return_value_realloc$3$link1=realloc((void *)h$link1->vals, (unsigned long int)new_n_buckets$link1 * sizeof(struct dynbuf *) /*8ul*/ );
        new_vals$link1 = (struct dynbuf **)return_value_realloc$3$link1;
        if(new_vals$link1 == ((struct dynbuf **)NULL))
        {
          free((void *)new_flags$link1);
          return -1;
        }

        h$link1->vals = new_vals$link1;
      }
    }

  }
  _Bool tmp_if_expr$4$link1;
  void *return_value_realloc$6$link1;
  if(!(j$link1 == 0u))
  {
    j$link1 = (unsigned int)0;
    for( ; !(j$link1 == h$link1->n_buckets); j$link1 = j$link1 + 1u)
      if((3u & h$link1->flags[(signed long int)(j$link1 >> 4)] >> ((0xfU & j$link1) << 1)) == 0u)
      {
        struct dynbuf *key$link1 = h$link1->keys[(signed long int)j$link1];
        struct dynbuf *val$link1;
        unsigned int new_mask$link1 = new_n_buckets$link1 - (unsigned int)1;
        val$link1 = h$link1->vals[(signed long int)j$link1];
        h$link1->flags[(signed long int)(j$link1 >> 4)] = h$link1->flags[(signed long int)(j$link1 >> 4)] | (unsigned int)(1ul << ((j$link1 & 0xfU) << 1));
        while((_Bool)1)
        {
          unsigned int k$link1;
          unsigned int i$link1;
          unsigned int step$link1 = (unsigned int)0;
          k$link1=kh_dynbuf_hash_func$link1(key$link1);
          i$link1 = k$link1 & new_mask$link1;
          for( ; (2u & new_flags$link1[(signed long int)(i$link1 >> 4)] >> ((0xfU & i$link1) << 1)) == 0u; i$link1 = i$link1 + step$link1 & new_mask$link1)
            step$link1 = step$link1 + 1u;
          new_flags$link1[(signed long int)(i$link1 >> 4)] = new_flags$link1[(signed long int)(i$link1 >> 4)] & (unsigned int)~(2ul << ((i$link1 & 0xfU) << 1));
          if(!(i$link1 >= h$link1->n_buckets))
            tmp_if_expr$4$link1 = (h$link1->flags[(signed long int)(i$link1 >> 4)] >> ((i$link1 & 0xfU) << 1) & (unsigned int)3) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4$link1 = (_Bool)0;
          if(tmp_if_expr$4$link1)
          {
            struct dynbuf *tmp$link1 = h$link1->keys[(signed long int)i$link1];
            h$link1->keys[(signed long int)i$link1] = key$link1;
            key$link1 = tmp$link1;
            {
              struct dynbuf *kh_resize_dynbufmap_t$$1$$2$$1$$1$$1$$1$$1$$2$$tmp$link1 = h$link1->vals[(signed long int)i$link1];
              h$link1->vals[(signed long int)i$link1] = val$link1;
              val$link1 = kh_resize_dynbufmap_t$$1$$2$$1$$1$$1$$1$$1$$2$$tmp$link1;
            }
            h$link1->flags[(signed long int)(i$link1 >> 4)] = h$link1->flags[(signed long int)(i$link1 >> 4)] | (unsigned int)(1ul << ((i$link1 & 0xfU) << 1));
          }

          else
          {
            h$link1->keys[(signed long int)i$link1] = key$link1;
            h$link1->vals[(signed long int)i$link1] = val$link1;
            break;
          }
        }
      }

    if(!(new_n_buckets$link1 >= h$link1->n_buckets))
    {
      void *return_value_realloc$5$link1;
      return_value_realloc$5$link1=realloc((void *)h$link1->keys, (unsigned long int)new_n_buckets$link1 * sizeof(struct dynbuf *) /*8ul*/ );
      h$link1->keys = (struct dynbuf **)return_value_realloc$5$link1;
      return_value_realloc$6$link1=realloc((void *)h$link1->vals, (unsigned long int)new_n_buckets$link1 * sizeof(struct dynbuf *) /*8ul*/ );
      h$link1->vals = (struct dynbuf **)return_value_realloc$6$link1;
    }

    free((void *)h$link1->flags);
    h$link1->flags = new_flags$link1;
    h$link1->n_buckets = new_n_buckets$link1;
    h$link1->n_occupied = h$link1->size;
    h$link1->upper_bound = (unsigned int)((double)h$link1->n_buckets * __ac_HASH_UPPER$link3 + 0.5);
  }

  return 0;
}

// kh_resize_sha1map_t
// file cachefkcrt.c line 56
static inline signed int kh_resize_sha1map_t(struct anonymous$0 *h, unsigned int new_n_buckets)
{
  unsigned int *new_flags = ((unsigned int *)NULL);
  unsigned int j = (unsigned int)1;
  new_n_buckets = new_n_buckets - 1u;
  new_n_buckets = new_n_buckets | new_n_buckets >> 1;
  new_n_buckets = new_n_buckets | new_n_buckets >> 2;
  new_n_buckets = new_n_buckets | new_n_buckets >> 4;
  new_n_buckets = new_n_buckets | new_n_buckets >> 8;
  new_n_buckets = new_n_buckets | new_n_buckets >> 16;
  new_n_buckets = new_n_buckets + 1u;
  if(!(new_n_buckets >= 4u))
    new_n_buckets = (unsigned int)4;

  if(h->size >= (unsigned int)((double)new_n_buckets * __ac_HASH_UPPER + 0.5))
    j = (unsigned int)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    new_flags = (unsigned int *)return_value_malloc$1;
    if(new_flags == ((unsigned int *)NULL))
      return -1;

    memset((void *)new_flags, 0xaa, (unsigned long int)(new_n_buckets < (unsigned int)16 ? (unsigned int)1 : new_n_buckets >> 4) * sizeof(unsigned int) /*4ul*/ );
    if(!(h->n_buckets >= new_n_buckets))
    {
      void **new_keys;
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
      new_keys = (void **)return_value_realloc$2;
      if(new_keys == ((void **)NULL))
      {
        free((void *)new_flags);
        return -1;
      }

      h->keys = new_keys;
      {
        void **new_vals;
        void *return_value_realloc$3;
        return_value_realloc$3=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
        new_vals = (void **)return_value_realloc$3;
        if(new_vals == ((void **)NULL))
        {
          free((void *)new_flags);
          return -1;
        }

        h->vals = new_vals;
      }
    }

  }
  _Bool tmp_if_expr$4;
  void *return_value_realloc$6;
  if(!(j == 0u))
  {
    j = (unsigned int)0;
    for( ; !(j == h->n_buckets); j = j + 1u)
      if((3u & h->flags[(signed long int)(j >> 4)] >> ((0xfU & j) << 1)) == 0u)
      {
        void *key = h->keys[(signed long int)j];
        void *val;
        unsigned int new_mask = new_n_buckets - (unsigned int)1;
        val = h->vals[(signed long int)j];
        h->flags[(signed long int)(j >> 4)] = h->flags[(signed long int)(j >> 4)] | (unsigned int)(1ul << ((j & 0xfU) << 1));
        while((_Bool)1)
        {
          unsigned int k;
          unsigned int i;
          unsigned int step = (unsigned int)0;
          k=kh_x509fpr_hash_func(key);
          i = k & new_mask;
          for( ; (2u & new_flags[(signed long int)(i >> 4)] >> ((0xfU & i) << 1)) == 0u; i = i + step & new_mask)
            step = step + 1u;
          new_flags[(signed long int)(i >> 4)] = new_flags[(signed long int)(i >> 4)] & (unsigned int)~(2ul << ((i & 0xfU) << 1));
          if(!(i >= h->n_buckets))
            tmp_if_expr$4 = (h->flags[(signed long int)(i >> 4)] >> ((i & 0xfU) << 1) & (unsigned int)3) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
          {
            void *tmp = h->keys[(signed long int)i];
            h->keys[(signed long int)i] = key;
            key = tmp;
            {
              void *kh_resize_sha1map_t$$1$$2$$1$$1$$1$$1$$1$$2$$tmp = h->vals[(signed long int)i];
              h->vals[(signed long int)i] = val;
              val = kh_resize_sha1map_t$$1$$2$$1$$1$$1$$1$$1$$2$$tmp;
            }
            h->flags[(signed long int)(i >> 4)] = h->flags[(signed long int)(i >> 4)] | (unsigned int)(1ul << ((i & 0xfU) << 1));
          }

          else
          {
            h->keys[(signed long int)i] = key;
            h->vals[(signed long int)i] = val;
            break;
          }
        }
      }

    if(!(new_n_buckets >= h->n_buckets))
    {
      void *return_value_realloc$5;
      return_value_realloc$5=realloc((void *)h->keys, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
      h->keys = (void **)return_value_realloc$5;
      return_value_realloc$6=realloc((void *)h->vals, (unsigned long int)new_n_buckets * sizeof(void *) /*8ul*/ );
      h->vals = (void **)return_value_realloc$6;
    }

    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (unsigned int)((double)h->n_buckets * __ac_HASH_UPPER + 0.5);
  }

  return 0;
}

// kh_x509fpr_hash_func
// file cachefkcrt.c line 42
static inline unsigned int kh_x509fpr_hash_func(void *b)
{
  unsigned int *p = (unsigned int *)((char *)b + (signed long int)20);
  unsigned int h = (unsigned int)0;
  do
  {
    p = p - 1l;
    if(!(p >= (unsigned int *)b))
      break;

    h = h ^ *p;
  }
  while((_Bool)1);
  return h;
}

// log_connect_close
// file log.c line 210
static void log_connect_close(void)
{
  close(connect_fd);
}

// log_connect_open
// file log.c line 169
static signed int log_connect_open(const char *logfile)
{
  connect_fd=open(logfile, 01 | 02000 | 0100, 0660);
  if(connect_fd == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_err_printf("Failed to open '%s' for writing: %s\n", logfile, return_value_strerror$2);
    return -1;
  }

  return 0;
}

// log_connect_writecb
// file log.c line 187
static signed long int log_connect_writecb(void *fh, const void *buf, unsigned long int sz)
{
  char timebuf[32l];
  signed long int epoch;
  struct tm *utc;
  unsigned long int n;
  time(&epoch);
  utc=gmtime(&epoch);
  n=strftime(timebuf, sizeof(char [32l]) /*32ul*/ , "%Y-%m-%d %H:%M:%S UTC ", utc);
  _Bool tmp_if_expr$5;
  signed long int return_value_write$4;
  if(n == 0ul)
  {
    log_err_printf("Error from strftime(): buffer too small\n");
    return (signed long int)-1;
  }

  else
  {
    signed long int return_value_write$3;
    return_value_write$3=write(connect_fd, (const void *)timebuf, n);
    if(return_value_write$3 == -1l)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_write$4=write(connect_fd, buf, sz);
      tmp_if_expr$5 = return_value_write$4 == (signed long int)-1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_err_printf("Warning: Failed to write to connect log: %s\n", return_value_strerror$2);
    }

    return (signed long int)0;
  }
}

// log_content_close
// file log.c line 489
signed int log_content_close(struct log_content_ctx **pctx)
{
  signed int rv = 0;
  _Bool tmp_if_expr$1;
  if(*pctx == ((struct log_content_ctx *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !((*pctx)->open != 0u) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -1;

  else
  {
    signed int return_value_logger_close$2;
    return_value_logger_close$2=logger_close(content_log, (void *)*pctx);
    if(return_value_logger_close$2 == -1)
      rv = -1;

    *pctx = (struct log_content_ctx *)(void *)0;
    return rv;
  }
}

// log_content_common_writecb
// file log.c line 507
static signed long int log_content_common_writecb(void *fh, const void *buf, unsigned long int sz)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  signed long int return_value_write$3;
  return_value_write$3=write(ctx->fd, buf, sz);
  if(return_value_write$3 == -1l)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_err_printf("Warning: Failed to write to content log: %s\n", return_value_strerror$2);
    return (signed long int)-1;
  }

  return (signed long int)0;
}

// log_content_dir_closecb
// file log.c line 534
static void log_content_dir_closecb(void *fh)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  if(!(ctx->u.dir.filename == ((char *)NULL)))
    free((void *)ctx->u.dir.filename);

  if(!(ctx->fd == 1))
    close(ctx->fd);

  free((void *)ctx);
}

// log_content_dir_opencb
// file log.c line 520
static signed int log_content_dir_opencb(void *fh)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  ctx->fd=open(ctx->u.dir.filename, 01 | 02000 | 0100, 0660);
  if(ctx->fd == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    log_err_printf("Failed to open '%s': %s (%i)\n", ctx->u.dir.filename, return_value_strerror$2, *return_value___errno_location$3);
    return -1;
  }

  return 0;
}

// log_content_file_closecb
// file log.c line 603
static void log_content_file_closecb(void *fh)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  if(!(ctx->u.file.header_req == ((char *)NULL)))
    free((void *)ctx->u.file.header_req);

  if(!(ctx->u.file.header_resp == ((char *)NULL)))
    free((void *)ctx->u.file.header_resp);

  free((void *)ctx);
}

// log_content_file_fini
// file log.c line 261
static void log_content_file_fini(void)
{
  if(!(content_fd == -1))
  {
    close(content_fd);
    content_fd = -1;
  }

}

// log_content_file_preinit
// file log.c line 249
static signed int log_content_file_preinit(const char *logfile)
{
  content_fd=open(logfile, 01 | 02000 | 0100, 0660);
  if(content_fd == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_err_printf("Failed to open '%s' for writing: %s\n", logfile, return_value_strerror$2);
    return -1;
  }

  return 0;
}

// log_content_file_prepcb
// file log.c line 618
static struct logbuf * log_content_file_prepcb(void *fh, unsigned long int prepflags, struct logbuf *lb)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  signed int is_request = (signed int)!(!((prepflags & (unsigned long int)1) != 0ul));
  struct logbuf *head;
  signed long int epoch;
  struct tm *utc;
  char *header;
  char *tmp_if_expr$1;
  if(!(is_request == 0))
    tmp_if_expr$1 = ctx->u.file.header_req;

  else
    tmp_if_expr$1 = ctx->u.file.header_resp;
  header = tmp_if_expr$1;
  signed long int return_value_logbuf_size$2;
  unsigned long int return_value_strlen$3;
  unsigned long int return_value_strftime$4;
  if(!(header == ((char *)NULL)))
  {
    return_value_logbuf_size$2=logbuf_size(lb);
    head=logbuf_new_printf(lb->fh, lb, " (%zu):\n", return_value_logbuf_size$2);
    if(head == ((struct logbuf *)NULL))
    {
      log_err_printf("Failed to allocate memory\n");
      logbuf_free(lb);
      return (struct logbuf *)(void *)0;
    }

    lb = head;
    return_value_strlen$3=strlen(header);
    head=logbuf_new_copy((const void *)header, return_value_strlen$3, lb->fh, lb);
    if(head == ((struct logbuf *)NULL))
    {
      log_err_printf("Failed to allocate memory\n");
      logbuf_free(lb);
      return (struct logbuf *)(void *)0;
    }

    lb = head;
    head=logbuf_new_alloc((unsigned long int)32, lb->fh, lb);
    if(head == ((struct logbuf *)NULL))
    {
      log_err_printf("Failed to allocate memory\n");
      logbuf_free(lb);
      return (struct logbuf *)(void *)0;
    }

    lb = head;
    time(&epoch);
    utc=gmtime(&epoch);
    return_value_strftime$4=strftime((char *)lb->buf, (unsigned long int)lb->sz, "%Y-%m-%d %H:%M:%S UTC ", utc);
    lb->sz = (signed long int)return_value_strftime$4;
  }


out:
  ;
  return lb;
}

// log_content_format_pathspec
// file log.c line 279
static char * log_content_format_pathspec(const char *logspec, char *srcaddr, char *dstaddr, char *exec_path, char *user, char *group)
{
  unsigned long int path_buflen = (unsigned long int)1024;
  char *path_buf;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(path_buflen);
  path_buf = (char *)return_value_malloc$1;
  unsigned long int tmp_if_expr$3;
  unsigned long int return_value_strlen$2;
  unsigned long int tmp_if_expr$5;
  unsigned long int return_value_strlen$4;
  unsigned long int tmp_if_expr$7;
  unsigned long int return_value_strlen$6;
  unsigned long int tmp_if_expr$9;
  unsigned long int return_value_strlen$8;
  signed long int epoch;
  struct tm *utc;
  if(path_buf == ((char *)NULL))
  {
    log_err_printf("failed to allocate path buffer\n");
    return (char *)(void *)0;
  }

  else
  {
    path_buf[(signed long int)0] = (char)0;
    unsigned long int path_len = (unsigned long int)0;
    const char *p = logspec;
    for( ; !((signed int)*p == 0); p = p + 1l)
    {
      const char *elem = (const char *)(void *)0;
      unsigned long int elem_len = (unsigned long int)0;
      const char iso8601[15l] = { '%', 'Y', '%', 'm', '%', 'd', 'T', '%', 'H', '%', 'M', '%', 'S', 'Z', 0 };
      char timebuf[24l];
      if((signed int)*p == 37)
      {
        p = p + 1l;
        switch((signed int)*p)
        {
          case 0:
          {
            p = p - 1l;
            elem_len = (unsigned long int)0;
            break;
          }
          case 37:
          {
            elem = p;
            elem_len = (unsigned long int)1;
            break;
          }
          case 100:
          {
            elem = dstaddr;
            elem_len=strlen(dstaddr);
            break;
          }
          case 115:
          {
            elem = srcaddr;
            elem_len=strlen(srcaddr);
            break;
          }
          case 120:
          {
            if(!(exec_path == ((char *)NULL)))
            {
              char *match = exec_path;
              do
              {
                match=strchr(match, 47);
                if(match == ((char *)NULL))
                  break;

                match = match + 1l;
                elem = match;
              }
              while((_Bool)1);
              if(!(elem == ((const char *)NULL)))
              {
                return_value_strlen$2=strlen(elem);
                tmp_if_expr$3 = return_value_strlen$2;
              }

              else
                tmp_if_expr$3 = (unsigned long int)0;
              elem_len = tmp_if_expr$3;
            }

            else
              elem_len = (unsigned long int)0;
            break;
          }
          case 88:
          {
            elem = exec_path;
            if(!(exec_path == ((char *)NULL)))
            {
              return_value_strlen$4=strlen(exec_path);
              tmp_if_expr$5 = return_value_strlen$4;
            }

            else
              tmp_if_expr$5 = (unsigned long int)0;
            elem_len = tmp_if_expr$5;
            break;
          }
          case 117:
          {
            elem = user;
            if(!(user == ((char *)NULL)))
            {
              return_value_strlen$6=strlen(user);
              tmp_if_expr$7 = return_value_strlen$6;
            }

            else
              tmp_if_expr$7 = (unsigned long int)0;
            elem_len = tmp_if_expr$7;
            break;
          }
          case 103:
          {
            elem = group;
            if(!(group == ((char *)NULL)))
            {
              return_value_strlen$8=strlen(group);
              tmp_if_expr$9 = return_value_strlen$8;
            }

            else
              tmp_if_expr$9 = (unsigned long int)0;
            elem_len = tmp_if_expr$9;
            break;
          }
          case 84:
          {
            time(&epoch);
            utc=gmtime(&epoch);
            strftime(timebuf, sizeof(char [24l]) /*24ul*/ , iso8601, utc);
            elem = timebuf;
            elem_len = sizeof(char [24l]) /*24ul*/ ;
          }
        }
        goto __CPROVER_DUMP_L27;
      }

      elem = p;
      elem_len = (unsigned long int)1;

    __CPROVER_DUMP_L27:
      ;
      if(elem_len >= 1ul)
      {
        if(!(path_buflen + -path_len >= 1ul + elem_len))
        {
          path_buflen = path_buflen + elem_len + (unsigned long int)1024;
          char *newbuf;
          void *return_value_realloc$10;
          return_value_realloc$10=realloc((void *)path_buf, path_buflen);
          newbuf = (char *)return_value_realloc$10;
          if(newbuf == ((char *)NULL))
          {
            log_err_printf("failed to reallocate path buffer\n");
            free((void *)path_buf);
            return (char *)(void *)0;
          }

          path_buf = newbuf;
        }

        strncat(path_buf, elem, elem_len);
        path_len = path_len + elem_len;
      }

    }
    /* assertion path_buflen > path_len */
    assert(path_buflen > path_len);
    path_buf[(signed long int)path_len] = (char)0;
    return path_buf;
  }
}

// log_content_open
// file log.c line 399
signed int log_content_open(struct log_content_ctx **pctx, struct opts *opts, char *srcaddr, char *dstaddr, char *exec_path, char *user, char *group)
{
  struct log_content_ctx *ctx;
  if(!(*pctx == ((struct log_content_ctx *)NULL)))
    return 0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct log_content_ctx) /*24ul*/ );
    *pctx = (struct log_content_ctx *)return_value_malloc$1;
    if(*pctx == ((struct log_content_ctx *)NULL))
      return -1;

    else
    {
      ctx = *pctx;
      if(!(opts->contentlog_isdir == 0u))
      {
        char timebuf[24l];
        signed long int epoch;
        struct tm *utc;
        signed long int return_value_time$2;
        return_value_time$2=time(&epoch);
        if(return_value_time$2 == -1l)
        {
          log_err_printf("Failed to get time\n");
          goto errout;
        }

        utc=gmtime(&epoch);
        if(utc == ((struct tm *)NULL))
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          char *return_value_strerror$4;
          return_value_strerror$4=strerror(*return_value___errno_location$3);
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          log_err_printf("Failed to convert time: %s (%i)\n", return_value_strerror$4, *return_value___errno_location$5);
          goto errout;
        }

        unsigned long int return_value_strftime$9;
        return_value_strftime$9=strftime(timebuf, sizeof(char [24l]) /*24ul*/ , "%Y%m%dT%H%M%SZ", utc);
        if(return_value_strftime$9 == 0ul)
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          log_err_printf("Failed to format time: %s (%i)\n", return_value_strerror$7, *return_value___errno_location$8);
          goto errout;
        }

        signed int return_value_asprintf$13;
        return_value_asprintf$13=asprintf(&ctx->u.dir.filename, "%s/%s-%s-%s.log", opts->contentlog, (const void *)timebuf, srcaddr, dstaddr);
        if(!(return_value_asprintf$13 >= 0))
        {
          signed int *return_value___errno_location$10;
          return_value___errno_location$10=__errno_location();
          char *return_value_strerror$11;
          return_value_strerror$11=strerror(*return_value___errno_location$10);
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          log_err_printf("Failed to format filename: %s (%i)\n", return_value_strerror$11, *return_value___errno_location$12);
          goto errout;
        }

      }

      else
        if(!(opts->contentlog_isspec == 0u))
        {
          ctx->u.spec.filename=log_content_format_pathspec(opts->contentlog, srcaddr, dstaddr, exec_path, user, group);
          if(ctx->u.spec.filename == ((char *)NULL))
            goto errout;

        }

        else
        {
          ctx->fd = content_fd;
          signed int return_value_asprintf$14;
          return_value_asprintf$14=asprintf(&ctx->u.file.header_req, "%s -> %s", srcaddr, dstaddr);
          if(!(return_value_asprintf$14 >= 0))
            goto errout;

          signed int return_value_asprintf$15;
          return_value_asprintf$15=asprintf(&ctx->u.file.header_resp, "%s -> %s", dstaddr, srcaddr);
          if(!(return_value_asprintf$15 >= 0))
          {
            free((void *)ctx->u.file.header_req);
            goto errout;
          }

        }
      signed int return_value_logger_open$16;
      return_value_logger_open$16=logger_open(content_log, (void *)ctx);
      if(!(return_value_logger_open$16 == -1))
      {
        ctx->open = (unsigned int)1;
        return 0;
      }

      else
      {

      errout:
        ;
        free((void *)ctx);
        *pctx = (struct log_content_ctx *)(void *)0;
        return -1;
      }
    }
  }
}

// log_content_spec_closecb
// file log.c line 583
static void log_content_spec_closecb(void *fh)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  if(!(ctx->u.spec.filename == ((char *)NULL)))
    free((void *)ctx->u.spec.filename);

  if(!(ctx->fd == -1))
    close(ctx->fd);

  free((void *)ctx);
}

// log_content_spec_opencb
// file log.c line 546
static signed int log_content_spec_opencb(void *fh)
{
  struct log_content_ctx *ctx = (struct log_content_ctx *)fh;
  char *filedir;
  char *filename2;
  filename2=strdup(ctx->u.spec.filename);
  if(filename2 == ((char *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    log_err_printf("Could not duplicate filname: %s (%i)\n", return_value_strerror$2, *return_value___errno_location$3);
    return -1;
  }

  filedir=dirname(filename2);
  if(filedir == ((char *)NULL))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    log_err_printf("Could not get dirname: %s (%i)\n", return_value_strerror$5, *return_value___errno_location$6);
    free((void *)filename2);
    return -1;
  }

  signed int return_value_sys_mkpath$10;
  return_value_sys_mkpath$10=sys_mkpath(filedir, (unsigned int)0755);
  if(return_value_sys_mkpath$10 == -1)
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    log_err_printf("Could not create directory '%s': %s (%i)\n", filedir, return_value_strerror$8, *return_value___errno_location$9);
    free((void *)filename2);
    return -1;
  }

  free((void *)filename2);
  ctx->fd=open(ctx->u.spec.filename, 01 | 02000 | 0100, 0660);
  if(ctx->fd == -1)
  {
    signed int *return_value___errno_location$11;
    return_value___errno_location$11=__errno_location();
    char *return_value_strerror$12;
    return_value_strerror$12=strerror(*return_value___errno_location$11);
    log_err_printf("Failed to open '%s': %s\n", ctx->u.spec.filename, return_value_strerror$12);
    return -1;
  }

  return 0;
}

// log_content_submit
// file log.c line 474
signed int log_content_submit(struct log_content_ctx *ctx, struct logbuf *lb, signed int is_request)
{
  unsigned long int prepflags = (unsigned long int)0;
  if(ctx->open == 0u)
  {
    log_err_printf("log_content_submit called on closed ctx\n");
    return -1;
  }

  else
  {
    if(!(is_request == 0))
      prepflags = prepflags | (unsigned long int)1;

    signed int return_value_logger_submit$1;
    return_value_logger_submit$1=logger_submit(content_log, (void *)ctx, prepflags, lb);
    return return_value_logger_submit$1;
  }
}

// log_dbg_mode
// file log.c line 154
void log_dbg_mode(signed int mode)
{
  dbg_mode = mode;
}

// log_dbg_print_free
// file log.h line 42
signed int log_dbg_print_free(char *s)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  signed int return_value_log_dbg_write_free$2;
  return_value_log_dbg_write_free$2=log_dbg_write_free((void *)s, return_value_strlen$1 + (unsigned long int)1);
  return return_value_log_dbg_write_free$2;
}

// log_dbg_printf
// file log.h line 41
signed int log_dbg_printf(const char *fmt, ...)
{
  void **ap;
  char *log_dbg_printf$$1$$buf;
  signed int rv;
  if(dbg_mode == 0)
    return 0;

  else
  {
    ap = (void **)&fmt;
    rv=vasprintf(&log_dbg_printf$$1$$buf, fmt, ap);
    ap = ((void **)NULL);
    if(!(rv >= 0))
      return -1;

    else
    {
      signed int return_value_log_dbg_print_free$1;
      return_value_log_dbg_print_free$1=log_dbg_print_free(log_dbg_printf$$1$$buf);
      return return_value_log_dbg_print_free$1;
    }
  }
}

// log_dbg_write_free
// file log.c line 115
signed int log_dbg_write_free(void *buf, unsigned long int sz)
{
  if(dbg_mode == 0)
    return 0;

  else
  {
    if(!(err_started == 0))
    {
      signed int return_value_logger_write_freebuf$1;
      return_value_logger_write_freebuf$1=logger_write_freebuf(err_log, (void *)0, (unsigned long int)0, buf, sz);
      return return_value_logger_write_freebuf$1;
    }

    else
    {
      log_err_writecb((void *)0, buf, sz);
      free(buf);
    }
    return 0;
  }
}

// log_err_mode
// file log.c line 100
void log_err_mode(signed int mode)
{
  err_mode = mode;
}

// log_err_printf
// file log.h line 36
signed int log_err_printf(const char *fmt, ...)
{
  void **ap;
  char *log_err_printf$$1$$buf;
  signed int rv;
  ap = (void **)&fmt;
  rv=vasprintf(&log_err_printf$$1$$buf, fmt, ap);
  ap = ((void **)NULL);
  if(!(rv >= 0))
    return -1;

  else
  {
    if(!(err_started == 0))
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(log_err_printf$$1$$buf);
      signed int return_value_logger_write_freebuf$2;
      return_value_logger_write_freebuf$2=logger_write_freebuf(err_log, (void *)0, (unsigned long int)0, (void *)log_err_printf$$1$$buf, return_value_strlen$1 + (unsigned long int)1);
      return return_value_logger_write_freebuf$2;
    }

    else
    {
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(log_err_printf$$1$$buf);
      log_err_writecb((void *)0, (const void *)(unsigned char *)log_err_printf$$1$$buf, return_value_strlen$3 + (unsigned long int)1);
      free((void *)log_err_printf$$1$$buf);
    }
    return 0;
  }
}

// log_err_writecb
// file log.c line 65
static signed long int log_err_writecb(void *fh, const void *buf, unsigned long int sz)
{
  unsigned long int return_value_fwrite$1;
  switch(err_mode)
  {
    case 0:
    {
      return_value_fwrite$1=fwrite(buf, sz - (unsigned long int)1, (unsigned long int)1, stderr);
      return (signed long int)return_value_fwrite$1;
    }
    case 1:
    {
      syslog(3, "%s", (const char *)buf);
      return (signed long int)0;
    }
    default:
      return (signed long int)-1;
  }
}

// log_fini
// file log.c line 761
void log_fini(void)
{
  if(!(content_log == ((struct logger *)NULL)))
    logger_leave(content_log);

  if(!(connect_log == ((struct logger *)NULL)))
    logger_leave(connect_log);

  logger_leave(err_log);
  if(!(content_log == ((struct logger *)NULL)))
    logger_join(content_log);

  if(!(connect_log == ((struct logger *)NULL)))
    logger_join(connect_log);

  logger_join(err_log);
  if(!(content_log == ((struct logger *)NULL)))
    logger_free(content_log);

  if(!(connect_log == ((struct logger *)NULL)))
    logger_free(connect_log);

  logger_free(err_log);
  if(!(content_log == ((struct logger *)NULL)))
    log_content_file_fini();

  if(!(connect_log == ((struct logger *)NULL)))
    log_connect_close();

}

// log_init
// file log.c line 739
signed int log_init(struct opts *opts)
{
  signed int return_value_logger_start$1;
  signed int return_value_logger_start$2;
  signed int return_value_logger_start$3;
  if(!(err_log == ((struct logger *)NULL)))
  {
    return_value_logger_start$1=logger_start(err_log);
    if(!(return_value_logger_start$1 == -1))
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(opts->debug == 0u)
      err_started = 1;

    if(!(connect_log == ((struct logger *)NULL)))
    {
      return_value_logger_start$2=logger_start(connect_log);
      if(!(return_value_logger_start$2 == -1))
        goto __CPROVER_DUMP_L3;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(!(content_log == ((struct logger *)NULL)))
      {
        return_value_logger_start$3=logger_start(content_log);
        if(!(return_value_logger_start$3 == -1))
          goto __CPROVER_DUMP_L4;

        return -1;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        return 0;
      }
    }
  }
}

// log_preinit
// file log.c line 677
signed int log_preinit(struct opts *opts)
{
  signed int (*opencb)(void *);
  void (*closecb)(void *);
  signed long int (*writecb)(void *, const void *, unsigned long int);
  struct logbuf * (*prepcb)(void *, unsigned long int, struct logbuf *);
  if(!(opts->contentlog == ((char *)NULL)))
  {
    if(!(opts->contentlog_isdir == 0u))
    {
      opencb = log_content_dir_opencb;
      closecb = log_content_dir_closecb;
      writecb = log_content_common_writecb;
      prepcb = (struct logbuf * (*)(void *, unsigned long int, struct logbuf *))(void *)0;
    }

    else
      if(!(opts->contentlog_isspec == 0u))
      {
        opencb = log_content_spec_opencb;
        closecb = log_content_spec_closecb;
        writecb = log_content_common_writecb;
        prepcb = (struct logbuf * (*)(void *, unsigned long int, struct logbuf *))(void *)0;
      }

      else
      {
        signed int return_value_log_content_file_preinit$1;
        return_value_log_content_file_preinit$1=log_content_file_preinit(opts->contentlog);
        if(return_value_log_content_file_preinit$1 == -1)
          goto out;

        opencb = (signed int (*)(void *))(void *)0;
        closecb = log_content_file_closecb;
        writecb = log_content_common_writecb;
        prepcb = log_content_file_prepcb;
      }
    content_log=logger_new(opencb, closecb, writecb, prepcb);
    if(!(content_log == ((struct logger *)NULL)))
      goto __CPROVER_DUMP_L4;

    log_content_file_fini();
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    if(!(opts->connectlog == ((char *)NULL)))
    {
      signed int return_value_log_connect_open$2;
      return_value_log_connect_open$2=log_connect_open(opts->connectlog);
      if(return_value_log_connect_open$2 == -1)
        goto out;

      connect_log=logger_new((signed int (*)(void *))(void *)0, (void (*)(void *))(void *)0, log_connect_writecb, (struct logbuf * (*)(void *, unsigned long int, struct logbuf *))(void *)0);
      if(connect_log == ((struct logger *)NULL))
      {
        log_connect_close();
        goto out;
      }

    }

    err_log=logger_new((signed int (*)(void *))(void *)0, (void (*)(void *))(void *)0, log_err_writecb, (struct logbuf * (*)(void *, unsigned long int, struct logbuf *))(void *)0);
    if(!(err_log == ((struct logger *)NULL)))
      return 0;

  }

out:
  ;
  if(!(content_log == ((struct logger *)NULL)))
  {
    log_content_file_fini();
    logger_free(content_log);
  }

  if(!(connect_log == ((struct logger *)NULL)))
  {
    log_connect_close();
    logger_free(connect_log);
  }

  return -1;
}

// logbuf_free
// file logbuf.c line 176
void logbuf_free(struct logbuf *lb)
{
  if(!(lb->buf == ((unsigned char *)NULL)))
    free((void *)lb->buf);

  if(!(lb->next == ((struct logbuf *)NULL)))
    logbuf_free(lb->next);

  free((void *)lb);
}

// logbuf_new
// file logbuf.c line 47
struct logbuf * logbuf_new(void *buf, unsigned long int sz, void *fh, struct logbuf *next)
{
  struct logbuf *lb;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct logbuf) /*40ul*/ );
  lb = (struct logbuf *)return_value_malloc$1;
  if(lb == ((struct logbuf *)NULL))
    return (struct logbuf *)(void *)0;

  else
  {
    lb->buf = (unsigned char *)buf;
    lb->sz = (signed long int)sz;
    lb->fh = fh;
    lb->ctl = (unsigned long int)0;
    lb->next = next;
    return lb;
  }
}

// logbuf_new_alloc
// file logbuf.c line 65
struct logbuf * logbuf_new_alloc(unsigned long int sz, void *fh, struct logbuf *next)
{
  struct logbuf *lb;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct logbuf) /*40ul*/ );
  lb = (struct logbuf *)return_value_malloc$1;
  if(lb == ((struct logbuf *)NULL))
    return (struct logbuf *)(void *)0;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sz);
    lb->buf = (unsigned char *)return_value_malloc$2;
    if(lb->buf == ((unsigned char *)NULL))
    {
      free((void *)lb);
      return (struct logbuf *)(void *)0;
    }

    else
    {
      lb->sz = (signed long int)sz;
      lb->fh = fh;
      lb->ctl = (unsigned long int)0;
      lb->next = next;
      return lb;
    }
  }
}

// logbuf_new_copy
// file logbuf.c line 86
struct logbuf * logbuf_new_copy(const void *buf, unsigned long int sz, void *fh, struct logbuf *next)
{
  struct logbuf *lb;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct logbuf) /*40ul*/ );
  lb = (struct logbuf *)return_value_malloc$1;
  if(lb == ((struct logbuf *)NULL))
    return (struct logbuf *)(void *)0;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sz);
    lb->buf = (unsigned char *)return_value_malloc$2;
    if(lb->buf == ((unsigned char *)NULL))
    {
      free((void *)lb);
      return (struct logbuf *)(void *)0;
    }

    else
    {
      memcpy((void *)lb->buf, buf, sz);
      lb->sz = (signed long int)sz;
      lb->fh = fh;
      lb->ctl = (unsigned long int)0;
      lb->next = next;
      return lb;
    }
  }
}

// logbuf_new_printf
// file logbuf.c line 108
struct logbuf * logbuf_new_printf(void *fh, struct logbuf *next, const char *fmt, ...)
{
  void **ap;
  struct logbuf *lb;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct logbuf) /*40ul*/ );
  lb = (struct logbuf *)return_value_malloc$1;
  if(lb == ((struct logbuf *)NULL))
    return (struct logbuf *)(void *)0;

  else
  {
    ap = (void **)&fmt;
    signed int return_value_vasprintf$2;
    return_value_vasprintf$2=vasprintf((char **)&lb->buf, fmt, ap);
    lb->sz = (signed long int)return_value_vasprintf$2;
    ap = ((void **)NULL);
    if(!(lb->sz >= 0l))
    {
      free((void *)lb);
      return (struct logbuf *)(void *)0;
    }

    else
    {
      lb->fh = fh;
      lb->ctl = (unsigned long int)0;
      lb->next = next;
      return lb;
    }
  }
}

// logbuf_size
// file logbuf.c line 132
signed long int logbuf_size(struct logbuf *lb)
{
  signed long int logbuf_size$$1$$sz = lb->sz;
  if(!(lb->next == ((struct logbuf *)NULL)))
  {
    signed long int return_value_logbuf_size$1;
    return_value_logbuf_size$1=logbuf_size(lb->next);
    logbuf_size$$1$$sz = logbuf_size$$1$$sz + return_value_logbuf_size$1;
  }

  return logbuf_size$$1$$sz;
}

// logbuf_write_free
// file logbuf.c line 149
signed long int logbuf_write_free(struct logbuf *lb, signed long int (*writefunc)(void *, const void *, unsigned long int))
{
  signed long int rv1;
  signed long int rv2 = (signed long int)0;
  rv1=writefunc(lb->fh, (const void *)lb->buf, (unsigned long int)lb->sz);
  if(!(lb->buf == ((unsigned char *)NULL)))
    free((void *)lb->buf);

  if(!(lb->next == ((struct logbuf *)NULL)))
  {
    if(rv1 == -1l)
      logbuf_free(lb->next);

    else
    {
      lb->next->fh = lb->fh;
      rv2=logbuf_write_free(lb->next, writefunc);
    }
  }

  free((void *)lb);
  if(rv1 == -1l || rv2 == -1l)
    return (signed long int)-1;

  else
    return rv1 + rv2;
}

// logger_clear
// file logger.c line 59
static void logger_clear(struct logger *logger)
{
  memset((void *)logger, 0, sizeof(struct logger) /*48ul*/ );
}

// logger_close
// file logger.h line 53
signed int logger_close(struct logger *logger, void *fh)
{
  struct logbuf *lb;
  if(logger->close == ((void (*)(void *))NULL))
    return 0;

  else
  {
    lb=logbuf_new((void *)0, (unsigned long int)0, (void *)0, (struct logbuf *)(void *)0);
    lb->fh = fh;
    lb->ctl = lb->ctl | (unsigned long int)2;
    void *return_value_thrqueue_enqueue$1;
    return_value_thrqueue_enqueue$1=thrqueue_enqueue(logger->queue, (void *)lb);
    return return_value_thrqueue_enqueue$1 != NULL ? 0 : -1;
  }
}

// logger_free
// file logger.h line 47
void logger_free(struct logger *logger)
{
  if(!(logger->queue == ((struct thrqueue *)NULL)))
    thrqueue_free(logger->queue);

  free((void *)logger);
}

// logger_join
// file logger.h line 50
signed int logger_join(struct logger *logger)
{
  signed int rv;
  rv=pthread_join(logger->thr, (void **)(void *)0);
  if(!(rv == 0))
    return -1;

  else
    return 0;
}

// logger_leave
// file logger.h line 49
void logger_leave(struct logger *logger)
{
  thrqueue_unblock_dequeue(logger->queue);
  sched_yield();
}

// logger_new
// file logger.h line 44
struct logger * logger_new(signed int (*openfunc)(void *), void (*closefunc)(void *), signed long int (*writefunc)(void *, const void *, unsigned long int), struct logbuf * (*prepfunc)(void *, unsigned long int, struct logbuf *))
{
  struct logger *logger;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct logger) /*48ul*/ );
  logger = (struct logger *)return_value_malloc$1;
  if(logger == ((struct logger *)NULL))
    return (struct logger *)(void *)0;

  else
  {
    logger_clear(logger);
    logger->open = openfunc;
    logger->close = closefunc;
    logger->write = writefunc;
    logger->prep = prepfunc;
    logger->queue = (struct thrqueue *)(void *)0;
    return logger;
  }
}

// logger_open
// file logger.h line 52
signed int logger_open(struct logger *logger, void *fh)
{
  struct logbuf *lb;
  if(logger->open == ((signed int (*)(void *))NULL))
    return 0;

  else
  {
    lb=logbuf_new((void *)0, (unsigned long int)0, (void *)0, (struct logbuf *)(void *)0);
    lb->fh = fh;
    lb->ctl = lb->ctl | (unsigned long int)1;
    void *return_value_thrqueue_enqueue$1;
    return_value_thrqueue_enqueue$1=thrqueue_enqueue(logger->queue, (void *)lb);
    return return_value_thrqueue_enqueue$1 != NULL ? 0 : -1;
  }
}

// logger_print
// file logger.c line 273
signed int logger_print(struct logger *logger, void *fh, unsigned long int prepflags, const char *s)
{
  struct logbuf *lb;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!(s == ((const char *)NULL)))
  {
    return_value_strlen$1=strlen(s);
    tmp_if_expr$2 = return_value_strlen$1;
  }

  else
    tmp_if_expr$2 = (unsigned long int)0;
  lb=logbuf_new_copy((const void *)s, tmp_if_expr$2, fh, (struct logbuf *)(void *)0);
  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    signed int return_value_logger_submit$3;
    return_value_logger_submit$3=logger_submit(logger, fh, prepflags, lb);
    return return_value_logger_submit$3;
  }
}

// logger_print_freebuf
// file logger.c line 293
signed int logger_print_freebuf(struct logger *logger, void *fh, unsigned long int prepflags, char *s)
{
  struct logbuf *lb;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!(s == ((char *)NULL)))
  {
    return_value_strlen$1=strlen(s);
    tmp_if_expr$2 = return_value_strlen$1;
  }

  else
    tmp_if_expr$2 = (unsigned long int)0;
  lb=logbuf_new((void *)s, tmp_if_expr$2, fh, (struct logbuf *)(void *)0);
  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    signed int return_value_logger_submit$3;
    return_value_logger_submit$3=logger_submit(logger, fh, prepflags, lb);
    return return_value_logger_submit$3;
  }
}

// logger_printf
// file logger.c line 244
signed int logger_printf(struct logger *logger, void *fh, unsigned long int prepflags, const char *fmt, ...)
{
  void **ap;
  struct logbuf *lb;
  lb=logbuf_new((void *)0, (unsigned long int)0, fh, (struct logbuf *)(void *)0);
  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    ap = (void **)&fmt;
    signed int return_value_vasprintf$1;
    return_value_vasprintf$1=vasprintf((char **)&lb->buf, fmt, ap);
    lb->sz = (signed long int)return_value_vasprintf$1;
    ap = ((void **)NULL);
    if(!(lb->sz >= 0l))
    {
      logbuf_free(lb);
      return -1;
    }

    else
    {
      signed int return_value_logger_submit$2;
      return_value_logger_submit$2=logger_submit(logger, fh, prepflags, lb);
      return return_value_logger_submit$2;
    }
  }
}

// logger_start
// file logger.h line 48
signed int logger_start(struct logger *logger)
{
  signed int rv;
  if(!(logger->queue == ((struct thrqueue *)NULL)))
    thrqueue_free(logger->queue);

  logger->queue=thrqueue_new((unsigned long int)1024);
  rv=pthread_create(&logger->thr, (const union pthread_attr_t *)(void *)0, logger_thread, (void *)logger);
  if(!(rv == 0))
    return -1;

  else
  {
    sched_yield();
    return 0;
  }
}

// logger_stop
// file logger.c line 224
signed int logger_stop(struct logger *logger)
{
  logger_leave(logger);
  signed int return_value_logger_join$1;
  return_value_logger_join$1=logger_join(logger);
  return return_value_logger_join$1;
}

// logger_submit
// file logger.h line 54
signed int logger_submit(struct logger *logger, void *fh, unsigned long int prepflags, struct logbuf *lb)
{
  if(!(logger->prep == ((struct logbuf * (*)(void *, unsigned long int, struct logbuf *))NULL)))
    lb=logger->prep(fh, prepflags, lb);

  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    lb->fh = fh;
    lb->ctl = (unsigned long int)0;
    void *return_value_thrqueue_enqueue$1;
    return_value_thrqueue_enqueue$1=thrqueue_enqueue(logger->queue, (void *)lb);
    return return_value_thrqueue_enqueue$1 != NULL ? 0 : -1;
  }
}

// logger_thread
// file logger.c line 159
static void * logger_thread(void *arg)
{
  struct logger *logger = (struct logger *)arg;
  struct logbuf *lb;
  void *return_value_thrqueue_dequeue$1;
  do
  {
    return_value_thrqueue_dequeue$1=thrqueue_dequeue(logger->queue);
    lb = (struct logbuf *)return_value_thrqueue_dequeue$1;
    if(lb == ((struct logbuf *)NULL))
      break;

    if(!((1ul & lb->ctl) == 0ul))
      logger->open(lb->fh);

    else
      if(!((2ul & lb->ctl) == 0ul))
        logger->close(lb->fh);

      else
        logbuf_write_free(lb, logger->write);
  }
  while((_Bool)1);
  return (void *)0;
}

// logger_write
// file logger.c line 263
signed int logger_write(struct logger *logger, void *fh, unsigned long int prepflags, const void *buf, unsigned long int sz)
{
  struct logbuf *lb;
  lb=logbuf_new_copy(buf, sz, fh, (struct logbuf *)(void *)0);
  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    signed int return_value_logger_submit$1;
    return_value_logger_submit$1=logger_submit(logger, fh, prepflags, lb);
    return return_value_logger_submit$1;
  }
}

// logger_write_freebuf
// file logger.h line 64
signed int logger_write_freebuf(struct logger *logger, void *fh, unsigned long int prepflags, void *buf, unsigned long int sz)
{
  struct logbuf *lb;
  lb=logbuf_new(buf, sz, fh, (struct logbuf *)(void *)0);
  if(lb == ((struct logbuf *)NULL))
    return -1;

  else
  {
    signed int return_value_logger_submit$1;
    return_value_logger_submit$1=logger_submit(logger, fh, prepflags, lb);
    return return_value_logger_submit$1;
  }
}

// main
// file main.t.c line 84
signed int main(signed int argc, char **argv)
{
  signed int nfail;
  struct SRunner *sr;
  struct Suite *return_value_blank_suite$1;
  return_value_blank_suite$1=blank_suite();
  sr=srunner_create(return_value_blank_suite$1);
  struct Suite *return_value_main_suite$2;
  return_value_main_suite$2=main_suite();
  srunner_add_suite(sr, return_value_main_suite$2);
  struct Suite *return_value_opts_suite$3;
  return_value_opts_suite$3=opts_suite();
  srunner_add_suite(sr, return_value_opts_suite$3);
  struct Suite *return_value_dynbuf_suite$4;
  return_value_dynbuf_suite$4=dynbuf_suite();
  srunner_add_suite(sr, return_value_dynbuf_suite$4);
  struct Suite *return_value_cert_suite$5;
  return_value_cert_suite$5=cert_suite();
  srunner_add_suite(sr, return_value_cert_suite$5);
  struct Suite *return_value_cachemgr_suite$6;
  return_value_cachemgr_suite$6=cachemgr_suite();
  srunner_add_suite(sr, return_value_cachemgr_suite$6);
  struct Suite *return_value_cachefkcrt_suite$7;
  return_value_cachefkcrt_suite$7=cachefkcrt_suite();
  srunner_add_suite(sr, return_value_cachefkcrt_suite$7);
  struct Suite *return_value_cachetgcrt_suite$8;
  return_value_cachetgcrt_suite$8=cachetgcrt_suite();
  srunner_add_suite(sr, return_value_cachetgcrt_suite$8);
  struct Suite *return_value_cachedsess_suite$9;
  return_value_cachedsess_suite$9=cachedsess_suite();
  srunner_add_suite(sr, return_value_cachedsess_suite$9);
  struct Suite *return_value_cachessess_suite$10;
  return_value_cachessess_suite$10=cachessess_suite();
  srunner_add_suite(sr, return_value_cachessess_suite$10);
  struct Suite *return_value_ssl_suite$11;
  return_value_ssl_suite$11=ssl_suite();
  srunner_add_suite(sr, return_value_ssl_suite$11);
  struct Suite *return_value_sys_suite$12;
  return_value_sys_suite$12=sys_suite();
  srunner_add_suite(sr, return_value_sys_suite$12);
  struct Suite *return_value_base64_suite$13;
  return_value_base64_suite$13=base64_suite();
  srunner_add_suite(sr, return_value_base64_suite$13);
  struct Suite *return_value_url_suite$14;
  return_value_url_suite$14=url_suite();
  srunner_add_suite(sr, return_value_url_suite$14);
  struct Suite *return_value_util_suite$15;
  return_value_util_suite$15=util_suite();
  srunner_add_suite(sr, return_value_util_suite$15);
  struct Suite *return_value_pxythrmgr_suite$16;
  return_value_pxythrmgr_suite$16=pxythrmgr_suite();
  srunner_add_suite(sr, return_value_pxythrmgr_suite$16);
  srunner_run_all(sr, (enum print_output)CK_NORMAL);
  nfail=srunner_ntests_failed(sr);
  srunner_free(sr);
  return !(nfail != 0) ? 0 : 1;
}

// main_suite
// file main.t.c line 55
struct Suite * main_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("main");
  tc=tcase_create("build_date");
  _tcase_add_test(tc, build_date_01, "build_date_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// nat_exist
// file nat.c line 484
signed int nat_exist(const char *name)
{
  if(name == ((const char *)NULL))
    name = engines[(signed long int)0].name;

  signed int return_value_nat_index$1;
  return_value_nat_index$1=nat_index(name);
  return (signed int)!(!(engines[(signed long int)return_value_nat_index$1].name != ((const char *)NULL)));
}

// nat_fini
// file nat.c line 603
void nat_fini(void)
{
  signed int i = 0;
  _Bool tmp_if_expr$1;
  if(!(engines[(signed long int)i].finicb == ((void (*)(void))NULL)))
    tmp_if_expr$1 = engines[(signed long int)i].used != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    log_dbg_printf("NAT engine fini '%s'\n", engines[(signed long int)i].name);
    engines[(signed long int)i].finicb();
    i = i + 1;
  }

}

// nat_getdefaultname
// file nat.c line 459
const char * nat_getdefaultname(void)
{
  return engines[(signed long int)0].name;
}

// nat_getlookupcb
// file nat.c line 509
signed int (*nat_getlookupcb(const char *name))(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int)
{
  signed int i;
  if(name == ((const char *)NULL))
    name = engines[(signed long int)0].name;

  i=nat_index(name);
  engines[(signed long int)i].used = (unsigned int)1;
  return engines[(signed long int)i].lookupcb;
}

// nat_getsocketcb
// file nat.c line 525
signed int (*nat_getsocketcb(const char *name))(signed int)
{
  if(name == ((const char *)NULL))
    name = engines[(signed long int)0].name;

  signed int return_value_nat_index$1;
  return_value_nat_index$1=nat_index(name);
  return engines[(signed long int)return_value_nat_index$1].socketcb;
}

// nat_getsockname_lookup_cb
// file nat.c line 378
static signed int nat_getsockname_lookup_cb(struct sockaddr *dst_addr, unsigned int *dst_addrlen, signed int s, struct sockaddr *src_addr, unsigned int src_addrlen)
{
  signed int return_value_getsockname$3;
  return_value_getsockname$3=getsockname(s, dst_addr, dst_addrlen);
  if(return_value_getsockname$3 == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_err_printf("Error from getsockname(): %s\n", return_value_strerror$2);
    return -1;
  }

  return 0;
}

// nat_index
// file nat.c line 470
static signed int nat_index(const char *name)
{
  signed int return_value_strcmp$1;
  if(!(name == ((const char *)NULL)))
  {
    signed int i = 0;
    for( ; !(engines[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
    {
      return_value_strcmp$1=strcmp(name, engines[(signed long int)i].name);
      if(return_value_strcmp$1 == 0)
        return i;

    }
  }

  return (signed int)(sizeof(struct engine [3l]) /*168ul*/  / sizeof(struct engine) /*56ul*/  - (unsigned long int)1);
}

// nat_init
// file nat.c line 588
signed int nat_init(void)
{
  signed int i = 0;
  _Bool tmp_if_expr$1;
  if(!(engines[(signed long int)i].initcb == ((signed int (*)(void))NULL)))
    tmp_if_expr$1 = engines[(signed long int)i].used != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    log_dbg_printf("NAT engine init '%s'\n", engines[(signed long int)i].name);
    signed int return_value;
    return_value=engines[(signed long int)i].initcb();
    if(return_value == -1)
      return -1;

    i = i + 1;
  }

  return 0;
}

// nat_iptransparent_socket_cb
// file nat.c line 352
static signed int nat_iptransparent_socket_cb(signed int s)
{
  signed int on = 1;
  signed int rv;
  rv=setsockopt(s, 0, 19, (void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(rv == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_err_printf("Error from setsockopt(IP_TRANSPARENT): %s\n", return_value_strerror$2);
  }

  return rv;
}

// nat_ipv6ready
// file nat.c line 537
signed int nat_ipv6ready(const char *name)
{
  if(name == ((const char *)NULL))
    name = engines[(signed long int)0].name;

  signed int return_value_nat_index$1;
  return_value_nat_index$1=nat_index(name);
  return (signed int)engines[(signed long int)return_value_nat_index$1].ipv6;
}

// nat_list_engines
// file nat.c line 548
void nat_list_engines(void)
{
  signed int i = 0;
  for( ; !(engines[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
    fprintf(stdout, "%s%s\n", engines[(signed long int)i].name, i != 0 ? "" : " (default)");
  fflush(stdout);
}

// nat_netfilter_lookup_cb
// file nat.c line 325
static signed int nat_netfilter_lookup_cb(struct sockaddr *dst_addr, unsigned int *dst_addrlen, signed int s, struct sockaddr *src_addr, unsigned int src_addrlen)
{
  signed int rv;
  if(!((signed int)src_addr->sa_family == 2))
  {
    log_err_printf("The netfilter NAT engine only supports IPv4 state lookups\n");
    return -1;
  }

  else
  {
    rv=getsockopt(s, 0, 80, (void *)dst_addr, dst_addrlen);
    if(rv == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_err_printf("Error from getsockopt(SO_ORIGINAL_DST): %s\n", return_value_strerror$2);
    }

    return rv;
  }
}

// nat_preinit
// file nat.c line 569
signed int nat_preinit(void)
{
  signed int i = 0;
  _Bool tmp_if_expr$1;
  if(!(engines[(signed long int)i].preinitcb == ((signed int (*)(void))NULL)))
    tmp_if_expr$1 = engines[(signed long int)i].used != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    log_dbg_printf("NAT engine preinit '%s'\n", engines[(signed long int)i].name);
    signed int return_value;
    return_value=engines[(signed long int)i].preinitcb();
    if(return_value == -1)
      return -1;

    i = i + 1;
  }

  return 0;
}

// nat_used
// file nat.c line 496
signed int nat_used(const char *name)
{
  if(name == ((const char *)NULL))
    name = engines[(signed long int)0].name;

  signed int return_value_nat_index$1;
  return_value_nat_index$1=nat_index(name);
  return (signed int)!(!(engines[(signed long int)return_value_nat_index$1].used != 0u));
}

// nat_version
// file nat.c line 615
void nat_version(void)
{
  fprintf(stderr, "NAT engines:");
  signed int i = 0;
  for( ; !(engines[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
    fprintf(stderr, " %s%s", engines[(signed long int)i].name, i != 0 ? "" : "*");
  if(engines[0l].name == ((const char *)NULL))
    fprintf(stderr, " -");

  fprintf(stderr, "\n");
  fprintf(stderr, "netfilter:");
  fprintf(stderr, " IP_TRANSPARENT");
  fprintf(stderr, " SOL_IPV6");
  fprintf(stderr, " !IPV6_ORIGINAL_DST");
  fprintf(stderr, "\n");
}

// opts_debug_01
// file opts.t.c line 365
static void opts_debug_01(signed int _i)
{
  tcase_fn_start("opts_debug_01", "opts.t.c", 365);
  struct opts *opts;
  opts=opts_new();
  opts->debug = (unsigned int)0;
  if(opts->debug == 0u)
    _mark_point("opts.t.c", 371);

  else
    _ck_assert_failed("opts.t.c", 371, "Assertion '!opts->debug' failed", (const void *)"plain 0", (void *)0);
  if((signed long int)opts->debug == 0l)
    _mark_point("opts.t.c", 372);

  else
    _ck_assert_failed("opts.t.c", 372, "Assertion '!OPTS_DEBUG(opts)' failed", (const void *)"macro 0", (void *)0);
  opts->debug = (unsigned int)1;
  if(!(opts->debug == 0u))
    _mark_point("opts.t.c", 374);

  else
    _ck_assert_failed("opts.t.c", 374, "Assertion '!!opts->debug' failed", (const void *)"plain 1", (void *)0);
  if(!((signed long int)opts->debug == 0l))
    _mark_point("opts.t.c", 375);

  else
    _ck_assert_failed("opts.t.c", 375, "Assertion '!!OPTS_DEBUG(opts)' failed", (const void *)"macro 1", (void *)0);
  opts_free(opts);
}

// opts_free
// file opts.h line 106
void opts_free(struct opts *opts)
{
  sk_pop_free((struct stack_st *)opts->chain, (void (*)(void *))(1 != 0 ? X509_free : (void (*)(struct x509_st *))0));
  if(!(opts->cacrt == ((struct x509_st *)NULL)))
    X509_free(opts->cacrt);

  if(!(opts->cakey == ((struct evp_pkey_st *)NULL)))
    EVP_PKEY_free(opts->cakey);

  if(!(opts->key == ((struct evp_pkey_st *)NULL)))
    EVP_PKEY_free(opts->key);

  if(!(opts->dh == ((struct dh_st *)NULL)))
    DH_free(opts->dh);

  if(!(opts->ecdhcurve == ((char *)NULL)))
    free((void *)opts->ecdhcurve);

  if(!(opts->spec == ((struct proxyspec *)NULL)))
    proxyspec_free(opts->spec);

  if(!(opts->ciphers == ((char *)NULL)))
    free((void *)opts->ciphers);

  if(!(opts->tgcrtdir == ((char *)NULL)))
    free((void *)opts->tgcrtdir);

  if(!(opts->dropuser == ((char *)NULL)))
    free((void *)opts->dropuser);

  if(!(opts->dropgroup == ((char *)NULL)))
    free((void *)opts->dropgroup);

  if(!(opts->jaildir == ((char *)NULL)))
    free((void *)opts->jaildir);

  if(!(opts->pidfile == ((char *)NULL)))
    free((void *)opts->pidfile);

  if(!(opts->connectlog == ((char *)NULL)))
    free((void *)opts->connectlog);

  if(!(opts->contentlog == ((char *)NULL)))
    free((void *)opts->contentlog);

  memset((void *)opts, 0, sizeof(struct opts) /*136ul*/ );
  free((void *)opts);
}

// opts_has_ssl_spec
// file opts.c line 116
signed int opts_has_ssl_spec(struct opts *opts)
{
  struct proxyspec *p = opts->spec;
  for( ; !(p == ((struct proxyspec *)NULL)); p = p->next)
    if(!(p->ssl == 0u))
      return 1;

  return 0;
}

// opts_new
// file opts.h line 105
struct opts * opts_new(void)
{
  struct opts *opts;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct opts) /*136ul*/ );
  opts = (struct opts *)return_value_malloc$1;
  memset((void *)opts, 0, sizeof(struct opts) /*136ul*/ );
  opts->sslcomp = (unsigned int)1;
  struct stack_st *return_value_sk_new_null$2;
  return_value_sk_new_null$2=sk_new_null();
  opts->chain = (struct stack_st_X509 *)return_value_sk_new_null$2;
  opts->sslmethod = SSLv23_method;
  return opts;
}

// opts_proto_dbg_dump
// file opts.c line 216
void opts_proto_dbg_dump(struct opts *opts)
{
  char *tmp_if_expr$2;
  char *tmp_if_expr$1;
  if(opts->sslmethod == TLSv1_method)
    tmp_if_expr$2 = "tls10";

  else
  {
    if(opts->sslmethod == TLSv1_1_method)
      tmp_if_expr$1 = "tls11";

    else
      tmp_if_expr$1 = opts->sslmethod == TLSv1_2_method ? "tls12" : "negotiate";
    tmp_if_expr$2 = tmp_if_expr$1;
  }
  log_dbg_printf("SSL/TLS protocol: %s%s%s%s%s%s\n", tmp_if_expr$2, (const void *)"", (const void *)"", opts->no_tls10 != 0u ? " -tls10" : "", opts->no_tls11 != 0u ? " -tls11" : "", opts->no_tls12 != 0u ? " -tls12" : "");
}

// opts_proto_disable
// file opts.c line 178
void opts_proto_disable(struct opts *opts, const char *optarg, const char *argv0)
{
  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(optarg, "tls10");
  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$4;
  if(return_value_strcmp$3 == 0)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_strcmp$4=strcmp(optarg, "tls1");
    tmp_if_expr$5 = !(return_value_strcmp$4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(tmp_if_expr$5)
    opts->no_tls10 = (unsigned int)1;

  else
  {
    return_value_strcmp$2=strcmp(optarg, "tls11");
    if(return_value_strcmp$2 == 0)
      opts->no_tls11 = (unsigned int)1;

    else
    {
      return_value_strcmp$1=strcmp(optarg, "tls12");
      if(return_value_strcmp$1 == 0)
        opts->no_tls12 = (unsigned int)1;

      else
      {
        fprintf(stderr, "%s: Unsupported SSL/TLS protocol '%s'\n", argv0, optarg);
        exit(1);
      }
    }
  }
}

// opts_proto_force
// file opts.c line 134
void opts_proto_force(struct opts *opts, const char *optarg, const char *argv0)
{
  if(!(opts->sslmethod == SSLv23_method))
  {
    fprintf(stderr, "%s: cannot use -r multiple times\n", argv0);
    exit(1);
  }

  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(optarg, "tls10");
  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$4;
  if(return_value_strcmp$3 == 0)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_strcmp$4=strcmp(optarg, "tls1");
    tmp_if_expr$5 = !(return_value_strcmp$4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(tmp_if_expr$5)
    opts->sslmethod = TLSv1_method;

  else
  {
    return_value_strcmp$2=strcmp(optarg, "tls11");
    if(return_value_strcmp$2 == 0)
      opts->sslmethod = TLSv1_1_method;

    else
    {
      return_value_strcmp$1=strcmp(optarg, "tls12");
      if(return_value_strcmp$1 == 0)
        opts->sslmethod = TLSv1_2_method;

      else
      {
        fprintf(stderr, "%s: Unsupported SSL/TLS protocol '%s'\n", argv0, optarg);
        exit(1);
      }
    }
  }
}

// opts_suite
// file opts.t.c line 381
struct Suite * opts_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("opts");
  tc=tcase_create("proxyspec_parse");
  _tcase_add_test(tc, proxyspec_parse_01, "proxyspec_parse_01", 0, 0, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_02, "proxyspec_parse_02", 0, 0, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_03, "proxyspec_parse_03", 0, 1, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_04, "proxyspec_parse_04", 0, 1, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_05, "proxyspec_parse_05", 0, 0, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_06, "proxyspec_parse_06", 0, 0, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_07, "proxyspec_parse_07", 0, 0, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_08, "proxyspec_parse_08", 0, 0, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_09, "proxyspec_parse_09", 0, 1, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_10, "proxyspec_parse_10", 0, 1, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_11, "proxyspec_parse_11", 0, 0, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_12, "proxyspec_parse_12", 0, 1, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_13, "proxyspec_parse_13", 0, 0, 0, 1);
  _tcase_add_test(tc, proxyspec_parse_14, "proxyspec_parse_14", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("opts_debug");
  _tcase_add_test(tc, opts_debug_01, "opts_debug_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// proxy_debug_base
// file proxy.c line 145
static void proxy_debug_base(struct event_base *ev_base)
{
  const char *return_value_event_base_get_method$1;
  return_value_event_base_get_method$1=event_base_get_method(ev_base);
  log_dbg_printf("Using libevent backend '%s'\n", return_value_event_base_get_method$1);
  enum event_method_feature f;
  signed int return_value_event_base_get_features$2;
  return_value_event_base_get_features$2=event_base_get_features(ev_base);
  f = (enum event_method_feature)return_value_event_base_get_features$2;
  log_dbg_printf("Event base supports: edge %s, O(1) %s, anyfd %s\n", ((signed int)f & EV_FEATURE_ET) != 0 ? "yes" : "no", ((signed int)f & EV_FEATURE_O1) != 0 ? "yes" : "no", ((signed int)f & EV_FEATURE_FDS) != 0 ? "yes" : "no");
}

// proxy_free
// file proxy.c line 423
void proxy_free(struct proxy_ctx *ctx)
{
  if(!(ctx->gcev == ((struct event *)NULL)))
    event_free(ctx->gcev);

  if(!(ctx->lctx == ((struct proxy_listener_ctx *)NULL)))
    proxy_listener_ctx_free(ctx->lctx);

  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 4ul); i = i + 1ul)
    if(!(ctx->sev[(signed long int)i] == ((struct event *)NULL)))
      event_free(ctx->sev[(signed long int)i]);

  if(!(ctx->thrmgr == ((struct pxy_thrmgr_ctx *)NULL)))
    pxy_thrmgr_free(ctx->thrmgr);

  if(!(ctx->evbase == ((struct event_base *)NULL)))
    event_base_free(ctx->evbase);

  free((void *)ctx);
}

// proxy_gc_cb
// file proxy.c line 261
static void proxy_gc_cb(signed int fd, signed short int what, void *arg)
{
  struct proxy_ctx *ctx = (struct proxy_ctx *)arg;
  if(!((signed long int)ctx->opts->debug == 0l))
    log_dbg_printf("Garbage collecting caches started.\n");

  cachemgr_gc();
  if(!((signed long int)ctx->opts->debug == 0l))
    log_dbg_printf("Garbage collecting caches done.\n");

}

// proxy_listener_acceptcb
// file proxy.c line 117
static void proxy_listener_acceptcb(struct evconnlistener *listener, signed int fd, struct sockaddr *peeraddr, signed int peeraddrlen, void *arg)
{
  struct proxy_listener_ctx *cfg = (struct proxy_listener_ctx *)arg;
  pxy_conn_setup(fd, peeraddr, peeraddrlen, cfg->thrmgr, cfg->spec, cfg->opts);
}

// proxy_listener_ctx_free
// file proxy.c line 102
static void proxy_listener_ctx_free(struct proxy_listener_ctx *ctx)
{
  if(!(ctx->evcl == ((struct evconnlistener *)NULL)))
    evconnlistener_free(ctx->evcl);

  if(!(ctx->next == ((struct proxy_listener_ctx *)NULL)))
    proxy_listener_ctx_free(ctx->next);

  free((void *)ctx);
}

// proxy_listener_ctx_new
// file proxy.c line 86
static struct proxy_listener_ctx * proxy_listener_ctx_new(struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts)
{
  struct proxy_listener_ctx *ctx;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct proxy_listener_ctx) /*40ul*/ );
  ctx = (struct proxy_listener_ctx *)return_value_malloc$1;
  if(ctx == ((struct proxy_listener_ctx *)NULL))
    return (struct proxy_listener_ctx *)(void *)0;

  else
  {
    memset((void *)ctx, 0, sizeof(struct proxy_listener_ctx) /*40ul*/ );
    ctx->thrmgr = thrmgr;
    ctx->spec = spec;
    ctx->opts = opts;
    return ctx;
  }
}

// proxy_listener_errorcb
// file proxy.c line 132
static void proxy_listener_errorcb(struct evconnlistener *listener, void *ctx)
{
  struct event_base *evbase;
  evbase=evconnlistener_get_base(listener);
  signed int err;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  err = *return_value___errno_location$1;
  char *return_value_strerror$2;
  return_value_strerror$2=strerror(err);
  log_err_printf("Error %d on listener: %s\n", err, return_value_strerror$2);
  event_base_loopbreak(evbase);
}

// proxy_listener_setup
// file proxy.c line 163
static struct proxy_listener_ctx * proxy_listener_setup(struct event_base *evbase, struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts)
{
  struct proxy_listener_ctx *plc;
  signed int fd;
  signed int on = 1;
  signed int rv;
  fd=socket((signed int)spec->listen_addr.ss_family, 1, 6);
  if(fd == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_err_printf("Error from socket(): %s\n", return_value_strerror$2);
    evutil_closesocket(fd);
    return (struct proxy_listener_ctx *)(void *)0;
  }

  rv=evutil_make_socket_nonblocking(fd);
  if(rv == -1)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    log_err_printf("Error making socket nonblocking: %s\n", return_value_strerror$4);
    evutil_closesocket(fd);
    return (struct proxy_listener_ctx *)(void *)0;
  }

  rv=setsockopt(fd, 1, 9, (void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(rv == -1)
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    log_err_printf("Error from setsockopt(SO_KEEPALIVE): %s\n", return_value_strerror$6);
    evutil_closesocket(fd);
    return (struct proxy_listener_ctx *)(void *)0;
  }

  rv=evutil_make_listen_socket_reuseable(fd);
  if(rv == -1)
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    log_err_printf("Error from setsockopt(SO_REUSABLE): %s\n", return_value_strerror$8);
    evutil_closesocket(fd);
    return (struct proxy_listener_ctx *)(void *)0;
  }

  signed int return_value;
  if(!(spec->natsocket == ((signed int (*)(signed int))NULL)))
  {
    return_value=spec->natsocket(fd);
    log_err_printf("Error from spec->natsocket()\n");
    evutil_closesocket(fd);
    return (struct proxy_listener_ctx *)(void *)0;
  }

  else
  {
    rv=bind(fd, (struct sockaddr *)&spec->listen_addr, spec->listen_addrlen);
    if(rv == -1)
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      char *return_value_strerror$10;
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      log_err_printf("Error from bind(): %s\n", return_value_strerror$10);
      evutil_closesocket(fd);
      return (struct proxy_listener_ctx *)(void *)0;
    }

    plc=proxy_listener_ctx_new(thrmgr, spec, opts);
    if(plc == ((struct proxy_listener_ctx *)NULL))
    {
      log_err_printf("Error creating listener context\n");
      evutil_closesocket(fd);
      return (struct proxy_listener_ctx *)(void *)0;
    }

    else
    {
      plc->evcl=evconnlistener_new(evbase, proxy_listener_acceptcb, (void *)plc, 1u << 1, 1024, fd);
      if(plc->evcl == ((struct evconnlistener *)NULL))
      {
        signed int *return_value___errno_location$11;
        return_value___errno_location$11=__errno_location();
        char *return_value_strerror$12;
        return_value_strerror$12=strerror(*return_value___errno_location$11);
        log_err_printf("Error creating evconnlistener: %s\n", return_value_strerror$12);
        proxy_listener_ctx_free(plc);
        evutil_closesocket(fd);
        return (struct proxy_listener_ctx *)(void *)0;
      }

      evconnlistener_set_error_cb(plc->evcl, proxy_listener_errorcb);
      return plc;
    }
  }
}

// proxy_new
// file proxy.c line 279
struct proxy_ctx * proxy_new(struct opts *opts)
{
  struct proxy_listener_ctx *head;
  struct proxy_ctx *ctx;
  struct evdns_base *dnsbase;
  signed int rc;
  evthread_use_pthreads();
  if(!((signed long int)opts->debug == 0l))
    event_enable_debug_mode();

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct proxy_ctx) /*72ul*/ );
  ctx = (struct proxy_ctx *)return_value_malloc$1;
  struct timeval gc_delay;
  if(ctx == ((struct proxy_ctx *)NULL))
    log_err_printf("Error allocating memory\n");

  else
  {
    memset((void *)ctx, 0, sizeof(struct proxy_ctx) /*72ul*/ );
    ctx->opts = opts;
    ctx->evbase=event_base_new();
    if(ctx->evbase == ((struct event_base *)NULL))
      log_err_printf("Error getting event base\n");

    else
    {
      dnsbase=evdns_base_new(ctx->evbase, 0);
      if(dnsbase == ((struct evdns_base *)NULL))
        log_err_printf("Error creating dns event base\n");

      else
      {
        rc=evdns_base_resolv_conf_parse(dnsbase, 15, "/etc/resolv.conf");
        evdns_base_free(dnsbase, 0);
        if(!(rc == 0))
          log_err_printf("evdns cannot parse resolv.conf: %s (%d)\n", rc == 1 ? "failed to open file" : (rc == 2 ? "failed to stat file" : (rc == 3 ? "file too large" : (rc == 4 ? "out of memory" : (rc == 5 ? "short read from file" : (rc == 6 ? "no nameservers listed in file" : "unknown error"))))), rc);

        else
        {
          if(!((signed long int)opts->debug == 0l))
            proxy_debug_base(ctx->evbase);

          ctx->thrmgr=pxy_thrmgr_new(opts);
          if(ctx->thrmgr == ((struct pxy_thrmgr_ctx *)NULL))
            log_err_printf("Error creating thread manager\n");

          else
          {
            ctx->lctx = (struct proxy_listener_ctx *)(void *)0;
            head = ctx->lctx;
            struct proxyspec *spec = opts->spec;
            for( ; !(spec == ((struct proxyspec *)NULL)); spec = spec->next)
            {
              head=proxy_listener_setup(ctx->evbase, ctx->thrmgr, spec, opts);
              if(head == ((struct proxy_listener_ctx *)NULL))
                goto leave2;

              head->next = ctx->lctx;
              ctx->lctx = head;
            }
            unsigned long int i = (unsigned long int)0;
            for( ; !(i >= 4ul); i = i + 1ul)
            {
              ctx->sev[(signed long int)i]=event_new(ctx->evbase, signals[(signed long int)i], (signed short int)(0x08 | 0x10), proxy_signal_cb, (void *)ctx);
              if(ctx->sev[(signed long int)i] == ((struct event *)NULL))
                goto leave3;

              event_add(ctx->sev[(signed long int)i], (struct timeval *)(void *)0);
            }
            gc_delay = (struct timeval){ .tv_sec=(signed long int)60, .tv_usec=(signed long int)0 };
            ctx->gcev=event_new(ctx->evbase, -1, (signed short int)0x10, proxy_gc_cb, (void *)ctx);
            if(!(ctx->gcev == ((struct event *)NULL)))
            {
              event_add(ctx->gcev, &gc_delay);
              return ctx;
            }


          leave4:
            ;
            if(!(ctx->gcev == ((struct event *)NULL)))
              event_free(ctx->gcev);


          leave3:
            ;
            unsigned long int proxy_new$$1$$11$$i = (unsigned long int)0;
            for( ; !(proxy_new$$1$$11$$i >= 4ul); proxy_new$$1$$11$$i = proxy_new$$1$$11$$i + 1ul)
              if(!(ctx->sev[(signed long int)proxy_new$$1$$11$$i] == ((struct event *)NULL)))
                event_free(ctx->sev[(signed long int)proxy_new$$1$$11$$i]);


          leave2:
            ;
            if(!(ctx->lctx == ((struct proxy_listener_ctx *)NULL)))
              proxy_listener_ctx_free(ctx->lctx);

            pxy_thrmgr_free(ctx->thrmgr);
          }
        }
      }

    leave1b:
      ;
      event_base_free(ctx->evbase);
    }

  leave1:
    ;
    free((void *)ctx);
  }

leave0:
  ;
  return (struct proxy_ctx *)(void *)0;
}

// proxy_run
// file proxy.c line 396
void proxy_run(struct proxy_ctx *ctx)
{
  if(!(ctx->opts->detach == 0u))
    event_reinit(ctx->evbase);

  if(!((signed long int)ctx->opts->debug == 0l))
    event_base_dump_events(ctx->evbase, stderr);

  signed int return_value_pxy_thrmgr_run$1;
  return_value_pxy_thrmgr_run$1=pxy_thrmgr_run(ctx->thrmgr);
  if(return_value_pxy_thrmgr_run$1 == -1)
    log_err_printf("Failed to start thread manager\n");

  else
  {
    if(!((signed long int)ctx->opts->debug == 0l))
      log_dbg_printf("Starting main event loop.\n");

    event_base_dispatch(ctx->evbase);
    if(!((signed long int)ctx->opts->debug == 0l))
      log_dbg_printf("Main event loop stopped.\n");

  }
}

// proxy_signal_cb
// file proxy.c line 242
static void proxy_signal_cb(signed int fd, signed short int what, void *arg)
{
  struct proxy_ctx *ctx = (struct proxy_ctx *)arg;
  if(!((signed long int)ctx->opts->debug == 0l))
    log_dbg_printf("Received signal %i\n", fd);

  if(fd == 13)
    log_err_printf("Warning: Received SIGPIPE; ignoring.\n");

  else
    event_base_loopbreak(ctx->evbase);
}

// proxyspec_free
// file opts.h line 114
void proxyspec_free(struct proxyspec *spec)
{
  while(!(spec == ((struct proxyspec *)NULL)))
  {
    struct proxyspec *next = spec->next;
    if(!(spec->natengine == ((char *)NULL)))
      free((void *)spec->natengine);

    memset((void *)spec, 0, sizeof(struct proxyspec) /*312ul*/ );
    free((void *)spec);
    spec = next;
  }
}

// proxyspec_parse
// file opts.h line 113
struct proxyspec * proxyspec_parse(signed int *argc, char ***argv, const char *natengine)
{
  struct proxyspec *curspec;
  struct proxyspec *spec = (struct proxyspec *)(void *)0;
  char *proxyspec_parse$$1$$addr;
  signed int af;
  signed int state = 0;
  signed int tmp_post$1;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  char *return_value_strpbrk$7;
  _Bool tmp_if_expr$13;
  signed int return_value_strcmp$12;
  _Bool tmp_if_expr$15;
  signed int return_value_strcmp$14;
  _Bool tmp_if_expr$17;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$10;
  signed int return_value_nat_exist$9;
  do
  {
    tmp_post$1 = *argc;
    *argc = *argc - 1;
    if(tmp_post$1 == 0)
      break;

    if(!(state == 0))
    {
      if(state == 1)
        goto __CPROVER_DUMP_L8;

      if(state == 2)
        goto __CPROVER_DUMP_L9;

      if(state == 3)
        goto __CPROVER_DUMP_L17;

      if(state == 4)
        goto __CPROVER_DUMP_L30;

      if(state == 5)
        goto __CPROVER_DUMP_L32;

    }

    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct proxyspec) /*312ul*/ );
    curspec = (struct proxyspec *)return_value_malloc$2;
    memset((void *)curspec, 0, sizeof(struct proxyspec) /*312ul*/ );
    curspec->next = spec;
    spec = curspec;
    signed int return_value_strcmp$6;
    return_value_strcmp$6=strcmp(*(*argv), "tcp");
    if(return_value_strcmp$6 == 0)
    {
      spec->ssl = (unsigned int)0;
      spec->http = (unsigned int)0;
    }

    else
    {
      return_value_strcmp$5=strcmp(*(*argv), "ssl");
      if(return_value_strcmp$5 == 0)
      {
        spec->ssl = (unsigned int)1;
        spec->http = (unsigned int)0;
      }

      else
      {
        return_value_strcmp$4=strcmp(*(*argv), "http");
        if(return_value_strcmp$4 == 0)
        {
          spec->ssl = (unsigned int)0;
          spec->http = (unsigned int)1;
        }

        else
        {
          return_value_strcmp$3=strcmp(*(*argv), "https");
          if(return_value_strcmp$3 == 0)
          {
            spec->ssl = (unsigned int)1;
            spec->http = (unsigned int)1;
          }

          else
          {
            fprintf(stderr, "Unknown connection type '%s'\n", *(*argv));
            exit(1);
          }
        }
      }
    }
    state = state + 1;
    goto __CPROVER_DUMP_L34;

  __CPROVER_DUMP_L8:
    ;
    proxyspec_parse$$1$$addr = *(*argv);
    state = state + 1;
    goto __CPROVER_DUMP_L34;

  __CPROVER_DUMP_L9:
    ;
    char *return_value_strstr$8;
    return_value_strstr$8=strstr(proxyspec_parse$$1$$addr, ":");
    if(!(return_value_strstr$8 == ((char *)NULL)))
      af = 10;

    else
    {
      return_value_strpbrk$7=strpbrk(proxyspec_parse$$1$$addr, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-");
      if(return_value_strpbrk$7 == ((char *)NULL))
        af = 2;

      else
        af = 0;
    }
    af=sys_sockaddr_parse(&spec->listen_addr, &spec->listen_addrlen, proxyspec_parse$$1$$addr, *(*argv), af, 0x0001);
    if(af == -1)
      exit(1);

    if(!(natengine == ((const char *)NULL)))
    {
      spec->natengine=strdup(natengine);
      if(spec->natengine == ((char *)NULL))
      {
        fprintf(stderr, "Out of memory\n");
        exit(1);
      }

    }

    else
      spec->natengine = (char *)(void *)0;
    state = state + 1;
    goto __CPROVER_DUMP_L34;

  __CPROVER_DUMP_L17:
    ;
    signed int return_value_strcmp$11;
    return_value_strcmp$11=strcmp(*(*argv), "tcp");
    if(return_value_strcmp$11 == 0)
      tmp_if_expr$13 = (_Bool)1;

    else
    {
      return_value_strcmp$12=strcmp(*(*argv), "ssl");
      tmp_if_expr$13 = !(return_value_strcmp$12 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$13)
      tmp_if_expr$15 = (_Bool)1;

    else
    {
      return_value_strcmp$14=strcmp(*(*argv), "http");
      tmp_if_expr$15 = !(return_value_strcmp$14 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$15)
      tmp_if_expr$17 = (_Bool)1;

    else
    {
      return_value_strcmp$16=strcmp(*(*argv), "https");
      tmp_if_expr$17 = !(return_value_strcmp$16 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$17)
    {
      *argv = *argv - 1l;
      *argc = *argc + 1;
      state = 0;
    }

    else
    {
      return_value_strcmp$10=strcmp(*(*argv), "sni");
      if(return_value_strcmp$10 == 0)
      {
        free((void *)spec->natengine);
        spec->natengine = (char *)(void *)0;
        if(spec->ssl == 0u)
        {
          fprintf(stderr, "SNI hostname lookup only works for ssl and https proxyspecs\n");
          exit(1);
        }

        state = 5;
      }

      else
      {
        return_value_nat_exist$9=nat_exist(*(*argv));
        if(!(return_value_nat_exist$9 == 0))
        {
          free((void *)spec->natengine);
          spec->natengine=strdup(*(*argv));
          if(spec->natengine == ((char *)NULL))
          {
            fprintf(stderr, "Out of memory\n");
            exit(1);
          }

          state = 0;
        }

        else
        {
          free((void *)spec->natengine);
          spec->natengine = (char *)(void *)0;
          proxyspec_parse$$1$$addr = *(*argv);
          state = state + 1;
        }
      }
    }
    goto __CPROVER_DUMP_L34;

  __CPROVER_DUMP_L30:
    ;
    af=sys_sockaddr_parse(&spec->connect_addr, &spec->connect_addrlen, proxyspec_parse$$1$$addr, *(*argv), af, 0);
    if(af == -1)
      exit(1);

    state = 0;
    goto __CPROVER_DUMP_L34;

  __CPROVER_DUMP_L32:
    ;
    signed int return_value_atoi$18;
    return_value_atoi$18=atoi(*(*argv));
    spec->sni_port = (unsigned short int)return_value_atoi$18;
    if(spec->sni_port == 0)
    {
      fprintf(stderr, "Invalid port '%s'\n", *(*argv));
      exit(1);
    }

    state = 0;

  __CPROVER_DUMP_L34:
    ;
    *argv = *argv + 1l;
  }
  while((_Bool)1);
  if(!(state == 0) && !(state == 3))
  {
    fprintf(stderr, "Incomplete proxyspec!\n");
    exit(1);
  }

  return spec;
}

// proxyspec_parse_01
// file opts.t.c line 73
static void proxyspec_parse_01(signed int _i)
{
  tcase_fn_start("proxyspec_parse_01", "opts.t.c", 73);
  struct proxyspec *spec;
  signed int argc = 5;
  char **argv = argv01;
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 80);

  else
    _ck_assert_failed("opts.t.c", 80, "Assertion '!!spec' failed", (const void *)"failed to parse spec", (void *)0);
  if(!(spec->ssl == 0u))
    _mark_point("opts.t.c", 81);

  else
    _ck_assert_failed("opts.t.c", 81, "Assertion 'spec->ssl' failed", (const void *)"not SSL", (void *)0);
  if(!(spec->http == 0u))
    _mark_point("opts.t.c", 82);

  else
    _ck_assert_failed("opts.t.c", 82, "Assertion 'spec->http' failed", (const void *)"not HTTP", (void *)0);
  if((unsigned long int)spec->listen_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 83);

  else
    _ck_assert_failed("opts.t.c", 83, "Assertion 'spec->listen_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 listen addr", (void *)0);
  if((unsigned long int)spec->connect_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 85);

  else
    _ck_assert_failed("opts.t.c", 85, "Assertion 'spec->connect_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 connect addr", (void *)0);
  if(spec->sni_port == 0)
    _mark_point("opts.t.c", 87);

  else
    _ck_assert_failed("opts.t.c", 87, "Assertion '!spec->sni_port' failed", (const void *)"SNI port is set", (void *)0);
  if(spec->natengine == ((char *)NULL))
    _mark_point("opts.t.c", 88);

  else
    _ck_assert_failed("opts.t.c", 88, "Assertion '!spec->natengine' failed", (const void *)"natengine is set", (void *)0);
  if(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 89);

  else
    _ck_assert_failed("opts.t.c", 89, "Assertion '!spec->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 90);

  else
    _ck_assert_failed("opts.t.c", 90, "Assertion '!spec->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  if(spec->next == ((struct proxyspec *)NULL))
    _mark_point("opts.t.c", 91);

  else
    _ck_assert_failed("opts.t.c", 91, "Assertion '!spec->next' failed", (const void *)"next is set", (void *)0);
  proxyspec_free(spec);
}

// proxyspec_parse_02
// file opts.t.c line 96
static void proxyspec_parse_02(signed int _i)
{
  tcase_fn_start("proxyspec_parse_02", "opts.t.c", 96);
  struct proxyspec *spec;
  signed int argc = 5;
  char **argv = argv02;
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 103);

  else
    _ck_assert_failed("opts.t.c", 103, "Assertion '!!spec' failed", (const void *)"failed to parse spec", (void *)0);
  if(!(spec->ssl == 0u))
    _mark_point("opts.t.c", 104);

  else
    _ck_assert_failed("opts.t.c", 104, "Assertion 'spec->ssl' failed", (const void *)"not SSL", (void *)0);
  if(!(spec->http == 0u))
    _mark_point("opts.t.c", 105);

  else
    _ck_assert_failed("opts.t.c", 105, "Assertion 'spec->http' failed", (const void *)"not HTTP", (void *)0);
  if((unsigned long int)spec->listen_addrlen == sizeof(struct sockaddr_in6) /*28ul*/ )
    _mark_point("opts.t.c", 106);

  else
    _ck_assert_failed("opts.t.c", 106, "Assertion 'spec->listen_addrlen == sizeof(struct sockaddr_in6)' failed", (const void *)"not IPv6 listen addr", (void *)0);
  if((unsigned long int)spec->connect_addrlen == sizeof(struct sockaddr_in6) /*28ul*/ )
    _mark_point("opts.t.c", 108);

  else
    _ck_assert_failed("opts.t.c", 108, "Assertion 'spec->connect_addrlen == sizeof(struct sockaddr_in6)' failed", (const void *)"not IPv6 connect addr", (void *)0);
  if(spec->sni_port == 0)
    _mark_point("opts.t.c", 110);

  else
    _ck_assert_failed("opts.t.c", 110, "Assertion '!spec->sni_port' failed", (const void *)"SNI port is set", (void *)0);
  if(spec->natengine == ((char *)NULL))
    _mark_point("opts.t.c", 111);

  else
    _ck_assert_failed("opts.t.c", 111, "Assertion '!spec->natengine' failed", (const void *)"natengine is set", (void *)0);
  if(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 112);

  else
    _ck_assert_failed("opts.t.c", 112, "Assertion '!spec->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 113);

  else
    _ck_assert_failed("opts.t.c", 113, "Assertion '!spec->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  if(spec->next == ((struct proxyspec *)NULL))
    _mark_point("opts.t.c", 114);

  else
    _ck_assert_failed("opts.t.c", 114, "Assertion '!spec->next' failed", (const void *)"next is set", (void *)0);
  proxyspec_free(spec);
}

// proxyspec_parse_03
// file opts.t.c line 119
static void proxyspec_parse_03(signed int _i)
{
  tcase_fn_start("proxyspec_parse_03", "opts.t.c", 119);
  struct proxyspec *spec;
  signed int argc = 2;
  char **argv = argv01;
  close(2);
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    proxyspec_free(spec);

}

// proxyspec_parse_04
// file opts.t.c line 132
static void proxyspec_parse_04(signed int _i)
{
  tcase_fn_start("proxyspec_parse_04", "opts.t.c", 132);
  struct proxyspec *spec;
  signed int argc = 4;
  char **argv = argv01;
  close(2);
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    proxyspec_free(spec);

}

// proxyspec_parse_05
// file opts.t.c line 145
static void proxyspec_parse_05(signed int _i)
{
  tcase_fn_start("proxyspec_parse_05", "opts.t.c", 145);
  struct proxyspec *spec;
  signed int argc = 5;
  char **argv = argv03;
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 152);

  else
    _ck_assert_failed("opts.t.c", 152, "Assertion '!!spec' failed", (const void *)"failed to parse spec", (void *)0);
  if(spec->ssl == 0u)
    _mark_point("opts.t.c", 153);

  else
    _ck_assert_failed("opts.t.c", 153, "Assertion '!spec->ssl' failed", (const void *)"SSL", (void *)0);
  if(!(spec->http == 0u))
    _mark_point("opts.t.c", 154);

  else
    _ck_assert_failed("opts.t.c", 154, "Assertion 'spec->http' failed", (const void *)"not HTTP", (void *)0);
  if((unsigned long int)spec->listen_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 155);

  else
    _ck_assert_failed("opts.t.c", 155, "Assertion 'spec->listen_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 listen addr", (void *)0);
  if((unsigned long int)spec->connect_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 157);

  else
    _ck_assert_failed("opts.t.c", 157, "Assertion 'spec->connect_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 connect addr", (void *)0);
  if(spec->sni_port == 0)
    _mark_point("opts.t.c", 159);

  else
    _ck_assert_failed("opts.t.c", 159, "Assertion '!spec->sni_port' failed", (const void *)"SNI port is set", (void *)0);
  if(spec->natengine == ((char *)NULL))
    _mark_point("opts.t.c", 160);

  else
    _ck_assert_failed("opts.t.c", 160, "Assertion '!spec->natengine' failed", (const void *)"natengine is set", (void *)0);
  if(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 161);

  else
    _ck_assert_failed("opts.t.c", 161, "Assertion '!spec->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 162);

  else
    _ck_assert_failed("opts.t.c", 162, "Assertion '!spec->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  if(spec->next == ((struct proxyspec *)NULL))
    _mark_point("opts.t.c", 163);

  else
    _ck_assert_failed("opts.t.c", 163, "Assertion '!spec->next' failed", (const void *)"next is set", (void *)0);
  proxyspec_free(spec);
}

// proxyspec_parse_06
// file opts.t.c line 168
static void proxyspec_parse_06(signed int _i)
{
  tcase_fn_start("proxyspec_parse_06", "opts.t.c", 168);
  struct proxyspec *spec;
  signed int argc = 5;
  char **argv = argv04;
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 175);

  else
    _ck_assert_failed("opts.t.c", 175, "Assertion '!!spec' failed", (const void *)"failed to parse spec", (void *)0);
  if(!(spec->ssl == 0u))
    _mark_point("opts.t.c", 176);

  else
    _ck_assert_failed("opts.t.c", 176, "Assertion 'spec->ssl' failed", (const void *)"not SSL", (void *)0);
  if(spec->http == 0u)
    _mark_point("opts.t.c", 177);

  else
    _ck_assert_failed("opts.t.c", 177, "Assertion '!spec->http' failed", (const void *)"HTTP", (void *)0);
  if((unsigned long int)spec->listen_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 178);

  else
    _ck_assert_failed("opts.t.c", 178, "Assertion 'spec->listen_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 listen addr", (void *)0);
  if((unsigned long int)spec->connect_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 180);

  else
    _ck_assert_failed("opts.t.c", 180, "Assertion 'spec->connect_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 connect addr", (void *)0);
  if(spec->sni_port == 0)
    _mark_point("opts.t.c", 182);

  else
    _ck_assert_failed("opts.t.c", 182, "Assertion '!spec->sni_port' failed", (const void *)"SNI port is set", (void *)0);
  if(spec->natengine == ((char *)NULL))
    _mark_point("opts.t.c", 183);

  else
    _ck_assert_failed("opts.t.c", 183, "Assertion '!spec->natengine' failed", (const void *)"natengine is set", (void *)0);
  if(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 184);

  else
    _ck_assert_failed("opts.t.c", 184, "Assertion '!spec->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 185);

  else
    _ck_assert_failed("opts.t.c", 185, "Assertion '!spec->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  if(spec->next == ((struct proxyspec *)NULL))
    _mark_point("opts.t.c", 186);

  else
    _ck_assert_failed("opts.t.c", 186, "Assertion '!spec->next' failed", (const void *)"next is set", (void *)0);
  proxyspec_free(spec);
}

// proxyspec_parse_07
// file opts.t.c line 191
static void proxyspec_parse_07(signed int _i)
{
  tcase_fn_start("proxyspec_parse_07", "opts.t.c", 191);
  struct proxyspec *spec;
  signed int argc = 5;
  char **argv = argv05;
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 198);

  else
    _ck_assert_failed("opts.t.c", 198, "Assertion '!!spec' failed", (const void *)"failed to parse spec", (void *)0);
  if(spec->ssl == 0u)
    _mark_point("opts.t.c", 199);

  else
    _ck_assert_failed("opts.t.c", 199, "Assertion '!spec->ssl' failed", (const void *)"SSL", (void *)0);
  if(spec->http == 0u)
    _mark_point("opts.t.c", 200);

  else
    _ck_assert_failed("opts.t.c", 200, "Assertion '!spec->http' failed", (const void *)"HTTP", (void *)0);
  if((unsigned long int)spec->listen_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 201);

  else
    _ck_assert_failed("opts.t.c", 201, "Assertion 'spec->listen_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 listen addr", (void *)0);
  if((unsigned long int)spec->connect_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 203);

  else
    _ck_assert_failed("opts.t.c", 203, "Assertion 'spec->connect_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 connect addr", (void *)0);
  if(spec->sni_port == 0)
    _mark_point("opts.t.c", 205);

  else
    _ck_assert_failed("opts.t.c", 205, "Assertion '!spec->sni_port' failed", (const void *)"SNI port is set", (void *)0);
  if(spec->natengine == ((char *)NULL))
    _mark_point("opts.t.c", 206);

  else
    _ck_assert_failed("opts.t.c", 206, "Assertion '!spec->natengine' failed", (const void *)"natengine is set", (void *)0);
  if(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 207);

  else
    _ck_assert_failed("opts.t.c", 207, "Assertion '!spec->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 208);

  else
    _ck_assert_failed("opts.t.c", 208, "Assertion '!spec->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  if(spec->next == ((struct proxyspec *)NULL))
    _mark_point("opts.t.c", 209);

  else
    _ck_assert_failed("opts.t.c", 209, "Assertion '!spec->next' failed", (const void *)"next is set", (void *)0);
  proxyspec_free(spec);
}

// proxyspec_parse_08
// file opts.t.c line 214
static void proxyspec_parse_08(signed int _i)
{
  tcase_fn_start("proxyspec_parse_08", "opts.t.c", 214);
  struct proxyspec *spec;
  signed int argc = 5;
  char **argv = argv06;
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 221);

  else
    _ck_assert_failed("opts.t.c", 221, "Assertion '!!spec' failed", (const void *)"failed to parse spec", (void *)0);
  if(!(spec->ssl == 0u))
    _mark_point("opts.t.c", 222);

  else
    _ck_assert_failed("opts.t.c", 222, "Assertion 'spec->ssl' failed", (const void *)"not SSL", (void *)0);
  if(!(spec->http == 0u))
    _mark_point("opts.t.c", 223);

  else
    _ck_assert_failed("opts.t.c", 223, "Assertion 'spec->http' failed", (const void *)"not HTTP", (void *)0);
  if((unsigned long int)spec->listen_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 224);

  else
    _ck_assert_failed("opts.t.c", 224, "Assertion 'spec->listen_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 listen addr", (void *)0);
  if(spec->connect_addrlen == 0u)
    _mark_point("opts.t.c", 226);

  else
    _ck_assert_failed("opts.t.c", 226, "Assertion '!spec->connect_addrlen' failed", (const void *)"connect addr set", (void *)0);
  if((signed int)spec->sni_port == 443)
    _mark_point("opts.t.c", 227);

  else
    _ck_assert_failed("opts.t.c", 227, "Assertion 'spec->sni_port == 443' failed", (const void *)"SNI port is not set", (void *)0);
  if(spec->natengine == ((char *)NULL))
    _mark_point("opts.t.c", 228);

  else
    _ck_assert_failed("opts.t.c", 228, "Assertion '!spec->natengine' failed", (const void *)"natengine is set", (void *)0);
  if(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 229);

  else
    _ck_assert_failed("opts.t.c", 229, "Assertion '!spec->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 230);

  else
    _ck_assert_failed("opts.t.c", 230, "Assertion '!spec->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  if(spec->next == ((struct proxyspec *)NULL))
    _mark_point("opts.t.c", 231);

  else
    _ck_assert_failed("opts.t.c", 231, "Assertion '!spec->next' failed", (const void *)"next is set", (void *)0);
  proxyspec_free(spec);
}

// proxyspec_parse_09
// file opts.t.c line 236
static void proxyspec_parse_09(signed int _i)
{
  tcase_fn_start("proxyspec_parse_09", "opts.t.c", 236);
  struct proxyspec *spec;
  signed int argc = 5;
  char **argv = argv07;
  close(2);
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    proxyspec_free(spec);

}

// proxyspec_parse_10
// file opts.t.c line 249
static void proxyspec_parse_10(signed int _i)
{
  tcase_fn_start("proxyspec_parse_10", "opts.t.c", 249);
  struct proxyspec *spec;
  signed int argc = 4;
  char **argv = argv06;
  close(2);
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    proxyspec_free(spec);

}

// proxyspec_parse_11
// file opts.t.c line 262
static void proxyspec_parse_11(signed int _i)
{
  tcase_fn_start("proxyspec_parse_11", "opts.t.c", 262);
  struct proxyspec *spec;
  signed int argc = 3;
  char **argv = argv08;
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 269);

  else
    _ck_assert_failed("opts.t.c", 269, "Assertion '!!spec' failed", (const void *)"failed to parse spec", (void *)0);
  if(!(spec->ssl == 0u))
    _mark_point("opts.t.c", 270);

  else
    _ck_assert_failed("opts.t.c", 270, "Assertion 'spec->ssl' failed", (const void *)"not SSL", (void *)0);
  if(!(spec->http == 0u))
    _mark_point("opts.t.c", 271);

  else
    _ck_assert_failed("opts.t.c", 271, "Assertion 'spec->http' failed", (const void *)"not HTTP", (void *)0);
  if((unsigned long int)spec->listen_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 272);

  else
    _ck_assert_failed("opts.t.c", 272, "Assertion 'spec->listen_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 listen addr", (void *)0);
  if(spec->connect_addrlen == 0u)
    _mark_point("opts.t.c", 274);

  else
    _ck_assert_failed("opts.t.c", 274, "Assertion '!spec->connect_addrlen' failed", (const void *)"connect addr set", (void *)0);
  if(spec->sni_port == 0)
    _mark_point("opts.t.c", 275);

  else
    _ck_assert_failed("opts.t.c", 275, "Assertion '!spec->sni_port' failed", (const void *)"SNI port is set", (void *)0);
  if(!(spec->natengine == ((char *)NULL)))
    _mark_point("opts.t.c", 276);

  else
    _ck_assert_failed("opts.t.c", 276, "Assertion '!!spec->natengine' failed", (const void *)"natengine not set", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(spec->natengine, "pf");
  if(return_value_strcmp$1 == 0)
    _mark_point("opts.t.c", 277);

  else
    _ck_assert_failed("opts.t.c", 277, "Assertion '!strcmp(spec->natengine, NATENGINE)' failed", (const void *)"natengine mismatch", (void *)0);
  if(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 278);

  else
    _ck_assert_failed("opts.t.c", 278, "Assertion '!spec->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 279);

  else
    _ck_assert_failed("opts.t.c", 279, "Assertion '!spec->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  if(spec->next == ((struct proxyspec *)NULL))
    _mark_point("opts.t.c", 280);

  else
    _ck_assert_failed("opts.t.c", 280, "Assertion '!spec->next' failed", (const void *)"next is set", (void *)0);
  proxyspec_free(spec);
}

// proxyspec_parse_12
// file opts.t.c line 285
static void proxyspec_parse_12(signed int _i)
{
  tcase_fn_start("proxyspec_parse_12", "opts.t.c", 285);
  struct proxyspec *spec;
  signed int argc = 4;
  char **argv = argv08;
  close(2);
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    proxyspec_free(spec);

}

// proxyspec_parse_13
// file opts.t.c line 298
static void proxyspec_parse_13(signed int _i)
{
  tcase_fn_start("proxyspec_parse_13", "opts.t.c", 298);
  struct proxyspec *spec;
  signed int argc = 10;
  char **argv = argv09;
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 305);

  else
    _ck_assert_failed("opts.t.c", 305, "Assertion '!!spec' failed", (const void *)"failed to parse spec", (void *)0);
  if(!(spec->ssl == 0u))
    _mark_point("opts.t.c", 306);

  else
    _ck_assert_failed("opts.t.c", 306, "Assertion 'spec->ssl' failed", (const void *)"not SSL", (void *)0);
  if(!(spec->http == 0u))
    _mark_point("opts.t.c", 307);

  else
    _ck_assert_failed("opts.t.c", 307, "Assertion 'spec->http' failed", (const void *)"not HTTP", (void *)0);
  if((unsigned long int)spec->listen_addrlen == sizeof(struct sockaddr_in6) /*28ul*/ )
    _mark_point("opts.t.c", 308);

  else
    _ck_assert_failed("opts.t.c", 308, "Assertion 'spec->listen_addrlen == sizeof(struct sockaddr_in6)' failed", (const void *)"not IPv6 listen addr", (void *)0);
  if((unsigned long int)spec->connect_addrlen == sizeof(struct sockaddr_in6) /*28ul*/ )
    _mark_point("opts.t.c", 310);

  else
    _ck_assert_failed("opts.t.c", 310, "Assertion 'spec->connect_addrlen == sizeof(struct sockaddr_in6)' failed", (const void *)"not IPv6 connect addr", (void *)0);
  if(spec->sni_port == 0)
    _mark_point("opts.t.c", 312);

  else
    _ck_assert_failed("opts.t.c", 312, "Assertion '!spec->sni_port' failed", (const void *)"SNI port is set", (void *)0);
  if(spec->natengine == ((char *)NULL))
    _mark_point("opts.t.c", 313);

  else
    _ck_assert_failed("opts.t.c", 313, "Assertion '!spec->natengine' failed", (const void *)"natengine is set", (void *)0);
  if(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 314);

  else
    _ck_assert_failed("opts.t.c", 314, "Assertion '!spec->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 315);

  else
    _ck_assert_failed("opts.t.c", 315, "Assertion '!spec->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  if(!(spec->next == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 316);

  else
    _ck_assert_failed("opts.t.c", 316, "Assertion '!!spec->next' failed", (const void *)"next is not set", (void *)0);
  if(!(spec->next->ssl == 0u))
    _mark_point("opts.t.c", 317);

  else
    _ck_assert_failed("opts.t.c", 317, "Assertion 'spec->next->ssl' failed", (const void *)"not SSL", (void *)0);
  if(!(spec->next->http == 0u))
    _mark_point("opts.t.c", 318);

  else
    _ck_assert_failed("opts.t.c", 318, "Assertion 'spec->next->http' failed", (const void *)"not HTTP", (void *)0);
  if((unsigned long int)spec->next->listen_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 319);

  else
    _ck_assert_failed("opts.t.c", 319, "Assertion 'spec->next->listen_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 listen addr", (void *)0);
  if((unsigned long int)spec->next->connect_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 321);

  else
    _ck_assert_failed("opts.t.c", 321, "Assertion 'spec->next->connect_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 connect addr", (void *)0);
  if(spec->next->sni_port == 0)
    _mark_point("opts.t.c", 323);

  else
    _ck_assert_failed("opts.t.c", 323, "Assertion '!spec->next->sni_port' failed", (const void *)"SNI port is set", (void *)0);
  if(spec->next->natengine == ((char *)NULL))
    _mark_point("opts.t.c", 324);

  else
    _ck_assert_failed("opts.t.c", 324, "Assertion '!spec->next->natengine' failed", (const void *)"natengine is set", (void *)0);
  if(spec->next->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 325);

  else
    _ck_assert_failed("opts.t.c", 325, "Assertion '!spec->next->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->next->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 326);

  else
    _ck_assert_failed("opts.t.c", 326, "Assertion '!spec->next->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  proxyspec_free(spec);
}

// proxyspec_parse_14
// file opts.t.c line 331
static void proxyspec_parse_14(signed int _i)
{
  tcase_fn_start("proxyspec_parse_14", "opts.t.c", 331);
  struct proxyspec *spec;
  signed int argc = 6;
  char **argv = argv10;
  spec=proxyspec_parse(&argc, &argv, "pf");
  if(!(spec == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 338);

  else
    _ck_assert_failed("opts.t.c", 338, "Assertion '!!spec' failed", (const void *)"failed to parse spec", (void *)0);
  if(!(spec->ssl == 0u))
    _mark_point("opts.t.c", 339);

  else
    _ck_assert_failed("opts.t.c", 339, "Assertion 'spec->ssl' failed", (const void *)"not SSL", (void *)0);
  if(!(spec->http == 0u))
    _mark_point("opts.t.c", 340);

  else
    _ck_assert_failed("opts.t.c", 340, "Assertion 'spec->http' failed", (const void *)"not HTTP", (void *)0);
  if((unsigned long int)spec->listen_addrlen == sizeof(struct sockaddr_in6) /*28ul*/ )
    _mark_point("opts.t.c", 341);

  else
    _ck_assert_failed("opts.t.c", 341, "Assertion 'spec->listen_addrlen == sizeof(struct sockaddr_in6)' failed", (const void *)"not IPv6 listen addr", (void *)0);
  if(spec->connect_addrlen == 0u)
    _mark_point("opts.t.c", 343);

  else
    _ck_assert_failed("opts.t.c", 343, "Assertion '!spec->connect_addrlen' failed", (const void *)"connect addr set", (void *)0);
  if(spec->sni_port == 0)
    _mark_point("opts.t.c", 344);

  else
    _ck_assert_failed("opts.t.c", 344, "Assertion '!spec->sni_port' failed", (const void *)"SNI port is set", (void *)0);
  if(!(spec->natengine == ((char *)NULL)))
    _mark_point("opts.t.c", 345);

  else
    _ck_assert_failed("opts.t.c", 345, "Assertion '!!spec->natengine' failed", (const void *)"natengine not set", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(spec->natengine, "pf");
  if(return_value_strcmp$1 == 0)
    _mark_point("opts.t.c", 346);

  else
    _ck_assert_failed("opts.t.c", 346, "Assertion '!strcmp(spec->natengine, NATENGINE)' failed", (const void *)"natengine mismatch", (void *)0);
  if(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 347);

  else
    _ck_assert_failed("opts.t.c", 347, "Assertion '!spec->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 348);

  else
    _ck_assert_failed("opts.t.c", 348, "Assertion '!spec->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  if(!(spec->next == ((struct proxyspec *)NULL)))
    _mark_point("opts.t.c", 349);

  else
    _ck_assert_failed("opts.t.c", 349, "Assertion '!!spec->next' failed", (const void *)"next is not set", (void *)0);
  if(!(spec->next->ssl == 0u))
    _mark_point("opts.t.c", 350);

  else
    _ck_assert_failed("opts.t.c", 350, "Assertion 'spec->next->ssl' failed", (const void *)"not SSL", (void *)0);
  if(!(spec->next->http == 0u))
    _mark_point("opts.t.c", 351);

  else
    _ck_assert_failed("opts.t.c", 351, "Assertion 'spec->next->http' failed", (const void *)"not HTTP", (void *)0);
  if((unsigned long int)spec->next->listen_addrlen == sizeof(struct sockaddr_in) /*16ul*/ )
    _mark_point("opts.t.c", 352);

  else
    _ck_assert_failed("opts.t.c", 352, "Assertion 'spec->next->listen_addrlen == sizeof(struct sockaddr_in)' failed", (const void *)"not IPv4 listen addr", (void *)0);
  if(spec->next->connect_addrlen == 0u)
    _mark_point("opts.t.c", 354);

  else
    _ck_assert_failed("opts.t.c", 354, "Assertion '!spec->next->connect_addrlen' failed", (const void *)"connect addr set", (void *)0);
  if(spec->next->sni_port == 0)
    _mark_point("opts.t.c", 355);

  else
    _ck_assert_failed("opts.t.c", 355, "Assertion '!spec->next->sni_port' failed", (const void *)"SNI port is set", (void *)0);
  if(!(spec->next->natengine == ((char *)NULL)))
    _mark_point("opts.t.c", 356);

  else
    _ck_assert_failed("opts.t.c", 356, "Assertion '!!spec->next->natengine' failed", (const void *)"natengine not set", (void *)0);
  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(spec->next->natengine, "pf");
  if(return_value_strcmp$2 == 0)
    _mark_point("opts.t.c", 357);

  else
    _ck_assert_failed("opts.t.c", 357, "Assertion '!strcmp(spec->next->natengine, NATENGINE)' failed", (const void *)"natengine mismatch", (void *)0);
  if(spec->next->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL))
    _mark_point("opts.t.c", 359);

  else
    _ck_assert_failed("opts.t.c", 359, "Assertion '!spec->next->natlookup' failed", (const void *)"natlookup() is set", (void *)0);
  if(spec->next->natsocket == ((signed int (*)(signed int))NULL))
    _mark_point("opts.t.c", 360);

  else
    _ck_assert_failed("opts.t.c", 360, "Assertion '!spec->next->natsocket' failed", (const void *)"natsocket() is set", (void *)0);
  proxyspec_free(spec);
}

// pthread_create_01
// file sys.t.c line 180
static void pthread_create_01(signed int _i)
{
  tcase_fn_start("pthread_create_01", "sys.t.c", 180);
  unsigned long int tid;
  signed int x = 0;
  void *rv;
  signed int return_value_pthread_create$1;
  return_value_pthread_create$1=pthread_create(&tid, (const union pthread_attr_t *)(void *)0, thrmain, (void *)&x);
  if(return_value_pthread_create$1 == 0)
    _mark_point("sys.t.c", 185);

  else
    _ck_assert_failed("sys.t.c", 185, "Assertion '!pthread_create(&tid, NULL, thrmain, &x)' failed", (const void *)"Cannot create thread", (void *)0);
  signed int return_value_pthread_join$2;
  return_value_pthread_join$2=pthread_join(tid, &rv);
  if(return_value_pthread_join$2 == 0)
    _mark_point("sys.t.c", 187);

  else
    _ck_assert_failed("sys.t.c", 187, "Assertion '!pthread_join(tid, &rv)' failed", (const void *)"Cannot join thread", (void *)0);
  if(x == 1)
    _mark_point("sys.t.c", 188);

  else
    _ck_assert_failed("sys.t.c", 188, "Assertion 'x == 1' failed", (const void *)"Thread failed to update x", (void *)0);
  if(rv == (void *)2)
    _mark_point("sys.t.c", 189);

  else
    _ck_assert_failed("sys.t.c", 189, "Assertion 'rv == (void*) 2' failed", (const void *)"Thread return value mismatch", (void *)0);
}

// pxy_bev_eventcb
// file pxyconn.c line 1635
static void pxy_bev_eventcb(struct bufferevent *bev, signed short int events, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  struct pxy_conn_desc *this;
  struct pxy_conn_desc *tmp_if_expr$1;
  if(bev == ctx->src.bev)
    tmp_if_expr$1 = &ctx->src;

  else
    tmp_if_expr$1 = &ctx->dst;
  this = tmp_if_expr$1;
  struct pxy_conn_desc *other;
  struct pxy_conn_desc *tmp_if_expr$2;
  if(bev == ctx->src.bev)
    tmp_if_expr$2 = &ctx->dst;

  else
    tmp_if_expr$2 = &ctx->src;
  other = tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  char *tmp_if_expr$11;
  char *tmp_if_expr$19;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  const char *tmp_if_expr$21;
  const char *return_value_ERR_reason_error_string$20;
  const char *tmp_if_expr$23;
  const char *return_value_ERR_lib_error_string$22;
  const char *tmp_if_expr$25;
  const char *return_value_ERR_func_error_string$24;
  char *tmp_if_expr$33;
  signed int *return_value___errno_location$31;
  char *return_value_strerror$32;
  const char *tmp_if_expr$35;
  const char *return_value_ERR_reason_error_string$34;
  const char *tmp_if_expr$37;
  const char *return_value_ERR_lib_error_string$36;
  const char *tmp_if_expr$39;
  const char *return_value_ERR_func_error_string$38;
  if(!((0x80 & (signed int)events) == 0))
  {
    if(bev == ctx->dst.bev)
    {
      ctx->connected = (unsigned int)1;
      if(!(ctx->spec->ssl == 0u))
      {
        if(ctx->passthrough == 0u)
        {
          ctx->src.ssl=pxy_srcssl_create(ctx, this->ssl);
          if(ctx->src.ssl == ((struct ssl_st *)NULL))
          {
            bufferevent_free_and_close_fd(bev, ctx);
            ctx->dst.bev = (struct bufferevent *)(void *)0;
            ctx->dst.ssl = (struct ssl_st *)(void *)0;
            if(!(ctx->opts->passthrough == 0u))
            {
              if(ctx->enomem == 0u)
              {
                ctx->passthrough = (unsigned int)1;
                ctx->connected = (unsigned int)0;
                log_dbg_printf("No cert found; falling back to passthrough\n");
                pxy_fd_readcb(ctx->fd, (signed short int)0, (void *)ctx);
                goto __CPROVER_DUMP_L69;
              }

            }

            evutil_closesocket(ctx->fd);
            pxy_conn_ctx_free(ctx);
            goto __CPROVER_DUMP_L69;
          }

        }

      }

      ctx->src.bev=pxy_bufferevent_setup(ctx, ctx->fd, ctx->src.ssl);
      if(ctx->src.bev == ((struct bufferevent *)NULL))
      {
        if(!(ctx->src.ssl == ((struct ssl_st *)NULL)))
        {
          SSL_free(ctx->src.ssl);
          ctx->src.ssl = (struct ssl_st *)(void *)0;
        }

        bufferevent_free_and_close_fd(bev, ctx);
        evutil_closesocket(ctx->fd);
        pxy_conn_ctx_free(ctx);
        goto __CPROVER_DUMP_L69;
      }

      if(!(ctx->opts->connectlog == ((char *)NULL)))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        if(!(ctx->opts->contentlog == ((char *)NULL)))
          tmp_if_expr$4 = !(ctx->passthrough != 0u) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
      {
        ctx->dst_str=sys_sockaddr_str((struct sockaddr *)&ctx->addr, ctx->addrlen);
        if(ctx->dst_str == ((char *)NULL))
        {
          ctx->enomem = (unsigned int)1;
          pxy_conn_terminate_free(ctx);
          goto __CPROVER_DUMP_L69;
        }

      }

      if(!(ctx->opts->contentlog == ((char *)NULL)))
      {
        if(ctx->passthrough == 0u)
        {
          signed int return_value_log_content_open$7;
          return_value_log_content_open$7=log_content_open(&ctx->logctx, ctx->opts, ctx->src_str, ctx->dst_str, (char *)(void *)0, (char *)(void *)0, (char *)(void *)0);
          if(return_value_log_content_open$7 == -1)
          {
            signed int *return_value___errno_location$6;
            return_value___errno_location$6=__errno_location();
            if(*return_value___errno_location$6 == 12)
              ctx->enomem = (unsigned int)1;

            pxy_conn_terminate_free(ctx);
            goto __CPROVER_DUMP_L69;
          }

        }

      }

    }


  connected:
    ;
    if(this->ssl == ((struct ssl_st *)NULL))
      tmp_if_expr$10 = (_Bool)1;

    else
      tmp_if_expr$10 = bev == ctx->src.bev ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$10)
    {
      if(ctx->spec->http == 0u)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = ctx->passthrough != 0u ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
      {
        if(!(ctx->opts->connectlog == ((char *)NULL)))
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
          pxy_log_connect_nonhttp(ctx);

      }

    }

    if(!((signed long int)ctx->opts->debug == 0l))
    {
      if(!(this->ssl == ((struct ssl_st *)NULL)))
      {
        if(bev == ctx->dst.bev)
          tmp_if_expr$11 = ctx->dst_str;

        else
          tmp_if_expr$11 = ctx->src_str;
        const char *return_value_SSL_get_version$12;
        return_value_SSL_get_version$12=SSL_get_version(this->ssl);
        const struct ssl_cipher_st *return_value_SSL_get_current_cipher$13;
        return_value_SSL_get_current_cipher$13=SSL_get_current_cipher(this->ssl);
        const char *return_value_SSL_CIPHER_get_name$14;
        return_value_SSL_CIPHER_get_name$14=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher$13);
        log_dbg_printf("SSL connected %s %s %s %s\n", bev == ctx->dst.bev ? "to" : "from", tmp_if_expr$11, return_value_SSL_get_version$12, return_value_SSL_CIPHER_get_name$14);
      }

      else
      {
        log_dbg_printf("TCP connected to %s\n", ctx->dst_str);
        log_dbg_printf("TCP connected from %s\n", ctx->src_str);
      }
    }

  }

  else
  {
    if(!((0x20 & (signed int)events) == 0))
    {
      unsigned long int sslerr;
      signed int have_sslerr = 0;
      sslerr=bufferevent_get_openssl_error(bev);
      if(!(sslerr == 0ul))
        have_sslerr = 1;

      signed int *return_value___errno_location$43;
      return_value___errno_location$43=__errno_location();
      if(*return_value___errno_location$43 == 0 && sslerr == 0ul)
      {
        if(!((signed long int)ctx->opts->debug == 0l))
          log_dbg_printf("Unclean SSL shutdown.\n");

      }

      else
        if((4095 & (signed int)sslerr) == 1040)
        {
          signed int *return_value___errno_location$15;
          return_value___errno_location$15=__errno_location();
          signed int *return_value___errno_location$16;
          return_value___errno_location$16=__errno_location();
          if(!(*return_value___errno_location$16 == 0))
          {
            return_value___errno_location$17=__errno_location();
            return_value_strerror$18=strerror(*return_value___errno_location$17);
            tmp_if_expr$19 = return_value_strerror$18;
          }

          else
            tmp_if_expr$19 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_reason_error_string$20=ERR_reason_error_string(sslerr);
            tmp_if_expr$21 = return_value_ERR_reason_error_string$20;
          }

          else
            tmp_if_expr$21 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_lib_error_string$22=ERR_lib_error_string(sslerr);
            tmp_if_expr$23 = return_value_ERR_lib_error_string$22;
          }

          else
            tmp_if_expr$23 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_func_error_string$24=ERR_func_error_string(sslerr);
            tmp_if_expr$25 = return_value_ERR_func_error_string$24;
          }

          else
            tmp_if_expr$25 = "-";
          log_dbg_printf("Error from bufferevent: %i:%s %lu:%i:%s:%i:%s:%i:%s\n", *return_value___errno_location$15, tmp_if_expr$19, sslerr, (signed int)(sslerr & (unsigned long int)0xfffL), tmp_if_expr$21, (signed int)((unsigned long int)sslerr >> 24L & (unsigned long int)0xffL), tmp_if_expr$23, (signed int)((unsigned long int)sslerr >> 12L & (unsigned long int)0xfffL), tmp_if_expr$25);
          do
          {
            sslerr=bufferevent_get_openssl_error(bev);
            if(sslerr == 0ul)
              break;

            const char *return_value_ERR_reason_error_string$26;
            return_value_ERR_reason_error_string$26=ERR_reason_error_string(sslerr);
            const char *return_value_ERR_lib_error_string$27;
            return_value_ERR_lib_error_string$27=ERR_lib_error_string(sslerr);
            const char *return_value_ERR_func_error_string$28;
            return_value_ERR_func_error_string$28=ERR_func_error_string(sslerr);
            log_dbg_printf("Additional SSL error: %lu:%i:%s:%i:%s:%i:%s\n", sslerr, (signed int)(sslerr & (unsigned long int)0xfffL), return_value_ERR_reason_error_string$26, (signed int)((unsigned long int)sslerr >> 24L & (unsigned long int)0xffL), return_value_ERR_lib_error_string$27, (signed int)((unsigned long int)sslerr >> 12L & (unsigned long int)0xfffL), return_value_ERR_func_error_string$28);
          }
          while((_Bool)1);
        }

        else
        {
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          signed int *return_value___errno_location$30;
          return_value___errno_location$30=__errno_location();
          if(!(*return_value___errno_location$30 == 0))
          {
            return_value___errno_location$31=__errno_location();
            return_value_strerror$32=strerror(*return_value___errno_location$31);
            tmp_if_expr$33 = return_value_strerror$32;
          }

          else
            tmp_if_expr$33 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_reason_error_string$34=ERR_reason_error_string(sslerr);
            tmp_if_expr$35 = return_value_ERR_reason_error_string$34;
          }

          else
            tmp_if_expr$35 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_lib_error_string$36=ERR_lib_error_string(sslerr);
            tmp_if_expr$37 = return_value_ERR_lib_error_string$36;
          }

          else
            tmp_if_expr$37 = "-";
          if(!(sslerr == 0ul))
          {
            return_value_ERR_func_error_string$38=ERR_func_error_string(sslerr);
            tmp_if_expr$39 = return_value_ERR_func_error_string$38;
          }

          else
            tmp_if_expr$39 = "-";
          log_err_printf("Error from bufferevent: %i:%s %lu:%i:%s:%i:%s:%i:%s\n", *return_value___errno_location$29, tmp_if_expr$33, sslerr, (signed int)(sslerr & (unsigned long int)0xfffL), tmp_if_expr$35, (signed int)((unsigned long int)sslerr >> 24L & (unsigned long int)0xffL), tmp_if_expr$37, (signed int)((unsigned long int)sslerr >> 12L & (unsigned long int)0xfffL), tmp_if_expr$39);
          do
          {
            sslerr=bufferevent_get_openssl_error(bev);
            if(sslerr == 0ul)
              break;

            const char *return_value_ERR_reason_error_string$40;
            return_value_ERR_reason_error_string$40=ERR_reason_error_string(sslerr);
            const char *return_value_ERR_lib_error_string$41;
            return_value_ERR_lib_error_string$41=ERR_lib_error_string(sslerr);
            const char *return_value_ERR_func_error_string$42;
            return_value_ERR_func_error_string$42=ERR_func_error_string(sslerr);
            log_err_printf("Additional SSL error: %lu:%i:%s:%i:%s:%i:%s\n", sslerr, (signed int)(sslerr & (unsigned long int)0xfffL), return_value_ERR_reason_error_string$40, (signed int)((unsigned long int)sslerr >> 24L & (unsigned long int)0xffL), return_value_ERR_lib_error_string$41, (signed int)((unsigned long int)sslerr >> 12L & (unsigned long int)0xfffL), return_value_ERR_func_error_string$42);
          }
          while((_Bool)1);
        }
      if(ctx->connected == 0u)
      {
        if(bev == ctx->dst.bev)
        {
          if(!(ctx->dst.ssl == ((struct ssl_st *)NULL)))
          {
            if(!(ctx->opts->passthrough == 0u))
            {
              if(!(have_sslerr == 0))
              {
                bufferevent_free_and_close_fd(bev, ctx);
                ctx->dst.bev = (struct bufferevent *)(void *)0;
                ctx->dst.ssl = (struct ssl_st *)(void *)0;
                ctx->passthrough = (unsigned int)1;
                log_dbg_printf("SSL dst connection failed; falling back to passthrough\n");
                pxy_fd_readcb(ctx->fd, (signed short int)0, (void *)ctx);
                goto __CPROVER_DUMP_L69;
              }

            }

          }

        }

        evutil_closesocket(ctx->fd);
        other->closed = (unsigned int)1;
      }

      else
        if(other->closed == 0u)
        {
          struct evbuffer *pxy_bev_eventcb$$1$$2$$5$$outbuf;
          pxy_bev_eventcb$$1$$2$$5$$outbuf=bufferevent_get_output(other->bev);
          unsigned long int return_value_evbuffer_get_length$44;
          return_value_evbuffer_get_length$44=evbuffer_get_length(pxy_bev_eventcb$$1$$2$$5$$outbuf);
          if(return_value_evbuffer_get_length$44 == 0ul)
          {
            bufferevent_free_and_close_fd(other->bev, ctx);
            other->closed = (unsigned int)1;
          }

        }

      goto leave;
    }

    if(!((0x10 & (signed int)events) == 0))
    {
      if(other->closed == 0u)
      {
        struct evbuffer *inbuf;
        struct evbuffer *outbuf;
        inbuf=bufferevent_get_input(bev);
        outbuf=bufferevent_get_output(other->bev);
        unsigned long int return_value_evbuffer_get_length$46;
        return_value_evbuffer_get_length$46=evbuffer_get_length(inbuf);
        if(return_value_evbuffer_get_length$46 >= 1ul)
          evbuffer_add_buffer(outbuf, inbuf);

        else
        {
          unsigned long int return_value_evbuffer_get_length$45;
          return_value_evbuffer_get_length$45=evbuffer_get_length(outbuf);
          if(return_value_evbuffer_get_length$45 == 0ul)
          {
            bufferevent_free_and_close_fd(other->bev, ctx);
            other->closed = (unsigned int)1;
          }

        }
      }

    }

    else
    {
      log_err_printf("Unknown bufferevent 0x%02X\n", (signed int)events);
      goto __CPROVER_DUMP_L69;
    }

  leave:
    ;
    if(!((signed long int)ctx->opts->debug == 0l))
    {
      log_dbg_printf("%s disconnected to %s\n", this->ssl != ((struct ssl_st *)NULL) ? "SSL" : "TCP", ctx->dst_str);
      log_dbg_printf("%s disconnected from %s\n", this->ssl != ((struct ssl_st *)NULL) ? "SSL" : "TCP", ctx->src_str);
    }

    this->closed = (unsigned int)1;
    bufferevent_free_and_close_fd(bev, ctx);
    if(!(other->closed == 0u))
      pxy_conn_ctx_free(ctx);

  }

__CPROVER_DUMP_L69:
  ;
}

// pxy_bev_readcb
// file pxyconn.c line 1439
static void pxy_bev_readcb(struct bufferevent *bev, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  struct pxy_conn_desc *other;
  struct pxy_conn_desc *tmp_if_expr$1;
  if(bev == ctx->src.bev)
    tmp_if_expr$1 = &ctx->dst;

  else
    tmp_if_expr$1 = &ctx->src;
  other = tmp_if_expr$1;
  if(ctx->connected == 0u)
  {
    log_err_printf("readcb called when other end not connected - aborting.\n");
    log_fini();
    exit(1);
  }

  struct evbuffer *inbuf;
  inbuf=bufferevent_get_input(bev);
  if(!(other->closed == 0u))
  {
    unsigned long int return_value_evbuffer_get_length$2;
    return_value_evbuffer_get_length$2=evbuffer_get_length(inbuf);
    evbuffer_drain(inbuf, return_value_evbuffer_get_length$2);
    goto __CPROVER_DUMP_L47;
  }

  struct evbuffer *outbuf;
  outbuf=bufferevent_get_output(other->bev);
  _Bool tmp_if_expr$6;
  if(!(ctx->spec->http == 0u))
    tmp_if_expr$6 = !(ctx->seen_req_header != 0u) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$6 = (_Bool)0;
  _Bool tmp_if_expr$7;
  if(tmp_if_expr$6)
    tmp_if_expr$7 = bev == ctx->src.bev ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$7 = (_Bool)0;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$7)
    tmp_if_expr$8 = !(ctx->passthrough != 0u) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$8 = (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$8)
  {
    struct logbuf *pxy_bev_readcb$$1$$3$$lb = (struct logbuf *)(void *)0;
    struct logbuf *tail = (struct logbuf *)(void *)0;
    char *line;
    do
    {
      line=evbuffer_readln(inbuf, (unsigned long int *)(void *)0, (enum evbuffer_eol_style)EVBUFFER_EOL_CRLF);
      if(line == ((char *)NULL))
        break;

      char *pxy_bev_readcb$$1$$3$$1$$replace;
      if(!(ctx->opts->contentlog == ((char *)NULL)))
      {
        if(ctx->passthrough == 0u)
        {
          struct logbuf *pxy_bev_readcb$$1$$3$$1$$1$$tmp;
          pxy_bev_readcb$$1$$3$$1$$1$$tmp=logbuf_new_printf((void *)0, (struct logbuf *)(void *)0, "%s\r\n", line);
          if(!(tail == ((struct logbuf *)NULL)))
          {
            if(!(pxy_bev_readcb$$1$$3$$1$$1$$tmp == ((struct logbuf *)NULL)))
            {
              tail->next = pxy_bev_readcb$$1$$3$$1$$1$$tmp;
              tail = tail->next;
            }

          }

          else
          {
            tail = pxy_bev_readcb$$1$$3$$1$$1$$tmp;
            pxy_bev_readcb$$1$$3$$lb = tail;
          }
        }

      }

      pxy_bev_readcb$$1$$3$$1$$replace=pxy_http_reqhdr_filter_line(line, ctx);
      if(pxy_bev_readcb$$1$$3$$1$$replace == line)
        evbuffer_add_printf(outbuf, "%s\r\n", line);

      else
        if(!(pxy_bev_readcb$$1$$3$$1$$replace == ((char *)NULL)))
        {
          evbuffer_add_printf(outbuf, "%s\r\n", pxy_bev_readcb$$1$$3$$1$$replace);
          free((void *)pxy_bev_readcb$$1$$3$$1$$replace);
        }

      free((void *)line);
      if(!(ctx->seen_req_header == 0u))
      {
        if(!(ctx->opts->deny_ocsp == 0u))
          pxy_ocsp_deny(ctx);

        break;
      }

    }
    while((_Bool)1);
    if(!(pxy_bev_readcb$$1$$3$$lb == ((struct logbuf *)NULL)))
    {
      if(!(ctx->opts->contentlog == ((char *)NULL)))
      {
        if(ctx->passthrough == 0u)
        {
          signed int return_value_log_content_submit$3;
          return_value_log_content_submit$3=log_content_submit(ctx->logctx, pxy_bev_readcb$$1$$3$$lb, 1);
          if(return_value_log_content_submit$3 == -1)
          {
            logbuf_free(pxy_bev_readcb$$1$$3$$lb);
            log_err_printf("Warning: Content log submission failed\n");
          }

        }

      }

    }

    if(ctx->seen_req_header == 0u)
      goto __CPROVER_DUMP_L47;

  }

  else
    if(!(ctx->spec->http == 0u))
    {
      if(ctx->seen_resp_header == 0u)
      {
        if(bev == ctx->dst.bev)
        {
          if(ctx->passthrough == 0u)
          {
            struct logbuf *pxy_bev_readcb$$1$$4$$lb = (struct logbuf *)(void *)0;
            struct logbuf *pxy_bev_readcb$$1$$4$$tail = (struct logbuf *)(void *)0;
            char *pxy_bev_readcb$$1$$4$$line;
            do
            {
              pxy_bev_readcb$$1$$4$$line=evbuffer_readln(inbuf, (unsigned long int *)(void *)0, (enum evbuffer_eol_style)EVBUFFER_EOL_CRLF);
              if(pxy_bev_readcb$$1$$4$$line == ((char *)NULL))
                break;

              char *replace;
              if(!(ctx->opts->contentlog == ((char *)NULL)))
              {
                if(ctx->passthrough == 0u)
                {
                  struct logbuf *tmp;
                  tmp=logbuf_new_printf((void *)0, (struct logbuf *)(void *)0, "%s\r\n", pxy_bev_readcb$$1$$4$$line);
                  if(!(pxy_bev_readcb$$1$$4$$tail == ((struct logbuf *)NULL)))
                  {
                    if(!(tmp == ((struct logbuf *)NULL)))
                    {
                      pxy_bev_readcb$$1$$4$$tail->next = tmp;
                      pxy_bev_readcb$$1$$4$$tail = pxy_bev_readcb$$1$$4$$tail->next;
                    }

                  }

                  else
                  {
                    pxy_bev_readcb$$1$$4$$tail = tmp;
                    pxy_bev_readcb$$1$$4$$lb = pxy_bev_readcb$$1$$4$$tail;
                  }
                }

              }

              replace=pxy_http_resphdr_filter_line(pxy_bev_readcb$$1$$4$$line, ctx);
              if(replace == pxy_bev_readcb$$1$$4$$line)
                evbuffer_add_printf(outbuf, "%s\r\n", pxy_bev_readcb$$1$$4$$line);

              else
                if(!(replace == ((char *)NULL)))
                {
                  evbuffer_add_printf(outbuf, "%s\r\n", replace);
                  free((void *)replace);
                }

              free((void *)pxy_bev_readcb$$1$$4$$line);
              if(!(ctx->seen_resp_header == 0u))
              {
                if(!(ctx->opts->connectlog == ((char *)NULL)))
                  tmp_if_expr$4 = (_Bool)1;

                else
                  tmp_if_expr$4 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$4)
                  pxy_log_connect_http(ctx);

                break;
              }

            }
            while((_Bool)1);
            if(!(pxy_bev_readcb$$1$$4$$lb == ((struct logbuf *)NULL)))
            {
              if(!(ctx->opts->contentlog == ((char *)NULL)))
              {
                if(ctx->passthrough == 0u)
                {
                  signed int return_value_log_content_submit$5;
                  return_value_log_content_submit$5=log_content_submit(ctx->logctx, pxy_bev_readcb$$1$$4$$lb, 0);
                  if(return_value_log_content_submit$5 == -1)
                  {
                    logbuf_free(pxy_bev_readcb$$1$$4$$lb);
                    log_err_printf("Warning: Content log submission failed\n");
                  }

                }

              }

            }

            if(ctx->seen_resp_header == 0u)
              goto __CPROVER_DUMP_L47;

          }

        }

      }

    }

  signed long int return_value_evbuffer_copyout$12;
  if(!(ctx->enomem == 0u))
    pxy_conn_terminate_free(ctx);

  else
  {
    unsigned long int return_value_evbuffer_get_length$9;
    return_value_evbuffer_get_length$9=evbuffer_get_length(inbuf);
    if(!(return_value_evbuffer_get_length$9 == 0ul))
    {
      if(!(ctx->opts->contentlog == ((char *)NULL)))
      {
        if(ctx->passthrough == 0u)
        {
          struct logbuf *lb;
          unsigned long int return_value_evbuffer_get_length$10;
          return_value_evbuffer_get_length$10=evbuffer_get_length(inbuf);
          lb=logbuf_new_alloc(return_value_evbuffer_get_length$10, (void *)0, (struct logbuf *)(void *)0);
          if(!(lb == ((struct logbuf *)NULL)))
          {
            return_value_evbuffer_copyout$12=evbuffer_copyout(inbuf, (void *)lb->buf, (unsigned long int)lb->sz);
            if(!(return_value_evbuffer_copyout$12 == -1l))
            {
              signed int return_value_log_content_submit$11;
              return_value_log_content_submit$11=log_content_submit(ctx->logctx, lb, (signed int)(bev == ctx->src.bev));
              if(return_value_log_content_submit$11 == -1)
              {
                logbuf_free(lb);
                log_err_printf("Warning: Content log submission failed\n");
              }

            }

          }

        }

      }

      evbuffer_add_buffer(outbuf, inbuf);
      unsigned long int return_value_evbuffer_get_length$13;
      return_value_evbuffer_get_length$13=evbuffer_get_length(outbuf);
      if(return_value_evbuffer_get_length$13 >= 131072ul)
      {
        bufferevent_setwatermark(other->bev, (signed short int)0x04, (unsigned long int)((128 * 1024) / 2), (unsigned long int)(128 * 1024));
        bufferevent_disable(bev, (signed short int)0x02);
      }

    }

  }

__CPROVER_DUMP_L47:
  ;
}

// pxy_bev_writecb
// file pxyconn.c line 1602
static void pxy_bev_writecb(struct bufferevent *bev, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  struct pxy_conn_desc *other;
  struct pxy_conn_desc *tmp_if_expr$1;
  if(bev == ctx->src.bev)
    tmp_if_expr$1 = &ctx->dst;

  else
    tmp_if_expr$1 = &ctx->src;
  other = tmp_if_expr$1;
  struct evbuffer *outbuf;
  outbuf=bufferevent_get_output(bev);
  unsigned long int return_value_evbuffer_get_length$2;
  return_value_evbuffer_get_length$2=evbuffer_get_length(outbuf);
  if(return_value_evbuffer_get_length$2 >= 1ul)
  {
    bufferevent_setwatermark(bev, (signed short int)0x04, (unsigned long int)0, (unsigned long int)0);
    if(other->closed == 0u)
      bufferevent_enable(other->bev, (signed short int)0x02);

  }

  else
    if(!(other->closed == 0u))
    {
      bufferevent_free_and_close_fd(bev, ctx);
      pxy_conn_ctx_free(ctx);
    }

}

// pxy_bufferevent_setup
// file pxyconn.c line 1097
static struct bufferevent * pxy_bufferevent_setup(struct pxy_conn_ctx *ctx, signed int fd, struct ssl_st *ssl)
{
  struct bufferevent *bev;
  if(!(ssl == ((struct ssl_st *)NULL)))
    bev=bufferevent_openssl_socket_new(ctx->evbase, fd, ssl, (enum bufferevent_ssl_state)(fd == -1 ? BUFFEREVENT_SSL_CONNECTING : BUFFEREVENT_SSL_ACCEPTING), 4);

  else
    bev=bufferevent_socket_new(ctx->evbase, fd, 4);
  if(bev == ((struct bufferevent *)NULL))
  {
    log_err_printf("Error creating bufferevent socket\n");
    return (struct bufferevent *)(void *)0;
  }

  else
  {
    bufferevent_setcb(bev, pxy_bev_readcb, pxy_bev_writecb, pxy_bev_eventcb, (void *)ctx);
    bufferevent_enable(bev, (signed short int)(0x02 | 0x04));
    return bev;
  }
}

// pxy_conn_connect
// file pxyconn.c line 1949
static void pxy_conn_connect(struct pxy_conn_ctx *ctx)
{
  if(ctx->addrlen == 0u)
  {
    log_err_printf("No target address; aborting connection\n");
    evutil_closesocket(ctx->fd);
    pxy_conn_ctx_free(ctx);
  }

  else
    if(!(ctx->spec->ssl == 0u))
    {
      if(ctx->passthrough != 0u)
        goto __CPROVER_DUMP_L2;

      ctx->dst.ssl=pxy_dstssl_create(ctx);
      if(!(ctx->dst.ssl == ((struct ssl_st *)NULL)))
        goto __CPROVER_DUMP_L2;

      log_err_printf("Error creating SSL\n");
      evutil_closesocket(ctx->fd);
      pxy_conn_ctx_free(ctx);
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      ctx->dst.bev=pxy_bufferevent_setup(ctx, -1, ctx->dst.ssl);
      if(ctx->dst.bev == ((struct bufferevent *)NULL))
      {
        if(!(ctx->dst.ssl == ((struct ssl_st *)NULL)))
        {
          SSL_free(ctx->dst.ssl);
          ctx->dst.ssl = (struct ssl_st *)(void *)0;
        }

        evutil_closesocket(ctx->fd);
        pxy_conn_ctx_free(ctx);
      }

      else
      {
        if(!((signed long int)ctx->opts->debug == 0l))
        {
          char *ip;
          ip=sys_sockaddr_str((struct sockaddr *)&ctx->addr, ctx->addrlen);
          log_dbg_printf("Connecting to %s\n", ip);
          if(!(ip == ((char *)NULL)))
            free((void *)ip);

        }

        bufferevent_socket_connect(ctx->dst.bev, (struct sockaddr *)&ctx->addr, (signed int)ctx->addrlen);
      }
    }
}

// pxy_conn_ctx_free
// file pxyconn.c line 215
static void pxy_conn_ctx_free(struct pxy_conn_ctx *ctx)
{
  pxy_thrmgr_detach(ctx->thrmgr, ctx->thridx);
  if(!(ctx->src_str == ((char *)NULL)))
    free((void *)ctx->src_str);

  if(!(ctx->dst_str == ((char *)NULL)))
    free((void *)ctx->dst_str);

  if(!(ctx->http_method == ((char *)NULL)))
    free((void *)ctx->http_method);

  if(!(ctx->http_uri == ((char *)NULL)))
    free((void *)ctx->http_uri);

  if(!(ctx->http_host == ((char *)NULL)))
    free((void *)ctx->http_host);

  if(!(ctx->http_content_type == ((char *)NULL)))
    free((void *)ctx->http_content_type);

  if(!(ctx->http_status_code == ((char *)NULL)))
    free((void *)ctx->http_status_code);

  if(!(ctx->http_status_text == ((char *)NULL)))
    free((void *)ctx->http_status_text);

  if(!(ctx->http_content_length == ((char *)NULL)))
    free((void *)ctx->http_content_length);

  if(!(ctx->ssl_names == ((char *)NULL)))
    free((void *)ctx->ssl_names);

  if(!(ctx->origcrt == ((struct x509_st *)NULL)))
    X509_free(ctx->origcrt);

  if(!(ctx->ev == ((struct event *)NULL)))
    event_free(ctx->ev);

  if(!(ctx->sni == ((char *)NULL)))
    free((void *)ctx->sni);

  if(!(ctx->opts->contentlog == ((char *)NULL)))
  {
    if(ctx->passthrough == 0u)
    {
      if(!(ctx->logctx == ((struct log_content_ctx *)NULL)))
      {
        signed int return_value_log_content_close$1;
        return_value_log_content_close$1=log_content_close(&ctx->logctx);
        if(return_value_log_content_close$1 == -1)
          log_err_printf("Warning: Content log close failed\n");

      }

    }

  }

  free((void *)ctx);
}

// pxy_conn_ctx_new
// file pxyconn.c line 188
static struct pxy_conn_ctx * pxy_conn_ctx_new(struct proxyspec *spec, struct opts *opts, struct pxy_thrmgr_ctx *thrmgr, signed int fd)
{
  struct pxy_conn_ctx *ctx;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct pxy_conn_ctx) /*360ul*/ );
  ctx = (struct pxy_conn_ctx *)return_value_malloc$1;
  if(ctx == ((struct pxy_conn_ctx *)NULL))
    return (struct pxy_conn_ctx *)(void *)0;

  else
  {
    memset((void *)ctx, 0, sizeof(struct pxy_conn_ctx) /*360ul*/ );
    ctx->spec = spec;
    ctx->opts = opts;
    ctx->fd = fd;
    ctx->thridx=pxy_thrmgr_attach(thrmgr, &ctx->evbase, &ctx->dnsbase);
    ctx->thrmgr = thrmgr;
    return ctx;
  }
}

// pxy_conn_setup
// file pxyconn.h line 42
void pxy_conn_setup(signed int fd, struct sockaddr *peeraddr, signed int peeraddrlen, struct pxy_thrmgr_ctx *thrmgr, struct proxyspec *spec, struct opts *opts)
{
  struct pxy_conn_ctx *ctx;
  ctx=pxy_conn_ctx_new(spec, opts, thrmgr, fd);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(ctx == ((struct pxy_conn_ctx *)NULL))
  {
    log_err_printf("Error allocating memory\n");
    evutil_closesocket(fd);
  }

  else
  {
    ctx->af = (signed int)peeraddr->sa_family;
    if(!(spec->natlookup == ((signed int (*)(struct sockaddr *, unsigned int *, signed int, struct sockaddr *, unsigned int))NULL)))
    {
      ctx->addrlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
      signed int return_value;
      return_value=spec->natlookup((struct sockaddr *)&ctx->addr, &ctx->addrlen, fd, peeraddr, (unsigned int)peeraddrlen);
      if(return_value == -1)
      {
        log_err_printf("Connection not found in NAT state table, aborting connection\n");
        evutil_closesocket(fd);
        pxy_conn_ctx_free(ctx);
      }

    }

    else
      if(spec->connect_addrlen >= 1u)
      {
        ctx->addrlen = spec->connect_addrlen;
        memcpy((void *)&ctx->addr, (const void *)&spec->connect_addr, (unsigned long int)ctx->addrlen);
      }

      else
        if(ctx->spec->ssl == 0u)
        {
          log_err_printf("SNI mode used for non-SSL connection; aborting connection\n");
          evutil_closesocket(fd);
          pxy_conn_ctx_free(ctx);
          goto __CPROVER_DUMP_L16;
        }

    if(!(ctx->opts->connectlog == ((char *)NULL)))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(!(ctx->opts->contentlog == ((char *)NULL)))
        tmp_if_expr$2 = !(ctx->passthrough != 0u) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      ctx->src_str=sys_sockaddr_str(peeraddr, (unsigned int)peeraddrlen);
      if(ctx->src_str == ((char *)NULL))
        goto memout;

    }

    if(!(ctx->spec->ssl == 0u))
    {
      ctx->ev=event_new(ctx->evbase, fd, (signed short int)0x02, pxy_fd_readcb, (void *)ctx);
      if(ctx->ev == ((struct event *)NULL))
        goto memout;

      event_add(ctx->ev, (struct timeval *)(void *)0);
    }

    else
      pxy_fd_readcb(fd, (signed short int)0, (void *)ctx);
    goto __CPROVER_DUMP_L16;

  memout:
    ;
    log_err_printf("Aborting connection setup (out of memory)!\n");
    evutil_closesocket(fd);
    pxy_conn_ctx_free(ctx);
    goto __CPROVER_DUMP_L16;
  }

__CPROVER_DUMP_L16:
  ;
}

// pxy_conn_terminate_free
// file pxyconn.c line 1421
void pxy_conn_terminate_free(struct pxy_conn_ctx *ctx)
{
  log_err_printf("Terminating connection%s!\n", ctx->enomem != 0u ? " (out of memory)" : "");
  if(!(ctx->dst.bev == ((struct bufferevent *)NULL)))
  {
    if(ctx->dst.closed == 0u)
      bufferevent_free_and_close_fd(ctx->dst.bev, ctx);

  }

  if(!(ctx->src.bev == ((struct bufferevent *)NULL)))
  {
    if(ctx->src.closed == 0u)
      bufferevent_free_and_close_fd(ctx->src.bev, ctx);

  }

  pxy_conn_ctx_free(ctx);
}

// pxy_debug_crt
// file pxyconn.c line 301
static void pxy_debug_crt(struct x509_st *crt)
{
  char *sj;
  sj=ssl_x509_subject(crt);
  if(!(sj == ((char *)NULL)))
  {
    log_dbg_printf("Subject DN: %s\n", sj);
    free((void *)sj);
  }

  char *names;
  names=ssl_x509_names_to_str(crt);
  if(!(names == ((char *)NULL)))
  {
    log_dbg_printf("Common Names: %s\n", names);
    free((void *)names);
  }

  unsigned char fpr[20l];
  signed int return_value_ssl_x509_fingerprint_sha1$1;
  return_value_ssl_x509_fingerprint_sha1$1=ssl_x509_fingerprint_sha1(crt, fpr);
  if(return_value_ssl_x509_fingerprint_sha1$1 == -1)
    log_err_printf("Warning: Error generating X509 fingerprint\n");

  else
    log_dbg_printf("Fingerprint: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n", fpr[(signed long int)0], fpr[(signed long int)1], fpr[(signed long int)2], fpr[(signed long int)3], fpr[(signed long int)4], fpr[(signed long int)5], fpr[(signed long int)6], fpr[(signed long int)7], fpr[(signed long int)8], fpr[(signed long int)9], fpr[(signed long int)10], fpr[(signed long int)11], fpr[(signed long int)12], fpr[(signed long int)13], fpr[(signed long int)14], fpr[(signed long int)15], fpr[(signed long int)16], fpr[(signed long int)17], fpr[(signed long int)18], fpr[(signed long int)19]);
}

// pxy_dstssl_create
// file pxyconn.c line 960
static struct ssl_st * pxy_dstssl_create(struct pxy_conn_ctx *ctx)
{
  struct ssl_ctx_st *sslctx;
  struct ssl_st *ssl;
  struct ssl_session_st *sess;
  const struct ssl_method_st *return_value;
  return_value=ctx->opts->sslmethod();
  sslctx=SSL_CTX_new(return_value);
  if(sslctx == ((struct ssl_ctx_st *)NULL))
  {
    ctx->enomem = (unsigned int)1;
    return (struct ssl_st *)(void *)0;
  }

  else
  {
    SSL_CTX_ctrl(sslctx, 32, 0x80000BFFL, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00800000L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00040000L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00000800L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00004000L, (void *)0);
    if(ctx->opts->sslcomp == 0u)
      SSL_CTX_ctrl(sslctx, 32, 0x00020000L, (void *)0);

    SSL_CTX_ctrl(sslctx, 32, 0x01000000L, (void *)0);
    if(!(ctx->opts->no_ssl3 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x02000000L, (void *)0);

    if(!(ctx->opts->no_tls10 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x04000000L, (void *)0);

    if(!(ctx->opts->no_tls11 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x10000000L, (void *)0);

    if(!(ctx->opts->no_tls12 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x08000000L, (void *)0);

    SSL_CTX_set_cipher_list(sslctx, ctx->opts->ciphers);
    SSL_CTX_set_verify(sslctx, 0x00, (signed int (*)(signed int, struct x509_store_ctx_st *))(void *)0);
    ssl=SSL_new(sslctx);
    SSL_CTX_free(sslctx);
    if(ssl == ((struct ssl_st *)NULL))
    {
      ctx->enomem = (unsigned int)1;
      return (struct ssl_st *)(void *)0;
    }

    else
    {
      if(!(ctx->sni == ((char *)NULL)))
        SSL_ctrl(ssl, 55, (signed long int)0, (void *)(char *)ctx->sni);

      signed long int return_value_SSL_ctrl$1;
      return_value_SSL_ctrl$1=SSL_ctrl(ssl, 33, (signed long int)0, (void *)0);
      SSL_ctrl(ssl, 33, return_value_SSL_ctrl$1 | 0x00000010L, (void *)0);
      void *return_value_cachedsess_mkkey$2;
      return_value_cachedsess_mkkey$2=cachedsess_mkkey((struct sockaddr *)&ctx->addr, ctx->addrlen, ctx->sni);
      void *return_value_cache_get$3;
      return_value_cache_get$3=cache_get(cachemgr_dsess, return_value_cachedsess_mkkey$2);
      sess = (struct ssl_session_st *)return_value_cache_get$3;
      if(!(sess == ((struct ssl_session_st *)NULL)))
      {
        if(!((signed long int)ctx->opts->debug == 0l))
          log_dbg_printf("Attempt reuse dst SSL session\n");

        SSL_set_session(ssl, sess);
        SSL_SESSION_free(sess);
      }

      return ssl;
    }
  }
}

// pxy_fd_readcb
// file pxyconn.c line 2030
static void pxy_fd_readcb(signed int fd, signed short int what, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  char *tmp_if_expr$1;
  unsigned int tmp_post$2;
  if(!(ctx->spec->ssl == 0u))
  {
    if(ctx->passthrough == 0u)
    {
      unsigned char pxy_fd_readcb$$1$$1$$buf[1024l];
      signed long int n;
      n=recv(fd, (void *)pxy_fd_readcb$$1$$1$$buf, sizeof(unsigned char [1024l]) /*1024ul*/ , 2);
      if(n == -1l)
      {
        log_err_printf("Error peeking on fd, aborting connection\n");
        evutil_closesocket(fd);
        pxy_conn_ctx_free(ctx);
        goto __CPROVER_DUMP_L10;
      }

      if(n == 0l)
      {
        evutil_closesocket(fd);
        pxy_conn_ctx_free(ctx);
        goto __CPROVER_DUMP_L10;
      }

      ctx->sni=ssl_tls_clienthello_parse_sni(pxy_fd_readcb$$1$$1$$buf, &n);
      if(!((signed long int)ctx->opts->debug == 0l))
      {
        if(!(ctx->sni == ((char *)NULL)))
          tmp_if_expr$1 = ctx->sni;

        else
          tmp_if_expr$1 = "n/a";
        log_dbg_printf("SNI peek: [%s] [%s]\n", tmp_if_expr$1, (!(ctx->sni != ((char *)NULL)) ? (n == (signed long int)-1 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? "incomplete" : "complete");
      }

      if(ctx->sni == ((char *)NULL))
      {
        if(n == -1l)
        {
          tmp_post$2 = (unsigned int)ctx->sni_peek_retries;
          ctx->sni_peek_retries = (unsigned int)ctx->sni_peek_retries + 1u;
          if(!(tmp_post$2 >= 50u))
          {
            struct timeval retry_delay = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)100 };
            event_free(ctx->ev);
            ctx->ev=event_new(ctx->evbase, fd, (signed short int)0, pxy_fd_readcb, (void *)ctx);
            if(ctx->ev == ((struct event *)NULL))
            {
              log_err_printf("Error creating retry event, aborting connection\n");
              evutil_closesocket(fd);
              pxy_conn_ctx_free(ctx);
              goto __CPROVER_DUMP_L10;
            }

            event_add(ctx->ev, &retry_delay);
            goto __CPROVER_DUMP_L10;
          }

        }

      }

      event_free(ctx->ev);
      ctx->ev = (struct event *)(void *)0;
    }

  }

  if(!(ctx->sni == ((char *)NULL)))
  {
    if(ctx->addrlen == 0u)
    {
      if(!(ctx->spec->sni_port == 0))
      {
        char sniport[6l];
        struct addrinfo hints;
        memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
        hints.ai_family = ctx->af;
        hints.ai_flags = 0x0020;
        hints.ai_socktype = 1;
        hints.ai_protocol = 6;
        snprintf(sniport, sizeof(char [6l]) /*6ul*/ , "%i", ctx->spec->sni_port);
        evdns_getaddrinfo(ctx->dnsbase, ctx->sni, sniport, &hints, pxy_sni_resolve_cb, (void *)ctx);
        goto __CPROVER_DUMP_L10;
      }

    }

  }

  pxy_conn_connect(ctx);

__CPROVER_DUMP_L10:
  ;
}

// pxy_http_reqhdr_filter_line
// file pxyconn.c line 1142
static char * pxy_http_reqhdr_filter_line(const char *line, struct pxy_conn_ctx *ctx)
{
  char *tmp_if_expr$2;
  char *return_value_strchr$1;
  _Bool tmp_if_expr$14;
  signed int return_value_strncasecmp$13;
  signed int return_value_strncasecmp$12;
  signed int return_value_strncasecmp$11;
  signed int return_value_strncasecmp$8;
  _Bool tmp_if_expr$10;
  signed int return_value_strncasecmp$9;
  if(ctx->http_method == ((char *)NULL))
  {
    char *space1;
    char *space2;
    space1=strchr(line, 32);
    if(!(space1 == ((char *)NULL)))
    {
      return_value_strchr$1=strchr(space1 + (signed long int)1, 32);
      tmp_if_expr$2 = return_value_strchr$1;
    }

    else
      tmp_if_expr$2 = (char *)(void *)0;
    space2 = tmp_if_expr$2;
    if(space1 == ((char *)NULL))
      ctx->seen_req_header = (unsigned int)1;

    else
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc((unsigned long int)((space1 - line) + (signed long int)1));
      ctx->http_method = (char *)return_value_malloc$3;
      if(!(ctx->http_method == ((char *)NULL)))
      {
        memcpy((void *)ctx->http_method, (const void *)line, (unsigned long int)(space1 - line));
        ctx->http_method[space1 - line] = (char)0;
      }

      else
      {
        ctx->enomem = (unsigned int)1;
        return (char *)(void *)0;
      }
      space1 = space1 + 1l;
      if(space2 == ((char *)NULL))
      {
        ctx->seen_req_header = (unsigned int)1;
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(space1);
        space2 = space1 + (signed long int)return_value_strlen$4;
      }

      void *return_value_malloc$5;
      return_value_malloc$5=malloc((unsigned long int)((space2 - space1) + (signed long int)1));
      ctx->http_uri = (char *)return_value_malloc$5;
      if(!(ctx->http_uri == ((char *)NULL)))
      {
        memcpy((void *)ctx->http_uri, (const void *)space1, (unsigned long int)(space2 - space1));
        ctx->http_uri[space2 - space1] = (char)0;
      }

      else
      {
        ctx->enomem = (unsigned int)1;
        return (char *)(void *)0;
      }
    }
  }

  else
  {
    char *newhdr;
    if(ctx->http_host == ((char *)NULL))
    {
      return_value_strncasecmp$13=strncasecmp(line, "Host:", (unsigned long int)5);
      tmp_if_expr$14 = !(return_value_strncasecmp$13 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$14 = (_Bool)0;
    if(tmp_if_expr$14)
    {
      char *return_value_util_skipws$6;
      return_value_util_skipws$6=util_skipws(line + (signed long int)5);
      ctx->http_host=strdup(return_value_util_skipws$6);
      if(ctx->http_host == ((char *)NULL))
      {
        ctx->enomem = (unsigned int)1;
        return (char *)(void *)0;
      }

    }

    else
    {
      return_value_strncasecmp$12=strncasecmp(line, "Content-Type:", (unsigned long int)13);
      if(return_value_strncasecmp$12 == 0)
      {
        char *return_value_util_skipws$7;
        return_value_util_skipws$7=util_skipws(line + (signed long int)13);
        ctx->http_content_type=strdup(return_value_util_skipws$7);
        if(ctx->http_content_type == ((char *)NULL))
        {
          ctx->enomem = (unsigned int)1;
          return (char *)(void *)0;
        }

      }

      else
      {
        return_value_strncasecmp$11=strncasecmp(line, "Connection:", (unsigned long int)11);
        if(return_value_strncasecmp$11 == 0)
        {
          ctx->sent_http_conn_close = (unsigned int)1;
          newhdr=strdup("Connection: close");
          if(newhdr == ((char *)NULL))
          {
            ctx->enomem = (unsigned int)1;
            return (char *)(void *)0;
          }

          return newhdr;
        }

        else
        {
          return_value_strncasecmp$8=strncasecmp(line, "Accept-Encoding:", (unsigned long int)16);
          if(return_value_strncasecmp$8 == 0)
            tmp_if_expr$10 = (_Bool)1;

          else
          {
            return_value_strncasecmp$9=strncasecmp(line, "Keep-Alive:", (unsigned long int)11);
            tmp_if_expr$10 = !(return_value_strncasecmp$9 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$10)
            return (char *)(void *)0;

          else
            if((signed int)*line == 0)
            {
              ctx->seen_req_header = (unsigned int)1;
              if(ctx->sent_http_conn_close == 0u)
              {
                newhdr=strdup("Connection: close\r\n");
                if(newhdr == ((char *)NULL))
                {
                  ctx->enomem = (unsigned int)1;
                  return (char *)(void *)0;
                }

                return newhdr;
              }

            }

        }
      }
    }
  }
  return (char *)line;
}

// pxy_http_resphdr_filter_line
// file pxyconn.c line 1228
static char * pxy_http_resphdr_filter_line(const char *line, struct pxy_conn_ctx *ctx)
{
  char *tmp_if_expr$2;
  char *return_value_strchr$1;
  _Bool tmp_if_expr$7;
  signed int return_value_strncmp$6;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$17;
  signed int return_value_strncasecmp$16;
  signed int return_value_strncasecmp$9;
  _Bool tmp_if_expr$11;
  signed int return_value_strncasecmp$10;
  _Bool tmp_if_expr$13;
  signed int return_value_strncasecmp$12;
  _Bool tmp_if_expr$15;
  signed int return_value_strncasecmp$14;
  if(ctx->http_status_code == ((char *)NULL))
  {
    char *space1;
    char *space2;
    space1=strchr(line, 32);
    if(!(space1 == ((char *)NULL)))
    {
      return_value_strchr$1=strchr(space1 + (signed long int)1, 32);
      tmp_if_expr$2 = return_value_strchr$1;
    }

    else
      tmp_if_expr$2 = (char *)(void *)0;
    space2 = tmp_if_expr$2;
    if(space1 == ((char *)NULL))
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_strncmp$6=strncmp(line, "HTTP", (unsigned long int)4);
      tmp_if_expr$7 = !(!(return_value_strncmp$6 != 0)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      ctx->seen_resp_header = (unsigned int)1;

    else
    {
      unsigned long int len_code;
      unsigned long int len_text;
      if(!(space2 == ((char *)NULL)))
      {
        len_code = (unsigned long int)((space2 - space1) - (signed long int)1);
        len_text=strlen(space2 + (signed long int)1);
      }

      else
      {
        len_code=strlen(space1 + (signed long int)1);
        len_text = (unsigned long int)0;
      }
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(len_code + (unsigned long int)1);
      ctx->http_status_code = (char *)return_value_malloc$3;
      void *return_value_malloc$4;
      return_value_malloc$4=malloc(len_text + (unsigned long int)1);
      ctx->http_status_text = (char *)return_value_malloc$4;
      if(ctx->http_status_code == ((char *)NULL))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = !(ctx->http_status_text != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
      {
        ctx->enomem = (unsigned int)1;
        return (char *)(void *)0;
      }

      memcpy((void *)ctx->http_status_code, (const void *)(space1 + (signed long int)1), len_code);
      ctx->http_status_code[(signed long int)len_code] = (char)0;
      if(!(space2 == ((char *)NULL)))
        memcpy((void *)ctx->http_status_text, (const void *)(space2 + (signed long int)1), len_text);

      ctx->http_status_text[(signed long int)len_text] = (char)0;
    }
  }

  else
  {
    if(ctx->http_content_length == ((char *)NULL))
    {
      return_value_strncasecmp$16=strncasecmp(line, "Content-Length:", (unsigned long int)15);
      tmp_if_expr$17 = !(return_value_strncasecmp$16 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$17 = (_Bool)0;
    if(tmp_if_expr$17)
    {
      char *return_value_util_skipws$8;
      return_value_util_skipws$8=util_skipws(line + (signed long int)15);
      ctx->http_content_length=strdup(return_value_util_skipws$8);
      if(ctx->http_content_length == ((char *)NULL))
      {
        ctx->enomem = (unsigned int)1;
        return (char *)(void *)0;
      }

    }

    else
    {
      return_value_strncasecmp$9=strncasecmp(line, "Public-Key-Pins:", (unsigned long int)16);
      if(return_value_strncasecmp$9 == 0)
        tmp_if_expr$11 = (_Bool)1;

      else
      {
        return_value_strncasecmp$10=strncasecmp(line, "Public-Key-Pins-Report-Only:", (unsigned long int)28);
        tmp_if_expr$11 = !(return_value_strncasecmp$10 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$11)
        tmp_if_expr$13 = (_Bool)1;

      else
      {
        return_value_strncasecmp$12=strncasecmp(line, "Strict-Transport-Security:", (unsigned long int)26);
        tmp_if_expr$13 = !(return_value_strncasecmp$12 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$13)
        tmp_if_expr$15 = (_Bool)1;

      else
      {
        return_value_strncasecmp$14=strncasecmp(line, "Alternate-Protocol:", (unsigned long int)19);
        tmp_if_expr$15 = !(return_value_strncasecmp$14 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$15)
        return (char *)(void *)0;

      else
        if((signed int)*line == 0)
          ctx->seen_resp_header = (unsigned int)1;

    }
  }
  return (char *)line;
}

// pxy_log_connect_http
// file pxyconn.c line 419
static void pxy_log_connect_http(struct pxy_conn_ctx *ctx)
{
  char *msg;
  signed int rv;
  _Bool tmp_if_expr$1;
  char *tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  char *tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  char *tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  char *tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  char *tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  char *tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  char *tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  char *tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  char *tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  char *tmp_if_expr$20;
  _Bool tmp_if_expr$21;
  char *tmp_if_expr$22;
  _Bool tmp_if_expr$23;
  char *tmp_if_expr$24;
  _Bool tmp_if_expr$25;
  char *tmp_if_expr$26;
  _Bool tmp_if_expr$27;
  char *tmp_if_expr$28;
  _Bool tmp_if_expr$29;
  char *tmp_if_expr$30;
  _Bool tmp_if_expr$31;
  char *tmp_if_expr$32;
  if(ctx->spec->ssl == 0u)
  {
    if(!(ctx->src_str == ((char *)NULL)))
      tmp_if_expr$1 = *ctx->src_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = ctx->src_str;

    else
      tmp_if_expr$2 = "-";
    if(!(ctx->dst_str == ((char *)NULL)))
      tmp_if_expr$3 = *ctx->dst_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = ctx->dst_str;

    else
      tmp_if_expr$4 = "-";
    if(!(ctx->http_host == ((char *)NULL)))
      tmp_if_expr$5 = *ctx->http_host != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = ctx->http_host;

    else
      tmp_if_expr$6 = "-";
    if(!(ctx->http_method == ((char *)NULL)))
      tmp_if_expr$7 = *ctx->http_method != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$7 = (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = ctx->http_method;

    else
      tmp_if_expr$8 = "-";
    if(!(ctx->http_uri == ((char *)NULL)))
      tmp_if_expr$9 = *ctx->http_uri != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$9 = (_Bool)0;
    if(tmp_if_expr$9)
      tmp_if_expr$10 = ctx->http_uri;

    else
      tmp_if_expr$10 = "-";
    if(!(ctx->http_status_code == ((char *)NULL)))
      tmp_if_expr$11 = *ctx->http_status_code != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$11 = (_Bool)0;
    if(tmp_if_expr$11)
      tmp_if_expr$12 = ctx->http_status_code;

    else
      tmp_if_expr$12 = "-";
    if(!(ctx->http_content_length == ((char *)NULL)))
      tmp_if_expr$13 = *ctx->http_content_length != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$13 = (_Bool)0;
    if(tmp_if_expr$13)
      tmp_if_expr$14 = ctx->http_content_length;

    else
      tmp_if_expr$14 = "-";
    rv=asprintf(&msg, "http %s %s %s %s %s %s %s%s\n", tmp_if_expr$2, tmp_if_expr$4, tmp_if_expr$6, tmp_if_expr$8, tmp_if_expr$10, tmp_if_expr$12, tmp_if_expr$14, ctx->ocsp_denied != 0u ? " ocsp:denied" : "");
  }

  else
  {
    if(!(ctx->src_str == ((char *)NULL)))
      tmp_if_expr$15 = *ctx->src_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$15 = (_Bool)0;
    if(tmp_if_expr$15)
      tmp_if_expr$16 = ctx->src_str;

    else
      tmp_if_expr$16 = "-";
    if(!(ctx->dst_str == ((char *)NULL)))
      tmp_if_expr$17 = *ctx->dst_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$17 = (_Bool)0;
    if(tmp_if_expr$17)
      tmp_if_expr$18 = ctx->dst_str;

    else
      tmp_if_expr$18 = "-";
    if(!(ctx->http_host == ((char *)NULL)))
      tmp_if_expr$19 = *ctx->http_host != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$19 = (_Bool)0;
    if(tmp_if_expr$19)
      tmp_if_expr$20 = ctx->http_host;

    else
      tmp_if_expr$20 = "-";
    if(!(ctx->http_method == ((char *)NULL)))
      tmp_if_expr$21 = *ctx->http_method != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$21 = (_Bool)0;
    if(tmp_if_expr$21)
      tmp_if_expr$22 = ctx->http_method;

    else
      tmp_if_expr$22 = "-";
    if(!(ctx->http_uri == ((char *)NULL)))
      tmp_if_expr$23 = *ctx->http_uri != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$23 = (_Bool)0;
    if(tmp_if_expr$23)
      tmp_if_expr$24 = ctx->http_uri;

    else
      tmp_if_expr$24 = "-";
    if(!(ctx->http_status_code == ((char *)NULL)))
      tmp_if_expr$25 = *ctx->http_status_code != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$25 = (_Bool)0;
    if(tmp_if_expr$25)
      tmp_if_expr$26 = ctx->http_status_code;

    else
      tmp_if_expr$26 = "-";
    if(!(ctx->http_content_length == ((char *)NULL)))
      tmp_if_expr$27 = *ctx->http_content_length != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$27 = (_Bool)0;
    if(tmp_if_expr$27)
      tmp_if_expr$28 = ctx->http_content_length;

    else
      tmp_if_expr$28 = "-";
    if(!(ctx->sni == ((char *)NULL)))
      tmp_if_expr$29 = *ctx->sni != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$29 = (_Bool)0;
    if(tmp_if_expr$29)
      tmp_if_expr$30 = ctx->sni;

    else
      tmp_if_expr$30 = "-";
    if(!(ctx->ssl_names == ((char *)NULL)))
      tmp_if_expr$31 = *ctx->ssl_names != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$31 = (_Bool)0;
    if(tmp_if_expr$31)
      tmp_if_expr$32 = ctx->ssl_names;

    else
      tmp_if_expr$32 = "-";
    const char *return_value_SSL_get_version$33;
    return_value_SSL_get_version$33=SSL_get_version(ctx->src.ssl);
    const struct ssl_cipher_st *return_value_SSL_get_current_cipher$34;
    return_value_SSL_get_current_cipher$34=SSL_get_current_cipher(ctx->src.ssl);
    const char *return_value_SSL_CIPHER_get_name$35;
    return_value_SSL_CIPHER_get_name$35=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher$34);
    const char *return_value_SSL_get_version$36;
    return_value_SSL_get_version$36=SSL_get_version(ctx->dst.ssl);
    const struct ssl_cipher_st *return_value_SSL_get_current_cipher$37;
    return_value_SSL_get_current_cipher$37=SSL_get_current_cipher(ctx->dst.ssl);
    const char *return_value_SSL_CIPHER_get_name$38;
    return_value_SSL_CIPHER_get_name$38=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher$37);
    rv=asprintf(&msg, "https %s %s %s %s %s %s %s sni:%s names:%s sproto:%s:%s dproto:%s:%s%s\n", tmp_if_expr$16, tmp_if_expr$18, tmp_if_expr$20, tmp_if_expr$22, tmp_if_expr$24, tmp_if_expr$26, tmp_if_expr$28, tmp_if_expr$30, tmp_if_expr$32, return_value_SSL_get_version$33, return_value_SSL_CIPHER_get_name$35, return_value_SSL_get_version$36, return_value_SSL_CIPHER_get_name$38, ctx->ocsp_denied != 0u ? " ocsp:denied" : "");
  }
  if(msg == ((char *)NULL) || !(rv >= 0))
    ctx->enomem = (unsigned int)1;

  else
  {
    if(ctx->opts->detach == 0u)
      log_err_printf("%s", msg);

    if(!(ctx->opts->connectlog == ((char *)NULL)))
    {
      signed int return_value_logger_print_freebuf$39;
      return_value_logger_print_freebuf$39=logger_print_freebuf(connect_log, (void *)0, (unsigned long int)0, msg);
      if(return_value_logger_print_freebuf$39 == -1)
      {
        free((void *)msg);
        log_err_printf("Warning: Connection logging failed\n");
      }

    }

    else
      free((void *)msg);
  }

out:
  ;
  goto __CPROVER_DUMP_L72;

__CPROVER_DUMP_L72:
  ;
}

// pxy_log_connect_nonhttp
// file pxyconn.c line 336
static void pxy_log_connect_nonhttp(struct pxy_conn_ctx *ctx)
{
  char *msg;
  signed int rv;
  _Bool tmp_if_expr$19;
  if(ctx->spec->ssl == 0u)
    tmp_if_expr$19 = (_Bool)1;

  else
    tmp_if_expr$19 = ctx->passthrough != 0u ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$1;
  char *tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  char *tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  char *tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  char *tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  char *tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  char *tmp_if_expr$12;
  if(tmp_if_expr$19)
  {
    if(!(ctx->src_str == ((char *)NULL)))
      tmp_if_expr$1 = *ctx->src_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = ctx->src_str;

    else
      tmp_if_expr$2 = "-";
    if(!(ctx->dst_str == ((char *)NULL)))
      tmp_if_expr$3 = *ctx->dst_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = ctx->dst_str;

    else
      tmp_if_expr$4 = "-";
    rv=asprintf(&msg, "%s %s %s\n", ctx->passthrough != 0u ? "passthrough" : "tcp", tmp_if_expr$2, tmp_if_expr$4);
  }

  else
  {
    if(!(ctx->src_str == ((char *)NULL)))
      tmp_if_expr$5 = *ctx->src_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = ctx->src_str;

    else
      tmp_if_expr$6 = "-";
    if(!(ctx->dst_str == ((char *)NULL)))
      tmp_if_expr$7 = *ctx->dst_str != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$7 = (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = ctx->dst_str;

    else
      tmp_if_expr$8 = "-";
    if(!(ctx->sni == ((char *)NULL)))
      tmp_if_expr$9 = *ctx->sni != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$9 = (_Bool)0;
    if(tmp_if_expr$9)
      tmp_if_expr$10 = ctx->sni;

    else
      tmp_if_expr$10 = "-";
    if(!(ctx->ssl_names == ((char *)NULL)))
      tmp_if_expr$11 = *ctx->ssl_names != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$11 = (_Bool)0;
    if(tmp_if_expr$11)
      tmp_if_expr$12 = ctx->ssl_names;

    else
      tmp_if_expr$12 = "-";
    const char *return_value_SSL_get_version$13;
    return_value_SSL_get_version$13=SSL_get_version(ctx->src.ssl);
    const struct ssl_cipher_st *return_value_SSL_get_current_cipher$14;
    return_value_SSL_get_current_cipher$14=SSL_get_current_cipher(ctx->src.ssl);
    const char *return_value_SSL_CIPHER_get_name$15;
    return_value_SSL_CIPHER_get_name$15=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher$14);
    const char *return_value_SSL_get_version$16;
    return_value_SSL_get_version$16=SSL_get_version(ctx->dst.ssl);
    const struct ssl_cipher_st *return_value_SSL_get_current_cipher$17;
    return_value_SSL_get_current_cipher$17=SSL_get_current_cipher(ctx->dst.ssl);
    const char *return_value_SSL_CIPHER_get_name$18;
    return_value_SSL_CIPHER_get_name$18=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher$17);
    rv=asprintf(&msg, "ssl %s %s sni:%s names:%s sproto:%s:%s dproto:%s:%s\n", tmp_if_expr$6, tmp_if_expr$8, tmp_if_expr$10, tmp_if_expr$12, return_value_SSL_get_version$13, return_value_SSL_CIPHER_get_name$15, return_value_SSL_get_version$16, return_value_SSL_CIPHER_get_name$18);
  }
  if(msg == ((char *)NULL) || !(rv >= 0))
    ctx->enomem = (unsigned int)1;

  else
  {
    if(ctx->opts->detach == 0u)
      log_err_printf("%s", msg);

    if(!(ctx->opts->connectlog == ((char *)NULL)))
    {
      signed int return_value_logger_print_freebuf$20;
      return_value_logger_print_freebuf$20=logger_print_freebuf(connect_log, (void *)0, (unsigned long int)0, msg);
      if(return_value_logger_print_freebuf$20 == -1)
      {
        free((void *)msg);
        log_err_printf("Warning: Connection logging failed\n");
      }

    }

    else
      free((void *)msg);
  }

out:
  ;
  goto __CPROVER_DUMP_L34;

__CPROVER_DUMP_L34:
  ;
}

// pxy_ocsp_deny
// file pxyconn.c line 1355
static void pxy_ocsp_deny(struct pxy_conn_ctx *ctx)
{
  struct evbuffer *inbuf;
  struct evbuffer *outbuf;
  signed int return_value_pxy_ocsp_is_valid_uri$1;
  signed int return_value_strncasecmp$3;
  signed long int return_value_evbuffer_copyout$7;
  if(!(ctx->http_method == ((char *)NULL)))
  {
    signed int return_value_strncasecmp$2;
    return_value_strncasecmp$2=strncasecmp(ctx->http_method, "GET", (unsigned long int)3);
    if(return_value_strncasecmp$2 == 0)
    {
      return_value_pxy_ocsp_is_valid_uri$1=pxy_ocsp_is_valid_uri(ctx->http_uri, ctx);
      if(!(return_value_pxy_ocsp_is_valid_uri$1 == 0))
        goto deny;

    }

    signed int return_value_strncasecmp$4;
    return_value_strncasecmp$4=strncasecmp(ctx->http_method, "POST", (unsigned long int)4);
    if(return_value_strncasecmp$4 == 0)
    {
      if(!(ctx->http_content_type == ((char *)NULL)))
      {
        return_value_strncasecmp$3=strncasecmp(ctx->http_content_type, "application/ocsp-request", (unsigned long int)24);
        if(return_value_strncasecmp$3 == 0)
          goto deny;

      }

    }

    goto __CPROVER_DUMP_L12;

  deny:
    ;
    inbuf=bufferevent_get_input(ctx->src.bev);
    outbuf=bufferevent_get_output(ctx->src.bev);
    unsigned long int return_value_evbuffer_get_length$9;
    return_value_evbuffer_get_length$9=evbuffer_get_length(inbuf);
    if(return_value_evbuffer_get_length$9 >= 1ul)
    {
      if(!(ctx->opts->contentlog == ((char *)NULL)))
      {
        if(ctx->passthrough == 0u)
        {
          struct logbuf *lb;
          unsigned long int return_value_evbuffer_get_length$5;
          return_value_evbuffer_get_length$5=evbuffer_get_length(inbuf);
          lb=logbuf_new_alloc(return_value_evbuffer_get_length$5, (void *)0, (struct logbuf *)(void *)0);
          if(!(lb == ((struct logbuf *)NULL)))
          {
            return_value_evbuffer_copyout$7=evbuffer_copyout(inbuf, (void *)lb->buf, (unsigned long int)lb->sz);
            if(!(return_value_evbuffer_copyout$7 == -1l))
            {
              signed int return_value_log_content_submit$6;
              return_value_log_content_submit$6=log_content_submit(ctx->logctx, lb, 1);
              if(return_value_log_content_submit$6 == -1)
              {
                logbuf_free(lb);
                log_err_printf("Warning: Content log submission failed\n");
              }

            }

          }

        }

      }

      unsigned long int return_value_evbuffer_get_length$8;
      return_value_evbuffer_get_length$8=evbuffer_get_length(inbuf);
      evbuffer_drain(inbuf, return_value_evbuffer_get_length$8);
    }

    bufferevent_free_and_close_fd(ctx->dst.bev, ctx);
    ctx->dst.closed = (unsigned int)1;
    static const char ocspresp[104l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '0', ' ', '2', '0', '0', ' ', 'O', 'K', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', '/', 'o', 'c', 's', 'p', '-', 'r', 'e', 's', 'p', 'o', 'n', 's', 'e', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'L', 'e', 'n', 'g', 't', 'h', ':', ' ', '5', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', '\r', '\n', '0', 3, '\n', 1, 3, 0 };
    evbuffer_add_printf(outbuf, ocspresp);
    ctx->ocsp_denied = (unsigned int)1;
    if(!(ctx->opts->contentlog == ((char *)NULL)))
    {
      if(ctx->passthrough == 0u)
      {
        struct logbuf *pxy_ocsp_deny$$1$$2$$lb;
        pxy_ocsp_deny$$1$$2$$lb=logbuf_new_copy((const void *)ocspresp, sizeof(const char [104l]) /*104ul*/  - (unsigned long int)1, (void *)0, (struct logbuf *)(void *)0);
        if(!(pxy_ocsp_deny$$1$$2$$lb == ((struct logbuf *)NULL)))
        {
          signed int return_value_log_content_submit$10;
          return_value_log_content_submit$10=log_content_submit(ctx->logctx, pxy_ocsp_deny$$1$$2$$lb, 0);
          if(return_value_log_content_submit$10 == -1)
          {
            logbuf_free(pxy_ocsp_deny$$1$$2$$lb);
            log_err_printf("Warning: Content log submission failed\n");
          }

        }

      }

    }

  }


__CPROVER_DUMP_L12:
  ;
}

// pxy_ocsp_is_valid_uri
// file pxyconn.c line 1299
static signed int pxy_ocsp_is_valid_uri(const char *uri, struct pxy_conn_ctx *ctx)
{
  char *buf_url;
  unsigned long int sz_url;
  char *buf_b64;
  unsigned long int sz_b64;
  unsigned char *buf_asn1;
  unsigned long int sz_asn1;
  signed int ret;
  buf_url=strrchr(uri, 47);
  if(buf_url == ((char *)NULL))
    return 0;

  else
  {
    buf_url = buf_url + 1l;
    if(!((signed int)*buf_url == 77))
    {
      if((signed int)*buf_url == 37)
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      char *return_value_strchr$1;
      return_value_strchr$1=strchr(uri, 63);
      if(!(return_value_strchr$1 == ((char *)NULL)))
        return 0;

      else
      {
        sz_url=strlen(buf_url);
        if(!(sz_url >= 32ul))
          return 0;

        else
        {
          buf_b64=url_dec(buf_url, sz_url, &sz_b64);
          if(buf_b64 == ((char *)NULL))
          {
            ctx->enomem = (unsigned int)1;
            return 0;
          }

          else
          {
            buf_asn1=base64_dec(buf_b64, sz_b64, &sz_asn1);
            if(buf_asn1 == ((unsigned char *)NULL))
            {
              ctx->enomem = (unsigned int)1;
              free((void *)buf_b64);
              return 0;
            }

            else
            {
              ret=ssl_is_ocspreq(buf_asn1, sz_asn1);
              free((void *)buf_asn1);
              free((void *)buf_b64);
              return ret;
            }
          }
        }
      }
    }
  }
}

// pxy_ossl_servername_cb
// file pxyconn.c line 877
static signed int pxy_ossl_servername_cb(struct ssl_st *ssl, signed int *al, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  const char *sn;
  struct x509_st *sslcrt;
  sn=SSL_get_servername(ssl, 0);
  _Bool tmp_if_expr$6;
  signed int return_value_ssl_x509_names_match$5;
  _Bool tmp_if_expr$4;
  if(sn == ((const char *)NULL))
    return 3;

  else
  {
    if(!((signed long int)ctx->opts->debug == 0l))
    {
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(sn, ctx->sni);
      if(!(return_value_strcmp$1 == 0))
        log_err_printf("Warning: SNI parser yielded different hostname than OpenSSL callback for the same ClientHello message: [%s] != [%s]\n", ctx->sni, sn);

    }

    if(ctx->immutable_cert == 0u)
    {
      sslcrt=SSL_get_certificate(ssl);
      return_value_ssl_x509_names_match$5=ssl_x509_names_match(sslcrt, sn);
      tmp_if_expr$6 = !(return_value_ssl_x509_names_match$5 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
    {
      struct x509_st *newcrt;
      struct ssl_ctx_st *newsslctx;
      if(!((signed long int)ctx->opts->debug == 0l))
        log_dbg_printf("Certificate cache: UPDATE (SNI mismatch)\n");

      newcrt=ssl_x509_forge(ctx->opts->cacrt, ctx->opts->cakey, sslcrt, sn, ctx->opts->key);
      if(newcrt == ((struct x509_st *)NULL))
      {
        ctx->enomem = (unsigned int)1;
        return 3;
      }

      void *return_value_cachefkcrt_mkkey$2;
      return_value_cachefkcrt_mkkey$2=cachefkcrt_mkkey(ctx->origcrt);
      void *return_value_cachefkcrt_mkval$3;
      return_value_cachefkcrt_mkval$3=cachefkcrt_mkval(newcrt);
      cache_set(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$2, return_value_cachefkcrt_mkval$3);
      if(!((signed long int)ctx->opts->debug == 0l))
      {
        log_dbg_printf("===> Updated forged server certificate:\n");
        pxy_debug_crt(newcrt);
      }

      if(!(ctx->opts->connectlog == ((char *)NULL)))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        if(!(ctx->ssl_names == ((char *)NULL)))
          free((void *)ctx->ssl_names);

        ctx->ssl_names=ssl_x509_names_to_str(newcrt);
        if(ctx->ssl_names == ((char *)NULL))
          ctx->enomem = (unsigned int)1;

      }

      newsslctx=pxy_srcsslctx_create(ctx, newcrt, ctx->opts->chain, ctx->opts->key);
      if(newsslctx == ((struct ssl_ctx_st *)NULL))
      {
        X509_free(newcrt);
        ctx->enomem = (unsigned int)1;
        return 3;
      }

      SSL_set_SSL_CTX(ssl, newsslctx);
      SSL_CTX_free(newsslctx);
      X509_free(newcrt);
    }

    else
      if(!((signed long int)ctx->opts->debug == 0l))
        log_dbg_printf("Certificate cache: KEEP (SNI match or target mode)\n");

    return 0;
  }
}

// pxy_ossl_sessget_cb
// file pxyconn.c line 580
static struct ssl_session_st * pxy_ossl_sessget_cb(struct ssl_st *ssl, unsigned char *id, signed int idlen, signed int *copy)
{
  struct ssl_session_st *sess;
  *copy = 0;
  void *return_value_cachessess_mkkey$1;
  return_value_cachessess_mkkey$1=cachessess_mkkey(id, (const unsigned long int)idlen);
  void *return_value_cache_get$2;
  return_value_cache_get$2=cache_get(cachemgr_ssess, return_value_cachessess_mkkey$1);
  sess = (struct ssl_session_st *)return_value_cache_get$2;
  log_dbg_printf("SSL session cache: %s\n", sess != ((struct ssl_session_st *)NULL) ? "HIT" : "MISS");
  return sess;
}

// pxy_ossl_sessnew_cb
// file pxyconn.c line 529
static signed int pxy_ossl_sessnew_cb(struct ssl_st *ssl, struct ssl_session_st *sess)
{
  if(!(sess == ((struct ssl_session_st *)NULL)))
  {
    void *return_value_cachessess_mkkey$1;
    return_value_cachessess_mkkey$1=cachessess_mkkey(sess->session_id, (const unsigned long int)sess->session_id_length);
    void *return_value_cachessess_mkval$2;
    return_value_cachessess_mkval$2=cachessess_mkval(sess);
    cache_set(cachemgr_ssess, return_value_cachessess_mkkey$1, return_value_cachessess_mkval$2);
  }

  return 0;
}

// pxy_ossl_sessremove_cb
// file pxyconn.c line 561
static void pxy_ossl_sessremove_cb(struct ssl_ctx_st *sslctx, struct ssl_session_st *sess)
{
  if(!(sess == ((struct ssl_session_st *)NULL)))
  {
    void *return_value_cachessess_mkkey$1;
    return_value_cachessess_mkkey$1=cachessess_mkkey(sess->session_id, (const unsigned long int)sess->session_id_length);
    cache_del(cachemgr_ssess, return_value_cachessess_mkkey$1);
  }

}

// pxy_sni_resolve_cb
// file pxyconn.c line 1999
static void pxy_sni_resolve_cb(signed int errcode, struct addrinfo *ai, void *arg)
{
  struct pxy_conn_ctx *ctx = (struct pxy_conn_ctx *)arg;
  if(!(errcode == 0))
  {
    const char *return_value_evutil_gai_strerror$1;
    return_value_evutil_gai_strerror$1=evutil_gai_strerror(errcode);
    log_err_printf("Cannot resolve SNI hostname '%s': %s\n", ctx->sni, return_value_evutil_gai_strerror$1);
    evutil_closesocket(ctx->fd);
    pxy_conn_ctx_free(ctx);
    goto __CPROVER_DUMP_L2;
  }

  memcpy((void *)&ctx->addr, (const void *)ai->ai_addr, (unsigned long int)ai->ai_addrlen);
  ctx->addrlen = ai->ai_addrlen;
  evutil_freeaddrinfo(ai);
  pxy_conn_connect(ctx);

__CPROVER_DUMP_L2:
  ;
}

// pxy_srccert_create
// file pxyconn.c line 728
static struct cert * pxy_srccert_create(struct pxy_conn_ctx *ctx)
{
  struct cert *cert = (struct cert *)(void *)0;
  if(!(ctx->opts->tgcrtdir == ((char *)NULL)))
  {
    if(!(ctx->sni == ((char *)NULL)))
    {
      void *return_value_cachetgcrt_mkkey$1;
      return_value_cachetgcrt_mkkey$1=cachetgcrt_mkkey(ctx->sni);
      void *return_value_cache_get$2;
      return_value_cache_get$2=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$1);
      cert = (struct cert *)return_value_cache_get$2;
      if(cert == ((struct cert *)NULL))
      {
        char *wildcarded;
        wildcarded=ssl_wildcardify(ctx->sni);
        if(wildcarded == ((char *)NULL))
        {
          ctx->enomem = (unsigned int)1;
          return (struct cert *)(void *)0;
        }

        void *return_value_cachetgcrt_mkkey$3;
        return_value_cachetgcrt_mkkey$3=cachetgcrt_mkkey(wildcarded);
        void *return_value_cache_get$4;
        return_value_cache_get$4=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$3);
        cert = (struct cert *)return_value_cache_get$4;
        free((void *)wildcarded);
      }

      if(!(cert == ((struct cert *)NULL)))
      {
        if(!((signed long int)ctx->opts->debug == 0l))
          log_dbg_printf("Target cert by SNI\n");

      }

    }

    else
      if(!(ctx->origcrt == ((struct x509_st *)NULL)))
      {
        char **names;
        names=ssl_x509_names(ctx->origcrt);
        char **p = names;
        for( ; !(*p == ((char *)NULL)); p = p + 1l)
        {
          if(cert == ((struct cert *)NULL))
          {
            void *return_value_cachetgcrt_mkkey$5;
            return_value_cachetgcrt_mkkey$5=cachetgcrt_mkkey(*p);
            void *return_value_cache_get$6;
            return_value_cache_get$6=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$5);
            cert = (struct cert *)return_value_cache_get$6;
          }

          if(cert == ((struct cert *)NULL))
          {
            char *pxy_srccert_create$$1$$1$$2$$1$$1$$2$$wildcarded;
            pxy_srccert_create$$1$$1$$2$$1$$1$$2$$wildcarded=ssl_wildcardify(*p);
            if(pxy_srccert_create$$1$$1$$2$$1$$1$$2$$wildcarded == ((char *)NULL))
              ctx->enomem = (unsigned int)1;

            else
            {
              void *return_value_cachetgcrt_mkkey$7;
              return_value_cachetgcrt_mkkey$7=cachetgcrt_mkkey(pxy_srccert_create$$1$$1$$2$$1$$1$$2$$wildcarded);
              void *return_value_cache_get$8;
              return_value_cache_get$8=cache_get(cachemgr_tgcrt, return_value_cachetgcrt_mkkey$7);
              cert = (struct cert *)return_value_cache_get$8;
              free((void *)pxy_srccert_create$$1$$1$$2$$1$$1$$2$$wildcarded);
            }
          }

          free((void *)*p);
        }
        free((void *)names);
        if(!(ctx->enomem == 0u))
          return (struct cert *)(void *)0;

        if(!(cert == ((struct cert *)NULL)))
        {
          if(!((signed long int)ctx->opts->debug == 0l))
            log_dbg_printf("Target cert by origcrt\n");

        }

      }

    if(!(cert == ((struct cert *)NULL)))
      ctx->immutable_cert = (unsigned int)1;

  }

  if(cert == ((struct cert *)NULL))
  {
    if(!(ctx->origcrt == ((struct x509_st *)NULL)))
    {
      if(!(ctx->opts->key == ((struct evp_pkey_st *)NULL)))
      {
        cert=cert_new();
        void *return_value_cachefkcrt_mkkey$9;
        return_value_cachefkcrt_mkkey$9=cachefkcrt_mkkey(ctx->origcrt);
        void *return_value_cache_get$10;
        return_value_cache_get$10=cache_get(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$9);
        cert->crt = (struct x509_st *)return_value_cache_get$10;
        if(!(cert->crt == ((struct x509_st *)NULL)))
        {
          if(!((signed long int)ctx->opts->debug == 0l))
            log_dbg_printf("Certificate cache: HIT\n");

        }

        else
        {
          if(!((signed long int)ctx->opts->debug == 0l))
            log_dbg_printf("Certificate cache: MISS\n");

          cert->crt=ssl_x509_forge(ctx->opts->cacrt, ctx->opts->cakey, ctx->origcrt, (const char *)(void *)0, ctx->opts->key);
          void *return_value_cachefkcrt_mkkey$11;
          return_value_cachefkcrt_mkkey$11=cachefkcrt_mkkey(ctx->origcrt);
          void *return_value_cachefkcrt_mkval$12;
          return_value_cachefkcrt_mkval$12=cachefkcrt_mkval(cert->crt);
          cache_set(cachemgr_fkcrt, return_value_cachefkcrt_mkkey$11, return_value_cachefkcrt_mkval$12);
        }
        cert_set_key(cert, ctx->opts->key);
        cert_set_chain(cert, ctx->opts->chain);
      }

    }

  }

  return cert;
}

// pxy_srcssl_create
// file pxyconn.c line 810
static struct ssl_st * pxy_srcssl_create(struct pxy_conn_ctx *ctx, struct ssl_st *origssl)
{
  struct cert *cert;
  void *return_value_cachedsess_mkkey$1;
  return_value_cachedsess_mkkey$1=cachedsess_mkkey((struct sockaddr *)&ctx->addr, ctx->addrlen, ctx->sni);
  struct ssl_session_st *return_value_SSL_get_session$2;
  return_value_SSL_get_session$2=SSL_get_session(origssl);
  void *return_value_cachedsess_mkval$3;
  return_value_cachedsess_mkval$3=cachedsess_mkval(return_value_SSL_get_session$2);
  cache_set(cachemgr_dsess, return_value_cachedsess_mkkey$1, return_value_cachedsess_mkval$3);
  ctx->origcrt=SSL_get_peer_certificate(origssl);
  if(!((signed long int)ctx->opts->debug == 0l))
  {
    if(!(ctx->origcrt == ((struct x509_st *)NULL)))
    {
      log_dbg_printf("===> Original server certificate:\n");
      pxy_debug_crt(ctx->origcrt);
    }

    else
      log_dbg_printf("===> Original server has no cert!\n");
  }

  cert=pxy_srccert_create(ctx);
  _Bool tmp_if_expr$5;
  struct x509_st *tmp_if_expr$4;
  if(cert == ((struct cert *)NULL))
    return (struct ssl_st *)(void *)0;

  else
  {
    if(!((signed long int)ctx->opts->debug == 0l))
    {
      log_dbg_printf("===> Forged server certificate:\n");
      pxy_debug_crt(cert->crt);
    }

    if(!(ctx->opts->connectlog == ((char *)NULL)))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(ctx->opts->detach != 0u) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
    {
      if(!(ctx->origcrt == ((struct x509_st *)NULL)))
        tmp_if_expr$4 = ctx->origcrt;

      else
        tmp_if_expr$4 = cert->crt;
      ctx->ssl_names=ssl_x509_names_to_str(tmp_if_expr$4);
      if(ctx->ssl_names == ((char *)NULL))
        ctx->enomem = (unsigned int)1;

    }

    struct ssl_ctx_st *sslctx;
    sslctx=pxy_srcsslctx_create(ctx, cert->crt, cert->chain, cert->key);
    cert_free(cert);
    if(sslctx == ((struct ssl_ctx_st *)NULL))
    {
      ctx->enomem = (unsigned int)1;
      return (struct ssl_st *)(void *)0;
    }

    else
    {
      struct ssl_st *ssl;
      ssl=SSL_new(sslctx);
      SSL_CTX_free(sslctx);
      if(ssl == ((struct ssl_st *)NULL))
      {
        ctx->enomem = (unsigned int)1;
        return (struct ssl_st *)(void *)0;
      }

      else
      {
        signed long int return_value_SSL_ctrl$6;
        return_value_SSL_ctrl$6=SSL_ctrl(ssl, 33, (signed long int)0, (void *)0);
        SSL_ctrl(ssl, 33, return_value_SSL_ctrl$6 | 0x00000010L, (void *)0);
        return ssl;
      }
    }
  }
}

// pxy_srcsslctx_create
// file pxyconn.c line 606
static struct ssl_ctx_st * pxy_srcsslctx_create(struct pxy_conn_ctx *ctx, struct x509_st *crt, struct stack_st_X509 *chain, struct evp_pkey_st *key)
{
  struct ssl_ctx_st *sslctx;
  const struct ssl_method_st *return_value;
  return_value=ctx->opts->sslmethod();
  sslctx=SSL_CTX_new(return_value);
  signed int return_value_EVP_PKEY_type$1;
  signed int return_value_EVP_PKEY_type$2;
  if(sslctx == ((struct ssl_ctx_st *)NULL))
    return (struct ssl_ctx_st *)(void *)0;

  else
  {
    SSL_CTX_ctrl(sslctx, 32, 0x80000BFFL, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00800000L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00040000L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00000800L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00004000L, (void *)0);
    SSL_CTX_ctrl(sslctx, 32, 0x00010000L, (void *)0);
    if(ctx->opts->sslcomp == 0u)
      SSL_CTX_ctrl(sslctx, 32, 0x00020000L, (void *)0);

    SSL_CTX_ctrl(sslctx, 32, 0x01000000L, (void *)0);
    if(!(ctx->opts->no_ssl3 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x02000000L, (void *)0);

    if(!(ctx->opts->no_tls10 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x04000000L, (void *)0);

    if(!(ctx->opts->no_tls11 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x10000000L, (void *)0);

    if(!(ctx->opts->no_tls12 == 0u))
      SSL_CTX_ctrl(sslctx, 32, 0x08000000L, (void *)0);

    SSL_CTX_set_cipher_list(sslctx, ctx->opts->ciphers);
    SSL_CTX_sess_set_new_cb(sslctx, pxy_ossl_sessnew_cb);
    SSL_CTX_sess_set_remove_cb(sslctx, pxy_ossl_sessremove_cb);
    SSL_CTX_sess_set_get_cb(sslctx, pxy_ossl_sessget_cb);
    SSL_CTX_ctrl(sslctx, 44, (signed long int)(0x0002 | 0x0100 | 0x0200), (void *)0);
    SSL_CTX_callback_ctrl(sslctx, 53, (void (*)(void))pxy_ossl_servername_cb);
    SSL_CTX_ctrl(sslctx, 54, (signed long int)0, (void *)ctx);
    if(!(ctx->opts->dh == ((struct dh_st *)NULL)))
      SSL_CTX_ctrl(sslctx, 3, (signed long int)0, (void *)(char *)ctx->opts->dh);

    else
    {
      return_value_EVP_PKEY_type$1=EVP_PKEY_type(key->type);
      if(!(return_value_EVP_PKEY_type$1 == 6))
        SSL_CTX_set_tmp_dh_callback(sslctx, ssl_tmp_dh_callback);

    }
    if(!(ctx->opts->ecdhcurve == ((char *)NULL)))
    {
      struct ec_key_st *ecdh;
      ecdh=ssl_ec_by_name(ctx->opts->ecdhcurve);
      SSL_CTX_ctrl(sslctx, 4, (signed long int)0, (void *)(char *)ecdh);
      EC_KEY_free(ecdh);
    }

    else
    {
      return_value_EVP_PKEY_type$2=EVP_PKEY_type(key->type);
      if(!(return_value_EVP_PKEY_type$2 == 6))
      {
        struct ec_key_st *pxy_srcsslctx_create$$1$$9$$ecdh;
        pxy_srcsslctx_create$$1$$9$$ecdh=ssl_ec_by_name((const char *)(void *)0);
        SSL_CTX_ctrl(sslctx, 4, (signed long int)0, (void *)(char *)pxy_srcsslctx_create$$1$$9$$ecdh);
        EC_KEY_free(pxy_srcsslctx_create$$1$$9$$ecdh);
      }

    }
    SSL_CTX_use_certificate(sslctx, crt);
    SSL_CTX_use_PrivateKey(sslctx, key);
    signed int i = 0;
    signed int return_value_sk_num$3;
    return_value_sk_num$3=sk_num((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0));
    if(!(i >= return_value_sk_num$3))
    {
      struct x509_st *c;
      void *return_value_sk_value$4;
      return_value_sk_value$4=sk_value((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0), i);
      c = (struct x509_st *)return_value_sk_value$4;
      ssl_x509_refcount_inc(c);
      SSL_CTX_ctrl(sslctx, 14, (signed long int)0, (void *)(char *)c);
      i = i + 1;
    }

    return sslctx;
  }
}

// pxy_ssl_shutdown
// file pxysslshut.c line 168
void pxy_ssl_shutdown(struct opts *opts, struct event_base *evbase, struct ssl_st *ssl, signed int fd)
{
  struct pxy_ssl_shutdown_ctx *sslshutctx;
  sslshutctx=pxy_ssl_shutdown_ctx_new(opts, evbase, ssl);
  if(sslshutctx == ((struct pxy_ssl_shutdown_ctx *)NULL))
  {
    if(!((signed long int)opts->debug == 0l))
    {
      log_dbg_printf("SSL_free() in state ");
      char *return_value_ssl_ssl_state_to_str$1;
      return_value_ssl_ssl_state_to_str$1=ssl_ssl_state_to_str(ssl);
      log_dbg_print_free(return_value_ssl_ssl_state_to_str$1);
      log_dbg_printf("\n");
    }

    SSL_free(ssl);
    evutil_closesocket(fd);
  }

  else
    pxy_ssl_shutdown_cb(fd, (signed short int)0, (void *)sslshutctx);
}

// pxy_ssl_shutdown_cb
// file pxysslshut.c line 90
static void pxy_ssl_shutdown_cb(signed int fd, signed short int what, void *arg)
{
  struct pxy_ssl_shutdown_ctx *ctx = (struct pxy_ssl_shutdown_ctx *)arg;
  struct timeval retry_delay = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)100 };
  signed short int want = (signed short int)0;
  signed int rv;
  signed int sslerr;
  if(!(ctx->ev == ((struct event *)NULL)))
  {
    event_free(ctx->ev);
    ctx->ev = (struct event *)(void *)0;
  }

  rv=SSL_shutdown(ctx->ssl);
  unsigned int tmp_post$1;
  if(!(rv == 1))
  {
    if(rv == -1)
    {
      sslerr=SSL_get_error(ctx->ssl, rv);
      switch(sslerr)
      {
        case 2:
        {
          want = (signed short int)0x02;
          break;
        }
        case 3:
        {
          want = (signed short int)0x04;
          break;
        }
        case 6:
          break;
        case 5:

        case 1:
          goto complete;
        default:
        {
          log_err_printf("Unhandled SSL_shutdown() error %i.  Closing fd.\n", sslerr);
          goto complete;
        }
      }
    }

    else
    {

    retry:
      ;
      tmp_post$1 = ctx->retries;
      ctx->retries = ctx->retries + 1u;
      if(tmp_post$1 >= 50u)
        log_err_printf("Failed to shutdown SSL connection cleanly: Max retries reached. Closing fd.\n");

      else
      {
        ctx->ev=event_new(ctx->evbase, fd, want, pxy_ssl_shutdown_cb, (void *)ctx);
        if(!(ctx->ev == ((struct event *)NULL)))
        {
          event_add(ctx->ev, want != 0 ? (struct timeval *)(void *)0 : &retry_delay);
          goto __CPROVER_DUMP_L12;
        }

        log_err_printf("Failed to shutdown SSL connection cleanly: Cannot create event. Closing fd.\n");
      }
    }
  }


complete:
  ;
  if(!((signed long int)ctx->opts->debug == 0l))
  {
    log_dbg_printf("SSL_free() in state ");
    char *return_value_ssl_ssl_state_to_str$2;
    return_value_ssl_ssl_state_to_str$2=ssl_ssl_state_to_str(ctx->ssl);
    log_dbg_print_free(return_value_ssl_ssl_state_to_str$2);
    log_dbg_printf("\n");
  }

  SSL_free(ctx->ssl);
  evutil_closesocket(fd);
  pxy_ssl_shutdown_ctx_free(ctx);

__CPROVER_DUMP_L12:
  ;
}

// pxy_ssl_shutdown_ctx_free
// file pxysslshut.c line 78
static void pxy_ssl_shutdown_ctx_free(struct pxy_ssl_shutdown_ctx *ctx)
{
  free((void *)ctx);
}

// pxy_ssl_shutdown_ctx_new
// file pxysslshut.c line 62
static struct pxy_ssl_shutdown_ctx * pxy_ssl_shutdown_ctx_new(struct opts *opts, struct event_base *evbase, struct ssl_st *ssl)
{
  struct pxy_ssl_shutdown_ctx *ctx;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct pxy_ssl_shutdown_ctx) /*40ul*/ );
  ctx = (struct pxy_ssl_shutdown_ctx *)return_value_malloc$1;
  if(ctx == ((struct pxy_ssl_shutdown_ctx *)NULL))
    return (struct pxy_ssl_shutdown_ctx *)(void *)0;

  else
  {
    ctx->opts = opts;
    ctx->evbase = evbase;
    ctx->ssl = ssl;
    ctx->ev = (struct event *)(void *)0;
    ctx->retries = (unsigned int)0;
    return ctx;
  }
}

// pxy_thrmgr_attach
// file pxythrmgr.h line 47
signed int pxy_thrmgr_attach(struct pxy_thrmgr_ctx *ctx, struct event_base **evbase, struct evdns_base **dnsbase)
{
  signed int thridx;
  unsigned long int minload;
  thridx = 0;
  pthread_mutex_lock(&ctx->mutex);
  minload = ctx->thr[(signed long int)thridx]->load;
  signed int idx = 1;
  for( ; !(idx >= ctx->num_thr); idx = idx + 1)
    if(!(ctx->thr[(signed long int)idx]->load >= minload))
    {
      minload = ctx->thr[(signed long int)idx]->load;
      thridx = idx;
    }

  *evbase = ctx->thr[(signed long int)thridx]->evbase;
  *dnsbase = ctx->thr[(signed long int)thridx]->dnsbase;
  ctx->thr[(signed long int)thridx]->load = ctx->thr[(signed long int)thridx]->load + 1ul;
  pthread_mutex_unlock(&ctx->mutex);
  return thridx;
}

// pxy_thrmgr_detach
// file pxythrmgr.h line 49
void pxy_thrmgr_detach(struct pxy_thrmgr_ctx *ctx, signed int thridx)
{
  pthread_mutex_lock(&ctx->mutex);
  ctx->thr[(signed long int)thridx]->load = ctx->thr[(signed long int)thridx]->load - 1ul;
  pthread_mutex_unlock(&ctx->mutex);
}

// pxy_thrmgr_free
// file pxythrmgr.h line 45
void pxy_thrmgr_free(struct pxy_thrmgr_ctx *ctx)
{
  if(!(ctx == ((struct pxy_thrmgr_ctx *)NULL)))
  {
    pthread_mutex_destroy(&ctx->mutex);
    if(!(ctx->thr == ((struct pxy_thr_ctx **)NULL)))
    {
      signed int pxy_thrmgr_free$$1$$1$$1$$idx = 0;
      for( ; !(pxy_thrmgr_free$$1$$1$$1$$idx >= ctx->num_thr); pxy_thrmgr_free$$1$$1$$1$$idx = pxy_thrmgr_free$$1$$1$$1$$idx + 1)
      {
        event_base_loopbreak(ctx->thr[(signed long int)pxy_thrmgr_free$$1$$1$$1$$idx]->evbase);
        sched_yield();
      }
      signed int pxy_thrmgr_free$$1$$1$$2$$idx = 0;
      for( ; !(pxy_thrmgr_free$$1$$1$$2$$idx >= ctx->num_thr); pxy_thrmgr_free$$1$$1$$2$$idx = pxy_thrmgr_free$$1$$1$$2$$idx + 1)
        pthread_join(ctx->thr[(signed long int)pxy_thrmgr_free$$1$$1$$2$$idx]->thr, (void **)(void *)0);
      signed int idx = 0;
      for( ; !(idx >= ctx->num_thr); idx = idx + 1)
      {
        evdns_base_free(ctx->thr[(signed long int)idx]->dnsbase, 0);
        event_base_free(ctx->thr[(signed long int)idx]->evbase);
        free((void *)ctx->thr[(signed long int)idx]);
      }
      free((void *)ctx->thr);
    }

    free((void *)ctx);
  }

}

// pxy_thrmgr_new
// file pxythrmgr.h line 43
struct pxy_thrmgr_ctx * pxy_thrmgr_new(struct opts *opts)
{
  struct pxy_thrmgr_ctx *ctx;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct pxy_thrmgr_ctx) /*56ul*/ );
  ctx = (struct pxy_thrmgr_ctx *)return_value_malloc$1;
  if(ctx == ((struct pxy_thrmgr_ctx *)NULL))
    return (struct pxy_thrmgr_ctx *)(void *)0;

  else
  {
    memset((void *)ctx, 0, sizeof(struct pxy_thrmgr_ctx) /*56ul*/ );
    unsigned int return_value_sys_get_cpu_cores$2;
    return_value_sys_get_cpu_cores$2=sys_get_cpu_cores();
    ctx->num_thr = (signed int)((unsigned int)2 * return_value_sys_get_cpu_cores$2);
    return ctx;
  }
}

// pxy_thrmgr_run
// file pxythrmgr.h line 44
signed int pxy_thrmgr_run(struct pxy_thrmgr_ctx *ctx)
{
  signed int idx = -1;
  if(ctx == ((struct pxy_thrmgr_ctx *)NULL))
    return -1;

  else
  {
    pthread_mutex_init(&ctx->mutex, (const union anonymous$15 *)(void *)0);
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)ctx->num_thr * sizeof(struct pxy_thr_ctx *) /*8ul*/ );
    ctx->thr = (struct pxy_thr_ctx **)return_value_malloc$1;
    if(ctx->thr == ((struct pxy_thr_ctx **)NULL))
      log_dbg_printf("Failed to allocate memory\n");

    else
    {
      memset((void *)ctx->thr, 0, (unsigned long int)ctx->num_thr * sizeof(struct pxy_thr_ctx *) /*8ul*/ );
      idx = 0;
      for( ; !(idx >= ctx->num_thr); idx = idx + 1)
      {
        void *return_value_malloc$2;
        return_value_malloc$2=malloc(sizeof(struct pxy_thr_ctx) /*40ul*/ );
        ctx->thr[(signed long int)idx] = (struct pxy_thr_ctx *)return_value_malloc$2;
        if(ctx->thr[(signed long int)idx] == ((struct pxy_thr_ctx *)NULL))
        {
          log_dbg_printf("Failed to allocate memory\n");
          goto leave;
        }

        memset((void *)ctx->thr[(signed long int)idx], 0, sizeof(struct pxy_thr_ctx) /*40ul*/ );
        ctx->thr[(signed long int)idx]->evbase=event_base_new();
        if(ctx->thr[(signed long int)idx]->evbase == ((struct event_base *)NULL))
        {
          log_dbg_printf("Failed to create evbase %d\n", idx);
          goto leave;
        }

        ctx->thr[(signed long int)idx]->dnsbase=evdns_base_new(ctx->thr[(signed long int)idx]->evbase, 1);
        if(ctx->thr[(signed long int)idx]->dnsbase == ((struct evdns_base *)NULL))
        {
          log_dbg_printf("Failed to create dnsbase %d\n", idx);
          goto leave;
        }

        ctx->thr[(signed long int)idx]->load = (unsigned long int)0;
        ctx->thr[(signed long int)idx]->running = 0;
      }
      log_dbg_printf("Initialized %d connection handling threads\n", ctx->num_thr);
      idx = 0;
      for( ; !(idx >= ctx->num_thr); idx = idx + 1)
      {
        signed int return_value_pthread_create$3;
        return_value_pthread_create$3=pthread_create(&ctx->thr[(signed long int)idx]->thr, (const union pthread_attr_t *)(void *)0, pxy_thrmgr_thr, (void *)ctx->thr[(signed long int)idx]);
        if(!(return_value_pthread_create$3 == 0))
          goto leave_thr;

        while(ctx->thr[(signed long int)idx]->running == 0)
          sched_yield();
      }
      log_dbg_printf("Started %d connection handling threads\n", ctx->num_thr);
      return 0;

    leave_thr:
      ;
      idx = idx - 1;
      for( ; idx >= 0; idx = idx - 1)
      {
        pthread_cancel(ctx->thr[(signed long int)idx]->thr);
        pthread_join(ctx->thr[(signed long int)idx]->thr, (void **)(void *)0);
      }
      idx = ctx->num_thr - 1;
    }

  leave:
    ;
    for( ; idx >= 0; idx = idx - 1)
      if(!(ctx->thr[(signed long int)idx] == ((struct pxy_thr_ctx *)NULL)))
      {
        if(!(ctx->thr[(signed long int)idx]->dnsbase == ((struct evdns_base *)NULL)))
          evdns_base_free(ctx->thr[(signed long int)idx]->dnsbase, 0);

        if(!(ctx->thr[(signed long int)idx]->evbase == ((struct event_base *)NULL)))
          event_base_free(ctx->thr[(signed long int)idx]->evbase);

        free((void *)ctx->thr[(signed long int)idx]);
      }

    pthread_mutex_destroy(&ctx->mutex);
    if(!(ctx->thr == ((struct pxy_thr_ctx **)NULL)))
    {
      free((void *)ctx->thr);
      ctx->thr = (struct pxy_thr_ctx **)(void *)0;
    }

    return -1;
  }
}

// pxy_thrmgr_thr
// file pxythrmgr.c line 76
static void * pxy_thrmgr_thr(void *arg)
{
  struct pxy_thr_ctx *ctx = (struct pxy_thr_ctx *)arg;
  struct timeval timer_delay = { .tv_sec=(signed long int)60, .tv_usec=(signed long int)0 };
  struct event *ev;
  ev=event_new(ctx->evbase, -1, (signed short int)0x10, pxy_thrmgr_timer_cb, (void *)0);
  if(ev == ((struct event *)NULL))
    return (void *)0;

  else
  {
    event_add(ev, &timer_delay);
    ctx->running = 1;
    event_base_dispatch(ctx->evbase);
    event_free(ev);
    return (void *)0;
  }
}

// pxy_thrmgr_timer_cb
// file pxythrmgr.c line 65
static void pxy_thrmgr_timer_cb(signed int fd, signed short int what, void *arg)
{
  ;
}

// pxythrmgr_libevent_01
// file pxythrmgr.t.c line 35
static void pxythrmgr_libevent_01(signed int _i)
{
  tcase_fn_start("pxythrmgr_libevent_01", "pxythrmgr.t.c", 35);
  struct event_base *evbase;
  evbase=event_base_new();
  if(!(evbase == ((struct event_base *)NULL)))
    _mark_point("pxythrmgr.t.c", 40);

  else
    _ck_assert_failed("pxythrmgr.t.c", 40, "Assertion '!!evbase' failed", (const void *)"no event base", (void *)0);
  event_base_free(evbase);
}

// pxythrmgr_libevent_02
// file pxythrmgr.t.c line 45
static void pxythrmgr_libevent_02(signed int _i)
{
  tcase_fn_start("pxythrmgr_libevent_02", "pxythrmgr.t.c", 45);
  struct event_base *evbase;
  struct evdns_base *dnsbase;
  evbase=event_base_new();
  if(!(evbase == ((struct event_base *)NULL)))
    _mark_point("pxythrmgr.t.c", 51);

  else
    _ck_assert_failed("pxythrmgr.t.c", 51, "Assertion '!!evbase' failed", (const void *)"no event base", (void *)0);
  dnsbase=evdns_base_new(evbase, 0);
  if(!(dnsbase == ((struct evdns_base *)NULL)))
    _mark_point("pxythrmgr.t.c", 53);

  else
    _ck_assert_failed("pxythrmgr.t.c", 53, "Assertion '!!dnsbase' failed", (const void *)"no evdns base", (void *)0);
  evdns_base_free(dnsbase, 0);
  event_base_free(evbase);
}

// pxythrmgr_libevent_03
// file pxythrmgr.t.c line 59
static void pxythrmgr_libevent_03(signed int _i)
{
  tcase_fn_start("pxythrmgr_libevent_03", "pxythrmgr.t.c", 59);
  struct event_base *evbase;
  struct evdns_base *dnsbase;
  signed int rc;
  evbase=event_base_new();
  if(!(evbase == ((struct event_base *)NULL)))
    _mark_point("pxythrmgr.t.c", 66);

  else
    _ck_assert_failed("pxythrmgr.t.c", 66, "Assertion '!!evbase' failed", (const void *)"no event base", (void *)0);
  dnsbase=evdns_base_new(evbase, 0);
  if(!(dnsbase == ((struct evdns_base *)NULL)))
    _mark_point("pxythrmgr.t.c", 68);

  else
    _ck_assert_failed("pxythrmgr.t.c", 68, "Assertion '!!dnsbase' failed", (const void *)"no evdns base", (void *)0);
  rc=evdns_base_resolv_conf_parse(dnsbase, 15, "/etc/resolv.conf");
  if(rc == 0)
    _mark_point("pxythrmgr.t.c", 71);

  else
    _ck_assert_failed("pxythrmgr.t.c", 71, "Assertion 'rc == 0' failed", (const void *)"unable to parse resolv.conf", (void *)0);
  evdns_base_free(dnsbase, 0);
  event_base_free(evbase);
}

// pxythrmgr_libevent_04
// file pxythrmgr.t.c line 77
static void pxythrmgr_libevent_04(signed int _i)
{
  tcase_fn_start("pxythrmgr_libevent_04", "pxythrmgr.t.c", 77);
  struct event_base *evbase;
  struct evdns_base *dnsbase;
  evbase=event_base_new();
  if(!(evbase == ((struct event_base *)NULL)))
    _mark_point("pxythrmgr.t.c", 83);

  else
    _ck_assert_failed("pxythrmgr.t.c", 83, "Assertion '!!evbase' failed", (const void *)"no event base", (void *)0);
  dnsbase=evdns_base_new(evbase, 1);
  if(!(dnsbase == ((struct evdns_base *)NULL)))
    _mark_point("pxythrmgr.t.c", 85);

  else
    _ck_assert_failed("pxythrmgr.t.c", 85, "Assertion '!!dnsbase' failed", (const void *)"no evdns base", (void *)0);
  evdns_base_free(dnsbase, 0);
  event_base_free(evbase);
}

// pxythrmgr_libevent_05
// file pxythrmgr.t.c line 91
static void pxythrmgr_libevent_05(signed int _i)
{
  tcase_fn_start("pxythrmgr_libevent_05", "pxythrmgr.t.c", 91);
  struct event_base *evbase1;
  struct event_base *evbase2;
  struct evdns_base *dnsbase;
  evbase1=event_base_new();
  if(!(evbase1 == ((struct event_base *)NULL)))
    _mark_point("pxythrmgr.t.c", 99);

  else
    _ck_assert_failed("pxythrmgr.t.c", 99, "Assertion '!!evbase1' failed", (const void *)"no event base 1", (void *)0);
  evbase2=event_base_new();
  if(!(evbase1 == ((struct event_base *)NULL)))
    _mark_point("pxythrmgr.t.c", 101);

  else
    _ck_assert_failed("pxythrmgr.t.c", 101, "Assertion '!!evbase1' failed", (const void *)"no event base 2", (void *)0);
  dnsbase=evdns_base_new(evbase2, 1);
  if(!(dnsbase == ((struct evdns_base *)NULL)))
    _mark_point("pxythrmgr.t.c", 103);

  else
    _ck_assert_failed("pxythrmgr.t.c", 103, "Assertion '!!dnsbase' failed", (const void *)"no evdns base", (void *)0);
  evdns_base_free(dnsbase, 0);
  event_base_free(evbase2);
  event_base_free(evbase1);
}

// pxythrmgr_suite
// file pxythrmgr.t.c line 111
struct Suite * pxythrmgr_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("pxythrmgr");
  tc=tcase_create("pxythrmgr_libevent");
  _tcase_add_test(tc, pxythrmgr_libevent_01, "pxythrmgr_libevent_01", 0, 0, 0, 1);
  _tcase_add_test(tc, pxythrmgr_libevent_02, "pxythrmgr_libevent_02", 0, 0, 0, 1);
  _tcase_add_test(tc, pxythrmgr_libevent_03, "pxythrmgr_libevent_03", 0, 0, 0, 1);
  _tcase_add_test(tc, pxythrmgr_libevent_04, "pxythrmgr_libevent_04", 0, 0, 0, 1);
  _tcase_add_test(tc, pxythrmgr_libevent_05, "pxythrmgr_libevent_05", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// ssl_dh_load
// file ssl.c line 584
struct dh_st * ssl_dh_load(const char *filename)
{
  struct dh_st *dh;
  struct _IO_FILE *fh;
  signed int return_value_ssl_init$1;
  return_value_ssl_init$1=ssl_init();
  if(return_value_ssl_init$1 == -1)
    return (struct dh_st *)(void *)0;

  else
  {
    fh=fopen(filename, "r");
    if(fh == ((struct _IO_FILE *)NULL))
      return (struct dh_st *)(void *)0;

    else
    {
      dh=PEM_read_DHparams(fh, (struct dh_st **)(void *)0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
      fclose(fh);
      return dh;
    }
  }
}

// ssl_dh_refcount_inc
// file ssl.c line 1096
void ssl_dh_refcount_inc(struct dh_st *dh)
{
  CRYPTO_add_lock(&dh->references, 1, 26, "ssl.c", 1099);
}

// ssl_dnsname_match
// file ssl.h line 167
signed int ssl_dnsname_match(const char *certname, unsigned long int certnamesz, const char *hostname, unsigned long int hostnamesz)
{
  signed int return_value_memcmp$1;
  void *return_value_memchr$3;
  signed int return_value_memcmp$5;
  void *return_value_memchr$4;
  if(!(hostnamesz >= certnamesz))
    return 0;

  else
    if(hostnamesz == certnamesz)
    {
      return_value_memcmp$1=memcmp((const void *)certname, (const void *)hostname, certnamesz);
      if(!(return_value_memcmp$1 == 0))
        goto __CPROVER_DUMP_L2;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed int return_value_memcmp$2;
      return_value_memcmp$2=memcmp((const void *)certname, (const void *)"xn--", (unsigned long int)4);
      if(return_value_memcmp$2 == 0)
        return 0;

      else
        if(certnamesz == 1ul)
        {
          if(!((signed int)*certname == 42))
            goto __CPROVER_DUMP_L4;

          return_value_memchr$3=memchr((const void *)hostname, 46, hostnamesz);
          if(!(return_value_memchr$3 == NULL))
            goto __CPROVER_DUMP_L4;

          return 1;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(certnamesz >= 3ul)
          {
            if(!((signed int)*certname == 42))
              goto __CPROVER_DUMP_L5;

            if(!((signed int)certname[1l] == 46))
              goto __CPROVER_DUMP_L5;

            return_value_memcmp$5=memcmp((const void *)&certname[(signed long int)1], (const void *)&hostname[(signed long int)(hostnamesz - (certnamesz - (unsigned long int)1))], certnamesz - (unsigned long int)1);
            if(!(return_value_memcmp$5 == 0))
              goto __CPROVER_DUMP_L5;

            return_value_memchr$4=memchr((const void *)hostname, 46, hostnamesz);
            if(!((const char *)return_value_memchr$4 == hostname + (signed long int)hostnamesz + -(-1l + (signed long int)certnamesz)))
              goto __CPROVER_DUMP_L5;

            return 1;
          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            return 0;
          }
        }
    }
}

// ssl_dnsname_match_01
// file ssl.t.c line 96
static void ssl_dnsname_match_01(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_01", "ssl.t.c", 96);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(name1, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1, name1, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  if(!(return_value_ssl_dnsname_match$1 == 0))
    _mark_point("ssl.t.c", 98);

  else
    _ck_assert_failed("ssl.t.c", 98, "Assertion 'ssl_dnsname_match(name1, sizeof(name1) - 1, name1, sizeof(name1) - 1)' failed", (const void *)"Hostname does not match itself", (void *)0);
}

// ssl_dnsname_match_02
// file ssl.t.c line 105
static void ssl_dnsname_match_02(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_02", "ssl.t.c", 105);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(name1, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1, name2, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 107);

  else
    _ck_assert_failed("ssl.t.c", 107, "Assertion '!ssl_dnsname_match(name1, sizeof(name1) - 1, name2, sizeof(name2) - 1)' failed", (const void *)"Hostname matches hostname with different TLD", (void *)0);
}

// ssl_dnsname_match_03
// file ssl.t.c line 114
static void ssl_dnsname_match_03(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_03", "ssl.t.c", 114);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard1, sizeof(char [14l]) /*14ul*/  - (unsigned long int)1, name1, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  if(!(return_value_ssl_dnsname_match$1 == 0))
    _mark_point("ssl.t.c", 116);

  else
    _ck_assert_failed("ssl.t.c", 116, "Assertion 'ssl_dnsname_match(wildcard1, sizeof(wildcard1) - 1, name1, sizeof(name1) - 1)' failed", (const void *)"Regular wildcard does not match", (void *)0);
}

// ssl_dnsname_match_04
// file ssl.t.c line 123
static void ssl_dnsname_match_04(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_04", "ssl.t.c", 123);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard1, sizeof(char [14l]) /*14ul*/  - (unsigned long int)1, name2, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 125);

  else
    _ck_assert_failed("ssl.t.c", 125, "Assertion '!ssl_dnsname_match(wildcard1, sizeof(wildcard1) - 1, name2, sizeof(name2) - 1)' failed", (const void *)"Regular wildcard matches other TLD", (void *)0);
}

// ssl_dnsname_match_05
// file ssl.t.c line 132
static void ssl_dnsname_match_05(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_05", "ssl.t.c", 132);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard1, sizeof(char [14l]) /*14ul*/  - (unsigned long int)1, name3, sizeof(char [12l]) /*12ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 134);

  else
    _ck_assert_failed("ssl.t.c", 134, "Assertion '!ssl_dnsname_match(wildcard1, sizeof(wildcard1) - 1, name3, sizeof(name3) - 1)' failed", (const void *)"Regular wildcard matches upper level domain", (void *)0);
}

// ssl_dnsname_match_06
// file ssl.t.c line 141
static void ssl_dnsname_match_06(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_06", "ssl.t.c", 141);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard1, sizeof(char [14l]) /*14ul*/  - (unsigned long int)1, name4, sizeof(char [22l]) /*22ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 143);

  else
    _ck_assert_failed("ssl.t.c", 143, "Assertion '!ssl_dnsname_match(wildcard1, sizeof(wildcard1) - 1, name4, sizeof(name4) - 1)' failed", (const void *)"Regular wildcard matches despite added suffix", (void *)0);
}

// ssl_dnsname_match_07
// file ssl.t.c line 150
static void ssl_dnsname_match_07(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_07", "ssl.t.c", 150);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard1, sizeof(char [14l]) /*14ul*/  - (unsigned long int)1, name5, sizeof(char [21l]) /*21ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 152);

  else
    _ck_assert_failed("ssl.t.c", 152, "Assertion '!ssl_dnsname_match(wildcard1, sizeof(wildcard1) - 1, name5, sizeof(name5) - 1)' failed", (const void *)"Regular wildcard matches two elements", (void *)0);
}

// ssl_dnsname_match_08
// file ssl.t.c line 159
static void ssl_dnsname_match_08(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_08", "ssl.t.c", 159);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard2, sizeof(char [18l]) /*18ul*/  - (unsigned long int)1, name6, sizeof(char [21l]) /*21ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 161);

  else
    _ck_assert_failed("ssl.t.c", 161, "Assertion '!ssl_dnsname_match(wildcard2, sizeof(wildcard2) - 1, name6, sizeof(name6) - 1)' failed", (const void *)"Wildcard matches in non-leftmost element", (void *)0);
}

// ssl_dnsname_match_09
// file ssl.t.c line 168
static void ssl_dnsname_match_09(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_09", "ssl.t.c", 168);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard3, sizeof(char [8l]) /*8ul*/  - (unsigned long int)1, name5, sizeof(char [21l]) /*21ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 170);

  else
    _ck_assert_failed("ssl.t.c", 170, "Assertion '!ssl_dnsname_match(wildcard3, sizeof(wildcard3) - 1, name5, sizeof(name5) - 1)' failed", (const void *)"Multiple wildcard matches", (void *)0);
}

// ssl_dnsname_match_10
// file ssl.t.c line 177
static void ssl_dnsname_match_10(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_10", "ssl.t.c", 177);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard4, sizeof(char [17l]) /*17ul*/  - (unsigned long int)1, name7, sizeof(char [20l]) /*20ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 179);

  else
    _ck_assert_failed("ssl.t.c", 179, "Assertion '!ssl_dnsname_match(wildcard4, sizeof(wildcard4) - 1, name7, sizeof(name7) - 1)' failed", (const void *)"Partial label wildcard matches", (void *)0);
}

// ssl_dnsname_match_11
// file ssl.t.c line 186
static void ssl_dnsname_match_11(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_11", "ssl.t.c", 186);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard5, sizeof(char [2l]) /*2ul*/  - (unsigned long int)1, name1, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 188);

  else
    _ck_assert_failed("ssl.t.c", 188, "Assertion '!ssl_dnsname_match(wildcard5, sizeof(wildcard5) - 1, name1, sizeof(name1) - 1)' failed", (const void *)"Global wildcard * matches fqdn", (void *)0);
}

// ssl_dnsname_match_12
// file ssl.t.c line 195
static void ssl_dnsname_match_12(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_12", "ssl.t.c", 195);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard5, sizeof(char [2l]) /*2ul*/  - (unsigned long int)1, name8, sizeof(char [3l]) /*3ul*/  - (unsigned long int)1);
  if(!(return_value_ssl_dnsname_match$1 == 0))
    _mark_point("ssl.t.c", 197);

  else
    _ck_assert_failed("ssl.t.c", 197, "Assertion 'ssl_dnsname_match(wildcard5, sizeof(wildcard5) - 1, name8, sizeof(name8) - 1)' failed", (const void *)"Global wildcard * does not match TLD", (void *)0);
}

// ssl_dnsname_match_13
// file ssl.t.c line 204
static void ssl_dnsname_match_13(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_13", "ssl.t.c", 204);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard6, sizeof(char [15l]) /*15ul*/  - (unsigned long int)1, name9, sizeof(char [17l]) /*17ul*/  - (unsigned long int)1);
  if(!(return_value_ssl_dnsname_match$1 == 0))
    _mark_point("ssl.t.c", 206);

  else
    _ck_assert_failed("ssl.t.c", 206, "Assertion 'ssl_dnsname_match(wildcard6, sizeof(wildcard6) - 1, name9, sizeof(name9) - 1)' failed", (const void *)"IDN wildcard does not match", (void *)0);
}

// ssl_dnsname_match_14
// file ssl.t.c line 213
static void ssl_dnsname_match_14(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_14", "ssl.t.c", 213);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard6, sizeof(char [15l]) /*15ul*/  - (unsigned long int)1, name10, sizeof(char [23l]) /*23ul*/  - (unsigned long int)1);
  if(!(return_value_ssl_dnsname_match$1 == 0))
    _mark_point("ssl.t.c", 215);

  else
    _ck_assert_failed("ssl.t.c", 215, "Assertion 'ssl_dnsname_match(wildcard6, sizeof(wildcard6) - 1, name10, sizeof(name10) - 1)' failed", (const void *)"IDN wildcard does not match IDN element", (void *)0);
}

// ssl_dnsname_match_15
// file ssl.t.c line 222
static void ssl_dnsname_match_15(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_15", "ssl.t.c", 222);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard7, sizeof(char [24l]) /*24ul*/  - (unsigned long int)1, name10, sizeof(char [23l]) /*23ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 224);

  else
    _ck_assert_failed("ssl.t.c", 224, "Assertion '!ssl_dnsname_match(wildcard7, sizeof(wildcard7) - 1, name10, sizeof(name10) - 1)' failed", (const void *)"Illegal IDN wildcard matches", (void *)0);
}

// ssl_dnsname_match_16
// file ssl.t.c line 231
static void ssl_dnsname_match_16(signed int _i)
{
  tcase_fn_start("ssl_dnsname_match_16", "ssl.t.c", 231);
  signed int return_value_ssl_dnsname_match$1;
  return_value_ssl_dnsname_match$1=ssl_dnsname_match(wildcard8, sizeof(char [25l]) /*25ul*/  - (unsigned long int)1, name10, sizeof(char [23l]) /*23ul*/  - (unsigned long int)1);
  if(return_value_ssl_dnsname_match$1 == 0)
    _mark_point("ssl.t.c", 233);

  else
    _ck_assert_failed("ssl.t.c", 233, "Assertion '!ssl_dnsname_match(wildcard8, sizeof(wildcard8) - 1, name10, sizeof(name10) - 1)' failed", (const void *)"Illegal IDN wildcard matches IDN element", (void *)0);
}

// ssl_ec_by_name
// file ssl.c line 607
struct ec_key_st * ssl_ec_by_name(const char *curvename)
{
  signed int nid;
  if(curvename == ((const char *)NULL))
    curvename = "secp160r2";

  nid=OBJ_sn2nid(curvename);
  if(nid == 0)
    return (struct ec_key_st *)(void *)0;

  else
  {
    struct ec_key_st *return_value_EC_KEY_new_by_curve_name$1;
    return_value_EC_KEY_new_by_curve_name$1=EC_KEY_new_by_curve_name(nid);
    return return_value_EC_KEY_new_by_curve_name$1;
  }
}

// ssl_features_01
// file ssl.t.c line 550
static void ssl_features_01(signed int _i)
{
  tcase_fn_start("ssl_features_01", "ssl.t.c", 550);
  signed int have_threads = 0;
  have_threads = 1;
  if(!(have_threads == 0))
    _mark_point("ssl.t.c", 556);

  else
    _ck_assert_failed("ssl.t.c", 556, "Assertion 'have_threads' failed", (const void *)"!OPENSSL_THREADS: no threading support", (void *)0);
}

// ssl_fini
// file ssl.h line 114
void ssl_fini(void)
{
  if(!(ssl_initialized == 0))
  {
    ERR_remove_state((unsigned long int)0);
    CRYPTO_set_locking_callback((void (*)(signed int, signed int, const char *, signed int))(void *)0);
    CRYPTO_set_dynlock_create_callback((struct CRYPTO_dynlock_value * (*)(const char *, signed int))(void *)0);
    CRYPTO_set_dynlock_lock_callback((void (*)(signed int, struct CRYPTO_dynlock_value *, const char *, signed int))(void *)0);
    CRYPTO_set_dynlock_destroy_callback((void (*)(struct CRYPTO_dynlock_value *, const char *, signed int))(void *)0);
    CRYPTO_THREADID_set_callback((void (*)(struct crypto_threadid_st *))(void *)0);
    signed int i = 0;
    for( ; !(i >= ssl_mutex_num); i = i + 1)
      pthread_mutex_destroy(&ssl_mutex[(signed long int)i]);
    free((void *)ssl_mutex);
    ENGINE_cleanup();
    CONF_modules_finish();
    CONF_modules_unload(1);
    CONF_modules_free();
    EVP_cleanup();
    ERR_free_strings();
    CRYPTO_cleanup_all_ex_data();
  }

}

// ssl_ia5string_strdup
// file ssl.c line 1369
static char * ssl_ia5string_strdup(struct asn1_string_st *ia5)
{
  char *str;
  _Bool tmp_if_expr$1;
  if(ia5 == ((struct asn1_string_st *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(ia5->length != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (char *)(void *)0;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)(ia5->length + 1));
    str = (char *)return_value_malloc$2;
    if(str == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      memcpy((void *)str, (const void *)ia5->data, (unsigned long int)ia5->length);
      str[(signed long int)ia5->length] = (char)0;
      return str;
    }
  }
}

// ssl_init
// file ssl.h line 112
signed int ssl_init(void)
{
  signed int fd;
  char ssl_init$$1$$buf[256l];
  signed int return_value_RAND_status$4;
  if(!(ssl_initialized == 0))
    return 0;

  else
  {
    SSL_library_init();
    SSL_load_error_strings();
    OPENSSL_add_all_algorithms_noconf();
    ssl_mutex_num=CRYPTO_num_locks();
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)ssl_mutex_num * sizeof(union anonymous$10) /*40ul*/ );
    ssl_mutex = (union anonymous$10 *)return_value_malloc$1;
    signed int i = 0;
    for( ; !(i >= ssl_mutex_num); i = i + 1)
      pthread_mutex_init(&ssl_mutex[(signed long int)i], (const union anonymous$15 *)(void *)0);
    CRYPTO_set_locking_callback(ssl_thr_locking_cb);
    CRYPTO_set_dynlock_create_callback(ssl_thr_dyn_create_cb);
    CRYPTO_set_dynlock_lock_callback(ssl_thr_dyn_lock_cb);
    CRYPTO_set_dynlock_destroy_callback(ssl_thr_dyn_destroy_cb);
    CRYPTO_THREADID_set_callback(ssl_thr_id_cb);
    fd=open("/dev/urandom", 00);
    if(fd == -1)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_err_printf("Error opening /dev/urandom for reading: %s\n", return_value_strerror$3);
      return -1;
    }

    do
    {
      return_value_RAND_status$4=RAND_status();
      if(!(return_value_RAND_status$4 == 0))
        break;

      signed long int return_value_read$7;
      return_value_read$7=read(fd, (void *)ssl_init$$1$$buf, sizeof(char [256l]) /*256ul*/ );
      if(return_value_read$7 == -1l)
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        log_err_printf("Error reading from /dev/urandom: %s\n", return_value_strerror$6);
        close(fd);
        return -1;
      }

      RAND_seed((const void *)ssl_init$$1$$buf, (signed int)sizeof(char [256l]) /*256ul*/ );
    }
    while((_Bool)1);
    close(fd);
    signed int return_value_RAND_poll$8;
    return_value_RAND_poll$8=RAND_poll();
    if(return_value_RAND_poll$8 == 0)
    {
      log_err_printf("RAND_poll() failed.\n");
      return -1;
    }

    else
    {
      ssl_initialized = 1;
      return 0;
    }
  }
}

// ssl_is_ocspreq
// file ssl.h line 161
signed int ssl_is_ocspreq(const unsigned char *buf, unsigned long int sz)
{
  struct ocsp_request_st *req;
  const unsigned char *p = (const unsigned char *)buf;
  req=d2i_OCSP_REQUEST((struct ocsp_request_st **)(void *)0, &p, (signed long int)sz);
  if(req == ((struct ocsp_request_st *)NULL))
    return 0;

  else
  {
    OCSP_REQUEST_free(req);
    return 1;
  }
}

// ssl_is_ocspreq_01
// file ssl.t.c line 539
static void ssl_is_ocspreq_01(signed int _i)
{
  tcase_fn_start("ssl_is_ocspreq_01", "ssl.t.c", 539);
  unsigned char *ssl_is_ocspreq_01$$1$$1$$buf;
  unsigned long int ssl_is_ocspreq_01$$1$$1$$sz;
  ssl_is_ocspreq_01$$1$$1$$buf=base64_dec(ocspreq01, sizeof(char [93l]) /*93ul*/  - (unsigned long int)1, &ssl_is_ocspreq_01$$1$$1$$sz);
  if(!(ssl_is_ocspreq_01$$1$$1$$buf == ((unsigned char *)NULL)))
    _mark_point("ssl.t.c", 545);

  else
    _ck_assert_failed("ssl.t.c", 545, "Assertion '!!buf' failed", (const void *)"failed to base64 decode", (void *)0);
  signed int return_value_ssl_is_ocspreq$1;
  return_value_ssl_is_ocspreq$1=ssl_is_ocspreq(ssl_is_ocspreq_01$$1$$1$$buf, ssl_is_ocspreq_01$$1$$1$$sz);
  if(!(return_value_ssl_is_ocspreq$1 == 0))
    _mark_point("ssl.t.c", 546);

  else
    _ck_assert_failed("ssl.t.c", 546, "Assertion 'ssl_is_ocspreq(buf, sz)' failed", (const void *)"is not ocsp req", (void *)0);
}

// ssl_key_genrsa
// file ssl.c line 1028
struct evp_pkey_st * ssl_key_genrsa(const signed int keysize)
{
  struct evp_pkey_st *pkey;
  struct rsa_st *rsa;
  rsa=RSA_generate_key(keysize, (unsigned long int)3, (void (*)(signed int, signed int, void *))(void *)0, (void *)0);
  if(rsa == ((struct rsa_st *)NULL))
    return (struct evp_pkey_st *)(void *)0;

  else
  {
    pkey=EVP_PKEY_new();
    EVP_PKEY_assign(pkey, 6, (void *)(char *)rsa);
    return pkey;
  }
}

// ssl_key_load
// file ssl.c line 994
struct evp_pkey_st * ssl_key_load(const char *filename)
{
  struct evp_pkey_st *key = (struct evp_pkey_st *)(void *)0;
  struct ssl_ctx_st *tmpctx;
  struct ssl_st *tmpssl;
  signed int rv;
  signed int return_value_ssl_init$1;
  return_value_ssl_init$1=ssl_init();
  if(return_value_ssl_init$1 == -1)
    return (struct evp_pkey_st *)(void *)0;

  else
  {
    const struct ssl_method_st *return_value_SSLv23_server_method$2;
    return_value_SSLv23_server_method$2=SSLv23_server_method();
    tmpctx=SSL_CTX_new(return_value_SSLv23_server_method$2);
    if(!(tmpctx == ((struct ssl_ctx_st *)NULL)))
    {
      rv=SSL_CTX_use_PrivateKey_file(tmpctx, filename, 1);
      if(rv == 1)
      {
        tmpssl=SSL_new(tmpctx);
        if(!(tmpssl == ((struct ssl_st *)NULL)))
        {
          key=SSL_get_privatekey(tmpssl);
          if(!(key == ((struct evp_pkey_st *)NULL)))
            ssl_key_refcount_inc(key);

          SSL_free(tmpssl);
        }

      }


    leave2:
      ;
      SSL_CTX_free(tmpctx);
    }


  leave1:
    ;
    return key;
  }
}

// ssl_key_refcount_inc
// file ssl.c line 1111
void ssl_key_refcount_inc(struct evp_pkey_st *key)
{
  CRYPTO_add_lock(&key->references, 1, 10, "ssl.c", 1114);
}

// ssl_openssl_version
// file ssl.c line 97
void ssl_openssl_version(void)
{
  fprintf(stderr, "compiled against %s (%lx)\n", (const void *)"OpenSSL 1.0.2e 3 Dec 2015", (unsigned long int)0x1000205fL);
  const char *return_value_SSLeay_version$1;
  return_value_SSLeay_version$1=SSLeay_version(0);
  unsigned long int return_value_SSLeay$2;
  return_value_SSLeay$2=SSLeay();
  fprintf(stderr, "rtlinked against %s (%lx)\n", return_value_SSLeay_version$1, return_value_SSLeay$2);
  fprintf(stderr, "TLS Server Name Indication (SNI) supported\n");
  fprintf(stderr, "OpenSSL is thread-safe with THREADID\n");
  fprintf(stderr, "Using SSL_MODE_RELEASE_BUFFERS\n");
  fprintf(stderr, "SSL/TLS protocol availability: %s\n", (const void *)"ssl3 tls10 tls11 tls12 ");
  fprintf(stderr, "SSL/TLS algorithm availability:");
  fprintf(stderr, " RSA");
  fprintf(stderr, " DSA");
  fprintf(stderr, " ECDSA");
  fprintf(stderr, " DH");
  fprintf(stderr, " ECDH");
  fprintf(stderr, " EC");
  fprintf(stderr, "\n");
  fprintf(stderr, "OpenSSL option availability:");
  fprintf(stderr, " SSL_OP_NO_COMPRESSION");
  fprintf(stderr, " SSL_OP_NO_TICKET");
  fprintf(stderr, " SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION");
  fprintf(stderr, " SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS");
  fprintf(stderr, " SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION");
  fprintf(stderr, " SSL_OP_TLS_ROLLBACK_BUG");
  fprintf(stderr, "\n");
}

// ssl_rand
// file ssl.c line 670
signed int ssl_rand(void *p, unsigned long int sz)
{
  signed int rv;
  rv=RAND_pseudo_bytes((unsigned char *)p, (signed int)sz);
  if(rv == -1)
  {
    rv=RAND_bytes((unsigned char *)p, (signed int)sz);
    if(rv == 1)
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// ssl_reinit
// file ssl.c line 373
void ssl_reinit(void)
{
  if(!(ssl_initialized == 0))
  {
    signed int i = 0;
    for( ; !(i >= ssl_mutex_num); i = i + 1)
      pthread_mutex_init(&ssl_mutex[(signed long int)i], (const union anonymous$15 *)(void *)0);
  }

}

// ssl_session_from_file
// file cachedsess.t.c line 43
static struct ssl_session_st * ssl_session_from_file(const char *filename)
{
  struct ssl_session_st *sess;
  struct _IO_FILE *f;
  f=fopen(filename, "r");
  if(f == ((struct _IO_FILE *)NULL))
    return (struct ssl_session_st *)(void *)0;

  else
  {
    sess=PEM_read_SSL_SESSION(f, (struct ssl_session_st **)(void *)0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
    fclose(f);
    return sess;
  }
}

// ssl_session_from_file$link1
// file cachessess.t.c line 42
static struct ssl_session_st * ssl_session_from_file$link1(const char *filename$link1)
{
  struct ssl_session_st *sess$link1;
  struct _IO_FILE *f$link1;
  f$link1=fopen(filename$link1, "r");
  if(f$link1 == ((struct _IO_FILE *)NULL))
    return (struct ssl_session_st *)(void *)0;

  else
  {
    sess$link1=PEM_read_SSL_SESSION(f$link1, (struct ssl_session_st **)(void *)0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
    fclose(f$link1);
    return sess$link1;
  }
}

// ssl_session_is_valid
// file ssl.h line 159
signed int ssl_session_is_valid(struct ssl_session_st *sess)
{
  signed long int curtimet;
  signed long int curtime;
  signed long int timeout;
  curtimet=time((signed long int *)(void *)0);
  if(curtimet == -1l)
    return 0;

  else
  {
    curtime = curtimet;
    if(!(curtime == curtimet) || !(curtime >= 0l))
      return 0;

    else
    {
      timeout=SSL_SESSION_get_timeout(sess);
      if(!(0x7fffffffffffffffL + -timeout >= curtime))
        return 0;

      else
      {
        signed long int return_value_SSL_SESSION_get_time$1;
        return_value_SSL_SESSION_get_time$1=SSL_SESSION_get_time(sess);
        return (signed int)(return_value_SSL_SESSION_get_time$1 < curtime + timeout);
      }
    }
  }
}

// ssl_session_to_str
// file ssl.c line 1507
char * ssl_session_to_str(struct ssl_session_st *sess)
{
  struct bio_st *bio;
  char *p;
  char *ret;
  unsigned long int ssl_session_to_str$$1$$sz;
  struct bio_method_st *return_value_BIO_s_mem$1;
  return_value_BIO_s_mem$1=BIO_s_mem();
  bio=BIO_new(return_value_BIO_s_mem$1);
  if(bio == ((struct bio_st *)NULL))
    return (char *)(void *)0;

  else
  {
    SSL_SESSION_print(bio, sess);
    signed long int return_value_BIO_ctrl$2;
    return_value_BIO_ctrl$2=BIO_ctrl(bio, 3, (signed long int)0, (void *)(char *)&p);
    ssl_session_to_str$$1$$sz = (unsigned long int)return_value_BIO_ctrl$2;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(ssl_session_to_str$$1$$sz + (unsigned long int)1);
    ret = (char *)return_value_malloc$3;
    if(ret == ((char *)NULL))
    {
      BIO_free(bio);
      return (char *)(void *)0;
    }

    else
    {
      memcpy((void *)ret, (const void *)p, ssl_session_to_str$$1$$sz);
      ret[(signed long int)ssl_session_to_str$$1$$sz] = (char)0;
      BIO_free(bio);
      return ret;
    }
  }
}

// ssl_setup
// file ssl.t.c line 40
static void ssl_setup(void)
{
  signed int return_value_ssl_init$1;
  return_value_ssl_init$1=ssl_init();
  if(return_value_ssl_init$1 == -1)
    exit(1);

}

// ssl_ssl_state_to_str
// file ssl.c line 428
char * ssl_ssl_state_to_str(struct ssl_st *ssl)
{
  char *str = (char *)(void *)0;
  signed int rv;
  const char *return_value_SSL_state_string$1;
  return_value_SSL_state_string$1=SSL_state_string(ssl);
  const char *return_value_SSL_state_string_long$2;
  return_value_SSL_state_string_long$2=SSL_state_string_long(ssl);
  rv=asprintf(&str, "%08x = %s%s%s%04x = %s (%s) [%s]", ssl->state, (ssl->state & 0x1000) != 0 ? "SSL_ST_CONNECT|" : "", (ssl->state & 0x2000) != 0 ? "SSL_ST_ACCEPT|" : "", (ssl->state & 0x4000) != 0 ? "SSL_ST_BEFORE|" : "", ssl->state & 0x0FFF, return_value_SSL_state_string$1, return_value_SSL_state_string_long$2, ssl->type == 0x1000 ? "connect socket" : "accept socket");
  return rv < 0 ? (char *)(void *)0 : str;
}

// ssl_suite
// file ssl.t.c line 561
struct Suite * ssl_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("ssl");
  tc=tcase_create("ssl_wildcardify");
  _tcase_add_test(tc, ssl_wildcardify_01, "ssl_wildcardify_01", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_wildcardify_02, "ssl_wildcardify_02", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_wildcardify_03, "ssl_wildcardify_03", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("ssl_dnsname_match");
  _tcase_add_test(tc, ssl_dnsname_match_01, "ssl_dnsname_match_01", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_02, "ssl_dnsname_match_02", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_03, "ssl_dnsname_match_03", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_04, "ssl_dnsname_match_04", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_05, "ssl_dnsname_match_05", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_06, "ssl_dnsname_match_06", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_07, "ssl_dnsname_match_07", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_08, "ssl_dnsname_match_08", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_09, "ssl_dnsname_match_09", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_10, "ssl_dnsname_match_10", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_11, "ssl_dnsname_match_11", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_12, "ssl_dnsname_match_12", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_13, "ssl_dnsname_match_13", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_14, "ssl_dnsname_match_14", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_15, "ssl_dnsname_match_15", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_dnsname_match_16, "ssl_dnsname_match_16", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("ssl_tls_clienthello_parse_sni");
  _tcase_add_test(tc, ssl_tls_clienthello_parse_sni_01, "ssl_tls_clienthello_parse_sni_01", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_tls_clienthello_parse_sni_02, "ssl_tls_clienthello_parse_sni_02", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_tls_clienthello_parse_sni_03, "ssl_tls_clienthello_parse_sni_03", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_tls_clienthello_parse_sni_04, "ssl_tls_clienthello_parse_sni_04", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_tls_clienthello_parse_sni_05, "ssl_tls_clienthello_parse_sni_05", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_tls_clienthello_parse_sni_06, "ssl_tls_clienthello_parse_sni_06", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_tls_clienthello_parse_sni_07, "ssl_tls_clienthello_parse_sni_07", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("ssl_x509_names");
  tcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);
  _tcase_add_test(tc, ssl_x509_names_01, "ssl_x509_names_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("ssl_x509_names_to_str");
  tcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);
  _tcase_add_test(tc, ssl_x509_names_to_str_01, "ssl_x509_names_to_str_01", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_x509_names_to_str_02, "ssl_x509_names_to_str_02", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("ssl_x509_subject");
  tcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);
  _tcase_add_test(tc, ssl_x509_subject_01, "ssl_x509_subject_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("ssl_x509_subject_cn");
  tcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);
  _tcase_add_test(tc, ssl_x509_subject_cn_01, "ssl_x509_subject_cn_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("ssl_x509_ocsps");
  tcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);
  _tcase_add_test(tc, ssl_x509_ocsps_01, "ssl_x509_ocsps_01", 0, 0, 0, 1);
  _tcase_add_test(tc, ssl_x509_ocsps_02, "ssl_x509_ocsps_02", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("ssl_is_ocspreq");
  _tcase_add_test(tc, ssl_is_ocspreq_01, "ssl_is_ocspreq_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("ssl_features");
  _tcase_add_test(tc, ssl_features_01, "ssl_features_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// ssl_teardown
// file ssl.t.c line 47
static void ssl_teardown(void)
{
  ssl_fini();
}

// ssl_thr_dyn_create_cb
// file ssl.c line 232
static struct CRYPTO_dynlock_value * ssl_thr_dyn_create_cb(const char *file, signed int line)
{
  struct CRYPTO_dynlock_value *dl;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct CRYPTO_dynlock_value) /*40ul*/ );
  dl = (struct CRYPTO_dynlock_value *)return_value_malloc$1;
  if(!(dl == ((struct CRYPTO_dynlock_value *)NULL)))
    pthread_mutex_init(&dl->mutex, (const union anonymous$15 *)(void *)0);

  return dl;
}

// ssl_thr_dyn_destroy_cb
// file ssl.c line 260
static void ssl_thr_dyn_destroy_cb(struct CRYPTO_dynlock_value *dl, const char *file, signed int line)
{
  pthread_mutex_destroy(&dl->mutex);
  free((void *)dl);
}

// ssl_thr_dyn_lock_cb
// file ssl.c line 246
static void ssl_thr_dyn_lock_cb(signed int mode, struct CRYPTO_dynlock_value *dl, const char *file, signed int line)
{
  if(!((1 & mode) == 0))
    pthread_mutex_lock(&dl->mutex);

  else
    pthread_mutex_unlock(&dl->mutex);
}

// ssl_thr_id_cb
// file ssl.c line 280
static void ssl_thr_id_cb(struct crypto_threadid_st *id)
{
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  CRYPTO_THREADID_set_numeric(id, (unsigned long int)return_value_pthread_self$1);
}

// ssl_thr_locking_cb
// file ssl.c line 218
static void ssl_thr_locking_cb(signed int mode, signed int type, const char *file, signed int line)
{
  if(!(type >= ssl_mutex_num))
  {
    if(!((1 & mode) == 0))
      pthread_mutex_lock(&ssl_mutex[(signed long int)type]);

    else
      pthread_mutex_unlock(&ssl_mutex[(signed long int)type]);
  }

}

// ssl_tls_clienthello_parse_sni
// file ssl.h line 164
char * ssl_tls_clienthello_parse_sni(const unsigned char *buf, signed long int *sz)
{
  const unsigned char *p = buf;
  signed long int n = *sz;
  char *servername = (char *)(void *)0;
  signed long int msglen;
  signed long int sidlen;
  signed long int suiteslen;
  signed long int compslen;
  signed long int tlsextslen;
  if(!(n >= 1l))
    *sz = (signed long int)-1;

  else
    if((signed int)*p == 22)
    {
      p = p + 1l;
      n = n - 1l;
      if(!(n >= 2l))
        *sz = (signed long int)-1;

      else
        if((signed int)*p == 3)
        {
          p = p + (signed long int)2;
          n = n - (signed long int)2;
          if(!(n >= 2l))
            *sz = (signed long int)-1;

          else
          {
            p = p + (signed long int)2;
            n = n - (signed long int)2;
            if(!(n >= 1l))
              *sz = (signed long int)-1;

            else
              if((signed int)*p == 1)
              {
                p = p + 1l;
                n = n - 1l;
                if(!(n >= 3l))
                  *sz = (signed long int)-1;

                else
                {
                  msglen = (signed long int)((signed int)p[(signed long int)2] + ((signed int)p[(signed long int)1] << 8) + ((signed int)p[(signed long int)0] << 16));
                  if(msglen >= 4l)
                  {
                    p = p + (signed long int)3;
                    n = n - (signed long int)3;
                    if(!(n >= msglen))
                      *sz = (signed long int)-1;

                    else
                    {
                      n = msglen;
                      if(n >= 2l)
                      {
                        if((signed int)*p == 3)
                        {
                          p = p + (signed long int)2;
                          n = n - (signed long int)2;
                          if(n >= 32l)
                          {
                            p = p + (signed long int)32;
                            n = n - (signed long int)32;
                            if(n >= 1l)
                            {
                              sidlen = (signed long int)*p;
                              p = p + (signed long int)1;
                              n = n - (signed long int)1;
                              if(n >= sidlen)
                              {
                                p = p + sidlen;
                                n = n - sidlen;
                                if(n >= 2l)
                                {
                                  suiteslen = (signed long int)((signed int)p[(signed long int)1] + ((signed int)p[(signed long int)0] << 8));
                                  p = p + (signed long int)2;
                                  n = n - (signed long int)2;
                                  if(n >= suiteslen)
                                  {
                                    p = p + suiteslen;
                                    n = n - suiteslen;
                                    if(n >= 1l)
                                    {
                                      compslen = (signed long int)*p;
                                      p = p + 1l;
                                      n = n - 1l;
                                      if(n >= compslen)
                                      {
                                        p = p + compslen;
                                        n = n - compslen;
                                        if(n >= 2l)
                                        {
                                          tlsextslen = (signed long int)((signed int)p[(signed long int)1] + ((signed int)p[(signed long int)0] << 8));
                                          p = p + (signed long int)2;
                                          n = n - (signed long int)2;
                                          if(n >= tlsextslen)
                                          {
                                            n = tlsextslen;
                                            while(n >= 1l)
                                            {
                                              if(!(n >= 4l))
                                                break;

                                              unsigned short int exttype = (unsigned short int)((signed int)p[(signed long int)1] + ((signed int)p[(signed long int)0] << 8));
                                              signed long int extlen = (signed long int)((signed int)p[(signed long int)3] + ((signed int)p[(signed long int)2] << 8));
                                              p = p + (signed long int)4;
                                              n = n - (signed long int)4;
                                              if(!(n >= extlen))
                                                break;

                                              if((signed int)exttype == 0)
                                              {
                                                signed long int extn = extlen;
                                                const unsigned char *extp = p;
                                                if(!(extn >= 2l))
                                                  break;

                                                signed long int namelistlen = (signed long int)((signed int)extp[(signed long int)1] + ((signed int)extp[(signed long int)0] << 8));
                                                extp = extp + (signed long int)2;
                                                extn = extn - (signed long int)2;
                                                if(!(namelistlen == extn))
                                                  break;

                                                while(extn >= 1l)
                                                {
                                                  if(!(extn >= 3l))
                                                    goto out;

                                                  unsigned char sntype = extp[(signed long int)0];
                                                  signed long int snlen = (signed long int)((signed int)extp[(signed long int)2] + ((signed int)extp[(signed long int)1] << 8));
                                                  extp = extp + (signed long int)3;
                                                  extn = extn - (signed long int)3;
                                                  if(!(extn >= snlen))
                                                    goto out;

                                                  if(snlen >= 256l)
                                                    goto out;

                                                  if((signed int)sntype == 0)
                                                  {
                                                    void *return_value_malloc$1;
                                                    return_value_malloc$1=malloc((unsigned long int)(snlen + (signed long int)1));
                                                    servername = (char *)return_value_malloc$1;
                                                    memcpy((void *)servername, (const void *)extp, (unsigned long int)snlen);
                                                    servername[snlen] = (char)0;
                                                    goto out;
                                                  }

                                                  extp = extp + snlen;
                                                  extn = extn - snlen;
                                                }
                                              }

                                              p = p + extlen;
                                              n = n - extlen;
                                            }
                                          }

                                        }

                                      }

                                    }

                                  }

                                }

                              }

                            }

                          }

                        }

                      }

                    }
                  }

                }
              }

          }
        }

    }


out:
  ;
  return servername;
}

// ssl_tls_clienthello_parse_sni_01
// file ssl.t.c line 315
static void ssl_tls_clienthello_parse_sni_01(signed int _i)
{
  tcase_fn_start("ssl_tls_clienthello_parse_sni_01", "ssl.t.c", 315);
  signed long int ssl_tls_clienthello_parse_sni_01$$1$$1$$sz;
  char *ssl_tls_clienthello_parse_sni_01$$1$$1$$sni;
  ssl_tls_clienthello_parse_sni_01$$1$$1$$sz = (signed long int)(sizeof(unsigned char [106l]) /*106ul*/  - (unsigned long int)1);
  ssl_tls_clienthello_parse_sni_01$$1$$1$$sni=ssl_tls_clienthello_parse_sni(clienthello01, &ssl_tls_clienthello_parse_sni_01$$1$$1$$sz);
  if(ssl_tls_clienthello_parse_sni_01$$1$$1$$sni == ((char *)NULL))
    _mark_point("ssl.t.c", 322);

  else
    _ck_assert_failed("ssl.t.c", 322, "Assertion 'sni == NULL' failed", (const void *)"sni not null but should be", (void *)0);
  if(!(ssl_tls_clienthello_parse_sni_01$$1$$1$$sz == -1l))
    _mark_point("ssl.t.c", 323);

  else
    _ck_assert_failed("ssl.t.c", 323, "Assertion 'sz != -1' failed", (const void *)"size is -1 but should not", (void *)0);
}

// ssl_tls_clienthello_parse_sni_02
// file ssl.t.c line 327
static void ssl_tls_clienthello_parse_sni_02(signed int _i)
{
  tcase_fn_start("ssl_tls_clienthello_parse_sni_02", "ssl.t.c", 327);
  signed long int ssl_tls_clienthello_parse_sni_02$$1$$1$$sz;
  char *ssl_tls_clienthello_parse_sni_02$$1$$1$$sni;
  ssl_tls_clienthello_parse_sni_02$$1$$1$$sz = (signed long int)(sizeof(unsigned char [121l]) /*121ul*/  - (unsigned long int)1);
  ssl_tls_clienthello_parse_sni_02$$1$$1$$sni=ssl_tls_clienthello_parse_sni(clienthello02, &ssl_tls_clienthello_parse_sni_02$$1$$1$$sz);
  if(ssl_tls_clienthello_parse_sni_02$$1$$1$$sni == ((char *)NULL))
    _mark_point("ssl.t.c", 334);

  else
    _ck_assert_failed("ssl.t.c", 334, "Assertion 'sni == NULL' failed", (const void *)"sni not null but should be", (void *)0);
  if(!(ssl_tls_clienthello_parse_sni_02$$1$$1$$sz == -1l))
    _mark_point("ssl.t.c", 335);

  else
    _ck_assert_failed("ssl.t.c", 335, "Assertion 'sz != -1' failed", (const void *)"size is -1 but should not", (void *)0);
}

// ssl_tls_clienthello_parse_sni_03
// file ssl.t.c line 339
static void ssl_tls_clienthello_parse_sni_03(signed int _i)
{
  tcase_fn_start("ssl_tls_clienthello_parse_sni_03", "ssl.t.c", 339);
  signed long int ssl_tls_clienthello_parse_sni_03$$1$$1$$sz;
  char *ssl_tls_clienthello_parse_sni_03$$1$$1$$sni;
  ssl_tls_clienthello_parse_sni_03$$1$$1$$sz = (signed long int)(sizeof(unsigned char [161l]) /*161ul*/  - (unsigned long int)1);
  ssl_tls_clienthello_parse_sni_03$$1$$1$$sni=ssl_tls_clienthello_parse_sni(clienthello03, &ssl_tls_clienthello_parse_sni_03$$1$$1$$sz);
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  if(!(ssl_tls_clienthello_parse_sni_03$$1$$1$$sni == ((char *)NULL)))
  {
    return_value_strcmp$1=strcmp(ssl_tls_clienthello_parse_sni_03$$1$$1$$sni, "192.168.100.4");
    tmp_if_expr$2 = !(return_value_strcmp$1 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    _mark_point("ssl.t.c", 346);

  else
    _ck_assert_failed("ssl.t.c", 346, "Assertion 'sni && !strcmp(sni, \"192.168.100.4\")' failed", (const void *)"sni not '192.168.100.4' but should be", (void *)0);
  if(!(ssl_tls_clienthello_parse_sni_03$$1$$1$$sz == -1l))
    _mark_point("ssl.t.c", 348);

  else
    _ck_assert_failed("ssl.t.c", 348, "Assertion 'sz != -1' failed", (const void *)"size is -1 but should not", (void *)0);
}

// ssl_tls_clienthello_parse_sni_04
// file ssl.t.c line 352
static void ssl_tls_clienthello_parse_sni_04(signed int _i)
{
  tcase_fn_start("ssl_tls_clienthello_parse_sni_04", "ssl.t.c", 352);
  signed long int ssl_tls_clienthello_parse_sni_04$$1$$1$$sz;
  char *ssl_tls_clienthello_parse_sni_04$$1$$1$$sni;
  ssl_tls_clienthello_parse_sni_04$$1$$1$$sz = (signed long int)(sizeof(unsigned char [114l]) /*114ul*/  - (unsigned long int)1);
  ssl_tls_clienthello_parse_sni_04$$1$$1$$sni=ssl_tls_clienthello_parse_sni(clienthello04, &ssl_tls_clienthello_parse_sni_04$$1$$1$$sz);
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  if(!(ssl_tls_clienthello_parse_sni_04$$1$$1$$sni == ((char *)NULL)))
  {
    return_value_strcmp$1=strcmp(ssl_tls_clienthello_parse_sni_04$$1$$1$$sni, "kamesh.com");
    tmp_if_expr$2 = !(return_value_strcmp$1 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    _mark_point("ssl.t.c", 359);

  else
    _ck_assert_failed("ssl.t.c", 359, "Assertion 'sni && !strcmp(sni, \"kamesh.com\")' failed", (const void *)"sni not 'kamesh.com' but should be", (void *)0);
  if(!(ssl_tls_clienthello_parse_sni_04$$1$$1$$sz == -1l))
    _mark_point("ssl.t.c", 361);

  else
    _ck_assert_failed("ssl.t.c", 361, "Assertion 'sz != -1' failed", (const void *)"size is -1 but should not", (void *)0);
}

// ssl_tls_clienthello_parse_sni_05
// file ssl.t.c line 365
static void ssl_tls_clienthello_parse_sni_05(signed int _i)
{
  tcase_fn_start("ssl_tls_clienthello_parse_sni_05", "ssl.t.c", 365);
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 113ul); i = i + 1ul)
  {
    signed long int ssl_tls_clienthello_parse_sni_05$$1$$1$$1$$1$$sz;
    char *ssl_tls_clienthello_parse_sni_05$$1$$1$$1$$1$$sni;
    ssl_tls_clienthello_parse_sni_05$$1$$1$$1$$1$$sz = (signed long int)i;
    ssl_tls_clienthello_parse_sni_05$$1$$1$$1$$1$$sni=ssl_tls_clienthello_parse_sni(clienthello04, &ssl_tls_clienthello_parse_sni_05$$1$$1$$1$$1$$sz);
    if(ssl_tls_clienthello_parse_sni_05$$1$$1$$1$$1$$sni == ((char *)NULL))
      _mark_point("ssl.t.c", 373);

    else
      _ck_assert_failed("ssl.t.c", 373, "Assertion 'sni == NULL' failed", (const void *)"sni not null but should be", (void *)0);
    if(ssl_tls_clienthello_parse_sni_05$$1$$1$$1$$1$$sz == -1l)
      _mark_point("ssl.t.c", 374);

    else
      _ck_assert_failed("ssl.t.c", 374, "Assertion 'sz == -1' failed", (const void *)"size is not -1 but should be", (void *)0);
  }
}

// ssl_tls_clienthello_parse_sni_06
// file ssl.t.c line 379
static void ssl_tls_clienthello_parse_sni_06(signed int _i)
{
  tcase_fn_start("ssl_tls_clienthello_parse_sni_06", "ssl.t.c", 379);
  signed long int ssl_tls_clienthello_parse_sni_06$$1$$1$$sz;
  char *ssl_tls_clienthello_parse_sni_06$$1$$1$$sni;
  ssl_tls_clienthello_parse_sni_06$$1$$1$$sz = (signed long int)(sizeof(unsigned char [387l]) /*387ul*/  - (unsigned long int)1);
  ssl_tls_clienthello_parse_sni_06$$1$$1$$sni=ssl_tls_clienthello_parse_sni(clienthello05, &ssl_tls_clienthello_parse_sni_06$$1$$1$$sz);
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  if(!(ssl_tls_clienthello_parse_sni_06$$1$$1$$sni == ((char *)NULL)))
  {
    return_value_strcmp$1=strcmp(ssl_tls_clienthello_parse_sni_06$$1$$1$$sni, "daniel.roe.ch");
    tmp_if_expr$2 = !(return_value_strcmp$1 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    _mark_point("ssl.t.c", 386);

  else
    _ck_assert_failed("ssl.t.c", 386, "Assertion 'sni && !strcmp(sni, \"daniel.roe.ch\")' failed", (const void *)"sni not 'daniel.roe.ch' but should be", (void *)0);
  if(!(ssl_tls_clienthello_parse_sni_06$$1$$1$$sz == -1l))
    _mark_point("ssl.t.c", 388);

  else
    _ck_assert_failed("ssl.t.c", 388, "Assertion 'sz != -1' failed", (const void *)"size is -1 but should not", (void *)0);
}

// ssl_tls_clienthello_parse_sni_07
// file ssl.t.c line 392
static void ssl_tls_clienthello_parse_sni_07(signed int _i)
{
  tcase_fn_start("ssl_tls_clienthello_parse_sni_07", "ssl.t.c", 392);
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 386ul); i = i + 1ul)
  {
    signed long int ssl_tls_clienthello_parse_sni_07$$1$$1$$1$$1$$sz;
    char *ssl_tls_clienthello_parse_sni_07$$1$$1$$1$$1$$sni;
    ssl_tls_clienthello_parse_sni_07$$1$$1$$1$$1$$sz = (signed long int)i;
    ssl_tls_clienthello_parse_sni_07$$1$$1$$1$$1$$sni=ssl_tls_clienthello_parse_sni(clienthello05, &ssl_tls_clienthello_parse_sni_07$$1$$1$$1$$1$$sz);
    if(ssl_tls_clienthello_parse_sni_07$$1$$1$$1$$1$$sni == ((char *)NULL))
      _mark_point("ssl.t.c", 400);

    else
      _ck_assert_failed("ssl.t.c", 400, "Assertion 'sni == NULL' failed", (const void *)"sni not null but should be", (void *)0);
    if(ssl_tls_clienthello_parse_sni_07$$1$$1$$1$$1$$sz == -1l)
      _mark_point("ssl.t.c", 401);

    else
      _ck_assert_failed("ssl.t.c", 401, "Assertion 'sz == -1' failed", (const void *)"size is not -1 but should be", (void *)0);
  }
}

// ssl_tmp_dh_callback
// file ssl.c line 541
struct dh_st * ssl_tmp_dh_callback(struct ssl_st *s, signed int is_export, signed int keylength)
{
  struct dh_st *dh;
  dh=DH_new();
  _Bool tmp_if_expr$1;
  if(dh == ((struct dh_st *)NULL))
  {
    log_err_printf("DH_new() failed\n");
    return (struct dh_st *)(void *)0;
  }

  else
  {
    switch(keylength)
    {
      case 512:
      {
        dh->p=BN_bin2bn(dh512_p, (signed int)sizeof(unsigned char [64l]) /*64ul*/ , (struct bignum_st *)(void *)0);
        break;
      }
      case 1024:
      {
        dh->p=BN_bin2bn(dh1024_p, (signed int)sizeof(unsigned char [128l]) /*128ul*/ , (struct bignum_st *)(void *)0);
        break;
      }
      case 2048:
      {
        dh->p=BN_bin2bn(dh2048_p, (signed int)sizeof(unsigned char [256l]) /*256ul*/ , (struct bignum_st *)(void *)0);
        break;
      }
      case 4096:
      {
        dh->p=BN_bin2bn(dh4096_p, (signed int)sizeof(unsigned char [512l]) /*512ul*/ , (struct bignum_st *)(void *)0);
        break;
      }
      default:
      {
        log_err_printf("Unhandled DH keylength %i%s\n", keylength, is_export != 0 ? " (export)" : "");
        DH_free(dh);
        return (struct dh_st *)(void *)0;
      }
    }
    dh->g=BN_bin2bn(dh_g, (signed int)sizeof(unsigned char [1l]) /*1ul*/ , (struct bignum_st *)(void *)0);
    if(dh->p == ((struct bignum_st *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = !(dh->g != ((struct bignum_st *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      log_err_printf("Failed to load DH p and g from memory\n");
      DH_free(dh);
      return (struct dh_st *)(void *)0;
    }

    else
      return dh;
  }
}

// ssl_wildcardify
// file ssl.h line 169
char * ssl_wildcardify(const char *hostname)
{
  char *dot;
  char *wildcarded;
  unsigned long int dotsz;
  dot=strchr(hostname, 46);
  char *return_value_strdup$1;
  if(dot == ((char *)NULL))
  {
    return_value_strdup$1=strdup("*");
    return return_value_strdup$1;
  }

  else
  {
    dotsz=strlen(dot);
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(dotsz + (unsigned long int)2);
    wildcarded = (char *)return_value_malloc$2;
    if(wildcarded == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      wildcarded[(signed long int)0] = (char)42;
      strncpy(wildcarded + (signed long int)1, dot, dotsz);
      wildcarded[(signed long int)(dotsz + (unsigned long int)1)] = (char)0;
      return wildcarded;
    }
  }
}

// ssl_wildcardify_01
// file ssl.t.c line 72
static void ssl_wildcardify_01(signed int _i)
{
  tcase_fn_start("ssl_wildcardify_01", "ssl.t.c", 72);
  char *wc;
  wc=ssl_wildcardify(name1);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(wc, wildcard1);
  if(return_value_strcmp$1 == 0)
    _mark_point("ssl.t.c", 75);

  else
    _ck_assert_failed("ssl.t.c", 75, "Assertion '!strcmp(wc, wildcard1)' failed", (const void *)"mismatch for 'www.example.org'", (void *)0);
  free((void *)wc);
}

// ssl_wildcardify_02
// file ssl.t.c line 80
static void ssl_wildcardify_02(signed int _i)
{
  tcase_fn_start("ssl_wildcardify_02", "ssl.t.c", 80);
  char *wc;
  wc=ssl_wildcardify(name8);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(wc, wildcard5);
  if(return_value_strcmp$1 == 0)
    _mark_point("ssl.t.c", 83);

  else
    _ck_assert_failed("ssl.t.c", 83, "Assertion '!strcmp(wc, wildcard5)' failed", (const void *)"mismatch for 'ch'", (void *)0);
  free((void *)wc);
}

// ssl_wildcardify_03
// file ssl.t.c line 88
static void ssl_wildcardify_03(signed int _i)
{
  tcase_fn_start("ssl_wildcardify_03", "ssl.t.c", 88);
  char *wc;
  wc=ssl_wildcardify(name11);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(wc, wildcard5);
  if(return_value_strcmp$1 == 0)
    _mark_point("ssl.t.c", 91);

  else
    _ck_assert_failed("ssl.t.c", 91, "Assertion '!strcmp(wc, wildcard5)' failed", (const void *)"mismatch for ''", (void *)0);
  free((void *)wc);
}

// ssl_x509_aias
// file ssl.c line 1389
char ** ssl_x509_aias(struct x509_st *crt, const signed int type)
{
  struct stack_st_ACCESS_DESCRIPTION *aias;
  char **res;
  signed int count;
  signed int i;
  signed int j;
  void *return_value_X509_get_ext_d2i$1;
  return_value_X509_get_ext_d2i$1=X509_get_ext_d2i(crt, 177, (signed int *)(void *)0, (signed int *)(void *)0);
  aias = (struct stack_st_ACCESS_DESCRIPTION *)return_value_X509_get_ext_d2i$1;
  _Bool tmp_if_expr$2;
  if(aias == ((struct stack_st_ACCESS_DESCRIPTION *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    count=sk_num((struct stack_st *)(1 != 0 ? aias : (struct stack_st_ACCESS_DESCRIPTION *)0));
    tmp_if_expr$2 = !(count != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_OBJ_obj2nid$5;
  if(tmp_if_expr$2)
    return (char **)(void *)0;

  else
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc((unsigned long int)(count + 1) * sizeof(char *) /*8ul*/ );
    res = (char **)return_value_malloc$3;
    if(res == ((char **)NULL))
    {
      sk_pop_free((struct stack_st *)(1 != 0 ? aias : (struct stack_st_ACCESS_DESCRIPTION *)0), (void (*)(void *))(1 != 0 ? ACCESS_DESCRIPTION_free : (void (*)(struct ACCESS_DESCRIPTION_st *))0));
      return (char **)(void *)0;
    }

    else
    {
      i = 0;
      j = 0;
      for( ; !(i >= count); i = i + 1)
      {
        struct ACCESS_DESCRIPTION_st *aia;
        void *return_value_sk_value$4;
        return_value_sk_value$4=sk_value((struct stack_st *)(1 != 0 ? aias : (struct stack_st_ACCESS_DESCRIPTION *)0), i);
        aia = (struct ACCESS_DESCRIPTION_st *)return_value_sk_value$4;
        if(!(aia == ((struct ACCESS_DESCRIPTION_st *)NULL)))
        {
          return_value_OBJ_obj2nid$5=OBJ_obj2nid(aia->method);
          if(return_value_OBJ_obj2nid$5 == type)
          {
            if(aia->location->type == 6)
            {
              res[(signed long int)j]=ssl_ia5string_strdup(aia->location->d.ia5);
              if(!(res[(signed long int)j] == ((char *)NULL)))
                j = j + 1;

            }

          }

        }

      }
      res[(signed long int)j] = (char *)(void *)0;
      sk_pop_free((struct stack_st *)(1 != 0 ? aias : (struct stack_st_ACCESS_DESCRIPTION *)0), (void (*)(void *))(1 != 0 ? ACCESS_DESCRIPTION_free : (void (*)(struct ACCESS_DESCRIPTION_st *))0));
      return res;
    }
  }
}

// ssl_x509_fingerprint_sha1
// file ssl.c line 1083
signed int ssl_x509_fingerprint_sha1(struct x509_st *crt, unsigned char *fpr)
{
  unsigned int ssl_x509_fingerprint_sha1$$1$$sz = (unsigned int)20;
  const struct env_md_st *return_value_EVP_sha1$1;
  return_value_EVP_sha1$1=EVP_sha1();
  signed int return_value_X509_digest$2;
  return_value_X509_digest$2=X509_digest(crt, return_value_EVP_sha1$1, fpr, &ssl_x509_fingerprint_sha1$$1$$sz);
  return return_value_X509_digest$2 != 0 ? 0 : -1;
}

// ssl_x509_forge
// file ssl.c line 731
struct x509_st * ssl_x509_forge(struct x509_st *cacrt, struct evp_pkey_st *cakey, struct x509_st *origcrt, const char *extraname, struct evp_pkey_st *key)
{
  struct X509_name_st *subject;
  struct X509_name_st *issuer;
  struct stack_st_GENERAL_NAME *names;
  struct GENERAL_NAME_st *gn;
  struct x509_st *crt;
  subject=X509_get_subject_name(origcrt);
  issuer=X509_get_subject_name(cacrt);
  _Bool tmp_if_expr$3;
  signed int return_value_X509_set_subject_name$2;
  _Bool tmp_if_expr$5;
  signed int return_value_X509_set_issuer_name$4;
  _Bool tmp_if_expr$7;
  signed int return_value_ssl_x509_serial_copyrand$6;
  _Bool tmp_if_expr$9;
  struct asn1_string_st *return_value_X509_gmtime_adj$8;
  _Bool tmp_if_expr$11;
  struct asn1_string_st *return_value_X509_gmtime_adj$10;
  _Bool tmp_if_expr$13;
  signed int return_value_X509_set_pubkey$12;
  struct v3_ext_ctx ctx;
  signed int return_value_ssl_x509_v3ext_add$14;
  _Bool tmp_if_expr$16;
  signed int return_value_ssl_x509_v3ext_add$15;
  _Bool tmp_if_expr$18;
  signed int return_value_ssl_x509_v3ext_add$17;
  _Bool tmp_if_expr$20;
  signed int return_value_ssl_x509_v3ext_add$19;
  _Bool tmp_if_expr$22;
  signed int return_value_ssl_x509_v3ext_add$21;
  const struct env_md_st *md;
  signed int return_value_EVP_PKEY_type$30;
  signed int return_value_X509_sign$31;
  if(issuer == ((struct X509_name_st *)NULL) || subject == ((struct X509_name_st *)NULL))
    return (struct x509_st *)(void *)0;

  else
  {
    crt=X509_new();
    if(crt == ((struct x509_st *)NULL))
      return (struct x509_st *)(void *)0;

    else
    {
      signed int return_value_X509_set_version$1;
      return_value_X509_set_version$1=X509_set_version(crt, (signed long int)0x02);
      if(return_value_X509_set_version$1 == 0)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_X509_set_subject_name$2=X509_set_subject_name(crt, subject);
        tmp_if_expr$3 = !(return_value_X509_set_subject_name$2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_X509_set_issuer_name$4=X509_set_issuer_name(crt, issuer);
        tmp_if_expr$5 = !(return_value_X509_set_issuer_name$4 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        return_value_ssl_x509_serial_copyrand$6=ssl_x509_serial_copyrand(crt, origcrt);
        tmp_if_expr$7 = return_value_ssl_x509_serial_copyrand$6 == -1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
        tmp_if_expr$9 = (_Bool)1;

      else
      {
        return_value_X509_gmtime_adj$8=X509_gmtime_adj(crt->cert_info->validity->notBefore, (signed long int)-60 * (signed long int)60 * (signed long int)24);
        tmp_if_expr$9 = !(return_value_X509_gmtime_adj$8 != ((struct asn1_string_st *)NULL)) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$9)
        tmp_if_expr$11 = (_Bool)1;

      else
      {
        return_value_X509_gmtime_adj$10=X509_gmtime_adj(crt->cert_info->validity->notAfter, (signed long int)60 * (signed long int)60 * (signed long int)24 * (signed long int)364);
        tmp_if_expr$11 = !(return_value_X509_gmtime_adj$10 != ((struct asn1_string_st *)NULL)) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$11)
        tmp_if_expr$13 = (_Bool)1;

      else
      {
        return_value_X509_set_pubkey$12=X509_set_pubkey(crt, key);
        tmp_if_expr$13 = !(return_value_X509_set_pubkey$12 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$13)
      {
        X509V3_set_ctx(&ctx, cacrt, crt, (struct X509_req_st *)(void *)0, (struct X509_crl_st *)(void *)0, 0);
        return_value_ssl_x509_v3ext_add$14=ssl_x509_v3ext_add(&ctx, crt, "basicConstraints", "CA:FALSE");
        if(return_value_ssl_x509_v3ext_add$14 == -1)
          tmp_if_expr$16 = (_Bool)1;

        else
        {
          return_value_ssl_x509_v3ext_add$15=ssl_x509_v3ext_add(&ctx, crt, "keyUsage", "digitalSignature,keyEncipherment");
          tmp_if_expr$16 = return_value_ssl_x509_v3ext_add$15 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$16)
          tmp_if_expr$18 = (_Bool)1;

        else
        {
          return_value_ssl_x509_v3ext_add$17=ssl_x509_v3ext_add(&ctx, crt, "extendedKeyUsage", "serverAuth");
          tmp_if_expr$18 = return_value_ssl_x509_v3ext_add$17 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$18)
          tmp_if_expr$20 = (_Bool)1;

        else
        {
          return_value_ssl_x509_v3ext_add$19=ssl_x509_v3ext_add(&ctx, crt, "subjectKeyIdentifier", "hash");
          tmp_if_expr$20 = return_value_ssl_x509_v3ext_add$19 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$20)
          tmp_if_expr$22 = (_Bool)1;

        else
        {
          return_value_ssl_x509_v3ext_add$21=ssl_x509_v3ext_add(&ctx, crt, "authorityKeyIdentifier", "keyid,issuer:always");
          tmp_if_expr$22 = return_value_ssl_x509_v3ext_add$21 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$22)
        {
          if(extraname == ((const char *)NULL))
          {
            signed int return_value_ssl_x509_v3ext_copy_by_nid$23;
            return_value_ssl_x509_v3ext_copy_by_nid$23=ssl_x509_v3ext_copy_by_nid(crt, origcrt, 85);
            if(return_value_ssl_x509_v3ext_copy_by_nid$23 == -1)
              goto errout;

          }

          else
          {
            void *return_value_X509_get_ext_d2i$24;
            return_value_X509_get_ext_d2i$24=X509_get_ext_d2i(origcrt, 85, ((signed int *)NULL), ((signed int *)NULL));
            names = (struct stack_st_GENERAL_NAME *)return_value_X509_get_ext_d2i$24;
            if(names == ((struct stack_st_GENERAL_NAME *)NULL))
            {
              char *cfval;
              signed int return_value_asprintf$25;
              return_value_asprintf$25=asprintf(&cfval, "DNS:%s", extraname);
              if(!(return_value_asprintf$25 >= 0))
                goto errout;

              signed int return_value_ssl_x509_v3ext_add$26;
              return_value_ssl_x509_v3ext_add$26=ssl_x509_v3ext_add(&ctx, crt, "subjectAltName", cfval);
              if(return_value_ssl_x509_v3ext_add$26 == -1)
              {
                free((void *)cfval);
                goto errout;
              }

              free((void *)cfval);
            }

            else
            {
              gn=GENERAL_NAME_new();
              if(gn == ((struct GENERAL_NAME_st *)NULL))
                goto errout2;

              gn->type = 2;
              struct asn1_string_st *return_value_ASN1_STRING_type_new$27;
              return_value_ASN1_STRING_type_new$27=ASN1_STRING_type_new(22);
              gn->d.dNSName = (struct asn1_string_st *)return_value_ASN1_STRING_type_new$27;
              if(gn->d.dNSName == ((struct asn1_string_st *)NULL))
                goto errout3;

              unsigned long int return_value_strlen$28;
              return_value_strlen$28=strlen(extraname);
              ASN1_STRING_set(gn->d.dNSName, (const void *)(unsigned char *)extraname, (signed int)return_value_strlen$28);
              sk_push((struct stack_st *)(1 != 0 ? names : (struct stack_st_GENERAL_NAME *)0), (void *)(1 != 0 ? gn : (struct GENERAL_NAME_st *)0));
              struct X509_extension_st *ext;
              ext=X509V3_EXT_i2d(85, 0, (void *)names);
              signed int return_value_X509_add_ext$29;
              return_value_X509_add_ext$29=X509_add_ext(crt, ext, -1);
              if(return_value_X509_add_ext$29 == 0)
              {
                if(!(ext == ((struct X509_extension_st *)NULL)))
                  X509_EXTENSION_free(ext);

                goto errout3;
              }

              X509_EXTENSION_free(ext);
              sk_pop_free((struct stack_st *)(1 != 0 ? names : (struct stack_st_GENERAL_NAME *)0), (void (*)(void *))(1 != 0 ? GENERAL_NAME_free : (void (*)(struct GENERAL_NAME_st *))0));
            }
          }
          return_value_EVP_PKEY_type$30=EVP_PKEY_type(cakey->type);
          switch(return_value_EVP_PKEY_type$30)
          {
            case 6:
            {
              md=EVP_sha1();
              break;
            }
            case 116:
            {
              md=EVP_dss1();
              break;
            }
            case 408:
            {
              md=EVP_ecdsa();
              break;
            }
            default:
              goto errout;
          }
          return_value_X509_sign$31=X509_sign(crt, cakey, md);
          if(!(return_value_X509_sign$31 == 0))
          {
            return crt;

          errout3:
            ;
            GENERAL_NAME_free(gn);

          errout2:
            ;
            sk_pop_free((struct stack_st *)(1 != 0 ? names : (struct stack_st_GENERAL_NAME *)0), (void (*)(void *))(1 != 0 ? GENERAL_NAME_free : (void (*)(struct GENERAL_NAME_st *))0));
          }

        }

      }


    errout:
      ;
      X509_free(crt);
      return (struct x509_st *)(void *)0;
    }
  }
}

// ssl_x509_is_valid
// file ssl.c line 1438
signed int ssl_x509_is_valid(struct x509_st *crt)
{
  signed int return_value_X509_cmp_current_time$1;
  return_value_X509_cmp_current_time$1=X509_cmp_current_time(crt->cert_info->validity->notAfter);
  if(!(return_value_X509_cmp_current_time$1 >= 1))
    return 0;

  else
  {
    signed int return_value_X509_cmp_current_time$2;
    return_value_X509_cmp_current_time$2=X509_cmp_current_time(crt->cert_info->validity->notBefore);
    if(return_value_X509_cmp_current_time$2 >= 1)
      return 0;

    else
      return 1;
  }
}

// ssl_x509_load
// file ssl.h line 140
struct x509_st * ssl_x509_load(const char *filename)
{
  struct x509_st *crt = (struct x509_st *)(void *)0;
  struct ssl_ctx_st *tmpctx;
  struct ssl_st *tmpssl;
  signed int rv;
  signed int return_value_ssl_init$1;
  return_value_ssl_init$1=ssl_init();
  if(return_value_ssl_init$1 == -1)
    return (struct x509_st *)(void *)0;

  else
  {
    const struct ssl_method_st *return_value_SSLv23_server_method$2;
    return_value_SSLv23_server_method$2=SSLv23_server_method();
    tmpctx=SSL_CTX_new(return_value_SSLv23_server_method$2);
    if(!(tmpctx == ((struct ssl_ctx_st *)NULL)))
    {
      rv=SSL_CTX_use_certificate_file(tmpctx, filename, 1);
      if(rv == 1)
      {
        tmpssl=SSL_new(tmpctx);
        if(!(tmpssl == ((struct ssl_st *)NULL)))
        {
          crt=SSL_get_certificate(tmpssl);
          if(!(crt == ((struct x509_st *)NULL)))
            ssl_x509_refcount_inc(crt);

          SSL_free(tmpssl);
        }

      }


    leave2:
      ;
      SSL_CTX_free(tmpctx);
    }


  leave1:
    ;
    return crt;
  }
}

// ssl_x509_names
// file ssl.h line 145
char ** ssl_x509_names(struct x509_st *crt)
{
  struct stack_st_GENERAL_NAME *altnames;
  char *cn;
  unsigned long int cnsz;
  char **res;
  char **p;
  unsigned long int count;
  cn=ssl_x509_subject_cn(crt, &cnsz);
  void *return_value_X509_get_ext_d2i$1;
  return_value_X509_get_ext_d2i$1=X509_get_ext_d2i(crt, 85, (signed int *)(void *)0, (signed int *)(void *)0);
  altnames = (struct stack_st_GENERAL_NAME *)return_value_X509_get_ext_d2i$1;
  signed int tmp_if_expr$3;
  signed int return_value_sk_num$2;
  if(!(altnames == ((struct stack_st_GENERAL_NAME *)NULL)))
  {
    return_value_sk_num$2=sk_num((struct stack_st *)(1 != 0 ? altnames : (struct stack_st_GENERAL_NAME *)0));
    tmp_if_expr$3 = return_value_sk_num$2;
  }

  else
    tmp_if_expr$3 = 0;
  count = (unsigned long int)(tmp_if_expr$3 + (cn != ((char *)NULL) ? 2 : 1));
  void *return_value_malloc$4;
  return_value_malloc$4=malloc(count * sizeof(char *) /*8ul*/ );
  res = (char **)return_value_malloc$4;
  char **tmp_post$5;
  signed int return_value_sk_num$6;
  signed int tmp_if_expr$9;
  if(res == ((char **)NULL))
    return (char **)(void *)0;

  else
  {
    p = res;
    if(!(cn == ((char *)NULL)))
    {
      tmp_post$5 = p;
      p = p + 1l;
      *tmp_post$5 = cn;
    }

    if(altnames == ((struct stack_st_GENERAL_NAME *)NULL))
    {
      *p = (char *)(void *)0;
      return res;
    }

    else
    {
      signed int i = 0;
      do
      {
        return_value_sk_num$6=sk_num((struct stack_st *)(1 != 0 ? altnames : (struct stack_st_GENERAL_NAME *)0));
        if(i >= return_value_sk_num$6)
          break;

        struct GENERAL_NAME_st *gn;
        void *return_value_sk_value$7;
        return_value_sk_value$7=sk_value((struct stack_st *)(1 != 0 ? altnames : (struct stack_st_GENERAL_NAME *)0), i);
        gn = (struct GENERAL_NAME_st *)return_value_sk_value$7;
        if(gn->type == 2)
        {
          unsigned char *altname;
          signed int altnamesz;
          ASN1_STRING_to_UTF8(&altname, gn->d.dNSName);
          if(altname == ((unsigned char *)NULL))
            break;

          altnamesz=ASN1_STRING_length(gn->d.dNSName);
          if(!(altnamesz >= 0))
          {
            CRYPTO_free((void *)(char *)altname);
            break;
          }

          void *return_value_malloc$8;
          return_value_malloc$8=malloc((unsigned long int)(altnamesz + 1));
          *p = (char *)return_value_malloc$8;
          if(*p == ((char *)NULL))
          {
            CRYPTO_free((void *)(char *)altname);
            GENERAL_NAMES_free(altnames);
            p = res;
            for( ; !(*p == ((char *)NULL)); p = p + 1l)
              free((void *)*p);
            free((void *)res);
            return (char **)(void *)0;
          }

          signed int j = 0;
          for( ; !(j >= altnamesz); j = j + 1)
          {
            if(!(altname[(signed long int)j] == 0))
              tmp_if_expr$9 = (signed int)altname[(signed long int)j];

            else
              tmp_if_expr$9 = 33;
            (*p)[(signed long int)j] = (char)tmp_if_expr$9;
          }
          (*p)[(signed long int)altnamesz] = (char)0;
          CRYPTO_free((void *)(char *)altname);
          p = p + 1l;
        }

        i = i + 1;
      }
      while((_Bool)1);
      *p = (char *)(void *)0;
      GENERAL_NAMES_free(altnames);
      return res;
    }
  }
}

// ssl_x509_names_01
// file ssl.t.c line 407
static void ssl_x509_names_01(signed int _i)
{
  tcase_fn_start("ssl_x509_names_01", "ssl.t.c", 407);
  struct x509_st *c;
  char **names;
  char **p;
  c=ssl_x509_load("extra/pki/server.crt");
  if(!(c == ((struct x509_st *)NULL)))
    _mark_point("ssl.t.c", 413);

  else
    _ck_assert_failed("ssl.t.c", 413, "Assertion '!!c' failed", (const void *)"loading certificate failed", (void *)0);
  names=ssl_x509_names(c);
  if(!(names == ((char **)NULL)))
    _mark_point("ssl.t.c", 415);

  else
    _ck_assert_failed("ssl.t.c", 415, "Assertion '!!names' failed", (const void *)"parsing names failed", (void *)0);
  if(!(*names == ((char *)NULL)))
    _mark_point("ssl.t.c", 416);

  else
    _ck_assert_failed("ssl.t.c", 416, "Assertion '!!names[0]' failed", (const void *)"first name", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(names[(signed long int)0], "daniel.roe.ch");
  if(return_value_strcmp$1 == 0)
    _mark_point("ssl.t.c", 417);

  else
    _ck_assert_failed("ssl.t.c", 417, "Assertion '!strcmp(names[0], \"daniel.roe.ch\")' failed", (const void *)"first name", (void *)0);
  if(!(names[1l] == ((char *)NULL)))
    _mark_point("ssl.t.c", 418);

  else
    _ck_assert_failed("ssl.t.c", 418, "Assertion '!!names[1]' failed", (const void *)"second name", (void *)0);
  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(names[(signed long int)1], "daniel.roe.ch");
  if(return_value_strcmp$2 == 0)
    _mark_point("ssl.t.c", 419);

  else
    _ck_assert_failed("ssl.t.c", 419, "Assertion '!strcmp(names[1], \"daniel.roe.ch\")' failed", (const void *)"second name", (void *)0);
  if(!(names[2l] == ((char *)NULL)))
    _mark_point("ssl.t.c", 420);

  else
    _ck_assert_failed("ssl.t.c", 420, "Assertion '!!names[2]' failed", (const void *)"third name", (void *)0);
  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(names[(signed long int)2], "www.roe.ch");
  if(return_value_strcmp$3 == 0)
    _mark_point("ssl.t.c", 421);

  else
    _ck_assert_failed("ssl.t.c", 421, "Assertion '!strcmp(names[2], \"www.roe.ch\")' failed", (const void *)"third name", (void *)0);
  if(!(names[3l] == ((char *)NULL)))
    _mark_point("ssl.t.c", 422);

  else
    _ck_assert_failed("ssl.t.c", 422, "Assertion '!!names[3]' failed", (const void *)"fourth name", (void *)0);
  signed int return_value_strcmp$4;
  return_value_strcmp$4=strcmp(names[(signed long int)3], "*.roe.ch");
  if(return_value_strcmp$4 == 0)
    _mark_point("ssl.t.c", 423);

  else
    _ck_assert_failed("ssl.t.c", 423, "Assertion '!strcmp(names[3], \"*.roe.ch\")' failed", (const void *)"fourth name", (void *)0);
  if(names[4l] == ((char *)NULL))
    _mark_point("ssl.t.c", 424);

  else
    _ck_assert_failed("ssl.t.c", 424, "Assertion '!names[4]' failed", (const void *)"too many names", (void *)0);
  p = names;
  char **tmp_post$5;
  while(!(*p == ((char *)NULL)))
  {
    tmp_post$5 = p;
    p = p + 1l;
    free((void *)*tmp_post$5);
  }
  free((void *)names);
  X509_free(c);
}

// ssl_x509_names_match
// file ssl.c line 1212
signed int ssl_x509_names_match(struct x509_st *crt, const char *dnsname)
{
  struct stack_st_GENERAL_NAME *altnames;
  char *cn;
  unsigned long int cnsz;
  unsigned long int dnsnamesz;
  dnsnamesz=strlen(dnsname);
  cn=ssl_x509_subject_cn(crt, &cnsz);
  signed int return_value_ssl_dnsname_match$1;
  signed int return_value_sk_num$3;
  if(!(cn == ((char *)NULL)))
  {
    return_value_ssl_dnsname_match$1=ssl_dnsname_match(cn, cnsz, dnsname, dnsnamesz);
    if(return_value_ssl_dnsname_match$1 == 0)
      goto __CPROVER_DUMP_L1;

    free((void *)cn);
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(cn == ((char *)NULL)))
      free((void *)cn);

    void *return_value_X509_get_ext_d2i$2;
    return_value_X509_get_ext_d2i$2=X509_get_ext_d2i(crt, 85, ((signed int *)NULL), ((signed int *)NULL));
    altnames = (struct stack_st_GENERAL_NAME *)return_value_X509_get_ext_d2i$2;
    if(altnames == ((struct stack_st_GENERAL_NAME *)NULL))
      return 0;

    else
    {
      signed int i = 0;
      do
      {
        return_value_sk_num$3=sk_num((struct stack_st *)(1 != 0 ? altnames : (struct stack_st_GENERAL_NAME *)0));
        if(i >= return_value_sk_num$3)
          break;

        struct GENERAL_NAME_st *gn;
        void *return_value_sk_value$4;
        return_value_sk_value$4=sk_value((struct stack_st *)(1 != 0 ? altnames : (struct stack_st_GENERAL_NAME *)0), i);
        gn = (struct GENERAL_NAME_st *)return_value_sk_value$4;
        if(gn->type == 2)
        {
          unsigned char *altname;
          signed int altnamesz;
          ASN1_STRING_to_UTF8(&altname, gn->d.dNSName);
          altnamesz=ASN1_STRING_length(gn->d.dNSName);
          if(!(altnamesz >= 0))
            break;

          signed int return_value_ssl_dnsname_match$5;
          return_value_ssl_dnsname_match$5=ssl_dnsname_match((char *)altname, (unsigned long int)altnamesz, dnsname, dnsnamesz);
          if(!(return_value_ssl_dnsname_match$5 == 0))
          {
            CRYPTO_free((void *)(char *)altname);
            GENERAL_NAMES_free(altnames);
            return 1;
          }

          CRYPTO_free((void *)(char *)altname);
        }

        i = i + 1;
      }
      while((_Bool)1);
      GENERAL_NAMES_free(altnames);
      return 0;
    }
  }
}

// ssl_x509_names_to_str
// file ssl.h line 147
char * ssl_x509_names_to_str(struct x509_st *crt)
{
  char **names;
  unsigned long int ssl_x509_names_to_str$$1$$sz;
  char *ssl_x509_names_to_str$$1$$buf = (char *)(void *)0;
  char *next;
  names=ssl_x509_names(crt);
  void *return_value_malloc$2;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  if(names == ((char **)NULL))
    return (char *)(void *)0;

  else
  {
    ssl_x509_names_to_str$$1$$sz = (unsigned long int)0;
    char **p = names;
    for( ; !(*p == ((char *)NULL)); p = p + 1l)
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(*p);
      ssl_x509_names_to_str$$1$$sz = ssl_x509_names_to_str$$1$$sz + return_value_strlen$1 + (unsigned long int)1;
    }
    if(!(ssl_x509_names_to_str$$1$$sz == 0ul))
    {
      return_value_malloc$2=malloc(ssl_x509_names_to_str$$1$$sz);
      ssl_x509_names_to_str$$1$$buf = (char *)return_value_malloc$2;
      if(!(ssl_x509_names_to_str$$1$$buf == ((char *)NULL)))
      {
        next = ssl_x509_names_to_str$$1$$buf;
        char **ssl_x509_names_to_str$$1$$3$$p = names;
        for( ; !(*ssl_x509_names_to_str$$1$$3$$p == ((char *)NULL)); ssl_x509_names_to_str$$1$$3$$p = ssl_x509_names_to_str$$1$$3$$p + 1l)
        {
          char *src = *ssl_x509_names_to_str$$1$$3$$p;
          for( ; !(*src == 0); *tmp_post$3 = *tmp_post$4)
          {
            tmp_post$3 = next;
            next = next + 1l;
            tmp_post$4 = src;
            src = src + 1l;
          }
          tmp_post$5 = next;
          next = next + 1l;
          *tmp_post$5 = (char)47;
        }
        next = next - 1l;
        *next = (char)0;
      }


    out2:
      ;
      char **ssl_x509_names_to_str$$1$$4$$p = names;
      for( ; !(*ssl_x509_names_to_str$$1$$4$$p == ((char *)NULL)); ssl_x509_names_to_str$$1$$4$$p = ssl_x509_names_to_str$$1$$4$$p + 1l)
        free((void *)*ssl_x509_names_to_str$$1$$4$$p);
    }


  out1:
    ;
    free((void *)names);
    return ssl_x509_names_to_str$$1$$buf;
  }
}

// ssl_x509_names_to_str_01
// file ssl.t.c line 433
static void ssl_x509_names_to_str_01(signed int _i)
{
  tcase_fn_start("ssl_x509_names_to_str_01", "ssl.t.c", 433);
  struct x509_st *c;
  char *names;
  c=ssl_x509_load("extra/pki/server.crt");
  if(!(c == ((struct x509_st *)NULL)))
    _mark_point("ssl.t.c", 439);

  else
    _ck_assert_failed("ssl.t.c", 439, "Assertion '!!c' failed", (const void *)"loading certificate failed", (void *)0);
  names=ssl_x509_names_to_str(c);
  if(!(names == ((char *)NULL)))
    _mark_point("ssl.t.c", 441);

  else
    _ck_assert_failed("ssl.t.c", 441, "Assertion '!!names' failed", (const void *)"no string", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(names, "daniel.roe.ch/daniel.roe.ch/www.roe.ch/*.roe.ch");
  if(return_value_strcmp$1 == 0)
    _mark_point("ssl.t.c", 442);

  else
    _ck_assert_failed("ssl.t.c", 442, "Assertion '!strcmp(names, \"daniel.roe.ch/daniel.roe.ch/www.roe.ch/*.roe.ch\")' failed", (const void *)"wrong name string", (void *)0);
  X509_free(c);
}

// ssl_x509_names_to_str_02
// file ssl.t.c line 449
static void ssl_x509_names_to_str_02(signed int _i)
{
  tcase_fn_start("ssl_x509_names_to_str_02", "ssl.t.c", 449);
  struct x509_st *c;
  char *names;
  c=ssl_x509_load("extra/pki/rsa.crt");
  if(!(c == ((struct x509_st *)NULL)))
    _mark_point("ssl.t.c", 455);

  else
    _ck_assert_failed("ssl.t.c", 455, "Assertion '!!c' failed", (const void *)"loading certificate failed", (void *)0);
  names=ssl_x509_names_to_str(c);
  if(!(names == ((char *)NULL)))
    _mark_point("ssl.t.c", 457);

  else
    _ck_assert_failed("ssl.t.c", 457, "Assertion '!!names' failed", (const void *)"no string", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(names, "SSLsplit Root CA");
  if(return_value_strcmp$1 == 0)
    _mark_point("ssl.t.c", 458);

  else
    _ck_assert_failed("ssl.t.c", 458, "Assertion '!strcmp(names, \"SSLsplit Root CA\")' failed", (const void *)"wrong name string", (void *)0);
  X509_free(c);
}

// ssl_x509_ocsps
// file ssl.h line 149
char ** ssl_x509_ocsps(struct x509_st *crt)
{
  char **return_value_ssl_x509_aias$1;
  return_value_ssl_x509_aias$1=ssl_x509_aias(crt, 178);
  return return_value_ssl_x509_aias$1;
}

// ssl_x509_ocsps_01
// file ssl.t.c line 501
static void ssl_x509_ocsps_01(signed int _i)
{
  tcase_fn_start("ssl_x509_ocsps_01", "ssl.t.c", 501);
  struct x509_st *c;
  char **ocsps;
  char **p;
  c=ssl_x509_load("extra/pki/server.crt");
  if(!(c == ((struct x509_st *)NULL)))
    _mark_point("ssl.t.c", 507);

  else
    _ck_assert_failed("ssl.t.c", 507, "Assertion '!!c' failed", (const void *)"loading certificate failed", (void *)0);
  ocsps=ssl_x509_ocsps(c);
  if(!(ocsps == ((char **)NULL)))
    _mark_point("ssl.t.c", 509);

  else
    _ck_assert_failed("ssl.t.c", 509, "Assertion '!!ocsps' failed", (const void *)"parsing OCSP extensions failed", (void *)0);
  if(!(*ocsps == ((char *)NULL)))
    _mark_point("ssl.t.c", 510);

  else
    _ck_assert_failed("ssl.t.c", 510, "Assertion '!!ocsps[0]' failed", (const void *)"first OCSP", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(ocsps[(signed long int)0], "http://daniel.roe.ch/test/ocsp");
  if(return_value_strcmp$1 == 0)
    _mark_point("ssl.t.c", 511);

  else
    _ck_assert_failed("ssl.t.c", 511, "Assertion '!strcmp(ocsps[0], \"http://daniel.roe.ch/test/ocsp\")' failed", (const void *)"first OCSP", (void *)0);
  if(ocsps[1l] == ((char *)NULL))
    _mark_point("ssl.t.c", 513);

  else
    _ck_assert_failed("ssl.t.c", 513, "Assertion '!ocsps[1]' failed", (const void *)"too many OCSPs", (void *)0);
  p = ocsps;
  char **tmp_post$2;
  while(!(*p == ((char *)NULL)))
  {
    tmp_post$2 = p;
    p = p + 1l;
    free((void *)*tmp_post$2);
  }
  free((void *)ocsps);
  X509_free(c);
}

// ssl_x509_ocsps_02
// file ssl.t.c line 522
static void ssl_x509_ocsps_02(signed int _i)
{
  tcase_fn_start("ssl_x509_ocsps_02", "ssl.t.c", 522);
  struct x509_st *c;
  char **ocsps;
  c=ssl_x509_load("extra/pki/rsa.crt");
  if(!(c == ((struct x509_st *)NULL)))
    _mark_point("ssl.t.c", 528);

  else
    _ck_assert_failed("ssl.t.c", 528, "Assertion '!!c' failed", (const void *)"loading certificate failed", (void *)0);
  ocsps=ssl_x509_ocsps(c);
  if(ocsps == ((char **)NULL))
    _mark_point("ssl.t.c", 530);

  else
    _ck_assert_failed("ssl.t.c", 530, "Assertion '!ocsps' failed", (const void *)"unexpected OCSP extensions", (void *)0);
  X509_free(c);
}

// ssl_x509_refcount_inc
// file ssl.c line 1126
void ssl_x509_refcount_inc(struct x509_st *crt)
{
  CRYPTO_add_lock(&crt->references, 1, 3, "ssl.c", 1129);
}

// ssl_x509_serial_copyrand
// file ssl.c line 693
signed int ssl_x509_serial_copyrand(struct x509_st *dstcrt, struct x509_st *srccrt)
{
  struct asn1_string_st *srcptr;
  struct asn1_string_st *dstptr;
  struct bignum_st *bnserial;
  unsigned int rand;
  signed int rv;
  rv=ssl_rand((void *)&rand, sizeof(unsigned int) /*4ul*/ );
  dstptr=X509_get_serialNumber(dstcrt);
  srcptr=X509_get_serialNumber(srccrt);
  if(dstptr == ((struct asn1_string_st *)NULL) || srcptr == ((struct asn1_string_st *)NULL) || rv == -1)
    return -1;

  else
  {
    bnserial=ASN1_INTEGER_to_BN(srcptr, (struct bignum_st *)(void *)0);
    if(bnserial == ((struct bignum_st *)NULL))
      ASN1_INTEGER_set(dstptr, (signed long int)rand);

    else
    {
      BN_add_word(bnserial, (unsigned long int)rand);
      BN_to_ASN1_INTEGER(bnserial, dstptr);
      BN_free(bnserial);
    }
    return 0;
  }
}

// ssl_x509_subject
// file ssl.h line 141
char * ssl_x509_subject(struct x509_st *crt)
{
  struct X509_name_st *return_value_X509_get_subject_name$1;
  return_value_X509_get_subject_name$1=X509_get_subject_name(crt);
  char *return_value_X509_NAME_oneline$2;
  return_value_X509_NAME_oneline$2=X509_NAME_oneline(return_value_X509_get_subject_name$1, (char *)(void *)0, 0);
  return return_value_X509_NAME_oneline$2;
}

// ssl_x509_subject_01
// file ssl.t.c line 463
static void ssl_x509_subject_01(signed int _i)
{
  tcase_fn_start("ssl_x509_subject_01", "ssl.t.c", 463);
  struct x509_st *c;
  char *subject;
  c=ssl_x509_load("extra/pki/server.crt");
  if(!(c == ((struct x509_st *)NULL)))
    _mark_point("ssl.t.c", 469);

  else
    _ck_assert_failed("ssl.t.c", 469, "Assertion '!!c' failed", (const void *)"loading certificate failed", (void *)0);
  subject=ssl_x509_subject(c);
  if(!(subject == ((char *)NULL)))
    _mark_point("ssl.t.c", 471);

  else
    _ck_assert_failed("ssl.t.c", 471, "Assertion '!!subject' failed", (const void *)"no string", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(subject, "/C=CH/O=SSLsplit Test Certificate/CN=daniel.roe.ch");
  if(return_value_strcmp$1 == 0)
    _mark_point("ssl.t.c", 472);

  else
    _ck_assert_failed("ssl.t.c", 472, "Assertion '!strcmp(subject, \"/C=CH/O=SSLsplit Test Certificate/\" \"CN=daniel.roe.ch\")' failed", (const void *)"wrong subject string", (void *)0);
  X509_free(c);
}

// ssl_x509_subject_cn
// file ssl.h line 142
char * ssl_x509_subject_cn(struct x509_st *crt, unsigned long int *psz)
{
  struct X509_name_st *ptr;
  char *cn;
  unsigned long int ssl_x509_subject_cn$$1$$sz;
  ptr=X509_get_subject_name(crt);
  _Bool tmp_if_expr$3;
  void *return_value_malloc$2;
  if(ptr == ((struct X509_name_st *)NULL))
    return (char *)(void *)0;

  else
  {
    signed int return_value_X509_NAME_get_text_by_NID$1;
    return_value_X509_NAME_get_text_by_NID$1=X509_NAME_get_text_by_NID(ptr, 13, (char *)(void *)0, 0);
    ssl_x509_subject_cn$$1$$sz = (unsigned long int)(return_value_X509_NAME_get_text_by_NID$1 + 1);
    if(ssl_x509_subject_cn$$1$$sz == 0ul)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_malloc$2=malloc(ssl_x509_subject_cn$$1$$sz);
      cn = (char *)return_value_malloc$2;
      tmp_if_expr$3 = !(cn != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      return (char *)(void *)0;

    else
    {
      signed int return_value_X509_NAME_get_text_by_NID$4;
      return_value_X509_NAME_get_text_by_NID$4=X509_NAME_get_text_by_NID(ptr, 13, cn, (signed int)ssl_x509_subject_cn$$1$$sz);
      if(return_value_X509_NAME_get_text_by_NID$4 == -1)
      {
        free((void *)cn);
        return (char *)(void *)0;
      }

      else
      {
        *psz = ssl_x509_subject_cn$$1$$sz;
        return cn;
      }
    }
  }
}

// ssl_x509_subject_cn_01
// file ssl.t.c line 479
static void ssl_x509_subject_cn_01(signed int _i)
{
  tcase_fn_start("ssl_x509_subject_cn_01", "ssl.t.c", 479);
  struct x509_st *c;
  char *cn;
  unsigned long int ssl_x509_subject_cn_01$$1$$1$$sz;
  unsigned long int expsz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen("daniel.roe.ch");
  expsz = return_value_strlen$1 + (unsigned long int)1;
  c=ssl_x509_load("extra/pki/server.crt");
  if(!(c == ((struct x509_st *)NULL)))
    _mark_point("ssl.t.c", 487);

  else
    _ck_assert_failed("ssl.t.c", 487, "Assertion '!!c' failed", (const void *)"loading certificate failed", (void *)0);
  cn=ssl_x509_subject_cn(c, &ssl_x509_subject_cn_01$$1$$1$$sz);
  if(!(cn == ((char *)NULL)))
    _mark_point("ssl.t.c", 489);

  else
    _ck_assert_failed("ssl.t.c", 489, "Assertion '!!cn' failed", (const void *)"no string", (void *)0);
  if(ssl_x509_subject_cn_01$$1$$1$$sz >= expsz)
    _mark_point("ssl.t.c", 490);

  else
    _ck_assert_failed("ssl.t.c", 490, "Assertion 'sz >= expsz' failed", (const void *)"subject CN size too small", (void *)0);
  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(cn, "daniel.roe.ch");
  if(return_value_strcmp$2 == 0)
    _mark_point("ssl.t.c", 491);

  else
    _ck_assert_failed("ssl.t.c", 491, "Assertion '!strcmp(cn, \"daniel.roe.ch\")' failed", (const void *)"wrong subject CN string", (void *)0);
  X509_free(c);
}

// ssl_x509_to_pem
// file ssl.c line 1480
char * ssl_x509_to_pem(struct x509_st *crt)
{
  struct bio_st *bio;
  char *p;
  char *ret;
  unsigned long int ssl_x509_to_pem$$1$$sz;
  struct bio_method_st *return_value_BIO_s_mem$1;
  return_value_BIO_s_mem$1=BIO_s_mem();
  bio=BIO_new(return_value_BIO_s_mem$1);
  if(bio == ((struct bio_st *)NULL))
    return (char *)(void *)0;

  else
  {
    PEM_write_bio_X509(bio, crt);
    signed long int return_value_BIO_ctrl$2;
    return_value_BIO_ctrl$2=BIO_ctrl(bio, 3, (signed long int)0, (void *)(char *)&p);
    ssl_x509_to_pem$$1$$sz = (unsigned long int)return_value_BIO_ctrl$2;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(ssl_x509_to_pem$$1$$sz + (unsigned long int)1);
    ret = (char *)return_value_malloc$3;
    if(ret == ((char *)NULL))
    {
      BIO_free(bio);
      return (char *)(void *)0;
    }

    else
    {
      memcpy((void *)ret, (const void *)p, ssl_x509_to_pem$$1$$sz);
      ret[(signed long int)ssl_x509_to_pem$$1$$sz] = (char)0;
      BIO_free(bio);
      return ret;
    }
  }
}

// ssl_x509_to_str
// file ssl.c line 1453
char * ssl_x509_to_str(struct x509_st *crt)
{
  struct bio_st *bio;
  char *p;
  char *ret;
  unsigned long int ssl_x509_to_str$$1$$sz;
  struct bio_method_st *return_value_BIO_s_mem$1;
  return_value_BIO_s_mem$1=BIO_s_mem();
  bio=BIO_new(return_value_BIO_s_mem$1);
  if(bio == ((struct bio_st *)NULL))
    return (char *)(void *)0;

  else
  {
    X509_print(bio, crt);
    signed long int return_value_BIO_ctrl$2;
    return_value_BIO_ctrl$2=BIO_ctrl(bio, 3, (signed long int)0, (void *)(char *)&p);
    ssl_x509_to_str$$1$$sz = (unsigned long int)return_value_BIO_ctrl$2;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(ssl_x509_to_str$$1$$sz + (unsigned long int)1);
    ret = (char *)return_value_malloc$3;
    if(ret == ((char *)NULL))
    {
      BIO_free(bio);
      return (char *)(void *)0;
    }

    else
    {
      memcpy((void *)ret, (const void *)p, ssl_x509_to_str$$1$$sz);
      ret[(signed long int)ssl_x509_to_str$$1$$sz] = (char)0;
      BIO_free(bio);
      return ret;
    }
  }
}

// ssl_x509_v3ext_add
// file ssl.c line 626
signed int ssl_x509_v3ext_add(struct v3_ext_ctx *ctx, struct x509_st *crt, char *k, char *v)
{
  struct X509_extension_st *ext;
  ext=X509V3_EXT_conf((struct lhash_st_CONF_VALUE *)(void *)0, ctx, k, v);
  if(ext == ((struct X509_extension_st *)NULL))
    return -1;

  else
  {
    signed int return_value_X509_add_ext$1;
    return_value_X509_add_ext$1=X509_add_ext(crt, ext, -1);
    if(!(return_value_X509_add_ext$1 == 1))
    {
      X509_EXTENSION_free(ext);
      return -1;
    }

    else
    {
      X509_EXTENSION_free(ext);
      return 0;
    }
  }
}

// ssl_x509_v3ext_copy_by_nid
// file ssl.c line 648
signed int ssl_x509_v3ext_copy_by_nid(struct x509_st *crt, struct x509_st *origcrt, signed int nid)
{
  struct X509_extension_st *ext;
  signed int pos;
  pos=X509_get_ext_by_NID(origcrt, nid, -1);
  if(pos == -1)
    return 0;

  else
  {
    ext=X509_get_ext(origcrt, pos);
    if(ext == ((struct X509_extension_st *)NULL))
      return -1;

    else
    {
      signed int return_value_X509_add_ext$1;
      return_value_X509_add_ext$1=X509_add_ext(crt, ext, -1);
      if(!(return_value_X509_add_ext$1 == 1))
        return -1;

      else
        return 1;
    }
  }
}

// ssl_x509chain_load
// file ssl.c line 869
signed int ssl_x509chain_load(struct x509_st **crt, struct stack_st_X509 **chain, const char *filename)
{
  struct x509_st *tmpcrt;
  struct ssl_ctx_st *tmpctx;
  struct ssl_st *tmpssl;
  struct stack_st_X509 *tmpchain;
  signed int rv;
  signed int return_value_ssl_init$1;
  return_value_ssl_init$1=ssl_init();
  signed long int return_value_SSL_CTX_ctrl$4;
  signed int return_value_sk_num$5;
  if(return_value_ssl_init$1 == -1)
    return -1;

  else
  {
    const struct ssl_method_st *return_value_SSLv23_server_method$2;
    return_value_SSLv23_server_method$2=SSLv23_server_method();
    tmpctx=SSL_CTX_new(return_value_SSLv23_server_method$2);
    if(!(tmpctx == ((struct ssl_ctx_st *)NULL)))
    {
      rv=SSL_CTX_use_certificate_chain_file(tmpctx, filename);
      if(rv == 1)
      {
        tmpssl=SSL_new(tmpctx);
        if(!(tmpssl == ((struct ssl_st *)NULL)))
        {
          tmpcrt=SSL_get_certificate(tmpssl);
          if(!(tmpcrt == ((struct x509_st *)NULL)))
          {
            if(*chain == ((struct stack_st_X509 *)NULL))
            {
              struct stack_st *return_value_sk_new_null$3;
              return_value_sk_new_null$3=sk_new_null();
              *chain = (struct stack_st_X509 *)return_value_sk_new_null$3;
              if(*chain == ((struct stack_st_X509 *)NULL))
                goto leave3;

            }

            return_value_SSL_CTX_ctrl$4=SSL_CTX_ctrl(tmpctx, 115, (signed long int)0, (void *)&tmpchain);
            rv = (signed int)return_value_SSL_CTX_ctrl$4;
            if(rv == 1)
            {
              if(!(crt == ((struct x509_st **)NULL)))
                *crt = tmpcrt;

              else
                sk_push((struct stack_st *)*chain, (void *)(1 != 0 ? tmpcrt : (struct x509_st *)0));
              ssl_x509_refcount_inc(tmpcrt);
              signed int i = 0;
              do
              {
                return_value_sk_num$5=sk_num((struct stack_st *)(1 != 0 ? tmpchain : (struct stack_st_X509 *)0));
                if(i >= return_value_sk_num$5)
                  break;

                void *return_value_sk_value$6;
                return_value_sk_value$6=sk_value((struct stack_st *)(1 != 0 ? tmpchain : (struct stack_st_X509 *)0), i);
                tmpcrt = (struct x509_st *)return_value_sk_value$6;
                ssl_x509_refcount_inc(tmpcrt);
                sk_push((struct stack_st *)*chain, (void *)(1 != 0 ? tmpcrt : (struct x509_st *)0));
                i = i + 1;
              }
              while((_Bool)1);
              SSL_free(tmpssl);
              SSL_CTX_free(tmpctx);
              return 0;
            }

          }


        leave3:
          ;
          SSL_free(tmpssl);
        }

      }


    leave2:
      ;
      SSL_CTX_free(tmpctx);
    }


  leave1:
    ;
    return -1;
  }
}

// ssl_x509chain_use
// file ssl.c line 939
void ssl_x509chain_use(struct ssl_ctx_st *sslctx, struct x509_st *crt, struct stack_st_X509 *chain)
{
  SSL_CTX_use_certificate(sslctx, crt);
  signed int i = 0;
  signed int return_value_sk_num$1;
  do
  {
    return_value_sk_num$1=sk_num((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0));
    if(i >= return_value_sk_num$1)
      break;

    struct x509_st *tmpcrt;
    void *return_value_sk_value$2;
    return_value_sk_value$2=sk_value((struct stack_st *)(1 != 0 ? chain : (struct stack_st_X509 *)0), i);
    tmpcrt = (struct x509_st *)return_value_sk_value$2;
    ssl_x509_refcount_inc(tmpcrt);
    sk_push((struct stack_st *)sslctx->extra_certs, (void *)(1 != 0 ? tmpcrt : (struct x509_st *)0));
    SSL_CTX_ctrl(sslctx, 14, (signed long int)0, (void *)(char *)tmpcrt);
    i = i + 1;
  }
  while((_Bool)1);
}

// sys_dir_eachfile
// file sys.h line 55
signed int sys_dir_eachfile(const char *dirname, void (*cb)(const char *, void *), void *arg)
{
  struct anonymous$11 *tree;
  struct _ftsent *node;
  char *paths[2l];
  paths[(signed long int)1] = (char *)(void *)0;
  paths[(signed long int)0]=strdup(dirname);
  _Bool tmp_if_expr$3;
  if(paths[0l] == ((char *)NULL))
    return -1;

  else
  {
    tree=fts_open(paths, 0x0004 | 0x0002, (signed int (*)(const struct _ftsent **, const struct _ftsent **))(void *)0);
    if(tree == ((struct anonymous$11 *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_err_printf("Cannot open directory '%s': %s\n", dirname, return_value_strerror$2);
      return -1;
    }

    do
    {
      node=fts_read(tree);
      if(node == ((struct _ftsent *)NULL))
        break;

      if((signed int)node->fts_level >= 1)
        tmp_if_expr$3 = (signed int)node->fts_name[(signed long int)0] == 46 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        fts_set(tree, node, 4);

      else
        if(!((8 & (signed int)node->fts_info) == 0))
          cb(node->fts_path, arg);

    }
    while((_Bool)1);
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    if(!(*return_value___errno_location$6 == 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_err_printf("Error reading directory entry: %s\n", return_value_strerror$5);
      return -1;
    }

    fts_close(tree);
    free((void *)paths[(signed long int)0]);
    return 0;
  }
}

// sys_dir_eachfile_01
// file sys.t.c line 157
static void sys_dir_eachfile_01(signed int _i)
{
  tcase_fn_start("sys_dir_eachfile_01", "sys.t.c", 157);
  signed int flag = 0;
  sys_dir_eachfile("extra/pki/targets", sys_dir_eachfile_cb, (void *)&flag);
  if(flag == 2)
    _mark_point("sys.t.c", 163);

  else
    _ck_assert_failed("sys.t.c", 163, "Assertion 'flag == 2' failed", (const void *)"Iterated wrong number of files", (void *)0);
}

// sys_dir_eachfile_cb
// file sys.t.c line 151
void sys_dir_eachfile_cb(const char *fn, void *arg)
{
  *((signed int *)arg) = *((signed int *)arg) + 1;
}

// sys_get_cpu_cores
// file sys.h line 57
unsigned int sys_get_cpu_cores(void)
{
  signed long int return_value_sysconf$1;
  return_value_sysconf$1=sysconf(84);
  return (unsigned int)return_value_sysconf$1;
}

// sys_get_cpu_cores_01
// file sys.t.c line 167
static void sys_get_cpu_cores_01(signed int _i)
{
  tcase_fn_start("sys_get_cpu_cores_01", "sys.t.c", 167);
  unsigned int return_value_sys_get_cpu_cores$1;
  return_value_sys_get_cpu_cores$1=sys_get_cpu_cores();
  if(return_value_sys_get_cpu_cores$1 >= 1u)
    _mark_point("sys.t.c", 169);

  else
    _ck_assert_failed("sys.t.c", 169, "Assertion 'sys_get_cpu_cores() >= 1' failed", (const void *)"Number of CPU cores < 1", (void *)0);
}

// sys_group_str
// file sys.h line 45
char * sys_group_str(unsigned int gid)
{
  static signed int bufsize = 0;
  if(bufsize == 0)
  {
    signed long int return_value_sysconf$1;
    return_value_sysconf$1=sysconf(69);
    bufsize = (signed int)return_value_sysconf$1;
    if(bufsize == -1)
      bufsize = 64;

  }

  char *sys_group_str$$1$$buf;
  char *newbuf;
  struct group grp;
  struct group *result = (struct group *)(void *)0;
  signed int rv;
  char *name;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)bufsize);
  sys_group_str$$1$$buf = (char *)return_value_malloc$2;
  if(sys_group_str$$1$$buf == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {
      rv=getgrgid_r(gid, &grp, sys_group_str$$1$$buf, (unsigned long int)bufsize, &result);
      if(rv == 0)
      {
        if(!(result == ((struct group *)NULL)))
        {
          name=strdup(grp.gr_name);
          free((void *)sys_group_str$$1$$buf);
          return name;
        }

        free((void *)sys_group_str$$1$$buf);
        signed int return_value_asprintf$3;
        return_value_asprintf$3=asprintf(&name, "%llu", (signed long long int)gid);
        if(!(return_value_asprintf$3 >= 0))
          return (char *)(void *)0;

        return name;
      }

      bufsize = bufsize * 2;
      void *return_value_realloc$4;
      return_value_realloc$4=realloc((void *)sys_group_str$$1$$buf, (unsigned long int)bufsize);
      newbuf = (char *)return_value_realloc$4;
      if(newbuf == ((char *)NULL))
      {
        free((void *)sys_group_str$$1$$buf);
        return (char *)(void *)0;
      }

      sys_group_str$$1$$buf = newbuf;
    }
    while(rv == 34);
    free((void *)sys_group_str$$1$$buf);
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(rv);
    log_err_printf("Failed to lookup gid: %s (%i)\n", return_value_strerror$5, rv);
    return (char *)(void *)0;
  }
}

// sys_group_str_01
// file sys.t.c line 200
static void sys_group_str_01(signed int _i)
{
  tcase_fn_start("sys_group_str_01", "sys.t.c", 200);
  char *name;
  name=sys_group_str((unsigned int)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(name, "root");
  if(return_value_strcmp$1 == 0)
    _mark_point("sys.t.c", 203);

  else
    _ck_assert_failed("sys.t.c", 203, "Assertion '!strcmp(name, TEST_ZEROGRP)' failed", (const void *)"Group 0 name mismatch", (void *)0);
}

// sys_isdir
// file sys.h line 51
signed int sys_isdir(const char *path)
{
  struct stat s;
  signed int return_value_stat$1;
  return_value_stat$1=stat(path, &s);
  if(return_value_stat$1 == -1)
    return 0;

  else
    if(!((16384u & s.st_mode) == 0u))
      return 1;

    else
      return 0;
}

// sys_isdir_01
// file sys.t.c line 85
static void sys_isdir_01(signed int _i)
{
  tcase_fn_start("sys_isdir_01", "sys.t.c", 85);
  signed int return_value_sys_isdir$1;
  return_value_sys_isdir$1=sys_isdir(dir);
  if(!(return_value_sys_isdir$1 == 0))
    _mark_point("sys.t.c", 87);

  else
    _ck_assert_failed("sys.t.c", 87, "Assertion 'sys_isdir(dir)' failed", (const void *)"Directory !isdir", (void *)0);
}

// sys_isdir_02
// file sys.t.c line 91
static void sys_isdir_02(signed int _i)
{
  tcase_fn_start("sys_isdir_02", "sys.t.c", 91);
  signed int return_value_sys_isdir$1;
  return_value_sys_isdir$1=sys_isdir(ldir);
  if(!(return_value_sys_isdir$1 == 0))
    _mark_point("sys.t.c", 93);

  else
    _ck_assert_failed("sys.t.c", 93, "Assertion 'sys_isdir(ldir)' failed", (const void *)"Symlink dir !isdir", (void *)0);
}

// sys_isdir_03
// file sys.t.c line 97
static void sys_isdir_03(signed int _i)
{
  tcase_fn_start("sys_isdir_03", "sys.t.c", 97);
  signed int return_value_sys_isdir$1;
  return_value_sys_isdir$1=sys_isdir(notexist);
  if(return_value_sys_isdir$1 == 0)
    _mark_point("sys.t.c", 99);

  else
    _ck_assert_failed("sys.t.c", 99, "Assertion '!sys_isdir(notexist)' failed", (const void *)"Not-exist isdir", (void *)0);
}

// sys_isdir_04
// file sys.t.c line 103
static void sys_isdir_04(signed int _i)
{
  tcase_fn_start("sys_isdir_04", "sys.t.c", 103);
  signed int return_value_sys_isdir$1;
  return_value_sys_isdir$1=sys_isdir(file);
  if(return_value_sys_isdir$1 == 0)
    _mark_point("sys.t.c", 105);

  else
    _ck_assert_failed("sys.t.c", 105, "Assertion '!sys_isdir(file)' failed", (const void *)"File isdir", (void *)0);
}

// sys_isdir_05
// file sys.t.c line 109
static void sys_isdir_05(signed int _i)
{
  tcase_fn_start("sys_isdir_05", "sys.t.c", 109);
  signed int return_value_sys_isdir$1;
  return_value_sys_isdir$1=sys_isdir(lfile);
  if(return_value_sys_isdir$1 == 0)
    _mark_point("sys.t.c", 111);

  else
    _ck_assert_failed("sys.t.c", 111, "Assertion '!sys_isdir(lfile)' failed", (const void *)"Symlink file isdir", (void *)0);
}

// sys_isdir_setup
// file sys.t.c line 48
static void sys_isdir_setup(void)
{
  basedir=strdup(template$link1);
  char *return_value_mkdtemp$1;
  return_value_mkdtemp$1=mkdtemp(basedir);
  if(return_value_mkdtemp$1 == ((char *)NULL))
  {
    perror("mkdtemp");
    exit(1);
  }

  asprintf(&file, "%s/file", basedir);
  asprintf(&lfile, "%s/lfile", basedir);
  asprintf(&dir, "%s/dir", basedir);
  asprintf(&ldir, "%s/ldir", basedir);
  asprintf(&notexist, "%s/DOES_NOT_EXIST", basedir);
  if(dir == ((char *)NULL) || file == ((char *)NULL) || ldir == ((char *)NULL) || lfile == ((char *)NULL) || notexist == ((char *)NULL))
  {
    perror("asprintf");
    exit(1);
  }

  signed int return_value_open$2;
  return_value_open$2=open(file, 0100 | 01 | 02000, 0600);
  close(return_value_open$2);
  symlink(file, lfile);
  mkdir(dir, (unsigned int)0700);
  symlink(dir, ldir);
}

// sys_isdir_teardown
// file sys.t.c line 71
static void sys_isdir_teardown(void)
{
  unlink(lfile);
  unlink(file);
  unlink(ldir);
  rmdir(dir);
  rmdir(basedir);
  free((void *)lfile);
  free((void *)file);
  free((void *)ldir);
  free((void *)dir);
  free((void *)notexist);
}

// sys_mkpath
// file sys.h line 52
signed int sys_mkpath(const char *path, unsigned int mode)
{
  signed long int sys_mkpath$array_size0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(path);
  sys_mkpath$array_size0 = (signed long int)(return_value_strlen$1 + (unsigned long int)1);
  char parent[sys_mkpath$array_size0];
  char *p;
  memcpy((void *)parent, (const void *)path, (unsigned long int)sys_mkpath$array_size0);
  p = parent;

__CPROVER_DUMP_L1:
  ;
  while((_Bool)1)
  {
    if((signed int)*p == 47)
    {
      p = p + 1l;
      goto __CPROVER_DUMP_L1;
    }

    p=strchr(p, 47);
    if(!(p == ((char *)NULL)))
      *p = (char)0;

    struct stat sbuf;
    signed int return_value_stat$5;
    return_value_stat$5=stat(parent, &sbuf);
    if(return_value_stat$5 == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(*return_value___errno_location$3 == 2)
      {
        signed int return_value_mkdir$2;
        return_value_mkdir$2=mkdir(parent, mode);
        if(!(return_value_mkdir$2 == 0))
          return -1;

      }

      else
        return -1;
    }

    else
      if(!((61440u & sbuf.st_mode) == 16384u))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 20;
        return -1;
      }

    if(!(p == ((char *)NULL)))
    {
      *p = (char)47;
      p = p + 1l;
    }

    if(p == ((char *)NULL))
      break;

  }
  return 0;
}

// sys_mkpath_01
// file sys.t.c line 136
static void sys_mkpath_01(signed int _i)
{
  tcase_fn_start("sys_mkpath_01", "sys.t.c", 136);
  char *sys_mkpath_01$$1$$1$$dir;
  asprintf(&sys_mkpath_01$$1$$1$$dir, "%s/a/bb/ccc/dddd/eeeee/ffffff/ggggggg/hhhhhhhh", basedir);
  if(!(sys_mkpath_01$$1$$1$$dir == ((char *)NULL)))
    _mark_point("sys.t.c", 142);

  else
    _ck_assert_failed("sys.t.c", 142, "Assertion '!!dir' failed", (const void *)"asprintf failed", (void *)0);
  signed int return_value_sys_isdir$1;
  return_value_sys_isdir$1=sys_isdir(sys_mkpath_01$$1$$1$$dir);
  if(return_value_sys_isdir$1 == 0)
    _mark_point("sys.t.c", 143);

  else
    _ck_assert_failed("sys.t.c", 143, "Assertion '!sys_isdir(dir)' failed", (const void *)"dir already sys_isdir()", (void *)0);
  signed int return_value_sys_mkpath$2;
  return_value_sys_mkpath$2=sys_mkpath(sys_mkpath_01$$1$$1$$dir, (unsigned int)0755);
  if(return_value_sys_mkpath$2 == 0)
    _mark_point("sys.t.c", 144);

  else
    _ck_assert_failed("sys.t.c", 144, "Assertion '!sys_mkpath(dir, 0755)' failed", (const void *)"sys_mkpath failed", (void *)0);
  signed int return_value_sys_isdir$3;
  return_value_sys_isdir$3=sys_isdir(sys_mkpath_01$$1$$1$$dir);
  if(!(return_value_sys_isdir$3 == 0))
    _mark_point("sys.t.c", 145);

  else
    _ck_assert_failed("sys.t.c", 145, "Assertion 'sys_isdir(dir)' failed", (const void *)"dir not sys_isdir()", (void *)0);
  free((void *)sys_mkpath_01$$1$$1$$dir);
}

// sys_mkpath_setup
// file sys.t.c line 116
static void sys_mkpath_setup(void)
{
  basedir=strdup(template$link1);
  char *return_value_mkdtemp$1;
  return_value_mkdtemp$1=mkdtemp(basedir);
  if(return_value_mkdtemp$1 == ((char *)NULL))
  {
    perror("mkdtemp");
    exit(1);
  }

}

// sys_mkpath_teardown
// file sys.t.c line 126
static void sys_mkpath_teardown(void)
{
  char *cmd;
  asprintf(&cmd, "rm -r '%s'", basedir);
  if(!(cmd == ((char *)NULL)))
    system(cmd);

}

// sys_pidf_close
// file sys.c line 194
void sys_pidf_close(signed int fd, const char *fn)
{
  unlink(fn);
  close(fd);
}

// sys_pidf_open
// file sys.c line 149
signed int sys_pidf_open(const char *fn)
{
  signed int fd;
  fd=open(fn, 02 | 0100, 0640);
  if(fd == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_err_printf("Failed to open '%s': %s\n", fn, return_value_strerror$2);
    return -1;
  }

  signed int return_value_flock$5;
  return_value_flock$5=flock(fd, 2 | 4);
  if(return_value_flock$5 == -1)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    log_err_printf("Failed to lock '%s': %s\n", fn, return_value_strerror$4);
    close(fd);
    return -1;
  }

  return fd;
}

// sys_pidf_write
// file sys.c line 173
signed int sys_pidf_write(signed int fd)
{
  char pidbuf[(signed long int)(sizeof(signed int) * 4) /*16l*/ ];
  signed int rv;
  signed int return_value_getpid$1;
  return_value_getpid$1=getpid();
  rv=snprintf(pidbuf, sizeof(char [16l]) /*16ul*/ , "%d\n", return_value_getpid$1);
  if(rv == -1 || rv >= (signed int)sizeof(char [16l]) /*16*/ )
    return -1;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(pidbuf);
    write(fd, (const void *)pidbuf, return_value_strlen$2);
    fsync(fd);
    signed int return_value_fcntl$3;
    return_value_fcntl$3=fcntl(fd, 1);
    fcntl(fd, 2, return_value_fcntl$3 | 1);
    return 0;
  }
}

// sys_privdrop
// file sys.c line 72
signed int sys_privdrop(const char *username, const char *groupname, const char *jaildir)
{
  struct passwd *pw = (struct passwd *)(void *)0;
  struct group *gr = (struct group *)(void *)0;
  signed int ret = -1;
  if(!(groupname == ((const char *)NULL)))
  {
    gr=getgrnam(groupname);
    if(gr == ((struct group *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_err_printf("Failed to getgrnam group '%s': %s\n", groupname, return_value_strerror$2);
      goto error;
    }

  }

  if(!(username == ((const char *)NULL)))
  {
    pw=getpwnam(username);
    if(pw == ((struct passwd *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      log_err_printf("Failed to getpwnam user '%s': %s\n", username, return_value_strerror$4);
      goto error;
    }

    if(!(gr == ((struct group *)NULL)))
      pw->pw_gid = gr->gr_gid;

    signed int return_value_initgroups$7;
    return_value_initgroups$7=initgroups(username, pw->pw_gid);
    if(return_value_initgroups$7 == -1)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      log_err_printf("Failed to initgroups user '%s': %s\n", username, return_value_strerror$6);
      goto error;
    }

  }

  if(!(jaildir == ((const char *)NULL)))
  {
    signed int return_value_chroot$10;
    return_value_chroot$10=chroot(jaildir);
    if(return_value_chroot$10 == -1)
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_err_printf("Failed to chroot to '%s': %s\n", jaildir, return_value_strerror$9);
      goto error;
    }

    signed int return_value_chdir$13;
    return_value_chdir$13=chdir("/");
    if(return_value_chdir$13 == -1)
    {
      signed int *return_value___errno_location$11;
      return_value___errno_location$11=__errno_location();
      char *return_value_strerror$12;
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      log_err_printf("Failed to chdir to '/': %s\n", return_value_strerror$12);
      goto error;
    }

  }

  unsigned int return_value_getuid$24;
  unsigned int return_value_geteuid$25;
  if(!(username == ((const char *)NULL)))
  {
    signed int return_value_setgid$16;
    return_value_setgid$16=setgid(pw->pw_gid);
    if(return_value_setgid$16 == -1)
    {
      signed int *return_value___errno_location$14;
      return_value___errno_location$14=__errno_location();
      char *return_value_strerror$15;
      return_value_strerror$15=strerror(*return_value___errno_location$14);
      log_err_printf("Failed to setgid to %i: %s\n", pw->pw_gid, return_value_strerror$15);
      goto error;
    }

    signed int return_value_setuid$19;
    return_value_setuid$19=setuid(pw->pw_uid);
    if(return_value_setuid$19 == -1)
    {
      signed int *return_value___errno_location$17;
      return_value___errno_location$17=__errno_location();
      char *return_value_strerror$18;
      return_value_strerror$18=strerror(*return_value___errno_location$17);
      log_err_printf("Failed to setuid to %i: %s\n", pw->pw_uid, return_value_strerror$18);
      goto error;
    }

  }

  else
  {
    return_value_getuid$24=getuid();
    return_value_geteuid$25=geteuid();
    if(!(return_value_getuid$24 == return_value_geteuid$25))
    {
      unsigned int return_value_getuid$22;
      return_value_getuid$22=getuid();
      signed int return_value_setuid$23;
      return_value_setuid$23=setuid(return_value_getuid$22);
      if(return_value_setuid$23 == -1)
      {
        signed int *return_value___errno_location$20;
        return_value___errno_location$20=__errno_location();
        char *return_value_strerror$21;
        return_value_strerror$21=strerror(*return_value___errno_location$20);
        log_err_printf("Failed to setuid(getuid()): %s\n", return_value_strerror$21);
        goto error;
      }

    }

  }
  ret = 0;

error:
  ;
  if(!(pw == ((struct passwd *)NULL)))
    endpwent();

  return ret;
}

// sys_sockaddr_parse
// file sys.h line 47
signed int sys_sockaddr_parse(struct sockaddr_storage *addr, unsigned int *addrlen, char *naddr, char *nport, signed int af, signed int flags)
{
  struct addrinfo hints;
  struct addrinfo *ai;
  signed int rv;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = af;
  hints.ai_socktype = 1;
  hints.ai_protocol = 6;
  hints.ai_flags = 0x0020 | flags;
  rv=evutil_getaddrinfo(naddr, nport, &hints, &ai);
  if(!(rv == 0))
  {
    const char *return_value_gai_strerror$1;
    return_value_gai_strerror$1=gai_strerror(rv);
    log_err_printf("Cannot resolve address '%s' port '%s': %s\n", naddr, nport, return_value_gai_strerror$1);
    return -1;
  }

  memcpy((void *)addr, (const void *)ai->ai_addr, (unsigned long int)ai->ai_addrlen);
  *addrlen = ai->ai_addrlen;
  af = ai->ai_family;
  freeaddrinfo(ai);
  return af;
}

// sys_sockaddr_str
// file sys.c line 342
char * sys_sockaddr_str(struct sockaddr *addr, unsigned int addrlen)
{
  char host[46l];
  char serv[6l];
  char *sys_sockaddr_str$$1$$buf;
  signed int rv;
  unsigned long int bufsz = sizeof(char [46l]) /*46ul*/  + sizeof(char [6l]) /*6ul*/  + (unsigned long int)3;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(bufsz);
  sys_sockaddr_str$$1$$buf = (char *)return_value_malloc$1;
  if(sys_sockaddr_str$$1$$buf == ((char *)NULL))
  {
    log_err_printf("Cannot allocate memory\n");
    return (char *)(void *)0;
  }

  else
  {
    rv=getnameinfo(addr, addrlen, host, (unsigned int)sizeof(char [46l]) /*46ul*/ , serv, (unsigned int)sizeof(char [6l]) /*6ul*/ , 1 | 2);
    if(!(rv == 0))
    {
      const char *return_value_gai_strerror$2;
      return_value_gai_strerror$2=gai_strerror(rv);
      log_err_printf("Cannot get nameinfo for socket address: %s\n", return_value_gai_strerror$2);
      free((void *)sys_sockaddr_str$$1$$buf);
      return (char *)(void *)0;
    }

    snprintf(sys_sockaddr_str$$1$$buf, bufsz, "[%s]:%s", (const void *)host, (const void *)serv);
    return sys_sockaddr_str$$1$$buf;
  }
}

// sys_suite
// file sys.t.c line 208
struct Suite * sys_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("sys");
  tc=tcase_create("sys_isdir");
  tcase_add_unchecked_fixture(tc, sys_isdir_setup, sys_isdir_teardown);
  _tcase_add_test(tc, sys_isdir_01, "sys_isdir_01", 0, 0, 0, 1);
  _tcase_add_test(tc, sys_isdir_02, "sys_isdir_02", 0, 0, 0, 1);
  _tcase_add_test(tc, sys_isdir_03, "sys_isdir_03", 0, 0, 0, 1);
  _tcase_add_test(tc, sys_isdir_04, "sys_isdir_04", 0, 0, 0, 1);
  _tcase_add_test(tc, sys_isdir_05, "sys_isdir_05", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("sys_mkpath");
  tcase_add_unchecked_fixture(tc, sys_mkpath_setup, sys_mkpath_teardown);
  _tcase_add_test(tc, sys_mkpath_01, "sys_mkpath_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("sys_dir_eachfile");
  _tcase_add_test(tc, sys_dir_eachfile_01, "sys_dir_eachfile_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("sys_get_cpu_cores");
  _tcase_add_test(tc, sys_get_cpu_cores_01, "sys_get_cpu_cores_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("pthread_create");
  _tcase_add_test(tc, pthread_create_01, "pthread_create_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("sys_user_str");
  _tcase_add_test(tc, sys_user_str_01, "sys_user_str_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  tc=tcase_create("sys_group_str");
  _tcase_add_test(tc, sys_group_str_01, "sys_group_str_01", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// sys_user_str
// file sys.h line 44
char * sys_user_str(unsigned int uid)
{
  static signed int bufsize = 0;
  if(bufsize == 0)
  {
    signed long int return_value_sysconf$1;
    return_value_sysconf$1=sysconf(70);
    bufsize = (signed int)return_value_sysconf$1;
    if(bufsize == -1)
      bufsize = 64;

  }

  char *sys_user_str$$1$$buf;
  char *newbuf;
  struct passwd pwd;
  struct passwd *result = (struct passwd *)(void *)0;
  signed int rv;
  char *name;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)bufsize);
  sys_user_str$$1$$buf = (char *)return_value_malloc$2;
  if(sys_user_str$$1$$buf == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {
      rv=getpwuid_r(uid, &pwd, sys_user_str$$1$$buf, (unsigned long int)bufsize, &result);
      if(rv == 0)
      {
        if(!(result == ((struct passwd *)NULL)))
        {
          name=strdup(pwd.pw_name);
          free((void *)sys_user_str$$1$$buf);
          return name;
        }

        free((void *)sys_user_str$$1$$buf);
        signed int return_value_asprintf$3;
        return_value_asprintf$3=asprintf(&name, "%llu", (signed long long int)uid);
        if(!(return_value_asprintf$3 >= 0))
          return (char *)(void *)0;

        return name;
      }

      bufsize = bufsize * 2;
      void *return_value_realloc$4;
      return_value_realloc$4=realloc((void *)sys_user_str$$1$$buf, (unsigned long int)bufsize);
      newbuf = (char *)return_value_realloc$4;
      if(newbuf == ((char *)NULL))
      {
        free((void *)sys_user_str$$1$$buf);
        return (char *)(void *)0;
      }

      sys_user_str$$1$$buf = newbuf;
    }
    while(rv == 34);
    free((void *)sys_user_str$$1$$buf);
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(rv);
    log_err_printf("Failed to lookup uid: %s (%i)\n", return_value_strerror$5, rv);
    return (char *)(void *)0;
  }
}

// sys_user_str_01
// file sys.t.c line 193
static void sys_user_str_01(signed int _i)
{
  tcase_fn_start("sys_user_str_01", "sys.t.c", 193);
  char *name;
  name=sys_user_str((unsigned int)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(name, "root");
  if(return_value_strcmp$1 == 0)
    _mark_point("sys.t.c", 196);

  else
    _ck_assert_failed("sys.t.c", 196, "Assertion '!strcmp(name, TEST_ZEROUSR)' failed", (const void *)"User 0 name mismatch", (void *)0);
}

// thrmain
// file sys.t.c line 174
void * thrmain(void *arg)
{
  *((signed int *)arg) = 1;
  return (void *)2;
}

// thrqueue_dequeue
// file thrqueue.c line 158
void * thrqueue_dequeue(struct thrqueue *queue)
{
  void *item;
  pthread_mutex_lock(&queue->mutex);
  while(queue->n == 0ul)
  {
    if(queue->block_dequeue == 0u)
    {
      pthread_mutex_unlock(&queue->mutex);
      return (void *)0;
    }

    pthread_cond_wait(&queue->notempty, &queue->mutex);
  }
  unsigned long int tmp_post$1 = queue->out;
  queue->out = queue->out + 1ul;
  item = queue->data[(signed long int)tmp_post$1];
  queue->out = queue->out % queue->sz;
  queue->n = queue->n - 1ul;
  pthread_mutex_unlock(&queue->mutex);
  pthread_cond_signal(&queue->notfull);
  return item;
}

// thrqueue_dequeue_nb
// file thrqueue.c line 184
void * thrqueue_dequeue_nb(struct thrqueue *queue)
{
  void *item;
  pthread_mutex_lock(&queue->mutex);
  unsigned long int tmp_post$1;
  if(queue->n == 0ul)
  {
    pthread_mutex_unlock(&queue->mutex);
    return (void *)0;
  }

  else
  {
    tmp_post$1 = queue->out;
    queue->out = queue->out + 1ul;
    item = queue->data[(signed long int)tmp_post$1];
    queue->out = queue->out % queue->sz;
    queue->n = queue->n - 1ul;
    pthread_mutex_unlock(&queue->mutex);
    pthread_cond_signal(&queue->notfull);
    return item;
  }
}

// thrqueue_enqueue
// file thrqueue.c line 112
void * thrqueue_enqueue(struct thrqueue *queue, void *item)
{
  pthread_mutex_lock(&queue->mutex);
  while(queue->n == queue->sz)
  {
    if(queue->block_enqueue == 0u)
    {
      pthread_mutex_unlock(&queue->mutex);
      return (void *)0;
    }

    pthread_cond_wait(&queue->notfull, &queue->mutex);
  }
  unsigned long int tmp_post$1 = queue->in;
  queue->in = queue->in + 1ul;
  queue->data[(signed long int)tmp_post$1] = item;
  queue->in = queue->in % queue->sz;
  queue->n = queue->n + 1ul;
  pthread_mutex_unlock(&queue->mutex);
  pthread_cond_broadcast(&queue->notempty);
  return item;
}

// thrqueue_enqueue_nb
// file thrqueue.c line 136
void * thrqueue_enqueue_nb(struct thrqueue *queue, void *item)
{
  pthread_mutex_lock(&queue->mutex);
  unsigned long int tmp_post$1;
  if(queue->n == queue->sz)
  {
    pthread_mutex_unlock(&queue->mutex);
    return (void *)0;
  }

  else
  {
    tmp_post$1 = queue->in;
    queue->in = queue->in + 1ul;
    queue->data[(signed long int)tmp_post$1] = item;
    queue->in = queue->in % queue->sz;
    queue->n = queue->n + 1ul;
    pthread_mutex_unlock(&queue->mutex);
    pthread_cond_signal(&queue->notempty);
    return item;
  }
}

// thrqueue_free
// file thrqueue.c line 96
void thrqueue_free(struct thrqueue *queue)
{
  free((void *)queue->data);
  pthread_mutex_destroy(&queue->mutex);
  pthread_cond_destroy(&queue->notempty);
  pthread_cond_destroy(&queue->notfull);
  free((void *)queue);
}

// thrqueue_new
// file thrqueue.c line 56
struct thrqueue * thrqueue_new(unsigned long int sz)
{
  struct thrqueue *queue;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct thrqueue) /*184ul*/ );
  queue = (struct thrqueue *)return_value_malloc$1;
  void *return_value_malloc$2;
  signed int return_value_pthread_mutex_init$3;
  signed int return_value_pthread_cond_init$4;
  signed int return_value_pthread_cond_init$5;
  if(!(queue == ((struct thrqueue *)NULL)))
  {
    return_value_malloc$2=malloc(sz * sizeof(void *) /*8ul*/ );
    queue->data = (void **)return_value_malloc$2;
    if(!(queue->data == ((void **)NULL)))
    {
      return_value_pthread_mutex_init$3=pthread_mutex_init(&queue->mutex, (const union anonymous$15 *)(void *)0);
      if(return_value_pthread_mutex_init$3 == 0)
      {
        return_value_pthread_cond_init$4=pthread_cond_init(&queue->notempty, (const union anonymous$15 *)(void *)0);
        if(return_value_pthread_cond_init$4 == 0)
        {
          return_value_pthread_cond_init$5=pthread_cond_init(&queue->notfull, (const union anonymous$15 *)(void *)0);
          if(return_value_pthread_cond_init$5 == 0)
          {
            queue->sz = sz;
            queue->n = (unsigned long int)0;
            queue->in = (unsigned long int)0;
            queue->out = (unsigned long int)0;
            queue->block_enqueue = (unsigned int)1;
            queue->block_dequeue = (unsigned int)1;
            return queue;
          }


        out4:
          ;
          pthread_cond_destroy(&queue->notempty);
        }


      out3:
        ;
        pthread_mutex_destroy(&queue->mutex);
      }


    out2:
      ;
      free((void *)queue->data);
    }


  out1:
    ;
    free((void *)queue);
  }


out0:
  ;
  return (struct thrqueue *)(void *)0;
}

// thrqueue_unblock_dequeue
// file thrqueue.c line 222
void thrqueue_unblock_dequeue(struct thrqueue *queue)
{
  queue->block_dequeue = (unsigned int)0;
  pthread_cond_broadcast(&queue->notempty);
  sched_yield();
}

// thrqueue_unblock_enqueue
// file thrqueue.c line 208
void thrqueue_unblock_enqueue(struct thrqueue *queue)
{
  queue->block_enqueue = (unsigned int)0;
  pthread_cond_broadcast(&queue->notfull);
  sched_yield();
}

// url_dec
// file url.h line 36
char * url_dec(const char *in, unsigned long int insz, unsigned long int *outsz)
{
  unsigned long int i;
  unsigned long int o;
  signed int hi;
  signed int lo;
  char *out;
  if(insz == 0ul)
  {
    *outsz = (unsigned long int)0;
    char *return_value_strdup$1;
    return_value_strdup$1=strdup("");
    return return_value_strdup$1;
  }

  i = (unsigned long int)0;
  o = (unsigned long int)0;
  for( ; !(i >= insz); i = i + 1ul)
    if((signed int)in[(signed long int)i] == 37)
      o = o + 1ul;

  if(!(insz >= 2ul * o))
  {
    *outsz = (unsigned long int)0;
    return (char *)(void *)0;
  }

  else
  {
    *outsz = insz - (unsigned long int)2 * o;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(*outsz + (unsigned long int)1);
    out = (char *)return_value_malloc$2;
    if(out == ((char *)NULL))
    {
      *outsz = (unsigned long int)0;
      return (char *)(void *)0;
    }

    else
    {
      i = (unsigned long int)0;
      o = (unsigned long int)0;
      for( ; !(i >= insz); o = o + 1ul)
      {
        if(!((signed int)in[(signed long int)i] == 37))
          out[(signed long int)o] = in[(signed long int)i];

        else
        {
          if(2ul + i >= insz)
            goto leave;

          static const signed int hex2dec[256l] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
          hi = hex2dec[(signed long int)(unsigned char)in[(signed long int)(i + (unsigned long int)1)]];
          if(hi == -1)
            goto leave;

          lo = hex2dec[(signed long int)(unsigned char)in[(signed long int)(i + (unsigned long int)2)]];
          if(lo == -1)
            goto leave;

          out[(signed long int)o] = (char)((hi & 0xF) << 4 | lo & 0xF);
          i = i + (unsigned long int)2;
        }
        i = i + 1ul;
      }
      out[(signed long int)*outsz] = (char)0;
      return out;

    leave:
      ;
      free((void *)out);
      return (char *)(void *)0;
    }
  }
}

// url_dec_01
// file url.t.c line 45
static void url_dec_01(signed int _i)
{
  tcase_fn_start("url_dec_01", "url.t.c", 45);
  char *url_dec_01$$1$$1$$buf;
  unsigned long int url_dec_01$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded01$link1);
  url_dec_01$$1$$1$$buf=url_dec(coded01$link1, return_value_strlen$1, &url_dec_01$$1$$1$$sz);
  if(!(url_dec_01$$1$$1$$buf == ((char *)NULL)))
    _mark_point("url.t.c", 51);

  else
    _ck_assert_failed("url.t.c", 51, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(plain01$link1);
  if(url_dec_01$$1$$1$$sz == return_value_strlen$2)
    _mark_point("url.t.c", 52);

  else
    _ck_assert_failed("url.t.c", 52, "Assertion 'sz == strlen(plain01)' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)plain01$link1, (const void *)url_dec_01$$1$$1$$buf, url_dec_01$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("url.t.c", 53);

  else
    _ck_assert_failed("url.t.c", 53, "Assertion '!memcmp(plain01, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)url_dec_01$$1$$1$$buf);
}

// url_dec_02
// file url.t.c line 58
static void url_dec_02(signed int _i)
{
  tcase_fn_start("url_dec_02", "url.t.c", 58);
  char *url_dec_02$$1$$1$$buf;
  unsigned long int url_dec_02$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded02$link1);
  url_dec_02$$1$$1$$buf=url_dec(coded02$link1, return_value_strlen$1, &url_dec_02$$1$$1$$sz);
  if(!(url_dec_02$$1$$1$$buf == ((char *)NULL)))
    _mark_point("url.t.c", 64);

  else
    _ck_assert_failed("url.t.c", 64, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(plain02$link1 + (signed long int)1);
  if(url_dec_02$$1$$1$$sz == 1ul + return_value_strlen$2)
    _mark_point("url.t.c", 65);

  else
    _ck_assert_failed("url.t.c", 65, "Assertion 'sz == strlen(plain02 + 1) + 1' failed", (const void *)"wrong length", (void *)0);
  signed int return_value_memcmp$3;
  return_value_memcmp$3=memcmp((const void *)plain02$link1, (const void *)url_dec_02$$1$$1$$buf, url_dec_02$$1$$1$$sz);
  if(return_value_memcmp$3 == 0)
    _mark_point("url.t.c", 66);

  else
    _ck_assert_failed("url.t.c", 66, "Assertion '!memcmp(plain02, buf, sz)' failed", (const void *)"wrong data", (void *)0);
  free((void *)url_dec_02$$1$$1$$buf);
}

// url_dec_03
// file url.t.c line 71
static void url_dec_03(signed int _i)
{
  tcase_fn_start("url_dec_03", "url.t.c", 71);
  char *url_dec_03$$1$$1$$buf;
  unsigned long int url_dec_03$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded03$link1);
  url_dec_03$$1$$1$$buf=url_dec(coded03$link1, return_value_strlen$1, &url_dec_03$$1$$1$$sz);
  if(url_dec_03$$1$$1$$buf == ((char *)NULL))
    _mark_point("url.t.c", 77);

  else
    _ck_assert_failed("url.t.c", 77, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// url_dec_04
// file url.t.c line 81
static void url_dec_04(signed int _i)
{
  tcase_fn_start("url_dec_04", "url.t.c", 81);
  char *url_dec_04$$1$$1$$buf;
  unsigned long int url_dec_04$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded04$link1);
  url_dec_04$$1$$1$$buf=url_dec(coded04$link1, return_value_strlen$1, &url_dec_04$$1$$1$$sz);
  if(url_dec_04$$1$$1$$buf == ((char *)NULL))
    _mark_point("url.t.c", 87);

  else
    _ck_assert_failed("url.t.c", 87, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// url_dec_05
// file url.t.c line 91
static void url_dec_05(signed int _i)
{
  tcase_fn_start("url_dec_05", "url.t.c", 91);
  char *url_dec_05$$1$$1$$buf;
  unsigned long int url_dec_05$$1$$1$$sz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(coded05$link1);
  url_dec_05$$1$$1$$buf=url_dec(coded05$link1, return_value_strlen$1, &url_dec_05$$1$$1$$sz);
  if(url_dec_05$$1$$1$$buf == ((char *)NULL))
    _mark_point("url.t.c", 97);

  else
    _ck_assert_failed("url.t.c", 97, "Assertion '!buf' failed", (const void *)"buffer returned", (void *)0);
}

// url_dec_06
// file url.t.c line 101
static void url_dec_06(signed int _i)
{
  tcase_fn_start("url_dec_06", "url.t.c", 101);
  char *url_dec_06$$1$$1$$buf;
  unsigned long int url_dec_06$$1$$1$$sz;
  url_dec_06$$1$$1$$buf=url_dec("", (unsigned long int)0, &url_dec_06$$1$$1$$sz);
  if(!(url_dec_06$$1$$1$$buf == ((char *)NULL)))
    _mark_point("url.t.c", 107);

  else
    _ck_assert_failed("url.t.c", 107, "Assertion '!!buf' failed", (const void *)"no buffer returned", (void *)0);
  if(url_dec_06$$1$$1$$sz == 0ul)
    _mark_point("url.t.c", 108);

  else
    _ck_assert_failed("url.t.c", 108, "Assertion '!sz' failed", (const void *)"length not 0", (void *)0);
  if(*url_dec_06$$1$$1$$buf == 0)
    _mark_point("url.t.c", 109);

  else
    _ck_assert_failed("url.t.c", 109, "Assertion '!buf[0]' failed", (const void *)"not empty string", (void *)0);
  free((void *)url_dec_06$$1$$1$$buf);
}

// url_suite
// file url.t.c line 116
struct Suite * url_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("url");
  tc=tcase_create("url_dec");
  _tcase_add_test(tc, url_dec_01, "url_dec_01", 0, 0, 0, 1);
  _tcase_add_test(tc, url_dec_02, "url_dec_02", 0, 0, 0, 1);
  _tcase_add_test(tc, url_dec_03, "url_dec_03", 0, 0, 0, 1);
  _tcase_add_test(tc, url_dec_04, "url_dec_04", 0, 0, 0, 1);
  _tcase_add_test(tc, url_dec_05, "url_dec_05", 0, 0, 0, 1);
  _tcase_add_test(tc, url_dec_06, "url_dec_06", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}

// util_skipws
// file util.h line 34
char * util_skipws(const char *s)
{
  unsigned long int return_value_strspn$1;
  return_value_strspn$1=strspn(s, " \t");
  return (char *)s + (signed long int)return_value_strspn$1;
}

// util_skipws_01
// file util.t.c line 41
static void util_skipws_01(signed int _i)
{
  tcase_fn_start("util_skipws_01", "util.t.c", 41);
  char *p;
  p=util_skipws(string01);
  if(!(p == ((char *)NULL)))
    _mark_point("util.t.c", 46);

  else
    _ck_assert_failed("util.t.c", 46, "Assertion '!!p' failed", (const void *)"no pointer returned", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(p, "test");
  if(return_value_strcmp$1 == 0)
    _mark_point("util.t.c", 47);

  else
    _ck_assert_failed("util.t.c", 47, "Assertion '!strcmp(p, \"test\")' failed", (const void *)"wrong data", (void *)0);
}

// util_skipws_02
// file util.t.c line 51
static void util_skipws_02(signed int _i)
{
  tcase_fn_start("util_skipws_02", "util.t.c", 51);
  char *p;
  p=util_skipws(string02);
  if(!(p == ((char *)NULL)))
    _mark_point("util.t.c", 56);

  else
    _ck_assert_failed("util.t.c", 56, "Assertion '!!p' failed", (const void *)"no pointer returned", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(p, "test");
  if(return_value_strcmp$1 == 0)
    _mark_point("util.t.c", 57);

  else
    _ck_assert_failed("util.t.c", 57, "Assertion '!strcmp(p, \"test\")' failed", (const void *)"wrong data", (void *)0);
}

// util_skipws_03
// file util.t.c line 61
static void util_skipws_03(signed int _i)
{
  tcase_fn_start("util_skipws_03", "util.t.c", 61);
  char *p;
  p=util_skipws(string03);
  if(!(p == ((char *)NULL)))
    _mark_point("util.t.c", 66);

  else
    _ck_assert_failed("util.t.c", 66, "Assertion '!!p' failed", (const void *)"no pointer returned", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(p, "test");
  if(return_value_strcmp$1 == 0)
    _mark_point("util.t.c", 67);

  else
    _ck_assert_failed("util.t.c", 67, "Assertion '!strcmp(p, \"test\")' failed", (const void *)"wrong data", (void *)0);
}

// util_skipws_04
// file util.t.c line 71
static void util_skipws_04(signed int _i)
{
  tcase_fn_start("util_skipws_04", "util.t.c", 71);
  char *p;
  p=util_skipws(string04);
  if(!(p == ((char *)NULL)))
    _mark_point("util.t.c", 76);

  else
    _ck_assert_failed("util.t.c", 76, "Assertion '!!p' failed", (const void *)"no pointer returned", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(p, "test");
  if(return_value_strcmp$1 == 0)
    _mark_point("util.t.c", 77);

  else
    _ck_assert_failed("util.t.c", 77, "Assertion '!strcmp(p, \"test\")' failed", (const void *)"wrong data", (void *)0);
}

// util_skipws_05
// file util.t.c line 81
static void util_skipws_05(signed int _i)
{
  tcase_fn_start("util_skipws_05", "util.t.c", 81);
  char *p;
  p=util_skipws(string05);
  if(!(p == ((char *)NULL)))
    _mark_point("util.t.c", 86);

  else
    _ck_assert_failed("util.t.c", 86, "Assertion '!!p' failed", (const void *)"no pointer returned", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(p, "\r\ntest");
  if(return_value_strcmp$1 == 0)
    _mark_point("util.t.c", 87);

  else
    _ck_assert_failed("util.t.c", 87, "Assertion '!strcmp(p, \"\\r\\ntest\")' failed", (const void *)"wrong data", (void *)0);
}

// util_skipws_06
// file util.t.c line 91
static void util_skipws_06(signed int _i)
{
  tcase_fn_start("util_skipws_06", "util.t.c", 91);
  char *p;
  p=util_skipws("");
  if(!(p == ((char *)NULL)))
    _mark_point("util.t.c", 96);

  else
    _ck_assert_failed("util.t.c", 96, "Assertion '!!p' failed", (const void *)"no pointer returned", (void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(p, "");
  if(return_value_strcmp$1 == 0)
    _mark_point("util.t.c", 97);

  else
    _ck_assert_failed("util.t.c", 97, "Assertion '!strcmp(p, \"\")' failed", (const void *)"wrong data", (void *)0);
}

// util_suite
// file main.t.c line 80
struct Suite * util_suite(void)
{
  struct Suite *s;
  struct TCase *tc;
  s=suite_create("util");
  tc=tcase_create("util_skipws");
  _tcase_add_test(tc, util_skipws_01, "util_skipws_01", 0, 0, 0, 1);
  _tcase_add_test(tc, util_skipws_02, "util_skipws_02", 0, 0, 0, 1);
  _tcase_add_test(tc, util_skipws_03, "util_skipws_03", 0, 0, 0, 1);
  _tcase_add_test(tc, util_skipws_04, "util_skipws_04", 0, 0, 0, 1);
  _tcase_add_test(tc, util_skipws_05, "util_skipws_05", 0, 0, 0, 1);
  _tcase_add_test(tc, util_skipws_06, "util_skipws_06", 0, 0, 0, 1);
  suite_add_tcase(s, tc);
  return s;
}
